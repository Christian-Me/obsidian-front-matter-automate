/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FolderTagPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian30 = require("obsidian");

// src/settings.ts
var import_obsidian12 = require("obsidian");

// src/frontmatter-tools.ts
var import_obsidian2 = require("obsidian");

// src/Log.ts
var import_obsidian = require("obsidian");

// src/Error.ts
var ErrorManager = class extends Error {
  constructor(msg, console_msg) {
    super(msg);
    this.console_msg = console_msg;
    this.name = this.constructor.name;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
function errorWrapperSync(fn2, msg) {
  try {
    return fn2();
  } catch (e) {
    if (e instanceof Error) {
      logError(new ErrorManager(msg, e.message));
    } else {
      logError(new ErrorManager(msg, String(e)));
    }
    return null;
  }
}

// src/Log.ts
var LOG = 0;
var ALERT = 1;
var ERROR = 2;
var WARNING = 3;
var INFO = 4;
var DEBUG = 5;
var TRACE = 6;
function logError(e) {
  const notice = new import_obsidian.Notice("", 8e3);
  if (e instanceof ErrorManager && e.console_msg) {
    notice.messageEl.innerHTML = `<b>Frontmatter Automate Error</b>:<br/>${e.message}<br/>Check console for more information`;
    console.error(`Frontmatter Error:`, e.message, "\n", e.console_msg);
  } else {
    notice.messageEl.innerHTML = `<b>Frontmatter Automate Error</b>:<br/>${e.message}`;
  }
}
var Logger = class {
  constructor() {
    this.logLevel = INFO;
  }
  setLevel(level) {
    if (typeof level === "number") {
      this.logLevel = level;
      this.log(LOG, `Log level set to ${this.getLevelName(this.logLevel)}`);
    } else {
      const levelName = level.toUpperCase();
      const levelIndex = this.getLevelNames().indexOf(levelName) + 1;
      if (levelIndex >= 0) {
        this.setLevel(levelIndex);
      } else {
        this.log(WARNING, `Invalid log level name: ${levelName}`);
      }
    }
  }
  getLevel() {
    return this.logLevel;
  }
  getLevelByName(levelName) {
    const levelIndex = this.getLevelNames().indexOf(levelName.toUpperCase()) + 1;
    if (levelIndex >= 0) {
      return levelIndex;
    } else {
      this.log(WARNING, `Invalid log level name: ${levelName}`);
      return INFO;
    }
  }
  getLevelByIndex(levelIndex) {
    if (levelIndex >= ALERT && levelIndex <= TRACE) {
      return levelIndex;
    } else {
      this.log(WARNING, `Invalid log level index: ${levelIndex}`);
      return INFO;
    }
  }
  getLevelByValue(levelValue) {
    if (levelValue >= ALERT && levelValue <= TRACE) {
      return levelValue;
    } else {
      this.log(WARNING, `Invalid log level value: ${levelValue}`);
      return INFO;
    }
  }
  shouldLog(level) {
    if (level === 0)
      return true;
    return level <= this.logLevel;
  }
  getLevelName(level) {
    switch (level) {
      case ALERT:
        return "ALERT";
      case ERROR:
        return "ERROR";
      case WARNING:
        return "WARNING";
      case INFO:
        return "INFO";
      case DEBUG:
        return "DEBUG";
      case TRACE:
        return "TRACE";
      default:
        return "LOG";
    }
  }
  getLevelNames() {
    return [ALERT, ERROR, WARNING, INFO, DEBUG, TRACE].map((level) => this.getLevelName(level));
  }
  log(level, ...msg) {
    if (!this.shouldLog(level))
      return;
    const levelName = this.getLevelName(level);
    let color = "";
    switch (level) {
      case ALERT:
        color = "background: #d32f2f; color: white; font-weight: bold";
        break;
      case ERROR:
        color = "color: #d32f2f; font-weight: bold";
        break;
      case WARNING:
        color = "color: #fbc02d; font-weight: bold";
        break;
      case INFO:
        color = "color: #1976d2; font-weight: bold";
        break;
      case DEBUG:
        color = "color: #388e3c;";
        break;
      case TRACE:
        color = "color: #616161;";
        break;
      default:
        color = "";
        break;
    }
    const prefix = `%c[${levelName}]`;
    const err = new Error();
    let caller = "";
    if (err.stack) {
      const stackLines = err.stack.split("\n");
      if (stackLines.length >= 3) {
        caller = stackLines[2].trim();
      }
    }
    switch (level) {
      case ALERT:
      case ERROR:
        console.groupCollapsed(prefix, color, ...msg);
        console.log("Caller Stack:", err);
        console.groupEnd();
        break;
      case WARNING:
        console.groupCollapsed(prefix, color, ...msg);
        console.log("Caller Stack:", err);
        console.groupEnd();
        break;
      case INFO:
        console.info(prefix, color, ...msg);
        break;
      case DEBUG:
      case TRACE:
      default:
        console.groupCollapsed(prefix, color, ...msg);
        console.log("Caller Stack:", err);
        console.groupEnd();
        break;
    }
    if (level === ALERT || level === ERROR) {
      new import_obsidian.Notice(`<b>Frontmatter Automate ${levelName}</b>:<br/>${msg.join(" ")}`, 8e3);
    }
  }
  groupCollapsed(level, ...msg) {
    if (!this.shouldLog(level))
      return;
    const levelName = this.getLevelName(level);
    let color = "";
    switch (level) {
      case ALERT:
        color = "background: #d32f2f; color: white; font-weight: bold";
        break;
      case ERROR:
        color = "color: #d32f2f; font-weight: bold";
        break;
      case WARNING:
        color = "color: #fbc02d; font-weight: bold";
        break;
      case INFO:
        color = "color: #1976d2; font-weight: bold";
        break;
      case DEBUG:
        color = "color: #388e3c;";
        break;
      case TRACE:
        color = "color: #616161;";
        break;
      default:
        color = "";
        break;
    }
    const prefix = `%c[${levelName}]`;
    console.groupCollapsed(prefix, color, ...msg);
  }
  groupEnd() {
    console.groupEnd();
  }
  logUpdate(msg) {
    new import_obsidian.Notice(`<b>Frontmatter Automate update</b>:<br/>${msg}`, 15e3);
  }
  logError(e) {
    const notice = new import_obsidian.Notice("", 8e3);
    if (e instanceof ErrorManager && e.console_msg) {
      notice.messageEl.innerHTML = `<b>Frontmatter Automate Error</b>:<br/>${e.message}<br/>Check console for more information`;
      logger.log(ERROR, `Frontmatter Error:`, e.message, "\n", e.console_msg);
    } else {
      notice.messageEl.innerHTML = `<b>Frontmatter Automate Error</b>:<br/>${e.message}`;
    }
  }
};
var logger = new Logger();

// src/frontmatter-tools.ts
function getPropertiesFromMetadataManager(app) {
  try {
    const metadataManager = app.metadataTypeManager;
    logger.log(DEBUG, "get properties:", metadataManager);
    return Object.values(metadataManager.properties).map((value) => ({
      name: value.name,
      type: value.type,
      count: value.count,
      source: "registered"
    })).sort((a, b) => a.name.localeCompare(b.name));
  } catch (e) {
    logger.log(ERROR, "Couldn't access properties from Metadata Manager", e);
    return [];
  }
}
function getTypesFromMetadataManager(app) {
  try {
    const metadataManager = app.metadataTypeManager;
    logger.log(DEBUG, "get types:", metadataManager);
    return Object.values(metadataManager.registeredTypeWidgets).map((value, index, array) => ({
      type: value.type,
      icon: value.icon,
      jsType: ""
    })).sort((a, b) => a.type.localeCompare(b.type));
  } catch (e) {
    logger.log(ERROR, "Couldn't access properties from Metadata Manager", e);
    return [];
  }
}

// src/tools.ts
var import_obsidian4 = require("obsidian");

// src/alertBox.ts
var import_obsidian3 = require("obsidian");
var AlertModal = class extends import_obsidian3.Modal {
  constructor(app, title, description, btn1, btn2, askAgainLabel) {
    super(app);
    this.title = title;
    this.description = description;
    this.btn1Text = btn1;
    this.btn2Text = btn2;
    this.askAgainLabel = askAgainLabel;
    this.promise = new Promise((resolve) => {
      this.resolvePromise = resolve;
    });
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: this.title });
    contentEl.createEl("p", { text: this.description });
    const settings = new import_obsidian3.Setting(contentEl);
    if (this.askAgainLabel) {
      const itemInfoDiv = settings.settingEl.getElementsByClassName("setting-item-info")[0];
      if (itemInfoDiv) {
        this.checkboxEl = itemInfoDiv.createEl("input", { type: "checkbox" });
        const label = itemInfoDiv.createEl("label", { text: this.askAgainLabel });
        label.style.marginLeft = "8px";
      }
    }
    settings.addButton((btn) => {
      btn.setButtonText(this.btn1Text).setCta().onClick(() => {
        var _a;
        this.close();
        this.resolvePromise({ proceed: true, data: { askConfirmation: (_a = this.checkboxEl) == null ? void 0 : _a.checked } });
      });
    });
    settings.addButton((btn) => {
      btn.setButtonText(this.btn2Text).onClick(() => {
        var _a;
        this.close();
        this.resolvePromise({ proceed: false, data: { askConfirmation: (_a = this.checkboxEl) == null ? void 0 : _a.checked } });
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  async openAndGetValue() {
    this.open();
    return this.promise;
  }
};

// src/rules/rules.ts
var RulePrototype = class {
  constructor(app, plugin) {
    this.rulesConfigDiv = void 0;
    this.ruleType = "buildIn";
    this.isLiveRule = false;
    // If true, the rule is a live rule and will be executed on file change
    this.type = ["text"];
    // Types that are supported by this rule
    this.configElements = {};
    // Elements that are used to configure the rule
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = ''\n  return result;\n}";
    this.scriptingTools = new ScriptingTools(app, plugin);
  }
  getSource() {
    return this.source;
  }
  fx(app, file, tools, input) {
    if (input === void 0 || input === null)
      input = tools.getCurrentContent();
    return input;
  }
  /**
   * Configures the settings tab for a specific rule in the plugin.
   *
   * @param optionEL - The HTML element where the configuration options will be rendered.
   * @param rule - The settings object for the frontmatter automation rule.
   * @param that - The context or reference to the calling object.
   * @param previewComponent - The component used to render a preview of the rule's effect.
   */
  configTab(optionEL, rule, that, previewComponent) {
    optionEL.empty();
  }
  defaultConfigElements(modifiers) {
    const configElements = {
      removeContent: true,
      ruleActive: true,
      modifyOnly: true,
      inputProperty: false,
      addPrefix: true,
      spaceReplacement: true,
      specialCharacterReplacement: true,
      convertToLowerCase: true,
      resultAsLink: true,
      addContent: true,
      excludeFolders: true,
      includeFolders: true,
      script: true
    };
    return Object.assign({}, configElements, modifiers);
  }
  /**
   * Checks if a specific rule option is enabled.
   *
   * @param {string} option - The name of the rule option to check.
   * @returns {boolean} - Returns true if the option is enabled, false otherwise.
   */
  useRuleOption(option) {
    if (this.configElements[option] === void 0) {
      return false;
    }
    return this.configElements[option] || false;
  }
  /**
   * Checks if the rule has any configuration options.
   *
   * @returns {boolean} - Returns true if the rule has options, false otherwise.
   */
  hasOwnConfigTab() {
    return Object.getPrototypeOf(this).configTab !== RulePrototype.prototype.configTab;
  }
  /**
   * Executes the `fx` function based on the `ruleType`.
   * Handles different function signatures dynamically.
   * 
   * @param {App} app - The Obsidian app instance.
   * @param {any} file - The file to pass to the rule's `fx` function.
   * @param {ScriptingTools} tools - The scripting tools to pass to the rule's `fx` function.
   * @param {any} [input] - Optional input for rules that require it (e.g., `buildIn.inputProperty`).
   * @returns {string} - The result of the `fx` function.
  */
  execute(app, file, tools, input) {
    switch (this.ruleType) {
      case "formatter":
      case "linkFormatter":
        return this.fx(app, file, tools, input);
      case "buildIn.inputProperty":
        return this.fx(app, file, tools, input);
      case "autocomplete.modal":
      case "automation":
        let result = "";
        this.fx(app, file, tools).then((res) => {
          result = res;
        }).catch((err) => {
          logger.log(ERROR, `Error executing async automation rule: ${err}`);
        });
        return result;
      default:
        return this.fx(app, file, tools);
    }
  }
};
var Rules = class {
  constructor(app, plugin) {
    this.app = void 0;
    this.plugin = void 0;
    this.tools = void 0;
    this.plugin = plugin;
    this.app = app;
    this.tools = void 0;
    this.rules = [];
  }
  init(app, plugin, tools) {
    this.app = app;
    this.plugin = plugin;
    this.tools = tools;
  }
  /**
   * Registers a new rule by adding it to the list of existing rules.
   *
   * @param rule - The rule prototype to be registered. This should conform to the `RulePrototype` interface.
   */
  registerRule(rule) {
    this.rules.push(rule);
  }
  /**
   * Retrieves a list of rules filtered by the specified rule type and property type.
   *
   * @param ruleType - The type of rule to filter by.
   * @param propertyType - The property type to filter by within the rule's type array.
   * @returns An array of objects containing the `id` and `name` of each matching rule, sorted alphabetically by name.
   */
  getRulesByType(ruleType, propertyType) {
    return this.rules.filter((rule) => rule.ruleType === ruleType && (!propertyType || rule.type.includes(propertyType))).map((rule) => ({ id: rule.id, name: rule.name })).sort((a, b) => a.name.localeCompare(b.name));
  }
  /**
   * Retrieves a rule object by its unique identifier.
   *
   * @param id - The unique identifier of the rule to retrieve.
   * @returns The rule object matching the provided ID, or `undefined` if no matching rule is found.
   * @throws Logs a warning to the console if the rule with the specified ID is not found.
   */
  getRuleById(id) {
    const ruleObject = this.rules.find((rule) => rule.id === id);
    if (!ruleObject) {
      logger.log(WARNING, `Rule with id "${id}" not found.`);
      return void 0;
    }
    return ruleObject;
  }
  /**
   * Retrieves the source code of a rule by its unique identifier.
   *
   * @param id - The unique identifier of the rule for which to retrieve the source code.
   * @returns The source code of the rule, or `undefined` if the rule is not found.
   */
  getSource(id) {
    const ruleObject = this.getRuleById(id);
    if (!ruleObject) {
      logger.log(WARNING, `Source for rule with id "${id}" not found.`);
      return void 0;
    }
    return ruleObject.getSource();
  }
  /**
   * Executes the `fx` function of a rule matching the given `id` and returns its result.
   * 
   * @param {string} id - The unique identifier of the rule to execute.
   * @param {App} app - The Obsidian app instance.
   * @param {any} file - The file to pass to the rule's `fx` function.
   * @param {ScriptingTools} tools - The scripting tools to pass to the rule's `fx` function.
   * @param {any} [input] - Optional input for rules that require it.
   * @returns {string | null} - The result of the `fx` function, or `null` if the rule is not found.
  */
  executeRuleById(id, ruleSettings, app, file, tools, input) {
    const rule = this.rules.find((rule2) => rule2.id === id);
    if (!rule) {
      logger.log(WARNING, `Rule with id "${id}" not found.`);
      return null;
    }
    return this.executeRule(ruleSettings, rule, app, file, tools, input);
  }
  /**
   * Executes the `fx` function of a given rule and returns its result.
   *
   * @param rule - The rule to execute.
   * @param app - The Obsidian app instance.
   * @param file - The file to pass to the rule's `fx` function.
   * @param tools - The scripting tools to pass to the rule's `fx` function.
   * @param input - Optional input for rules that require it.
   * @returns {string | null} - The result of the `fx` function, or `null` if the rule is not found.
   */
  executeRule(ruleSettings, rule, app, file, tools, input) {
    switch (rule.ruleType) {
      case "formatter":
      case "linkFormatter":
      case "buildIn.inputProperty":
        return rule.execute(app, file, tools, input);
      case "automation":
        return rule.execute(app, file, tools);
      default:
        if (ruleSettings.useCustomCode && ruleSettings.buildInCode && ruleSettings.buildInCode !== "") {
          const code = parseJSCode(ruleSettings.buildInCode);
          if (typeof code === "function") {
            return code(app, file, tools);
          } else {
            logger.log(ERROR, `Invalid custom code for rule "${ruleSettings.content}": ${ruleSettings.buildInCode}`);
            return `Invalid custom code for rule "${ruleSettings.id}"`;
          }
        } else {
          return rule.execute(app, file, tools, input);
        }
    }
  }
  applyFormatOptions(value, rule, activeFile, tools) {
    if (rule.type === "number" || rule.type === "checkbox" || rule.type === "date" || rule.type === "datetime")
      return value;
    switch (typeof value) {
      case "boolean":
      case "number":
        return value;
      case "string":
        if (rule.formatters && rule.formatters.length > 0) {
          rule.formatters.forEach((formatterId) => {
            value = this.executeRuleById(formatterId, rule, this.app, activeFile, tools, value);
          });
        }
        if (rule.linkFormatter && rule.linkFormatter !== "") {
          value = this.executeRuleById(rule.linkFormatter, rule, this.app, activeFile, tools, value);
        }
        return value;
      case "object":
        if (Array.isArray(value)) {
          return value.map((value2) => this.applyFormatOptions(value2, rule, activeFile, tools));
        }
        return value;
    }
    return;
  }
  mergeResult(result, oldResult, returnResult, rule) {
    if (!this.tools) {
      console.warn("Tools are not available for merging results.");
      return result;
    }
    switch (rule.addContent) {
      case "overwrite":
        returnResult = result;
        break;
      case "end":
        if (rule.type === "multitext" || rule.type === "tags" || rule.type === "aliases") {
          if (!result)
            result = [];
          if (typeof result === "string")
            result = [result];
          if (!Array.isArray(returnResult))
            returnResult = [returnResult];
          if (!Array.isArray(oldResult))
            oldResult = [oldResult];
          let filtered = returnResult.filter((value) => !oldResult.includes(value));
          returnResult = this.tools.removeDuplicateStrings(filtered.concat(result));
        } else {
          if (!returnResult)
            returnResult = "";
          returnResult = returnResult.replaceAll(returnResult, oldResult);
          returnResult = returnResult + result;
        }
        break;
      case "start":
        if (rule.type === "multitext" || rule.type === "tags" || rule.type === "aliases") {
          if (!result)
            result = [];
          if (typeof result === "string")
            result = [result];
          if (!Array.isArray(returnResult))
            returnResult = [returnResult];
          if (!Array.isArray(oldResult))
            oldResult = [oldResult];
          let filtered = returnResult.filter((value) => !oldResult.includes(value));
          returnResult = this.tools.removeDuplicateStrings(result.concat(filtered));
        } else {
          if (!returnResult)
            returnResult = "";
          returnResult = returnResult.replaceAll(returnResult, oldResult);
          returnResult = result + returnResult;
        }
        break;
    }
    return returnResult;
  }
  /**
   * Builds the configuration tab for a specific rule by its ID.
   *
   * @param id - The unique identifier of the rule for which the configuration tab is being built.
   * @param optionEL - The HTML element where the configuration tab will be rendered.
   * @param rule - The definition of the rule, containing its properties and settings.
   * @param that - A reference to the current context or object, typically used for maintaining scope.
   * @param previewComponent - A component used to render a preview of the rule's effect or configuration.
   *
   * @remarks
   * If a rule with the specified ID is found, its `configTab` method is invoked to build the configuration tab.
   * If no rule is found, a warning is logged to the console.
   */
  buildConfigTab(id, optionEL, rule, that, previewComponent) {
    const ruleInstance = this.rules.find((rule2) => rule2.id === id);
    if (ruleInstance) {
      ruleInstance.configTab(optionEL, rule, that, previewComponent);
    } else {
      console.warn(`Rule with id "${id}" not found for config tab.`);
    }
  }
};
var rulesManager = new Rules();

// src/tools.ts
function parseJSCode(jsCode) {
  function parseFunction(jsCode2) {
    try {
      jsCode2 = cleanCodeString(jsCode2);
      var funcReg = /function *\(([^()]*)\)[ \n\t]*{(.*)}/gmi;
      var match = funcReg.exec(jsCode2.replace(/\n/g, " "));
      if (!match)
        return void 0;
      var args = match[1].split(",");
      args.push(match[2]);
      return new Function(...args);
    } catch (error) {
      logger.log(ERROR, "error parsing JS function!", error);
      return error.message;
    }
  }
  ;
  return parseFunction(jsCode);
}
function cleanCodeString(codeString) {
  if (typeof codeString !== "string") {
    throw new TypeError("Input must be a string.");
  }
  let inMultiLineComment = false;
  let inSingleLineComment = false;
  let inString = null;
  let inRegExp = false;
  let cleanedCode = "";
  let i = 0;
  while (i < codeString.length) {
    const char = codeString[i];
    const nextChar = codeString[i + 1];
    if (inMultiLineComment) {
      if (char === "*" && nextChar === "/") {
        inMultiLineComment = false;
        i += 2;
        continue;
      } else {
        i++;
        continue;
      }
    }
    if (inSingleLineComment) {
      if (char === "\n" || char === "\r") {
        inSingleLineComment = false;
        cleanedCode += char;
        i++;
        continue;
      } else {
        i++;
        continue;
      }
    }
    if (inString) {
      if (char === inString) {
        inString = null;
      } else if (char === "\\") {
        cleanedCode += char;
        i++;
        if (i < codeString.length) {
          cleanedCode += codeString[i];
        }
        i++;
        continue;
      }
      cleanedCode += char;
      i++;
      continue;
    }
    if (inRegExp) {
      if (char === "/") {
        inRegExp = false;
      } else if (char === "\\") {
        cleanedCode += char;
        i++;
        if (i < codeString.length) {
          cleanedCode += codeString[i];
        }
        i++;
        continue;
      }
      cleanedCode += char;
      i++;
      continue;
    }
    if (char === "/" && nextChar === "*") {
      inMultiLineComment = true;
      i += 2;
      continue;
    }
    if (char === "/" && nextChar === "/") {
      inSingleLineComment = true;
      i += 2;
      continue;
    }
    if (char === '"' || char === "'") {
      inString = char;
      cleanedCode += char;
      i++;
      continue;
    }
    if (char === "/") {
      const prevMeaningfulChar = cleanedCode.trim().slice(-1);
      if (prevMeaningfulChar === "" || ["(", ",", "=", ":", "[", "!", "&", "|", "?", "{", ";", "\n", "\r"].includes(prevMeaningfulChar)) {
        inRegExp = true;
        cleanedCode += char;
        i++;
        continue;
      }
    }
    cleanedCode += char;
    i++;
  }
  return cleanedCode;
}
function resolveFolder(app, folder_str) {
  folder_str = (0, import_obsidian4.normalizePath)(folder_str);
  const folder = app.vault.getAbstractFileByPath(folder_str);
  if (!folder) {
    throw new ErrorManager(`Folder "${folder_str}" doesn't exist`);
  }
  if (!(folder instanceof import_obsidian4.TFolder)) {
    throw new ErrorManager(`${folder_str} is a file, not a folder`);
  }
  return folder;
}
function getFilesFromFolder(app, folder_str) {
  const folder = resolveFolder(app, folder_str);
  const files = [];
  import_obsidian4.Vault.recurseChildren(folder, (file) => {
    if (file instanceof import_obsidian4.TFile) {
      files.push(file);
    }
  });
  files.sort((a, b) => {
    return a.path.localeCompare(b.path);
  });
  return files;
}
var ScriptingTools = class {
  constructor(app, plugin, settings, rule, frontmatter, activeFile) {
    this.knownProperties = {};
    this.app = app;
    this.plugin = plugin;
    this.settings = settings;
    this.rule = rule;
    this.frontmatter = frontmatter;
    this.activeFile = activeFile;
  }
  /**
   * Retrieves the frontmatter object associated with the current instance.
   *
   * @returns The frontmatter data.
   */
  getFrontmatter() {
    return this.frontmatter;
  }
  /**
   * Sets the frontmatter property for the current instance.
   *
   * @param frontmatter - The frontmatter object to assign.
   */
  setFrontmatter(frontmatter) {
    this.frontmatter = frontmatter;
  }
  /**
   * Sets a property in the frontmatter object. If the frontmatter does not exist, it initializes it as an empty object.
   *
   * @param key - The property name to set in the frontmatter.
   * @param value - The value to assign to the specified property.
   */
  setFrontmatterProperty(key, value) {
    if (!this.frontmatter)
      this.frontmatter = {};
    this.frontmatter[key] = value;
  }
  /**
   * Retrieves the value of a specified property from the frontmatter object.
   *
   * @param key - The name of the property to retrieve from the frontmatter.
   * @returns The value associated with the specified key in the frontmatter, or `undefined` if the key does not exist.
   */
  getFrontmatterProperty(key) {
    return this.frontmatter[key];
  }
  /**
   * Sets the currently active file.
   *
   * @param file - The file to set as active. Must be an instance of `TFile`.
   */
  setActiveFile(file) {
    this.activeFile = file;
  }
  /**
   * Returns the currently active file.
   *
   * @returns The active file object, or `undefined` if no file is active.
   */
  getActiveFile() {
    return this.activeFile;
  }
  /**
   * Sets the current rule configuration for the frontmatter automation.
   *
   * @param rule - The rule settings to apply, represented by a `FrontmatterAutomateRuleSettings` object.
   */
  setRule(rule) {
    this.rule = rule;
  }
  /**
   * Retrieves the current rule associated with this instance.
   *
   * @returns The rule object or value stored in the `rule` property.
   */
  getRule() {
    return this.rule;
  }
  /**
   * Retrieves a rule function based on the provided rule settings.
   *
   * @param rule - Optional. The rule settings to use for retrieving the rule function.
   *               If not provided, the method uses the instance's default rule.
   * @returns The rule function associated with the specified rule settings, or `undefined` if no rule is found.
   */
  getRuleFunction(rule) {
    if (!rule)
      rule = this.rule;
    if (rule) {
      return rulesManager.getRuleById(rule.content);
    }
  }
  /**
   * Sets the current content to the provided value.
   *
   * @param content - The content to set as the current content. Can be of any type.
   */
  setCurrentContent(content) {
    this.currentContent = content;
  }
  /**
   * Retrieves the current content stored in the instance.
   *
   * @returns The current content.
   */
  getCurrentContent() {
    return this.currentContent;
  }
  /**
   * Updates the specified frontmatter property of a given file with new content.
   *
   * If no file is provided, the currently active file is used. If neither is available, the method returns early.
   * The method logs the update operation and only supports updating properties with primitive values or arrays.
   * If `newContent` is an object (but not an array), a warning is issued and the update is not performed.
   * The file's modification time (`mtime`) is preserved and not changed during the update.
   *
   * @param property - The frontmatter property to update.
   * @param newContent - The new value to assign to the property. Objects (except arrays) are not supported.
   * @param file - (Optional) The file whose frontmatter should be updated. If omitted, the active file is used.
   */
  updateFrontmatter(property, newContent, file) {
    if (!this.app)
      return;
    if (!file)
      file = this.activeFile;
    if (!file)
      return;
    this.app.fileManager.processFrontMatter(file, (frontmatter) => {
      logger.log(DEBUG, `updateFrontmatter '${file.path}' frontmatter '${property}' to '${newContent.toString()}'`);
      if (typeof newContent === "object" && !Array.isArray(newContent)) {
        logger.log(WARNING, `updateFrontmatter '${file.path}'|'${property}' object not supported!`);
      } else {
        frontmatter[property] = newContent;
      }
    }, { "mtime": file.stat.mtime });
  }
  /**
   * Displays a confirmation dialog with customizable message, title, and button labels.
   *
   * @param message - The message to display in the confirmation dialog.
   * @param title - The title of the dialog window. Defaults to 'Confirm'.
   * @param button1 - The label for the confirmation button. Defaults to 'Yes'.
   * @param button2 - The label for the cancellation button. Defaults to 'No'.
   * @returns A promise that resolves to a boolean indicating whether the user confirmed (true) or cancelled (false).
   */
  async showConfirmDialog(message, title = "Confirm", button1 = "Yes", button2 = "No") {
    const result = await new AlertModal(this.app, title, message, button1, button2).openAndGetValue();
    return result.proceed;
  }
  /**
   * * Get the option config for a specific rule. Optional the specific parameter by providing an option ID.
   *
   * @param {string} ruleId
   * @param {string} [optionId]
   * @return {*} 
   */
  getOptionConfig(ruleId, optionId) {
    if (!ruleId || ruleId === void 0 || !this.settings)
      return void 0;
    const rule = this.settings.rules.find((rule2) => rule2.id === ruleId);
    if (rule && rule.hasOwnProperty("optionsConfig")) {
      const optionConfig = rule.optionsConfig[ruleId];
      if (optionConfig) {
        if (optionId) {
          logger.log(TRACE, `getOptionConfig: ${ruleId} option '${optionId}'`, rule, optionConfig[optionId]);
          return optionConfig[optionId];
        } else {
          return optionConfig;
        }
      }
    }
    return void 0;
  }
  /**
   * Retrieves all markdown files in the vault whose paths include the specified matching string.
   *
   * The `matching` parameter is normalized to ensure it ends with a single '/' character,
   * and is used to filter files whose paths contain this substring.
   *
   * @param folderPath - The folder path or substring to match within file paths.
   * @returns An array of `TFile` objects whose paths include the normalized `matching` string.
   */
  getFilesInVault(folderPath) {
    folderPath = folderPath.replace(/^\/|\/$/g, "") + "/";
    const files = this.app.vault.getMarkdownFiles();
    const matchingFiles = files.filter((file) => file instanceof import_obsidian4.TFile && file.path.includes(folderPath));
    return matchingFiles;
  }
  /**
   * Creates a mock `TFile` object from a given file path string.
   *
   * This method parses the provided path to construct a `TFile`-like object,
   * extracting the file name, extension, and base name. The returned object
   * contains placeholder values for file statistics and parent, as these details
   * are unknown. If the input path is empty or undefined, the method returns `undefined`.
   *
   * @param path - The file path string to generate the mock `TFile` from.
   * @returns A mock `TFile` object representing the file at the given path, or `undefined` if the path is invalid.
   */
  getMockFileFromPath(path) {
    if (!path)
      return void 0;
    let oldFile;
    let oldFileParts = path.split("/");
    oldFile = {
      path,
      extension: oldFileParts[oldFileParts.length - 1].split(".")[1],
      name: oldFileParts[oldFileParts.length - 1],
      stat: { mtime: 0, ctime: 0, size: 0 },
      // stats are unknown
      basename: this.removeAllExtensions(oldFileParts[oldFileParts.length - 1]),
      vault: this.app.vault,
      parent: null
      // parent is unknown
    };
    return oldFile;
  }
  /**
   * Retrieves a `TFile` object from a given file path.
   *
   * @param path - The file path to search for. If `undefined`, the function returns `undefined`.
   * @param filesCheck - An optional array of `TFile` objects to search within. If not provided, all markdown files in the vault are used.
   * @returns The matching `TFile` if found; otherwise, `undefined`.
   */
  getTFileFromPath(path, filesCheck = void 0) {
    if (!path)
      return void 0;
    const files = filesCheck ? filesCheck : this.app.vault.getMarkdownFiles();
    const matchingFiles = files.filter(
      (file) => file instanceof import_obsidian4.TFile && file.path.toLocaleLowerCase() === path.toLocaleLowerCase()
    );
    return matchingFiles.length > 0 ? matchingFiles[0] : void 0;
  }
  /**
   * Creates a new file at the specified path using the content from a template file.
   * If the file already exists, returns the existing file instead of creating a new one.
   *
   * @param fileNameWithPath - The full path (including file name) where the new file should be created.
   * @param templateFileWithPath - The full path to the template file whose content will be used.
   * @returns A promise that resolves to the newly created file or the existing file if it already exists.
   * @throws {ErrorManager} If the folder path is invalid, does not exist, or is not a folder.
   */
  async createFileFromPath(fileNameWithPath, templateFileWithPath) {
    const fileName = fileNameWithPath.replace(/^\/|\/$/g, "");
    const templateFile = templateFileWithPath.replace(/^\/|\/$/g, "");
    const folderPath = this.getFolderFromPath(fileName);
    const fileNameOnly = fileName.split("/").pop() || fileName;
    if (!folderPath) {
      throw new ErrorManager(`Invalid folder path: "${folderPath}"`);
    }
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!folder) {
      throw new ErrorManager(`Folder "${folderPath}" doesn't exist`);
    }
    if (!(folder instanceof import_obsidian4.TFolder)) {
      throw new ErrorManager(`${folderPath} is a file, not a folder`);
    }
    const templateContent = await this.app.vault.read(this.app.vault.getAbstractFileByPath(templateFile));
    const fileExists = this.app.vault.getAbstractFileByPath(fileNameWithPath);
    if (!fileExists) {
      return await this.app.vault.create(folder.path + "/" + fileNameOnly, templateContent);
    }
    return fileExists;
  }
  // create the file if it does not exist
  /**
   * * Fetches custom property information from all markdown files in the vault.
   *
   * @return {*} 
   */
  fetchCustomPropertyInfos(app) {
    const propertyInfos = {};
    const files = app.vault.getMarkdownFiles();
    files.forEach((file) => {
      const metadata = app.metadataCache.getFileCache(file);
      if (metadata == null ? void 0 : metadata.frontmatter) {
        Object.keys(metadata.frontmatter).forEach((key) => {
          if (!propertyInfos[key]) {
            propertyInfos[key] = { name: key, type: "text" };
          }
        });
      }
    });
    return propertyInfos;
  }
  /**
   * Fetches known properties from the metadata cache.
   * If the method getAllPropertyInfos is not available, it falls back to fetchCustomPropertyInfos.
   * @param app The Obsidian app instance.
   */
  async fetchKnownProperties(app) {
    let propertyInfos = {};
    if (typeof app.metadataCache.getAllPropertyInfos === "function") {
      propertyInfos = app.metadataCache.getAllPropertyInfos();
    } else {
      propertyInfos = this.fetchCustomPropertyInfos(app);
    }
    propertyInfos = Object.fromEntries(
      Object.entries(propertyInfos).sort(([keyA], [keyB]) => keyA.localeCompare(keyB))
    );
    this.knownProperties = {};
    Object.keys(propertyInfos).forEach((key) => {
      this.knownProperties[propertyInfos[key].name] = propertyInfos[key];
    });
    logger.log(DEBUG, this.knownProperties);
    return this.knownProperties;
  }
  /**
   * Retrieves the known properties, initializing them if they have not been loaded yet.
   * If the properties are not already cached, this method fetches them using `fetchCustomPropertyInfos`
   * and stores them for future access.
   *
   * @returns The cached or newly fetched known properties.
   */
  getKnownProperties() {
    if (!this.knownProperties) {
      this.knownProperties = this.fetchCustomPropertyInfos(this.app);
    }
    return this.knownProperties;
  }
  /**
   * Extracts the path and title from a given link string.
   *
   * The input link is expected to be in the format `[[path|title]]` or `[[path]]`.
   * This function removes square brackets, splits the link by the `|` character,
   * and determines the path and title. If the title is not provided, the path is
   * used as the title.
   *
   * @param link - The link string to extract parts from, typically in the format `[[path|title]]` or `[[path]]`.
   * @returns An object containing the `path` and `title` extracted from the link.
   */
  extractLinkParts(link) {
    const cleanedLink = link.replace(/[\[\]]/g, "");
    const parts = cleanedLink.split("|");
    const path = parts[0].trim();
    const title = parts.length > 1 ? parts[1].trim() : path;
    return { path, title };
  }
  /**
   * Extracts the path, title, and file name from a given file link string.
   *
   * Splits the input string by the "/" character to separate the file name from its path.
   * The title is derived from the file name by removing all extensions and trimming whitespace.
   *
   * @param link - The file link string to extract parts from.
   * @returns An object containing:
   *   - `path`: The directory path portion of the link (excluding the file name).
   *   - `title`: The file name without extensions and trimmed.
   *   - `fileName`: The full file name (with extensions, if any).
   */
  extractPathParts(link) {
    const parts = link.split("/");
    const fileName = parts.pop() || "";
    const title = this.removeAllExtensions(fileName).trim();
    const path = parts.join("/").trim();
    return { path, title, fileName };
  }
  /**
   * Removes one or more leading slashes from the beginning of the given path string.
   *
   * @param path - The input string from which to remove leading slashes.
   * @returns The input string without any leading slashes.
   */
  removeLeadingSlash(path) {
    return path.replace(/^\/+/, "");
  }
  /**
   * Ensures that the given path string starts with a leading slash ('/').
   * If the path already begins with a slash, it is returned unchanged.
   *
   * @param path - The input path string to modify.
   * @returns The path string guaranteed to start with a leading slash.
   */
  addLeadingSlash(path) {
    return path.replace(/^(?!\/)/, "/");
  }
  /**
   * Check if a string complies with ISO Standard
   * 
   * @param str Any string
   * @param options Options to look for
   * @returns 
   */
  isISOString(str, options = {}) {
    const {
      withMilliseconds = false,
      withTimezone = false,
      withTime = true,
      withDate = true
    } = options;
    let dateRegexStr = "^(?:\\d{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[12]\\d|3[01]))";
    let timeRegexStr = "(?:T(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
    if (withMilliseconds) {
      timeRegexStr += "\\.\\d{3}";
    }
    if (withTimezone) {
      timeRegexStr += "(?:Z|[+-](?:[01]\\d|2[0-3]):[0-5]\\d)?)?";
    } else {
      timeRegexStr += ")?";
    }
    let regexStr = "";
    if (withDate && withTime) {
      regexStr = `${dateRegexStr}${timeRegexStr}$`;
    } else if (withDate) {
      regexStr = `${dateRegexStr}$`;
    } else if (withTime) {
      regexStr = `^${timeRegexStr.slice(4)}$`;
    } else {
      return false;
    }
    const regex = new RegExp(regexStr);
    return regex.test(str);
  }
  /**
   * Try to convert Any Types to a specific Type
   * @param input 
   * @param typeString 'string' | 'number' | 'boolean' | 'string[]'
   * @returns 
   */
  tryConvert(input, typeString) {
    switch (typeString) {
      case "string":
        if (typeof input === "string") {
          return input;
        }
        return void 0;
      case "number":
        const num = Number(input);
        if (!isNaN(num)) {
          return num;
        }
        return void 0;
      case "boolean":
        if (typeof input === "boolean") {
          return input;
        }
        if (typeof input === "string") {
          const lowerValue = input.toLowerCase();
          if (lowerValue === "true") {
            return true;
          }
          if (lowerValue === "false") {
            return false;
          }
        }
        if (typeof input === "number") {
          if (input === 1) {
            return true;
          }
          if (input === 0) {
            return false;
          }
        }
        return void 0;
      case "string[]":
        if (Array.isArray(input) && input.every((item) => typeof item === "string")) {
          return input;
        }
        return void 0;
      default:
        return void 0;
    }
  }
  /**
   * Formats a given text string to be safe for use in YAML by replacing special characters.
   *
   * Replaces all characters that are not alphanumeric, dash, underscore, slash, or certain accented characters
   * with a specified replacement string. If no replacement string is provided, it uses the value from settings,
   * or defaults to `'-'`.
   *
   * @param text - The input string to format.
   * @param replaceBy - Optional. The string to replace special characters with. If not provided, uses the value from settings or `'-'`.
   * @returns The formatted string safe for YAML usage.
   */
  formatToYAMLSaveString(text, replaceBy = void 0) {
    let replaceString = "-";
    if (!replaceBy && this.settings) {
      replaceString = this.settings.specialCharReplacement || "-";
    } else {
      if (replaceBy)
        replaceString = replaceBy;
    }
    return text.replace(/[^a-zA-Z0-9\-_\/äöüßÄÖÜáéíóúýÁÉÍÓÚÝàèìòùÀÈÌÒÙâêîôûÂÊÎÔÛãñõÃÑÕ]/g, replaceString);
  }
  /**
   * Converts a string to a YAML-safe format by adding quotes when necessary.
   * @param input The string, boolean, number or array to make YAML-safe
   * @returns The safely quoted string when needed, or the original string if safe
   */
  toYamlSafeString(input) {
    if (Array.isArray(input)) {
      input.forEach((item, index) => {
        input[index] = this.toYamlSafeString(item).toString();
      });
      return input;
    }
    switch (typeof input) {
      case "number":
        return input;
      case "boolean":
        return input ? "true" : "false";
      case "string":
        const trimmed = input.trim();
        if (trimmed === "")
          return '""';
        const needsQuotes = /[:{}\[\],&*#?|<>=!%@`"'\\]|^[-?\n]|[\s\n]|^[yYnN]|^[0-9]|^[+-]|^(true|false|yes|no|on|off)$/i.test(trimmed);
        const isAlreadyQuoted = trimmed.startsWith('"') && trimmed.endsWith('"') || trimmed.startsWith("'") && trimmed.endsWith("'");
        if (!needsQuotes && !isAlreadyQuoted) {
          return trimmed;
        }
        if (!isAlreadyQuoted) {
          return `"${trimmed.replace(/"/g, '\\"')}"`;
        }
        return trimmed;
      default:
        logger.log(ERROR, `toYamlSafeString(${input}) if of type '${typeof input}'`);
        return input;
    }
  }
  /**
   * Converts an input string or array of strings into a Markdown Link format.
   * 
   * @param input - The input to be converted. Can be a string or an array of strings.
   * @param replaceSpaces - Optional parameter to specify a replacement for spaces in the path or title.
   *                        If provided, spaces will be replaced with this value.
   * @returns A string in Markdown Link format if the input is a single string, or a concatenated string
   *          of Markdown Links if the input is an array of strings.
   * 
   * The Markdown Link format is `[title](path)`, where:
   * - `path` is the formatted path of the link.
   * - `title` is the formatted title of the link.
   * 
   * If the input is an array, each element is converted to a WikiLink and joined with a comma.
   */
  toMarkdownLink(input, replaceSpaces) {
    if (Array.isArray(input)) {
      return input.map((item) => this.toWikiLink(item)).join(", ");
    }
    if (typeof input === "string") {
      const { path, title, fileName } = this.extractPathParts(input);
      const formattedPath = this.replaceSpaces(input, replaceSpaces);
      const formattedTitle = this.replaceSpaces(title, replaceSpaces);
      return `[[${formattedPath}|${formattedTitle}]]`;
    }
    return input;
  }
  /**
   * Converts an input string or array of strings into a WikiLink format string or array of strings.
   * 
   * @param input - The input to be converted. Can be a string or an array of strings.
   * @param replaceSpaces - Optional parameter to specify a replacement for spaces in the path or title.
   *                        If provided, spaces will be replaced with this value.
   * @returns A string in WikiLink format if the input is a single string, or a concatenated string
   *          of WikiLinks if the input is an array of strings.
   * 
   * The WikiLink format is `[[fileName]]`, where:
   * - `fileName` is the formatted unique fileName of the link.
   * 
   * If the input is an array, each element is converted to a WikiLink and joined with a comma.
   */
  toWikiLink(input, replaceSpaces = " ") {
    if (Array.isArray(input)) {
      return input.flatMap((item) => this.toWikiLink(item));
    }
    if (typeof input === "string") {
      const { path, title } = this.extractLinkParts(input);
      const formattedTitle = this.replaceSpaces(this.removeAllExtensions(title), replaceSpaces);
      return `[[${formattedTitle}]]`;
    }
    return input;
  }
  /**
   * Replaces all whitespace characters in the given text with a specified replacement string.
   *
   * @param text - The input string in which spaces will be replaced.
   * @param replaceBy - Optional. The string to replace spaces with. If not provided, uses the value from `this.settings.spaceReplacement` or defaults to '_'.
   * @returns The modified string with spaces replaced by the specified replacement string.
   */
  replaceSpaces(text, replaceBy = void 0) {
    let replaceString = "_";
    if (!replaceBy && this.settings) {
      replaceString = this.settings.spaceReplacement || "_";
    } else {
      if (replaceBy)
        replaceString = replaceBy;
    }
    return text.replace(/\s+/g, replaceString);
  }
  /**
   * Removes the ALL file extension(s) from a given file name.
   *
   * @param fileName - The name of the file, including its extension.
   * @returns The file name without its extension.
   */
  removeAllExtensions(fileName) {
    return fileName.split(".")[0];
  }
  /**
   * Removes the last file extension(s) from a given file name.
   *
   * @param fileName - The name of the file, including its extension.
   * @returns The file name without its extension.
   */
  removeExtensions(fileName) {
    const result = fileName.split(".");
    result.pop();
    if (result.length === 0)
      return fileName;
    return result.join(".") || fileName;
  }
  /**
   * Converts a given string to camelCase format.
   *
   * Splits the input text by spaces, lowercases the first word,
   * and capitalizes the first letter of each subsequent word,
   * then joins them together without spaces.
   *
   * @param text - The input string to be converted.
   * @returns The camelCase formatted string.
   */
  formatUpperCamelCase(text) {
    let textParts = text.split(" ");
    let convertedTextParts = [];
    textParts.forEach((text2, index) => {
      let newTextPart = text2.toLowerCase();
      newTextPart = newTextPart.charAt(0).toUpperCase() + newTextPart.slice(1);
      convertedTextParts.push(newTextPart);
    });
    return convertedTextParts.join("");
  }
  /**
   * get the path to a file from a string containing the full parh/name string
   * @param path string
   * @param separator string defaults to '/'
   * @returns string
   */
  getFolderFromPath(path, separator = "/") {
    if (path === null)
      return null;
    if (path === void 0)
      return void 0;
    const currentPathParts = path.split("/");
    currentPathParts.pop();
    return currentPathParts.join(separator);
  }
  /**
   * removes duplicate strings in an array and deletes empty strings
   * @param stringArray 
   * @returns 
   */
  removeDuplicateStrings(stringArray) {
    if (!stringArray)
      return [];
    const uniqueStringsSet = new Set(stringArray);
    uniqueStringsSet.delete("");
    return [...uniqueStringsSet];
  }
};
function getFolderFromPath(path, separator = "/") {
  if (path === null)
    return null;
  if (path === void 0)
    return void 0;
  const currentPathParts = path.split("/");
  currentPathParts.pop();
  return currentPathParts.join(separator);
}

// src/types.ts
var versionString = "0.0.25";
var DEFAULT_FILTER_FILES_AND_FOLDERS = {
  selectedFolders: [],
  selectedFiles: [],
  mode: "exclude",
  display: "folders"
};
var DEFAULT_FRONTMATTER_AUTOMATE_SETTINGS = {
  tagPrefix: "",
  excludeRootFolder: false,
  tagsPropertyName: "tags",
  spaceReplacement: "",
  specialCharReplacement: "",
  lowercaseTags: false,
  knownProperties: [],
  rules: [],
  useTextArea: false,
  exclude: {
    selectedFolders: [],
    selectedFiles: [],
    mode: "exclude",
    display: "folders"
  },
  include: {
    selectedFolders: [],
    selectedFiles: [],
    mode: "include",
    display: "folders"
  },
  configuredProperties: [],
  debugLevel: WARNING,
  delayCreateEvent: 0,
  // default to no delay
  folderConfig: { folders: [], rows: [] }
};
var DEFAULT_RULE_DEFINITION = {
  id: "",
  active: true,
  asLink: false,
  //deprecated
  addContent: "overwrite",
  property: "",
  value: "",
  customProperty: "",
  type: "text",
  typeProperty: { name: "", type: "text", source: "registered" },
  content: "",
  buildInCode: "",
  jsCode: "",
  showContent: false,
  exclude: {
    selectedFolders: [],
    selectedFiles: [],
    mode: "exclude",
    display: "folders"
  },
  include: {
    selectedFolders: [],
    selectedFiles: [],
    mode: "include",
    display: "folders"
  },
  prefix: "",
  spaceReplacement: "",
  specialCharReplacement: "",
  lowercaseTags: false,
  //deprecated
  formatter: "toOriginal",
  //deprecated
  formatters: ["toOriginal"],
  linkFormatter: "toOriginalLink",
  inputProperty: "",
  onlyModify: true,
  useCustomCode: false
};

// src/directorySelectionModal.ts
var import_obsidian5 = require("obsidian");
var DirectorySelectionModal = class extends import_obsidian5.Modal {
  // Reference to update dropdown on reset
  /**
   * Creates an instance of the DirectorySelectionModal.
   * @param app - The Obsidian App instance.
   * @param initialFolders - Array of initially selected folder paths.
   * @param initialFiles - Array of initially selected file paths.
   * @param initialMode - The initial selection mode ('include' or 'exclude').
   * @param okCallback - Function to call when the user clicks "OK". Receives the selection result.
   */
  constructor(app, initialFolders, initialFiles, initialOptions, okCallback) {
    super(app);
    this.showFiles = false;
    // Container for the tree view
    this.treeNodes = /* @__PURE__ */ new Map();
    // Map path to node info for quick access
    this.modeDropdown = null;
    this.initialFoldersSnapshot = new Set(initialFolders);
    this.initialFilesSnapshot = new Set(initialFiles);
    this.initialModeSnapshot = initialOptions.selectionMode;
    this.initialDisplaySnapshot = initialOptions.displayMode;
    this.showFiles = initialOptions.displayMode === "files" || initialOptions.displayMode === "file" || initialFiles.length > 0;
    this.options = initialOptions;
    this.okCallback = okCallback;
    this.resetSelectionToInitial();
  }
  /**
   * Resets the current selection state to the initial state provided at construction.
   */
  resetSelectionToInitial() {
    this.currentFolders = new Set(this.initialFoldersSnapshot);
    this.currentFiles = new Set(this.initialFilesSnapshot);
    this.currentMode = this.initialModeSnapshot;
  }
  /**
   * Resets the current selection state to empty.
   */
  resetSelectionToEmpty() {
    this.currentFolders = /* @__PURE__ */ new Set([]);
    this.currentFiles = /* @__PURE__ */ new Set([]);
    this.currentMode = this.initialModeSnapshot;
  }
  /**
   * Called when the modal is opened. Builds the UI.
   */
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("directory-selection-modal");
    if (this.includeExcludeSelectable) {
      contentEl.createEl("h2", { text: this.options.title || "Include or Exclude Folders and Files" });
    } else {
      contentEl.createEl("h2", { text: this.options.title || `${this.currentMode === "exclude" ? "Exclude" : "Include"} Folders and Files` });
    }
    const controlsEl = contentEl.createDiv({ cls: "modal-controls" });
    this.createModeSetting(controlsEl);
    this.createShowFilesSetting(controlsEl);
    this.treeRootElement = contentEl.createDiv({ cls: "tree-view-container" });
    this.treeRootElement.style.maxHeight = "600px";
    this.treeRootElement.style.overflowY = "auto";
    this.treeRootElement.style.border = "1px solid var(--background-modifier-border)";
    this.treeRootElement.style.padding = "10px";
    this.treeRootElement.style.marginTop = "10px";
    this.treeRootElement.style.marginBottom = "10px";
    if (!this.treeNodes.size) {
      this.buildAndRenderTree();
    }
    this.createActionButtons(contentEl);
  }
  /**
   * Creates the dropdown setting for choosing the selection mode.
   * @param containerEl - The HTML element to append the setting to.
   */
  createModeSetting(containerEl) {
    if (this.includeExcludeSelectable) {
      this.modeDropdown = new import_obsidian5.Setting(containerEl).setName("Selection Mode").setDesc("Choose if the selected files and folders should be excluded or included.").addDropdown((dropdown) => {
        dropdown.addOption("exclude", "exclude").addOption("include", "include").setValue(this.currentMode).onChange((value) => {
          this.currentMode = value;
          this.updateTreeAppearance();
        });
      });
    }
  }
  /**
   * Updates the mode dropdown UI element to reflect the currentMode state.
   */
  updateModeDropdown() {
    var _a;
    const dropdownComponent = (_a = this.modeDropdown) == null ? void 0 : _a.components[0];
    if (dropdownComponent && typeof dropdownComponent.setValue === "function") {
      dropdownComponent.setValue(this.currentMode);
    }
  }
  /**
   * Creates the toggle setting for showing/hiding files in the tree.
   * @param containerEl - The HTML element to append the setting to.
   */
  createShowFilesSetting(containerEl) {
    if (this.options.optionShowFiles) {
      new import_obsidian5.Setting(containerEl).setName("Show Files").setDesc("Show Files within the directory tree.").addToggle((toggle) => {
        toggle.setValue(this.showFiles).onChange((value) => {
          this.showFiles = value;
          this.buildAndRenderTree();
        });
      });
    }
  }
  /**
   * Creates the "OK" and "Reset" buttons.
   * @param containerEl - The HTML element to append the buttons to.
   */
  createActionButtons(containerEl) {
    const buttonsEl = containerEl.createDiv({ cls: "modal-buttons" });
    buttonsEl.style.marginTop = "15px";
    buttonsEl.style.display = "flex";
    buttonsEl.style.justifyContent = "flex-end";
    buttonsEl.style.gap = "10px";
    const resetButton = buttonsEl.createEl("button");
    (0, import_obsidian5.setIcon)(resetButton, "reset");
    resetButton.ariaLabel = "Reset selection";
    resetButton.onclick = () => {
      this.resetSelectionToInitial();
      this.updateModeDropdown();
      this.buildAndRenderTree();
    };
    const emptyButton = buttonsEl.createEl("button");
    (0, import_obsidian5.setIcon)(emptyButton, "eraser");
    emptyButton.ariaLabel = "Clear selection";
    emptyButton.onclick = () => {
      this.resetSelectionToEmpty();
      this.updateModeDropdown();
      this.buildAndRenderTree();
    };
    const cancelButton = buttonsEl.createEl("button", { text: "Cancel" });
    cancelButton.ariaLabel = "close and discard changes";
    cancelButton.onclick = () => {
      this.okCallback(null);
      this.close();
    };
    const okButton = buttonsEl.createEl("button", { text: "OK", cls: "mod-cta" });
    okButton.ariaLabel = "close and save changes";
    okButton.onclick = () => {
      this.close();
    };
  }
  /**
   * Builds the logical tree structure data from the vault's files and folders.
   * @returns The root node of the tree structure.
   */
  buildTreeData() {
    const vaultRootNode = {
      path: "/",
      // Root folder path
      name: this.app.vault.getName() || "Vault",
      // Use vault name or default
      type: "folder",
      children: [],
      // Placeholder elements, will be assigned during rendering
      element: null,
      checkbox: null,
      label: null,
      container: null
    };
    const folderNodes = /* @__PURE__ */ new Map();
    folderNodes.set("/", vaultRootNode);
    const allFiles = this.app.vault.getFiles();
    allFiles.forEach((file) => {
      const parentFolder = file.parent;
      if (!parentFolder)
        return;
      let currentPath = "";
      const pathParts = parentFolder.path.split("/").filter((p) => p.length > 0);
      let parentNode = vaultRootNode;
      pathParts.forEach((part) => {
        currentPath = currentPath === "/" ? part : `${currentPath}/${part}`;
        if (!folderNodes.has(currentPath)) {
          const newFolderNode = {
            path: currentPath,
            name: part,
            type: "folder",
            children: [],
            element: null,
            checkbox: null,
            label: null,
            container: null
          };
          folderNodes.set(currentPath, newFolderNode);
          if (!parentNode.children) {
            parentNode.children = [];
          }
          parentNode.children.push(newFolderNode);
          parentNode = newFolderNode;
        } else {
          parentNode = folderNodes.get(currentPath);
        }
      });
    });
    if (this.showFiles) {
      allFiles.forEach((file) => {
        const parentFolder = file.parent;
        let parentPath = "";
        if (parentFolder) {
          parentPath = "/" + (parentFolder.path === "/" ? "" : parentFolder.path);
        }
        const parentNode = folderNodes.get(parentPath);
        const fileNode = {
          path: file.path,
          name: file.name,
          type: "file",
          element: null,
          checkbox: null,
          label: null,
          container: null
        };
        if (parentNode) {
          if (!parentNode.children) {
            parentNode.children = [];
          }
          parentNode.children.push(fileNode);
        }
      });
    }
    const sortNodes = (a, b) => {
      if (a.type === "folder" && b.type === "file")
        return -1;
      if (a.type === "file" && b.type === "folder")
        return 1;
      return a.name.localeCompare(b.name);
    };
    folderNodes.forEach((node) => {
      var _a;
      return (_a = node.children) == null ? void 0 : _a.sort(sortNodes);
    });
    return vaultRootNode;
  }
  /**
   * Renders the entire tree structure in the DOM based on the tree data.
   */
  renderTree() {
    var _a;
    this.treeRootElement.empty();
    this.treeNodes.clear();
    const treeData = this.buildTreeData();
    const rootUl = this.treeRootElement.createEl("ul");
    rootUl.addClass("tree-root-ul");
    rootUl.style.listStyle = "none";
    rootUl.style.paddingLeft = "0";
    this.renderTreeNode(treeData, rootUl, 0, this.currentFolders, this.currentFiles);
    (_a = treeData.children) == null ? void 0 : _a.forEach((childNode) => {
    });
  }
  /**
   * Recursively renders a single tree node and its children in the DOM.
   * @param node - The TreeNode data to render.
   * @param parentElement - The HTML `ul` element to append this node's `li` to.
   * @param level - The current indentation level.
   */
  renderTreeNode(node, parentElement, level, selectedPaths, selectedfiles) {
    const li = parentElement.createEl("li");
    li.style.marginLeft = `${level * 20}px`;
    li.addClass(`tree-node-${node.type}`);
    const container = li.createDiv({ cls: "tree-node-container" });
    container.style.display = "flex";
    container.style.alignItems = "center";
    container.style.padding = "2px 0";
    let toggleButton = null;
    let isCollapsed = true;
    if (node.type === "folder") {
      toggleButton = container.createSpan({ cls: "tree-toggle-button" });
      toggleButton.textContent = "\u25B6";
      toggleButton.style.cursor = "pointer";
      toggleButton.style.marginRight = "5px";
      const shouldExpand = this.shouldExpandFolder(node, selectedPaths, selectedfiles);
      if (shouldExpand) {
        isCollapsed = false;
      }
      toggleButton.onclick = () => {
        isCollapsed = !isCollapsed;
        if (toggleButton)
          toggleButton.textContent = isCollapsed ? "\u25B6" : "\u25BC";
        if (childrenUl)
          childrenUl.style.display = isCollapsed ? "none" : "block";
      };
    }
    const checkbox = container.createEl("input", { type: "checkbox" });
    checkbox.id = `tree-cb-${node.path.replace(/[^a-zA-Z0-9]/g, "-")}`;
    checkbox.dataset.path = node.path;
    checkbox.dataset.type = node.type;
    const label = container.createEl("label");
    label.textContent = `${node.type === "folder" ? "\u{1F4C1}" : "\u{1F4C4}"} ${node.name}`;
    label.htmlFor = checkbox.id;
    label.style.marginLeft = "5px";
    label.style.cursor = "pointer";
    label.title = node.path;
    node.element = li;
    node.checkbox = checkbox;
    node.label = label;
    node.container = container;
    this.treeNodes.set(node.path, node);
    if (node.type === "folder") {
      checkbox.checked = this.currentFolders.has(node.path);
    } else {
      checkbox.checked = this.currentFiles.has(node.path);
    }
    checkbox.onchange = (event) => {
      const target = event.target;
      const path = target.dataset.path;
      const type = target.dataset.type;
      if (target.checked) {
        if (type === "folder") {
          if (this.options.displayMode === "folder") {
            this.currentFolders.clear();
          }
          this.currentFolders.add(path);
        } else {
          if (this.options.displayMode === "file") {
            this.currentFiles.clear();
          }
          this.currentFiles.add(path);
        }
      } else {
        if (type === "folder")
          this.currentFolders.delete(path);
        else
          this.currentFiles.delete(path);
      }
      this.updateTreeAppearance();
    };
    let childrenUl = null;
    if (node.type === "folder" && node.children && node.children.length > 0) {
      childrenUl = li.createEl("ul");
      childrenUl.style.listStyle = "none";
      childrenUl.style.paddingLeft = "0";
      childrenUl.style.marginLeft = "0";
      childrenUl.style.display = isCollapsed ? "none" : "block";
      node.children.forEach((child) => this.renderTreeNode(child, childrenUl, level + 1, selectedPaths, selectedfiles));
    }
  }
  // Helper method to determine if a folder should be expanded
  shouldExpandFolder(node, selectedPaths, selectedFiles) {
    if (selectedPaths.has(node.path) || selectedFiles.has(node.path)) {
      return true;
    }
    if (node.children) {
      for (const child of node.children) {
        if (this.shouldExpandFolder(child, selectedPaths, selectedFiles)) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Updates the visual appearance (enabled/disabled/styling) of all nodes
   * in the tree based on the current mode and selections.
   */
  updateTreeAppearance() {
    this.treeNodes.forEach((node) => {
      let isDisabled = false;
      let isEffectivelyIncluded = false;
      let isEffectivelyExcluded = false;
      let ancestorFolderSelected = false;
      let currentPath = node.path;
      while (currentPath !== "/") {
        const parentPath = currentPath.substring(0, currentPath.lastIndexOf("/")) || "/";
        if (this.currentFolders.has(parentPath)) {
          ancestorFolderSelected = true;
          break;
        }
        if (parentPath === currentPath)
          break;
        currentPath = parentPath;
      }
      const nodeSelected = node.type === "folder" ? this.currentFolders.has(node.path) : this.currentFiles.has(node.path);
      if (this.currentMode === "exclude") {
        isEffectivelyExcluded = nodeSelected || ancestorFolderSelected;
        isDisabled = isEffectivelyExcluded;
      } else {
        if (node.type === "folder") {
          isEffectivelyIncluded = nodeSelected || ancestorFolderSelected;
        } else {
          const parentPath = node.path.substring(0, node.path.lastIndexOf("/")) || "/";
          const parentEffectivelyIncluded = this.isPathEffectivelyIncluded(parentPath);
          isEffectivelyIncluded = nodeSelected || parentEffectivelyIncluded;
        }
        isDisabled = !isEffectivelyIncluded;
      }
      node.checkbox.disabled = false;
      node.checkbox.checked = nodeSelected;
      if (isDisabled) {
        node.element.addClass("is-disabled");
      } else {
        node.element.removeClass("is-disabled");
      }
      node.element.classList.remove("is-included", "is-excluded");
      if (this.currentMode === "include" && isEffectivelyIncluded) {
        node.element.addClass("is-included");
      } else if (this.currentMode === "exclude" && isEffectivelyExcluded) {
        node.element.addClass("is-excluded");
      }
    });
  }
  /**
   * Helper function to determine if a given path is effectively included
   * in the current selection under 'include' mode.
   * A path is included if it (file or folder) is selected, or if any of its ancestor FOLDERS are selected.
   * @param path - The folder or file path to check.
   * @returns True if the path should be considered included, false otherwise.
   */
  isPathEffectivelyIncluded(path) {
    if (this.currentMode !== "include") {
      return !this.isPathEffectivelyExcluded(path);
    }
    if (this.currentFiles.has(path) || this.currentFolders.has(path)) {
      return true;
    }
    let current = path;
    while (current !== "/") {
      const parentPath = current.substring(0, current.lastIndexOf("/")) || "/";
      if (this.currentFolders.has(parentPath)) {
        return true;
      }
      if (parentPath === current)
        break;
      current = parentPath;
    }
    return false;
  }
  /**
  * Helper function to determine if a given path is effectively excluded
  * in the current selection under 'exclude' mode.
  * A path is excluded if it (file or folder) is selected, or if any of its ancestor FOLDERS are selected.
  * @param path - The folder or file path to check.
  * @returns True if the path should be considered excluded, false otherwise.
  */
  isPathEffectivelyExcluded(path) {
    if (this.currentMode !== "exclude") {
      return false;
    }
    if (this.currentFiles.has(path) || this.currentFolders.has(path)) {
      return true;
    }
    let current = path;
    while (current !== "/") {
      const parentPath = current.substring(0, current.lastIndexOf("/")) || "/";
      if (this.currentFolders.has(parentPath)) {
        return true;
      }
      if (parentPath === current)
        break;
      current = parentPath;
    }
    return false;
  }
  /**
   * Combines building the tree data, rendering the DOM, and applying initial appearance.
   */
  buildAndRenderTree() {
    this.renderTree();
    this.updateTreeAppearance();
  }
  /**
   * Called when the modal is closed. Cleans up resources.
   */
  onClose() {
    const result = {
      folders: Array.from(this.currentFolders),
      files: Array.from(this.currentFiles),
      mode: this.currentMode,
      display: this.currentDisplay
    };
    this.okCallback(result);
    const { contentEl } = this;
    contentEl.empty();
    this.treeNodes.clear();
    this.modeDropdown = null;
  }
};
function openDirectorySelectionModal(app, initialFolders, initialFiles, options, okCallback) {
  new DirectorySelectionModal(
    app,
    initialFolders,
    initialFiles,
    options,
    okCallback
  ).open();
}

// src/settings-properties.ts
var import_obsidian11 = require("obsidian");

// src/rules.ts
function executeRuleObject(event, app, plugin, settings, currentFile, currentContent, rule, frontMatter, oldLocationResults) {
  var _a;
  if (!rule)
    return currentContent;
  if (!rule.active)
    return currentContent;
  if (!currentFile)
    return currentContent;
  if (!checkIfFileAllowed(currentFile, settings, rule))
    return currentContent;
  const tools = new ScriptingTools(app, plugin, settings, rule, frontMatter);
  let result = currentContent;
  let oldResult = void 0;
  tools.setCurrentContent(frontMatter[rule.property]);
  tools.setRule(rule);
  tools.setFrontmatter(frontMatter);
  tools.setActiveFile(currentFile);
  const ruleObject = rulesManager.getRuleById(rule.content);
  if (!ruleObject)
    return currentContent;
  result = rulesManager.executeRule(rule, ruleObject, app, currentFile, tools, frontMatter);
  result = rulesManager.applyFormatOptions(result, rule, currentFile, tools);
  if (oldLocationResults && oldLocationResults.length > 0 && rule.addContent !== "overwrite") {
    oldResult = (_a = oldLocationResults.find((res) => res.ruleId === rule.id)) == null ? void 0 : _a.result;
    if (!oldResult) {
      logger.log(ERROR, `executeRuleObject: Old result for rule ${rule.property}|${rule.content} not found!`, oldLocationResults);
      return result;
    }
    oldResult = rulesManager.applyFormatOptions(oldResult, rule, currentFile, tools);
    logger.log(DEBUG, `executeRuleObject: Merging result for rule ${rule.property}|${rule.content} with old result`, oldResult, result);
    result = rulesManager.mergeResult(result, oldResult, currentContent, rule);
  } else {
    result = rulesManager.mergeResult(result, result, currentContent, rule);
  }
  return result;
}
function filterFile(file, fileList, filterMode, type) {
  let result = false;
  const filterArray = type === "folders" ? fileList[filterMode].selectedFolders : fileList[filterMode].selectedFiles;
  if (filterArray.length === 0)
    return filterMode === "include" ? false : true;
  const filePath = file.path;
  const fileFolder = getFolderFromPath(file.path);
  const fileName = file.basename + "." + file.extension;
  if (type === "files") {
    result = filterArray.includes(filePath);
  }
  if (type === "folders") {
    for (let path of filterArray) {
      result = (fileFolder == null ? void 0 : fileFolder.startsWith(path.slice(1))) || false;
      if (result === true)
        return filterMode === "exclude" ? !result : result;
    }
    ;
  }
  ;
  return filterMode === "exclude" ? !result : result;
}
function checkIfFileAllowed(file, settings, rule) {
  let result = true;
  if (!file)
    return false;
  if (settings) {
    try {
      if (settings.exclude.selectedFiles.length > 0) {
        result = filterFile(file, settings, "exclude", "files");
      }
      if (result && settings.exclude.selectedFolders.length > 0) {
        result = filterFile(file, settings, "exclude", "folders");
      }
      if (!result && settings.include.selectedFiles.length > 0) {
        result = filterFile(file, settings, "include", "files");
      }
      if (!result && settings.include.selectedFolders.length > 0) {
        result = filterFile(file, settings, "include", "folders");
      }
    } catch (error) {
      logger.log(ERROR, `Error filtering file ${file.path} globally: ${error}`);
      return false;
    }
  }
  if (rule) {
    try {
      if (result && rule.exclude.selectedFiles.length > 0) {
        result = filterFile(file, rule, "exclude", "files");
      }
      if (result && rule.exclude.selectedFolders.length > 0) {
        result = filterFile(file, rule, "exclude", "folders");
      }
      if (!result && rule.include.selectedFiles.length > 0) {
        result = filterFile(file, rule, "include", "files");
      }
      if (!result && rule.include.selectedFolders.length > 0) {
        result = filterFile(file, rule, "include", "folders");
      }
    } catch (error) {
      logger.log(ERROR, `Error filtering file ${file.path} by rule ${rule.property}|${rule.content}: ${error}`);
      return false;
    }
  }
  return result;
}

// src/settings-properties.ts
var import_crypto = require("crypto");

// src/editorModal.ts
var import_obsidian7 = require("obsidian");

// src/uiElements.ts
var import_obsidian6 = require("obsidian");
function renderValueInput(containerEl, propertyInfo, currentValue, changeCallback) {
  let returnComponent;
  containerEl.empty();
  if (!propertyInfo) {
    containerEl.setText("");
    containerEl.addClass("text-muted");
    return;
  }
  const type = propertyInfo.type;
  switch (type) {
    case "number":
      returnComponent = new import_obsidian6.TextComponent(containerEl).setPlaceholder("Numeric Value").setValue(currentValue !== void 0 && currentValue !== null ? String(currentValue) : "").onChange(async (value) => {
        const numValue = value === "" ? void 0 : parseFloat(value);
        changeCallback(propertyInfo, isNaN(numValue) ? void 0 : numValue);
      });
      returnComponent.inputEl.type = "number";
      break;
    case "checkbox":
      returnComponent = containerEl.createDiv({ cls: "tri-state-checkbox clickable-icon" });
      returnComponent.setAttribute("aria-label", "Checkbox change state");
      returnComponent.setAttribute("role", "checkbox");
      const updateCheckboxVisual = (state) => {
        let iconName;
        let ariaState;
        if (state === true) {
          iconName = "check-square";
          ariaState = "true";
        } else if (state === false) {
          iconName = "square";
          ariaState = "false";
        } else {
          iconName = "minus-square";
          ariaState = "mixed";
        }
        (0, import_obsidian6.setIcon)(returnComponent, iconName);
        returnComponent.setAttribute("aria-checked", ariaState);
        returnComponent.dataset.state = String(state);
      };
      updateCheckboxVisual(currentValue);
      returnComponent.addEventListener("click", async () => {
        let currentState = returnComponent.dataset.state;
        let nextState;
        if (currentState === "false") {
          nextState = true;
        } else if (currentState === "true") {
          nextState = void 0;
        } else {
          nextState = false;
        }
        changeCallback(propertyInfo, nextState);
        updateCheckboxVisual(nextState);
      });
      break;
    case "date":
      returnComponent = new import_obsidian6.TextComponent(containerEl).setPlaceholder("YYYY-MM-DD").setValue(currentValue || "").onChange(async (value) => {
        changeCallback(propertyInfo, value || void 0);
      });
      returnComponent.inputEl.type = "date";
      break;
    case "datetime":
      returnComponent = new import_obsidian6.TextComponent(containerEl).setPlaceholder("YYYY-MM-DDTHH:mm").setValue(currentValue || "").onChange(async (value) => {
        changeCallback(propertyInfo, value || void 0);
      });
      returnComponent.inputEl.type = "datetime-local";
      break;
    case "aliases":
    case "tags":
    case "multitext":
      returnComponent = new import_obsidian6.TextComponent(containerEl).setPlaceholder("values (divided by comma)").setValue(Array.isArray(currentValue) ? currentValue.join(", ") : currentValue || "").onChange(async (value) => {
        const arrayValue = value.split(",").map((s) => s.trim()).filter((s) => s);
        changeCallback(propertyInfo, arrayValue.length > 0 ? arrayValue : void 0);
      });
      break;
    case "text":
    default:
      returnComponent = new import_obsidian6.TextComponent(containerEl).setPlaceholder("value").setValue(currentValue || "").onChange(async (value) => {
        changeCallback(propertyInfo, value || void 0);
      });
      break;
  }
  if (type !== "checkbox") {
    returnComponent.inputEl.style.backgroundColor = "transparent";
    returnComponent.inputEl.style.width = "100%";
    returnComponent.inputEl.style.border = "none";
  }
  return returnComponent;
}
function updatePropertyIcon(iconEl, type) {
  let iconName = "hash";
  switch (type) {
    case "text":
      iconName = "align-left";
      break;
    case "number":
      iconName = "binary";
      break;
    case "multitext":
      iconName = "list";
      break;
    case "date":
      iconName = "calendar";
      break;
    case "datetime":
      iconName = "clock";
      break;
    case "checkbox":
      iconName = "check-square";
      break;
    case "tags":
      iconName = "tags";
      break;
    case "aliases":
      iconName = "forward";
      break;
    default:
      iconName = "help-circle";
  }
  (0, import_obsidian6.setIcon)(iconEl, iconName);
}

// src/editorModal.ts
var codeEditorModal = class extends import_obsidian7.Modal {
  /**
   * Creates an instance of the DirectorySelectionModal.
   * @param app - The Obsidian App instance.
   * @param plugin - The plugin instance.
   * @param initialCode - String with the initial code.
   * @param expectedType - Expected return type.
   * @param activeFile - The currently active file or folder.
   * @param frontmatter - Frontmatter data for the active file.
   * @param okCallback - Function to call when the user clicks "OK". Receives the selection result.
   */
  constructor(app, plugin, initialCode, expectedType, activeFile, frontmatter, okCallback) {
    super(app);
    this.initialCode = initialCode;
    this.expectedType = expectedType;
    this.useTextArea = false;
    this.checkedSuccessfully = false;
    this.activeFile = activeFile;
    this.frontmatter = frontmatter;
    this.currentType = expectedType;
    this.currentCode = initialCode;
    this.plugin = plugin;
    this.scriptingTools = new ScriptingTools(
      app,
      this.plugin,
      this.plugin.settings,
      void 0,
      this.frontmatter,
      this.activeFile instanceof import_obsidian7.TFile ? this.activeFile : void 0
    );
    this.okCallback = okCallback;
    this.resetSelectionToInitial();
  }
  /**
   * Resets the current selection state to the initial state provided at construction.
   */
  resetSelectionToInitial() {
    var _a;
    this.currentCode = this.initialCode;
    (_a = this.cmEditor) == null ? void 0 : _a.setValue(this.currentCode);
    if (this.functionResultTextComponent)
      this.functionResultTextComponent.setValue("");
  }
  /**
   * Resets the current selection state to empty.
   */
  resetSelectionToEmpty() {
    var _a;
    this.currentCode = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    (_a = this.cmEditor) == null ? void 0 : _a.setValue(this.currentCode);
    if (this.functionResultTextComponent)
      this.functionResultTextComponent.setValue("");
  }
  loadCodeMirrorMode(mode) {
    try {
      require(`obsidian/lib/codemirror/mode/${mode}/${mode}.js`);
      logger.log(DEBUG, `CodeMirror mode '${mode}' loaded successfully (using require).`);
    } catch (error) {
      logger.log(ERROR, `Failed to load CodeMirror mode '${mode}' (using require):`, error);
    }
  }
  /**
   * Called when the modal is opened. Builds the UI.
   */
  async onOpen() {
    const { contentEl } = this;
    if (contentEl.parentElement)
      contentEl.parentElement.style.width = "900px";
    contentEl.empty();
    contentEl.addClass("codeEditor-modal");
    contentEl.createEl("h2", { text: "JavaScript Editor" });
    contentEl.createEl("body", { text: `Make sure your code results: ${this.expectedType}` });
    this.editorRootElement = contentEl.createDiv({ cls: "codeEditor-container" });
    this.editorRootElement.style.height = "600px";
    this.editorRootElement.style.overflowY = "auto";
    this.editorRootElement.style.padding = "10px";
    this.editorRootElement.style.marginTop = "10px";
    this.editorRootElement.style.marginBottom = "10px";
    this.cmEditor = null;
    const ruleOptionsDiv = contentEl.createDiv({ cls: "codeEditor-options" });
    if (this.useTextArea) {
      const ruleOptionsSettings = new import_obsidian7.Setting(this.editorRootElement).addTextArea((textArea) => {
        textArea.setPlaceholder("ender valid JS Code");
        textArea.inputEl.setAttribute("style", `height:190px; width:80%;`);
        textArea.onChange(async (value) => {
          if (this.functionTestButton)
            this.functionTestButton.buttonEl.addClass("mod-warning");
          this.currentCode = value;
        });
      });
    } else {
      const CodeMirror = window.CodeMirror;
      if (CodeMirror) {
        if (!CodeMirror.modes.javascript) {
          await this.loadCodeMirrorMode("javascript");
          logger.log(TRACE, "javaScript support loaded");
        }
      }
      let jsCode = this.currentCode;
      this.cmEditor = CodeMirror(this.editorRootElement, {
        value: jsCode || "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result; // return you result.\n}",
        mode: "javascript",
        lineNumbers: true,
        theme: "obsidian",
        indentUnit: 4,
        lineWrapping: false,
        readOnly: false,
        outerHeight: "600px"
      });
      if (this.cmEditor) {
        this.cmEditor.on("change", (cmEditor) => {
          if (this.functionTestButton)
            this.functionTestButton.buttonEl.addClass("mod-warning");
        });
        this.cmEditor.on("blur", (cmEditor) => {
          this.currentCode = cmEditor.getValue();
        });
      }
      ;
      new import_obsidian7.Setting(ruleOptionsDiv).addButton((button) => {
        this.functionTestButton = button;
        button.setWarning().setButtonText("Run Code").setTooltip("Run the code and check for errors").onClick(async () => {
          if (this.cmEditor) {
            let jsCode2 = this.cmEditor.getValue();
            let userFunction = parseJSCode(jsCode2);
            if (typeof userFunction === "string") {
              let errorHint = "See console for details!";
              if (userFunction.contains("Unexpected token")) {
                errorHint = "Did you missed a semicolon (;)?";
              }
              if (this.functionResultTextComponent)
                this.functionResultTextComponent.setValue(`Syntax error: ${userFunction}! ${errorHint}`);
              this.checkedSuccessfully = false;
              button.buttonEl.addClass("mod-warning");
            } else {
              if (userFunction) {
                try {
                  const result = userFunction(this.app, this.activeFile, this.scriptingTools);
                  if (this.functionResultTextComponent)
                    this.functionResultTextComponent.setValue(`'${result.toString()}' (${typeof result})`);
                  this.updateTypeIcons(result, typesContainer, this.expectedType, this.currentType, this.plugin.settings);
                  button.buttonEl.removeClass("mod-warning");
                  this.checkedSuccessfully = true;
                } catch (e) {
                  if (this.functionResultTextComponent) {
                    const errorMessage = e instanceof Error ? e.message : String(e);
                    this.functionResultTextComponent.setValue(`Syntax error: ${errorMessage}! See console for details!`);
                  }
                  logger.log(ERROR, "Syntax error. ", e, jsCode2, userFunction);
                  this.checkedSuccessfully = false;
                  button.buttonEl.addClass("mod-warning");
                }
              } else {
                logger.log(ERROR, "syntax error");
                this.checkedSuccessfully = false;
              }
            }
          }
        });
      }).addText((text) => {
        this.functionResultTextComponent = text;
        text.setPlaceholder("function result").setDisabled(true);
        this.functionResultTextComponent.inputEl.style.width = "580px";
      });
      const typesContainer = ruleOptionsDiv.createDiv({ cls: "property-icons-container" });
    }
    this.createActionButtons(contentEl);
  }
  updateTypeIcons(value, container, expectedType, currentType, settings) {
    const newType = typeof value;
    const typeIcons = {
      "string": ["text", "tags", "aliases", "multitext", "date", "datetime"],
      "number": ["number"],
      "boolean": ["checkbox"],
      "object": ["tags", "aliases", "multitext"]
    };
    if (newType === "string") {
      if (!this.scriptingTools.isISOString(value, { withDate: true })) {
        typeIcons[newType].splice(typeIcons[newType].indexOf("date"), 1);
      }
      if (!this.scriptingTools.isISOString(value, { withDate: true, withTime: true })) {
        typeIcons[newType].splice(typeIcons[newType].indexOf("datetime"), 1);
      }
    }
    container.empty();
    for (let obsidianType of typeIcons[newType]) {
      if (obsidianType) {
        const iconEl = container.createSpan({ cls: "property-icon setting-item-icon" });
        updatePropertyIcon(iconEl, obsidianType);
      }
    }
  }
  /**
   * Creates the "OK" and "Reset" buttons.
   * @param containerEl - The HTML element to append the buttons to.
   */
  createActionButtons(containerEl) {
    const buttonsEl = containerEl.createDiv({ cls: "modal-buttons" });
    buttonsEl.style.marginTop = "15px";
    buttonsEl.style.display = "flex";
    buttonsEl.style.justifyContent = "flex-end";
    buttonsEl.style.gap = "10px";
    const resetButton = buttonsEl.createEl("button");
    (0, import_obsidian7.setIcon)(resetButton, "reset");
    resetButton.ariaLabel = "Reset selection";
    resetButton.onclick = () => {
      this.resetSelectionToInitial();
    };
    const emptyButton = buttonsEl.createEl("button");
    (0, import_obsidian7.setIcon)(emptyButton, "eraser");
    emptyButton.ariaLabel = "Clear selection";
    emptyButton.onclick = () => {
      this.resetSelectionToEmpty();
    };
    const cancelButton = buttonsEl.createEl("button", { text: "Cancel" });
    cancelButton.ariaLabel = "close and discard changes";
    cancelButton.onclick = () => {
      logger.log(TRACE, "Cancel Clicked - Returning");
      this.okCallback(null);
      this.close();
    };
    const okButton = buttonsEl.createEl("button", { text: "OK", cls: "mod-cta" });
    cancelButton.ariaLabel = "close and save changes";
    okButton.onclick = () => {
      this.close();
    };
  }
  /**
   * Called when the modal is closed. Cleans up resources.
   */
  onClose() {
    const result = {
      code: this.currentCode,
      checked: this.checkedSuccessfully,
      type: "text"
    };
    logger.log(TRACE, "OK Clicked - Returning Result:", result);
    this.okCallback(result);
    const { contentEl } = this;
    contentEl.empty();
  }
};
function openCodeEditorModal(app, plugin, initialCode, expectedType, activeFile, frontmatter, okCallback) {
  new codeEditorModal(
    app,
    plugin,
    initialCode,
    expectedType,
    activeFile,
    frontmatter,
    okCallback
  ).open();
}

// src/uiMultiPropertySetting.ts
var import_obsidian8 = require("obsidian");
var MultiPropertySetting = class {
  constructor(container) {
    this.name = "";
    this.desc = "";
    this.value = [];
    this.onChangeCb = () => {
    };
    this.options = [];
    this.extraButtonCallbacks = [];
    this.container = container;
    this.settingEl = container.createDiv();
  }
  setName(name) {
    this.name = name;
    return this;
  }
  setDesc(desc) {
    this.desc = desc;
    return this;
  }
  setValue(value) {
    this.value = value.length ? [...value] : [""];
    this.render();
    return this;
  }
  setOptions(options) {
    this.options = options;
    this.render();
    return this;
  }
  onChange(cb) {
    this.onChangeCb = cb;
    return this;
  }
  /**
   * Allows adding extra buttons to each row.
   * The callback receives the Setting and the row index.
   */
  addExtraButton(cb) {
    this.extraButtonCallbacks.push(cb);
    this.render();
    return this;
  }
  styleDisabled(el, disabled) {
    if (disabled) {
      el.extraSettingsEl.addClass("mod-disabled");
      el.extraSettingsEl.setAttr("aria-disabled", "true");
      el.extraSettingsEl.tabIndex = -1;
      el.extraSettingsEl.removeAttribute("aria-label");
    } else {
      el.extraSettingsEl.removeClass("mod-disabled");
      el.extraSettingsEl.setAttr("aria-disabled", "false");
    }
  }
  render() {
    this.settingEl.empty();
    const arr = this.value;
    arr.forEach((selected, idx) => {
      const setting = new import_obsidian8.Setting(this.settingEl).setName(idx === 0 ? this.name : "").setDesc(idx === 0 ? this.desc : "").addDropdown((dd) => {
        this.options.forEach((item) => {
          if (typeof item === "string") {
            dd.addOption(item, item);
          } else {
            dd.addOption(item.id, item.name);
          }
        });
        dd.setValue(selected || "");
        dd.onChange((value) => {
          arr[idx] = value;
          this.value = arr;
          this.onChangeCb([...arr]);
          this.render();
        });
      });
      if (idx > 0) {
        setting.settingEl.style.borderTop = "none";
        setting.settingEl.style.padding = "0 0 0.75em";
      } else {
        setting.settingEl.style.borderTop = "1px solid var(--background-modifier-border)";
        setting.settingEl.style.padding = "0.75em 0";
      }
      const settingControl = setting.controlEl;
      if (settingControl) {
        settingControl.style.gap = "0.1em";
      }
      setting.addExtraButton((btn) => {
        btn.setIcon("arrow-up").setTooltip("Move up").setDisabled(idx === 0).onClick(() => {
          [arr[idx - 1], arr[idx]] = [arr[idx], arr[idx - 1]];
          this.value = arr;
          this.onChangeCb([...arr]);
          this.render();
        });
        this.styleDisabled(btn, idx === 0);
      });
      setting.addExtraButton((btn) => {
        btn.setIcon("arrow-down").setTooltip("Move down").setDisabled(idx === arr.length - 1).onClick(() => {
          [arr[idx], arr[idx + 1]] = [arr[idx + 1], arr[idx]];
          this.value = arr;
          this.onChangeCb([...arr]);
          this.render();
        });
        this.styleDisabled(btn, idx === arr.length - 1);
      });
      setting.addExtraButton((btn) => {
        btn.setIcon("minus-circle").setTooltip("Remove property").setDisabled(arr.length === 1).onClick(() => {
          arr.splice(idx, 1);
          this.value = arr.length ? arr : [""];
          this.onChangeCb([...this.value]);
          this.render();
        });
        this.styleDisabled(btn, arr.length === 1);
      });
      this.extraButtonCallbacks.forEach((cb) => cb(setting, idx));
    });
    const plusButton = new import_obsidian8.Setting(this.settingEl).addExtraButton((btn) => {
      btn.setIcon("plus-circle").setTooltip("Add property").setDisabled(arr[arr.length - 1] === "" || !arr[arr.length - 1]).onClick(() => {
        if (arr[arr.length - 1] !== "" && arr[arr.length - 1]) {
          arr.push("");
          this.value = arr;
          this.onChangeCb([...arr]);
          this.render();
        }
      });
      this.styleDisabled(btn, arr[arr.length - 1] === "" || !arr[arr.length - 1]);
    });
    plusButton.settingEl.style.borderTop = "none";
    plusButton.settingEl.style.padding = "0 0 0.75em";
  }
};

// src/uiTreeHierarchySortableSettings.ts
var import_obsidian9 = require("obsidian");
var ROOT_FOLDER = void 0;
var TreeHierarchySortableSettings = class {
  constructor(container, data, rowRenderCb) {
    this.title = "";
    this.description = "";
    this.filter = "";
    this.onChangeCb = () => {
    };
    this.onRowCreatedCb = () => {
    };
    this.onRowDeletedCb = () => {
    };
    this.onDeleteBtCb = () => {
    };
    this.onRenderedCb = () => {
    };
    this.extraButtonCbs = [];
    this.container = container;
    this.settingEl = container.createDiv({ cls: "FMA-folder-list-setting" });
    this.data = data || { folders: [], rows: [] };
    this.rowRenderCb = rowRenderCb;
    this.render();
  }
  setTitle(title) {
    this.title = title;
    this.render();
    return this;
  }
  setDescription(description) {
    this.description = description;
    this.render();
    return this;
  }
  addExtraButtonToHeader(cb) {
    this.extraButtonCbs.push(cb);
    this.render();
    return this;
  }
  onDeleteBt(cb) {
    this.onDeleteBtCb = cb;
    return this;
  }
  addRow(folderId, keywords = [], payload) {
    const newRow = {
      id: crypto.randomUUID(),
      folderId,
      keywords,
      disabled: false,
      payload
    };
    if (!folderId) {
      this.data.rows.push(newRow);
      this.onChangeCb(this.data);
      this.render();
      return this;
    }
    const lastIdx = this.data.rows.map((r) => r.folderId).lastIndexOf(folderId);
    if (lastIdx === -1) {
      this.data.rows.unshift(newRow);
    } else {
      this.data.rows.splice(lastIdx + 1, 0, newRow);
    }
    this.onRowCreatedCb(newRow);
    this.onChangeCb(this.data);
    this.render();
    return this;
  }
  addFolder(name, parentId) {
    const newFolder = {
      id: crypto.randomUUID(),
      name,
      parentId,
      disabled: false,
      // Default to enabled
      collapsed: false
      // Default to expanded
    };
    this.data.folders.push(newFolder);
    this.onChangeCb(this.data);
    this.render();
    return this;
  }
  setData(data) {
    this.data = data;
    this.render();
    return this;
  }
  onChange(cb) {
    this.onChangeCb = cb;
    return this;
  }
  onRowCreated(cb) {
    this.onRowCreatedCb = cb;
    return this;
  }
  onRowDeleted(cb) {
    this.onRowDeletedCb = cb;
    return this;
  }
  onRendered(cb) {
    this.onRenderedCb = cb;
    return this;
  }
  moveRow(rowId, targetRowId) {
    const fromIdx = this.data.rows.findIndex((r) => r.id === rowId);
    if (fromIdx === -1)
      return;
    if (rowId === targetRowId)
      return;
    const moved = this.data.rows[fromIdx];
    const row = this.data.rows[fromIdx];
    this.onRowDeletedCb(row);
    logger.log(TRACE, `removing id${rowId} from ${fromIdx}`, this.data.rows);
    this.data.rows.splice(fromIdx, 1);
    let insertIdx;
    if (targetRowId) {
      insertIdx = this.data.rows.findIndex((r) => r.id === targetRowId);
      if (insertIdx === -1) {
        insertIdx = this.data.rows.length;
      }
      const targetRow = this.data.rows[insertIdx];
      if (fromIdx <= insertIdx && moved.folderId === (targetRow == null ? void 0 : targetRow.folderId))
        insertIdx++;
      moved.folderId = targetRow == null ? void 0 : targetRow.folderId;
    } else {
      insertIdx = this.data.rows.length;
    }
    logger.log(TRACE, `Inserting moved row id${rowId} at ${insertIdx}`, this.data.rows);
    this.data.rows.splice(insertIdx, 0, moved);
    this.onChangeCb(this.data);
    this.render();
  }
  moveRowToFolder(rowId, folderId) {
    const fromIdx = this.data.rows.findIndex((r) => r.id === rowId);
    if (fromIdx === -1)
      return;
    const moved = this.data.rows[fromIdx];
    this.data.rows.splice(fromIdx, 1);
    moved.folderId = folderId;
    this.data.rows.push(moved);
    this.onChangeCb(this.data);
    this.render();
  }
  moveFolderToFolder(folderId, targetFolderId) {
    if (folderId === targetFolderId)
      return;
    const fromIdx = this.data.folders.findIndex((f) => f.id === folderId);
    if (fromIdx === -1)
      return;
    const moved = this.data.folders[fromIdx];
    this.data.folders.splice(fromIdx, 1);
    moved.parentId = targetFolderId;
    this.data.folders.push(moved);
    this.onChangeCb(this.data);
    this.render();
  }
  propagateFolderDisabled(folderId, disabled) {
    for (const folder of this.data.folders) {
      if (folder.parentId === folderId) {
        folder.disabled = disabled;
        this.propagateFolderDisabled(folder.id, disabled);
      }
    }
    for (const row of this.data.rows) {
      if (row.folderId === folderId) {
        row.disabled = disabled;
      }
    }
  }
  render() {
    this.settingEl.empty();
    const headerSetting = new import_obsidian9.Setting(this.settingEl).setClass("FMA-folder-list-root-header");
    headerSetting.settingEl.createSpan({ cls: "FMA-folder-list-drag-handle", text: " " });
    headerSetting.settingEl.style.borderTop = "1px solid var(--background-modifier-border)";
    headerSetting.settingEl.style.padding = "0.75em 0";
    headerSetting.setName(this.title || "");
    headerSetting.setDesc(this.description || "");
    const filterInput = new import_obsidian9.SearchComponent(headerSetting.controlEl);
    filterInput.setPlaceholder("Filter folders/rows...");
    filterInput.setValue(this.filter);
    filterInput.inputEl.style.width = "200px";
    filterInput.onChange((val) => {
      this.filter = val;
      this.renderList();
    });
    headerSetting.addExtraButton((btn) => {
      btn.setIcon("plus-circle").setTooltip("Add row to root").onClick(() => {
        this.addRow(void 0, []);
      });
    });
    headerSetting.addExtraButton((btn) => {
      btn.setIcon("folder").setTooltip("Add folder to root").onClick(() => {
        this.addFolder(this.getNextFolderName(), void 0);
      });
    });
    headerSetting.addExtraButton((btn) => {
      btn.setIcon("trash").setTooltip("Drop here to delete row or folder").onClick(() => {
        this.onDeleteBtCb();
        this.onChangeCb(this.data);
        this.render();
      });
      const binEl = btn.extraSettingsEl;
      binEl.addEventListener("dragover", (e) => {
        e.preventDefault();
        binEl.classList.add("FMA-bin-drop-target");
      });
      binEl.addEventListener("dragleave", (e) => {
        binEl.classList.remove("FMA-bin-drop-target");
      });
      binEl.addEventListener("drop", (e) => {
        var _a;
        e.preventDefault();
        binEl.classList.remove("FMA-bin-drop-target");
        const data = (_a = e.dataTransfer) == null ? void 0 : _a.getData("text/plain");
        if (!data)
          return;
        const { type, id } = JSON.parse(data);
        if (type === "row") {
          this.data.rows = this.data.rows.filter((r) => r.id !== id);
        } else if (type === "folder") {
          this.deleteFolderAndContents(id);
        }
        this.onChangeCb(this.data);
        this.render();
      });
    });
    this.extraButtonCbs.forEach((cb) => {
      cb(headerSetting);
    });
    this.renderList();
  }
  renderList() {
    const oldList = this.settingEl.querySelector(".FMA-folder-list-content");
    if (oldList)
      oldList.remove();
    const listEl = this.settingEl.createDiv({ cls: "FMA-folder-list-content" });
    this.renderFolder(void 0, listEl, 0);
    this.renderRows(void 0, listEl, 0);
    const dropZone = new import_obsidian9.Setting(listEl).setClass("FMA-folder-list-drop-zone");
    dropZone.settingEl.addEventListener("dragover", (e) => this.onDragOver(e, "root", "folder-dropzone"));
    dropZone.settingEl.addEventListener("drop", (e) => {
      var _a;
      e.preventDefault();
      e.stopPropagation();
      const data = (_a = e.dataTransfer) == null ? void 0 : _a.getData("text/plain");
      if (!data)
        return;
      const { type, id } = JSON.parse(data);
      if (type === "row") {
        this.moveRowToFolder(id, void 0);
      } else if (type === "folder") {
        this.moveFolderToFolder(id, void 0);
      }
    });
    dropZone.settingEl.addEventListener("dragenter", (e) => {
      e.preventDefault();
      e.stopPropagation();
      dropZone.settingEl.classList.add("FMA-dropzone-target");
    });
    dropZone.settingEl.addEventListener("dragleave", (e) => {
      e.preventDefault();
      e.stopPropagation();
      dropZone.settingEl.classList.remove("FMA-dropzone-target");
    });
    this.onRenderedCb();
  }
  renderFolder(parentId, parentEl, depth) {
    if (!this.data || !this.data.folders)
      return;
    const folders = this.data.folders.filter((f) => f.parentId === parentId);
    folders.forEach((folder) => {
      const setting = new import_obsidian9.Setting(parentEl).setClass("FMA-folder-list-folder-setting");
      setting.nameEl.empty();
      setting.settingEl.style.marginLeft = `${depth * 20}px`;
      const dragHandle = setting.nameEl.createSpan({ cls: "FMA-folder-list-drag-handle" });
      dragHandle.setText("\u2630");
      dragHandle.draggable = true;
      dragHandle.style.marginRight = "0.5em";
      dragHandle.addEventListener("dragstart", (e) => this.onDragStart(e, "folder", folder.id));
      dragHandle.addEventListener("dragover", (e) => this.onDragOver(e, "folder", folder.id));
      dragHandle.addEventListener("drop", (e) => this.onDrop(e, "folder", folder.id));
      setting.addToggle((toggle) => {
        toggle.setValue(!folder.disabled).onChange((val) => {
          folder.disabled = !val;
          this.propagateFolderDisabled(folder.id, folder.disabled);
          this.onChangeCb(this.data);
          this.renderList();
        });
      }).setTooltip("Disable all rules in this folder and subfolders");
      const nameInput = new import_obsidian9.TextComponent(setting.nameEl);
      nameInput.setValue(folder.name);
      nameInput.inputEl.style.maxWidth = "100%";
      nameInput.inputEl.style.border = "0";
      nameInput.inputEl.style.marginRight = "0.5em";
      nameInput.onChange((val) => {
        folder.name = val;
        this.onChangeCb(this.data);
      });
      setting.addExtraButton((btn) => {
        btn.setIcon("plus-circle").setTooltip("Add row to folder").onClick(() => {
          this.addRow(folder.id, []);
        });
      });
      setting.addExtraButton((btn) => {
        btn.setIcon("folder").setTooltip("Add subfolder").onClick(() => {
          this.addFolder(this.getNextFolderName(), folder.id);
        });
      });
      setting.addExtraButton((btn) => {
        var _a;
        const isCollapsed = (_a = folder.collapsed) != null ? _a : false;
        btn.setIcon(isCollapsed ? "chevron-right" : "chevron-down").setTooltip(isCollapsed ? "Expand" : "Collapse").onClick(() => {
          folder.collapsed = !isCollapsed;
          this.onChangeCb(this.data);
          this.renderList();
        });
      });
      setting.settingEl._dragEnterCount = 0;
      setting.settingEl.addEventListener("dragenter", (e) => {
        setting.settingEl._dragEnterCount++;
        setting.settingEl.classList.add("FMA-drop-target");
      });
      setting.settingEl.addEventListener("dragleave", (e) => {
        setting.settingEl._dragEnterCount--;
        if (setting.settingEl._dragEnterCount <= 0) {
          setting.settingEl.classList.remove("FMA-drop-target");
          setting.settingEl._dragEnterCount = 0;
        }
      });
      setting.settingEl.addEventListener("dragover", (e) => this.onDragOver(e, "folder", folder.id));
      setting.settingEl.addEventListener("drop", (e) => this.onDrop(e, "folder", folder.id));
      setting.settingEl.addEventListener("dragleave", (e) => this.onDragLeave(e));
      if (folder.disabled)
        setting.settingEl.classList.add("FMA-mod-FolderList-disabled");
      if (!folder.collapsed) {
        this.renderFolder(folder.id, parentEl, depth + 1);
        this.renderRows(folder.id, parentEl, depth + 1);
      }
    });
  }
  renderRows(folderId, parentEl, depth) {
    if (!this.data || !this.data.rows)
      return;
    const rows = this.data.rows.filter((r) => r.folderId === folderId && this.rowMatchesFilter(r));
    rows.forEach((row) => {
      const setting = new import_obsidian9.Setting(parentEl).setClass("FMA-folder-list-row-setting");
      setting.nameEl.empty();
      setting.settingEl.style.marginLeft = `${depth * 20}px`;
      if (setting.nameEl.parentElement) {
        setting.nameEl.parentElement.style.marginInlineEnd = "0px";
        setting.nameEl.parentElement.style.width = "100%";
        setting.nameEl.parentElement.style.display = "flex";
        setting.nameEl.parentElement.style.flexDirection = "column";
      }
      setting.nameEl.style.display = "flex";
      setting.nameEl.style.width = "100%";
      const dragHandle = setting.nameEl.createSpan({ cls: "FMA-folder-list-drag-handle" });
      dragHandle.setText("\u2261");
      dragHandle.draggable = true;
      dragHandle.style.marginRight = "0.5em";
      dragHandle.addEventListener("dragstart", (e) => this.onDragStart(e, "row", row.id));
      dragHandle.addEventListener("dragover", (e) => this.onDragOver(e, "row", row.id));
      dragHandle.addEventListener("drop", (e) => this.onDrop(e, "row", row.id));
      if (row.disabled)
        setting.settingEl.addClass("FMA-mod-FolderList-disabled");
      this.rowRenderCb(row, setting.nameEl);
      setting.settingEl.addEventListener("dragover", (e) => this.onDragOver(e, "row", row.id));
      setting.settingEl.addEventListener("drop", (e) => this.onDrop(e, "row", row.id));
      setting.settingEl.addEventListener("dragleave", (e) => this.onDragLeave(e));
    });
  }
  // --- Drag & Drop Handlers (simplified, expand as needed) ---
  onDragStart(e, type, id) {
    var _a;
    (_a = e.dataTransfer) == null ? void 0 : _a.setData("text/plain", JSON.stringify({ type, id }));
  }
  onDragOver(e, type, id) {
    var _a;
    e.preventDefault();
    const target = e.currentTarget;
    const data = (_a = e.dataTransfer) == null ? void 0 : _a.getData("text/plain");
    if (type === "row" && data) {
      const { type: dragType } = JSON.parse(data);
      if (dragType === "folder") {
        return;
      }
    }
    if (type === "folder") {
      target.classList.add("FMA-drop-target");
    }
    if (type === "row") {
      target.classList.add("FMA-drop-target");
    }
  }
  onDragLeave(e) {
    const target = e.currentTarget;
    target.classList.remove("FMA-drop-target");
  }
  onDrop(e, type, targetId) {
    var _a;
    e.preventDefault();
    e.stopPropagation();
    const target = e.currentTarget;
    target.classList.remove("FMA-drop-target");
    const data = (_a = e.dataTransfer) == null ? void 0 : _a.getData("text/plain");
    if (!data)
      return;
    const { type: dragType, id: dragId } = JSON.parse(data);
    if (dragType === "row") {
      if (type === "folder") {
        this.moveRowToFolder(dragId, targetId);
        return;
      }
      if (type === "row") {
        this.moveRow(dragId, targetId);
        return;
      }
      if (type === "root" && targetId === "row-dropzone") {
        return;
      }
    }
    if (dragType === "folder") {
      if (type === "folder") {
        this.moveFolderToFolder(dragId, targetId);
        return;
      }
      if (type === "root" && targetId === "folder-dropzone") {
        this.moveFolderToFolder(dragId, void 0);
        return;
      }
    }
  }
  rowMatchesFilter(row) {
    if (!this.filter)
      return true;
    return row.keywords.some((k) => k.toLowerCase().includes(this.filter.toLowerCase()));
  }
  getNextFolderName() {
    let i = 1;
    let name;
    do {
      name = `Folder ${i++}`;
    } while (this.data.folders.some((f) => f.name === name));
    return name;
  }
  deleteFolderAndContents(folderId) {
    const subfolders = this.data.folders.filter((f) => f.parentId === folderId);
    subfolders.forEach((f) => this.deleteFolderAndContents(f.id));
    const rowsToDelete = this.data.rows.filter((r) => r.folderId === folderId);
    rowsToDelete.forEach((row) => this.onRowDeletedCb(row));
    this.data.folders = this.data.folders.filter((f) => f.id !== folderId);
    this.data.rows = this.data.rows.filter((r) => r.folderId !== folderId);
  }
};

// src/uiMarkdownHelpModal.ts
var import_obsidian10 = require("obsidian");
var MarkdownHelpModal = class extends import_obsidian10.Modal {
  constructor(app, markdown, sourcePath = "") {
    super(app);
    this.markdown = markdown;
    this.sourcePath = sourcePath;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    await import_obsidian10.MarkdownRenderer.render(this.app, this.markdown, contentEl, this.sourcePath, this);
  }
};
async function fetchMarkdownFromGitHub(url) {
  const response = await fetch(url);
  if (!response.ok)
    throw new Error("Could not load file from GitHub");
  return await response.text();
}

// src/settings-properties.ts
var RulesTable = class extends import_obsidian11.PluginSettingTab {
  constructor(app, plugin, container, settings) {
    super(app, plugin);
    this.knownProperties = {};
    this.activeFile = null;
    this.plugin = plugin;
    this.container = container;
    this.settings = settings;
    this.tools = new ScriptingTools(app, plugin);
    this.activeFile = this.app.workspace.getActiveFile();
  }
  // Helper to render one rule
  renderPropertyRow(containerEl, rule) {
    const rowEl = containerEl.createDiv({ cls: "property-setting-row setting-item" });
    rowEl.style.width = "100%";
    rowEl.id = rule.id;
    const controlEl = rowEl.createDiv({ cls: "setting-item-control" });
    controlEl.style.width = "100%";
    controlEl.style.display = "flex";
    controlEl.style.gap = "0px";
    const leftContainer = controlEl.createDiv({ cls: "property-left-container" });
    const iconEl = leftContainer.createSpan({ cls: "property-icon setting-item-icon" });
    (0, import_obsidian11.setIcon)(iconEl, "hash");
    const searchContainer = leftContainer.createDiv({ cls: "property-search-container" });
    const nameInput = new import_obsidian11.TextComponent(searchContainer).setPlaceholder("Select property...").setValue(rule.property || "").onChange(async (value) => {
      this.renderSearchResults(searchContainer, value, rule);
    });
    nameInput.inputEl.style.border = "none";
    nameInput.inputEl.addEventListener("focus", () => {
      this.renderSearchResults(searchContainer, nameInput.getValue(), rule);
    });
    nameInput.inputEl.addEventListener("input", () => {
      this.renderSearchResults(searchContainer, nameInput.getValue(), rule);
    });
    nameInput.inputEl.addEventListener("blur", (event) => {
      setTimeout(() => {
        const relatedTarget = event.relatedTarget;
        const resultsEl = searchContainer.querySelector(".property-search-results");
        if (!resultsEl || !resultsEl.contains(relatedTarget)) {
          this.clearSearchResults(searchContainer);
        }
      }, 100);
    });
    const currentPropertyInfo = this.knownProperties[rule.property];
    if (currentPropertyInfo) {
      updatePropertyIcon(iconEl, currentPropertyInfo.type);
    } else if (rule.property) {
      (0, import_obsidian11.setIcon)(iconEl, "alert-circle");
    }
    const middleContainer = controlEl.createDiv({ cls: "property-middle-container" });
    const valueContainer = middleContainer.createDiv({ cls: "FMA-property-value-container" });
    if (this.activeFile) {
      this.app.fileManager.processFrontMatter(this.activeFile, async (frontmatter) => {
        rule.value = await executeRuleObject("preview", this.app, this, this.plugin.settings, this.activeFile, "", rule, frontmatter);
      }, { "mtime": this.activeFile.stat.mtime });
    }
    const previewComponent = this.renderValueInput(valueContainer, currentPropertyInfo, rule.value, rule);
    this.updatePreview(rule, previewComponent);
    const propertyDevDropdown = new import_obsidian11.DropdownComponent(middleContainer);
    propertyDevDropdown.selectEl.style.minWidth = "35%";
    propertyDevDropdown.selectEl.style.maxWidth = "50%";
    propertyDevDropdown.addOption("", "Select a content");
    rulesManager.getRulesByType("buildIn", rule.type).forEach((rule2) => {
      propertyDevDropdown.addOption(rule2.id, rule2.name);
    });
    propertyDevDropdown.setValue(rule.content);
    propertyDevDropdown.onChange(async (value) => {
      if (value !== "") {
        const ruleFunction = rulesManager.getRuleById(value);
        switch (ruleFunction == null ? void 0 : ruleFunction.ruleType) {
          case "script":
          case "buildIn.inputProperty":
          case "buildIn":
            let oldOriginalCode = rulesManager.getSource(value) || rulesManager.getSource("default") || "";
            if (rule.buildInCode !== "" && rule.buildInCode !== oldOriginalCode) {
              const shouldProceed = await new AlertModal(
                this.app,
                "Overwrite existing code?",
                "I sees like you have custom code for this rule! Should this be overwritten by default code for this parameter?",
                "Yes",
                "No"
              ).openAndGetValue();
              if (shouldProceed.proceed) {
                rule.buildInCode = rulesManager.getSource(value) || rulesManager.getSource("default") || "";
                rule.useCustomCode = false;
              } else {
                rule.buildInCode;
              }
              await this.plugin.saveSettings();
            } else {
              rule.buildInCode = rulesManager.getSource(value) || rulesManager.getSource("default") || "";
              rule.useCustomCode = false;
              await this.plugin.saveSettings();
            }
            await this.plugin.saveSettings();
            break;
          case "automation":
          case "autocomplete.modal":
            break;
          default:
        }
        rule.content = value;
        await this.plugin.saveSettings();
        this.updatePreview(rule, previewComponent);
        this.renderPropertyOptions(optionEL, rule, previewComponent);
      }
    });
    const leftContainerEl = controlEl.createDiv({ cls: "FMA-property-right-container" });
    new import_obsidian11.ButtonComponent(leftContainerEl).setIcon("gear").setTooltip("open settings").setClass("property-icon-button").onClick(async () => {
      let settingsContainers = containerEl.getElementsByClassName("property-options-container");
      for (let container of settingsContainers) {
        if (container.getAttribute("id") !== rule.id)
          container.setAttribute("style", "display: none;");
      }
      this.renderPropertyOptions(optionEL, rule, previewComponent);
      optionEL.style.display = optionEL.style.display === "block" ? "none" : "block";
    });
    controlEl.style.display = "flex";
    controlEl.style.alignItems = "center";
    controlEl.style.justifyContent = "space-between";
    controlEl.style.width = "100%";
    leftContainer.style.display = "flex";
    leftContainer.style.alignItems = "center";
    leftContainer.style.minWidth = "100px";
    iconEl.style.marginRight = "8px";
    searchContainer.style.position = "relative";
    let optionEL;
    if (containerEl.parentElement) {
      optionEL = containerEl.parentElement.createDiv({ cls: "property-options-container" });
      optionEL.id = rule.id;
      optionEL.style.display = "none";
    } else {
      optionEL = containerEl.createDiv({ cls: "property-options-container" });
      optionEL.id = rule.id;
      optionEL.style.display = "none";
    }
  }
  renderPropertyOptions(optionEL, rule, previewComponent) {
    var _a, _b, _c, _d, _e, _f;
    if (!(previewComponent instanceof import_obsidian11.TextComponent))
      return;
    optionEL.empty();
    const ruleFn = rulesManager.getRuleById(rule.content);
    if (!ruleFn)
      return;
    if (ruleFn.useRuleOption("removeContent")) {
      const removeContentButton = new import_obsidian11.Setting(optionEL).setName("Remove content").setDesc(`Before making changes you might consider to remove content generated by this rule`).addButton(
        (button) => {
          button.setWarning().setButtonText("Remove Content").setCta().onClick(() => {
            let count = this.plugin.removeFrontmatterParamsFromAllFiles(rule);
            button.removeCta();
            button.setDisabled(true);
            removeContentButton.setDesc(`Removed this rule from ${count.files} files.`);
          });
        }
      );
    }
    if (ruleFn.useRuleOption("ruleActive")) {
      new import_obsidian11.Setting(optionEL).setName("Rule active").setDesc("If enabled, the rule will be executed").addToggle(
        (toggle) => toggle.setValue(rule.active).onChange(async (value) => {
          rule.active = value;
          await this.plugin.saveSettings();
        })
      );
    }
    if (ruleFn.useRuleOption("modifyOnly")) {
      new import_obsidian11.Setting(optionEL).setName("Modify only").setDesc("Only modify existing properties").addToggle((toggle) => toggle.setValue(rule.onlyModify).onChange(async (value) => {
        rule.onlyModify = value;
        await this.plugin.saveSettings();
        this.updatePreview(rule, previewComponent);
      }));
    }
    if (rule.type === "text" || rule.type === "multitext" || rule.type === "tags" || rule.type === "aliases") {
      let formatRule = rulesManager.getRuleById(rule.formatter);
      const formatterRules = rulesManager.getRulesByType("formatter") || [];
      let formatOptionsButton;
      if (ruleFn.useRuleOption("convertToLowerCase")) {
        const multiProp = new MultiPropertySetting(optionEL).setName("Format output").setDesc("Format output using selected options.").setOptions(formatterRules).setValue(rule.formatters || ["toOriginal"]).onChange((formatter) => {
          rule.formatters = formatter;
          formatRule = rulesManager.getRuleById(rule.formatter);
          this.updatePreview(rule, previewComponent);
        });
        multiProp.addExtraButton((setting, idx) => {
          setting.addExtraButton((btn) => {
            var _a2, _b2, _c2, _d2, _e2, _f2;
            btn.setIcon("gear").setTooltip("Options").setDisabled(!((_c2 = rulesManager.getRuleById((_b2 = (_a2 = rule == null ? void 0 : rule.formatters) == null ? void 0 : _a2[idx]) != null ? _b2 : "toOriginal")) == null ? void 0 : _c2.hasOwnConfigTab()) || false).onClick(() => {
              var _a3, _b3;
              converterOptionDiv.style.display = "block";
              converterOptionDiv.empty();
              formatRule = rulesManager.getRuleById((_b3 = (_a3 = rule == null ? void 0 : rule.formatters) == null ? void 0 : _a3[idx]) != null ? _b3 : "toOriginal");
              formatRule == null ? void 0 : formatRule.configTab(converterOptionDiv, rule, this, previewComponent);
            });
            multiProp.styleDisabled(btn, !((_f2 = rulesManager.getRuleById((_e2 = (_d2 = rule == null ? void 0 : rule.formatters) == null ? void 0 : _d2[idx]) != null ? _e2 : "toOriginal")) == null ? void 0 : _f2.hasOwnConfigTab()) || false);
          });
        });
      }
      let converterOptionDiv = optionEL.createDiv({ cls: "property-converter-option" });
      converterOptionDiv.style.display = "none";
      converterOptionDiv.style.marginLeft = "20px";
      if (ruleFn.useRuleOption("resultAsLink")) {
        new import_obsidian11.Setting(optionEL).setName("Result as Link").setDesc("Format Result as Link").addDropdown((dropdown) => {
          rulesManager.getRulesByType("linkFormatter").forEach((rule2) => {
            dropdown.addOption(rule2.id, rule2.name);
          });
          dropdown.setValue(rule.linkFormatter || "toOriginalLink");
          dropdown.onChange(async (value) => {
            rule.linkFormatter = value;
            await this.plugin.saveSettings();
            this.updatePreview(rule, previewComponent);
          });
        });
      }
    }
    if (rule.type === "text" || rule.type === "multitext" || rule.type === "tags" || rule.type === "aliases") {
      if (ruleFn.useRuleOption("addContent")) {
        new import_obsidian11.Setting(optionEL).setName("Add content").setDesc("select how the content should be stored").addDropdown(
          (dropdown) => dropdown.addOption("overwrite", "replace content").addOption("start", "place on start").addOption("end", "place on end").setValue(rule.addContent).onChange(async (value) => {
            if (value !== "") {
              rule.addContent = value === "overwrite" ? "overwrite" : value === "start" ? "start" : "end";
              await this.plugin.saveSettings();
              this.updatePreview(rule, previewComponent);
            }
          })
        );
      }
    }
    if (ruleFn.useRuleOption("excludeFolders")) {
      const excludeEL = new import_obsidian11.Setting(optionEL).setName("Exclude Files and Folders from this rule").setDesc(`Currently ${((_a = rule.exclude) == null ? void 0 : _a.selectedFolders.length) || 0} folders and ${((_b = rule.exclude) == null ? void 0 : _b.selectedFiles.length) || 0} files will be ${((_c = rule.exclude) == null ? void 0 : _c.mode) || "exclude"}d.`).addButton((button) => {
        button.setIcon("folder-x").setButtonText("Exclude").setCta().onClick(() => {
          var _a2, _b2, _c2;
          openDirectorySelectionModal(
            this.app,
            ((_a2 = rule.exclude) == null ? void 0 : _a2.selectedFolders) || [],
            ((_b2 = rule.exclude) == null ? void 0 : _b2.selectedFiles) || [],
            {
              selectionMode: "exclude",
              displayMode: ((_c2 = rule.exclude) == null ? void 0 : _c2.display) || "folders",
              optionSelectionMode: false,
              optionShowFiles: true
            },
            (result) => {
              var _a3, _b3, _c3;
              if (!result)
                return;
              if (!rule.exclude) {
                rule.exclude = Object.assign({}, DEFAULT_FILTER_FILES_AND_FOLDERS, {
                  mode: "exclude"
                });
              }
              ;
              rule.exclude.selectedFolders = result.folders;
              rule.exclude.selectedFiles = result.files;
              rule.exclude.mode = "exclude";
              rule.exclude.display = result.display;
              this.plugin.saveSettings();
              logger.log(DEBUG, rule.exclude);
              this.updateFilterIndicator(this.activeFile, this.propertiesListEl);
              excludeEL.setDesc(`Currently ${((_a3 = rule.exclude) == null ? void 0 : _a3.selectedFolders.length) || 0} folders and ${((_b3 = rule.exclude) == null ? void 0 : _b3.selectedFiles.length) || 0} files will be ${((_c3 = rule.exclude) == null ? void 0 : _c3.mode) || "exclude"}d.`);
            }
          );
        });
      });
    }
    if (ruleFn.useRuleOption("includeFolders")) {
      const includeEL = new import_obsidian11.Setting(optionEL).setName("Include Files and Folders for this rule ").setDesc(`Currently ${((_d = rule.include) == null ? void 0 : _d.selectedFolders.length) || 0} folders and ${((_e = rule.include) == null ? void 0 : _e.selectedFiles.length) || 0} files will be ${((_f = rule.include) == null ? void 0 : _f.mode) || "include"}d even if they are excluded globally.`).addButton((button) => {
        button.setIcon("folder-check").setButtonText("Include").setCta().onClick(() => {
          var _a2, _b2, _c2;
          openDirectorySelectionModal(
            this.app,
            ((_a2 = rule.include) == null ? void 0 : _a2.selectedFolders) || [],
            ((_b2 = rule.include) == null ? void 0 : _b2.selectedFiles) || [],
            {
              selectionMode: "include",
              displayMode: ((_c2 = rule.include) == null ? void 0 : _c2.display) || "folders",
              optionSelectionMode: false,
              optionShowFiles: true
            },
            (result) => {
              var _a3, _b3, _c3;
              if (!result)
                return;
              if (!rule.include) {
                rule.include = Object.assign({}, DEFAULT_FILTER_FILES_AND_FOLDERS, {
                  mode: "include"
                });
              }
              ;
              rule.include.selectedFolders = result.folders;
              rule.include.selectedFiles = result.files;
              rule.include.mode = "include";
              rule.include.display = result.display;
              this.plugin.saveSettings();
              logger.log(DEBUG, rule.include);
              this.updateFilterIndicator(this.activeFile, this.propertiesListEl);
              includeEL.setDesc(`Currently ${((_a3 = rule.include) == null ? void 0 : _a3.selectedFolders.length) || 0} folders and ${((_b3 = rule.include) == null ? void 0 : _b3.selectedFiles.length) || 0} files will be ${((_c3 = rule.include) == null ? void 0 : _c3.mode) || "include"}d.`);
            }
          );
        });
      });
    }
    if (ruleFn.useRuleOption("script")) {
      new import_obsidian11.Setting(optionEL).setName("Script").setDesc("edit the script for own modifications").addButton((button) => {
        button.setButtonText("JS Editor").onClick(() => {
          var _a2, _b2, _c2;
          logger.log(
            DEBUG,
            `Opening code editor for rule ${rule.id} with content ${rule.content}, file: ${(_a2 = this.activeFile) == null ? void 0 : _a2.path}`,
            this.activeFile,
            this.activeFile ? this.app.metadataCache.getFileCache(this.activeFile) || {} : {}
          );
          openCodeEditorModal(
            this.app,
            this.plugin,
            rule.buildInCode,
            ((_b2 = rule.typeProperty) == null ? void 0 : _b2.type) || "text",
            this.activeFile,
            this.activeFile ? ((_c2 = this.app.metadataCache.getFileCache(this.activeFile)) == null ? void 0 : _c2.frontmatter) || {} : {},
            (result) => {
              if (!result)
                return;
              rule.buildInCode = result.code;
              rule.useCustomCode = true;
              button.setCta();
              this.plugin.saveSettings();
              this.updatePreview(rule, previewComponent);
            }
          );
        });
        if (rule.useCustomCode) {
          button.setCta();
        } else {
          button.removeCta();
        }
      });
    }
    let ruleOptionDiv = optionEL.createDiv({ cls: "property-rule-option" });
    ruleOptionDiv.style.marginLeft = "20px";
    rulesManager.buildConfigTab(rule.content, ruleOptionDiv, rule, this, previewComponent);
    this.updatePreview(rule, previewComponent);
  }
  /**
   * Retrieves the configuration option for a specific rule and property.
   *
   * @param ruleId - The unique identifier of the rule.
   * @param propertyId - The specific property for which the configuration is being retrieved.
   * @returns The configuration value for the specified property, or undefined if not found.
   */
  getOptionConfig(ruleId, propertyId) {
    const rule = this.plugin.settings.rules.find((rule2) => rule2.id === ruleId);
    if (rule) {
      const optionConfig = rule.optionsConfig[ruleId];
      if (optionConfig[propertyId]) {
        return optionConfig[propertyId];
      }
    }
    return void 0;
  }
  /**
   * Sets the configuration option for a specific rule and property.
   *
   * @param ruleId - The unique identifier of the rule.
   * @param propertyId - The specific property for which the configuration is being set.
   * @param config - The configuration value to be set.
   */
  setOptionConfig(ruleId, propertyId, config) {
    const rule = this.plugin.settings.rules.find((rule2) => rule2.id === ruleId);
    if (rule) {
      if (!rule.optionsConfig)
        rule.optionsConfig = {};
      if (!rule.optionsConfig[ruleId])
        rule.optionsConfig[ruleId] = {};
      rule.optionsConfig[ruleId][propertyId] = config;
      this.plugin.saveSettings();
    }
  }
  hasOptionConfig(ruleId) {
    const rule = this.plugin.settings.rules.find((rule2) => rule2.id === ruleId);
    if (rule) {
      if (!rule.optionsConfig)
        rule.optionsConfig = {};
      if (!rule.optionsConfig[ruleId])
        rule.optionsConfig[ruleId] = {};
      return Object.keys(rule.optionsConfig[ruleId]).length > 0;
    }
    return false;
  }
  setOptionConfigDefaults(ruleId, defaults) {
    const rule = this.plugin.settings.rules.find((rule2) => rule2.id === ruleId);
    if (rule) {
      if (!rule.optionsConfig)
        rule.optionsConfig = {};
      rule.optionsConfig[ruleId] = Object.assign({}, defaults, rule.optionsConfig[ruleId] || {});
    }
    return rule.optionsConfig[ruleId];
  }
  renderSearchResults(searchContainerEl, searchTerm, payload) {
    this.clearSearchResults(searchContainerEl);
    const filteredProperties = Object.entries(this.knownProperties).filter(([name]) => name.toLowerCase().includes(searchTerm.toLowerCase()));
    if (filteredProperties.length === 0 && searchTerm) {
      return;
    }
    if (filteredProperties.length === 0 && !searchTerm) {
      return;
    }
    const resultsEl = searchContainerEl.createDiv({ cls: "property-search-results menu" });
    resultsEl.style.position = "absolute";
    resultsEl.style.top = "100%";
    resultsEl.style.left = "0";
    resultsEl.style.width = "calc(100% + 100px)";
    resultsEl.style.zIndex = "10";
    resultsEl.style.maxHeight = "200px";
    resultsEl.style.overflowY = "auto";
    let activeIndex = -1;
    const updateActiveItem = (newIndex) => {
      const items = resultsEl.querySelectorAll(".menu-item");
      items.forEach((item, index) => {
        if (index === newIndex) {
          item.addClass("property-search-is-active");
          item.scrollIntoView({ block: "nearest" });
        } else {
          item.removeClass("property-search-is-active");
        }
      });
      activeIndex = newIndex;
    };
    const selectActiveItem = async () => {
      if (activeIndex >= 0 && activeIndex < filteredProperties.length) {
        const [name, info] = filteredProperties[activeIndex];
        payload.property = name;
        payload.type = info.type;
        payload.value = void 0;
        await this.plugin.saveSettings();
        this.clearSearchResults(searchContainerEl);
        this.display();
      }
    };
    filteredProperties.forEach(([name, info], index) => {
      const itemEl = resultsEl.createDiv({ cls: "menu-item" });
      const itemIcon = itemEl.createSpan({ cls: "menu-item-icon" });
      updatePropertyIcon(itemIcon, info.type);
      itemEl.createSpan({ text: name });
      itemEl.addEventListener("mousedown", async (e) => {
        e.preventDefault();
        activeIndex = index;
        await selectActiveItem();
      });
    });
    searchContainerEl.addEventListener("keydown", async (e) => {
      const items = resultsEl.querySelectorAll(".menu-item");
      if (e.key === "ArrowDown") {
        e.preventDefault();
        updateActiveItem((activeIndex + 1) % items.length);
      } else if (e.key === "ArrowUp") {
        e.preventDefault();
        updateActiveItem((activeIndex - 1 + items.length) % items.length);
      } else if (e.key === "Enter") {
        e.preventDefault();
        await selectActiveItem();
      }
    });
  }
  clearSearchResults(searchContainerEl) {
    const resultsEl = searchContainerEl.querySelector(".property-search-results");
    if (resultsEl) {
      resultsEl.remove();
    }
  }
  renderValueInput(containerEl, propertyInfo, currentValue, payload) {
    let returnComponent;
    if (!propertyInfo) {
      containerEl.setText("");
      containerEl.addClass("text-muted");
      return;
    }
    const type = propertyInfo.type;
    switch (type) {
      case "number":
        returnComponent = new import_obsidian11.TextComponent(containerEl).setPlaceholder("Numeric Value").setValue(currentValue !== void 0 && currentValue !== null ? String(currentValue) : "").onChange(async (value) => {
          const numValue = value === "" ? void 0 : parseFloat(value);
          payload.value = isNaN(numValue) ? void 0 : numValue;
          await this.plugin.saveSettings();
        });
        returnComponent.inputEl.type = "number";
        break;
      case "checkbox":
        returnComponent = containerEl.createDiv({ cls: "FMA-tri-state-checkbox" });
        returnComponent.setAttribute("aria-label", "Checkbox change state");
        returnComponent.setAttribute("role", "checkbox");
        const updateCheckboxVisual = (state) => {
          let iconName;
          let ariaState;
          if (state === true) {
            iconName = "check-square";
            ariaState = "true";
          } else if (state === false) {
            iconName = "square";
            ariaState = "false";
          } else {
            iconName = "minus-square";
            ariaState = "mixed";
          }
          (0, import_obsidian11.setIcon)(returnComponent, iconName);
          returnComponent.setAttribute("aria-checked", ariaState);
          returnComponent.dataset.state = String(state);
        };
        updateCheckboxVisual(currentValue);
        returnComponent.addEventListener("click", async () => {
          let currentState = returnComponent.dataset.state;
          let nextState;
          if (currentState === "false") {
            nextState = true;
          } else if (currentState === "true") {
            nextState = void 0;
          } else {
            nextState = false;
          }
          payload.value = nextState;
          await this.plugin.saveSettings();
          updateCheckboxVisual(nextState);
        });
        break;
      case "date":
        returnComponent = new import_obsidian11.TextComponent(containerEl).setPlaceholder("YYYY-MM-DD").setValue(currentValue || "").onChange(async (value) => {
          payload.value = value || void 0;
          await this.plugin.saveSettings();
        });
        returnComponent.inputEl.type = "date";
        break;
      case "datetime":
        returnComponent = new import_obsidian11.TextComponent(containerEl).setPlaceholder("YYYY-MM-DDTHH:mm").setValue(currentValue || "").onChange(async (value) => {
          payload.value = value || void 0;
          await this.plugin.saveSettings();
        });
        returnComponent.inputEl.type = "datetime-local";
        break;
      case "aliases":
      case "tags":
      case "multitext":
        returnComponent = new import_obsidian11.TextComponent(containerEl).setPlaceholder("values (divided by comma)").setValue(Array.isArray(currentValue) ? currentValue.join(", ") : currentValue || "").onChange(async (value) => {
          const arrayValue = value.split(",").map((s) => s.trim()).filter((s) => s);
          payload.value = arrayValue.length > 0 ? arrayValue : void 0;
          await this.plugin.saveSettings();
        });
        break;
      case "text":
      default:
        returnComponent = new import_obsidian11.TextComponent(containerEl).setPlaceholder("value").setValue(currentValue || "").onChange(async (value) => {
          payload.value = value || void 0;
          await this.plugin.saveSettings();
        });
        break;
    }
    if (type !== "checkbox") {
      returnComponent.inputEl.addClass("FMA-property-value-input");
    } else {
      returnComponent.addClass("FMA-property-value-input");
    }
    return returnComponent;
  }
  async updatePreview(rule, previewComponent) {
    if (this.activeFile) {
      let ruleResult;
      await this.app.fileManager.processFrontMatter(this.activeFile, async (frontmatter) => {
        ruleResult = await executeRuleObject("preview", this.app, this, this.plugin.settings, this.activeFile, "", rule, frontmatter);
      }, { "mtime": this.activeFile.stat.mtime });
      switch (typeof ruleResult) {
        case "object":
          if (Array.isArray(ruleResult))
            previewComponent.inputEl.value = ruleResult.toString();
          break;
        default:
          if (previewComponent == null ? void 0 : previewComponent.inputEl)
            previewComponent.inputEl.value = ruleResult;
          break;
      }
    }
  }
  async display() {
    const containerEl = this.container;
    containerEl.empty();
    this.knownProperties = await this.tools.fetchKnownProperties(this.app);
    this.propertiesListEl = containerEl;
    const folderList = new TreeHierarchySortableSettings(
      containerEl,
      this.plugin.settings.folderConfig,
      (row, rowEl) => {
        this.renderPropertyRow(rowEl, row.payload);
      }
    ).setTitle("Rules").setDescription("add rules to selected frontmatter properties").onChange((data) => {
      this.plugin.settings.folderConfig = data;
      this.updateFilterIndicator(this.activeFile, this.propertiesListEl);
      this.plugin.saveSettings();
    }).onRendered(() => {
      this.updateFilterIndicator(this.activeFile, this.propertiesListEl);
    }).onRowCreated(async (row) => {
      const defaultName = "";
      row.payload = Object.assign({}, DEFAULT_RULE_DEFINITION, {
        id: (0, import_crypto.randomUUID)().toString()
      });
      await this.plugin.saveSettings();
    }).onDeleteBt(async () => {
      const shouldProceed = await new AlertModal(
        this.app,
        "Erase all Rules?",
        "Do you really like to erase ALL rules?",
        "Yes",
        "No"
      ).openAndGetValue();
      if (shouldProceed.proceed) {
        this.plugin.folderConfig.rows = [];
        this.plugin.saveSettings();
      }
    }).addExtraButtonToHeader((el) => {
      el.addExtraButton(
        (btn) => btn.setIcon("circle-help").onClick(async () => {
          let markdown = "Could not load help from GitHub.";
          try {
            markdown = await fetchMarkdownFromGitHub(
              "https://raw.githubusercontent.com/Christian-Me/obsidian-front-matter-automate/main/doc/README.md"
            );
          } catch (e) {
          }
          new MarkdownHelpModal(this.app, markdown, "modules.md").open();
        })
      );
    });
    if (this.plugin.settings.folderConfig.rows.length === 0 && this.plugin.settings.rules.length > 0) {
      this.plugin.settings.rules.forEach((rule) => {
        const keywords = [];
        keywords.push(rule.content);
        folderList.addRow(ROOT_FOLDER, [], rule);
      });
    }
    let activeFile = this.app.workspace.getActiveFile();
    this.updateFilterIndicator(activeFile, this.propertiesListEl);
  }
  updateFilterIndicator(activeFile, propertiesListEl) {
    if (activeFile) {
      this.plugin.settings.folderConfig.rows.forEach((row, index) => {
        const rule = row.payload;
        const propertyRowElements = propertiesListEl.getElementsByClassName("property-setting-row");
        const propertyRowEl = Array.from(propertyRowElements).filter((el) => el.id === rule.id)[0];
        if (!propertyRowEl) {
          return;
        }
        const propertyLeftDiv = propertyRowEl.querySelector(".property-left-container");
        if (checkIfFileAllowed(activeFile, this.plugin.settings, rule)) {
          propertyLeftDiv == null ? void 0 : propertyLeftDiv.addClass("property-left-container-allowed");
        } else {
          propertyLeftDiv == null ? void 0 : propertyLeftDiv.removeClass("property-left-container-allowed");
        }
      });
    }
  }
};

// src/settings.ts
var FolderTagSettingTab = class extends import_obsidian12.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.scriptingTools = new ScriptingTools(app, plugin);
  }
  hide() {
    this.plugin.settings.liveRules = [];
    this.plugin.settings.rules.forEach((rule) => {
      let ruleFunction = rulesManager.getRuleById(rule.content);
      if (!ruleFunction)
        return;
      if (ruleFunction.isLiveRule) {
        this.plugin.settings.liveRules.push(rule);
      }
    });
    this.plugin.saveSettings();
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile && activeFile.extension === "md") {
      this.plugin.updateFrontmatterParameters("active-leaf-change", activeFile, this.plugin.settings.folderConfig);
    }
  }
  display() {
    this.knownProperties = getPropertiesFromMetadataManager(this.app);
    this.knownTypes = getTypesFromMetadataManager(this.app);
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian12.Setting(containerEl).setName(`Front matter automate V${versionString}`).setDesc(`This plugin automates the management of front matter in your Obsidian notes. It allows you to set rules for automatically adding, modifying, or removing front matter properties based on various events like file creation, renaming, or active leaf changes.`).addButton(
      (button) => button.setIcon("circle-help").setTooltip("Online Help").onClick(async () => {
        let markdown = "Could not load help from GitHub.";
        try {
          markdown = await fetchMarkdownFromGitHub(
            "https://raw.githubusercontent.com/Christian-Me/obsidian-front-matter-automate/main/readme.md"
          );
        } catch (e) {
        }
        new MarkdownHelpModal(this.app, markdown, "readme.md").open();
      })
    );
    new import_obsidian12.Setting(containerEl).setName("Exclude Files and Folders globally").setDesc(`Currently ${this.plugin.settings.exclude.selectedFolders.length} folders and ${this.plugin.settings.exclude.selectedFiles.length} files will be ${this.plugin.settings.exclude.mode}d.`).addButton((button) => {
      button.setIcon("folder-x").setButtonText("Exclude").setCta().onClick(() => {
        openDirectorySelectionModal(
          this.app,
          this.plugin.settings.exclude.selectedFolders || [],
          this.plugin.settings.exclude.selectedFiles || [],
          {
            selectionMode: this.plugin.settings.exclude.mode || "exclude",
            displayMode: this.plugin.settings.exclude.display || "folders",
            optionSelectionMode: false,
            optionShowFiles: true
          },
          (result) => {
            if (!result)
              return;
            this.plugin.settings.exclude.selectedFolders = result.folders;
            this.plugin.settings.exclude.selectedFiles = result.files;
            this.plugin.settings.exclude.mode = result.mode;
            this.plugin.settings.exclude.display = result.display;
            this.plugin.saveSettings();
            this.display();
          }
        );
      });
    });
    new import_obsidian12.Setting(containerEl).setName("Include Files and Folders globally").setDesc(`Currently ${this.plugin.settings.include.selectedFolders.length} folders and ${this.plugin.settings.include.selectedFiles.length} files will be ${this.plugin.settings.include.mode}d even if they are excluded.`).addButton((button) => {
      button.setIcon("folder-check").setButtonText("Include").setCta().onClick(() => {
        openDirectorySelectionModal(
          this.app,
          this.plugin.settings.include.selectedFolders || [],
          this.plugin.settings.include.selectedFiles || [],
          {
            selectionMode: this.plugin.settings.include.mode || "include",
            displayMode: this.plugin.settings.include.display || "folders",
            optionSelectionMode: false,
            optionShowFiles: true
          },
          (result) => {
            if (!result)
              return;
            this.plugin.settings.include.selectedFolders = result.folders;
            this.plugin.settings.include.selectedFiles = result.files;
            this.plugin.settings.include.mode = result.mode;
            this.plugin.settings.include.display = result.display;
            this.plugin.saveSettings();
            this.display();
          }
        );
      });
    });
    new import_obsidian12.Setting(containerEl).setName("Debug").setDesc("Select the debug level to show in the console").addDropdown((dropdown) => {
      dropdown.addOptions(
        Object.fromEntries(logger.getLevelNames().map((level) => [level, level]))
      );
      dropdown.setValue(logger.getLevelName(this.plugin.settings.debugLevel));
      dropdown.onChange((value) => {
        this.plugin.settings.debugLevel = logger.getLevelByName(value);
        logger.setLevel(this.plugin.settings.debugLevel);
        this.plugin.saveSettings();
      });
    });
    new import_obsidian12.Setting(containerEl).setName("Delay create event (until better solution is found)").setDesc("Set a delay before triggering the create event to allow for file creation to complete. (in milliseconds)").addText((text) => {
      text.setValue(this.plugin.settings.delayCreateEvent.toString());
      text.onChange(async (value) => {
        this.plugin.settings.delayCreateEvent = parseInt(value) || 0;
        await this.plugin.saveSettings();
      });
    });
    this.rulesContainer = containerEl.createDiv("properties-list");
    const rulesTable = new RulesTable(this.app, this.plugin, this.rulesContainer, this.plugin.settings.folderConfig);
    rulesTable.display();
    new import_obsidian12.Setting(containerEl).setName("Backup & Restore Configuration").setDesc("Export your current config as a JSON file or restore from a backup.").addButton((btn) => {
      btn.setButtonText("Backup").setIcon("download").onClick(() => {
        const dataStr = JSON.stringify(this.plugin.settings, null, 2);
        const blob = new Blob([dataStr], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "frontmatter-automate-backup.json";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      });
    }).addButton((btn) => {
      btn.setButtonText("Restore").setIcon("upload").onClick(() => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".json,application/json";
        input.onchange = async () => {
          if (!input.files || input.files.length === 0)
            return;
          const file = input.files[0];
          const text = await file.text();
          try {
            const data = JSON.parse(text);
            this.plugin.settings = data;
            await this.plugin.saveSettings();
            this.display();
            new import_obsidian12.Notice("Frontmatter Automate\nConfiguration restored from backup.");
          } catch (e) {
            new import_obsidian12.Notice("Frontmatter Automate\nFailed to restore: Invalid JSON file.", 2e3);
          }
        };
        input.click();
      });
    });
  }
};

// src/rules/addPrefix.ts
var import_obsidian13 = require("obsidian");
var RuleAddPrefix = class extends RulePrototype {
  constructor() {
    super();
    this.id = "addPrefix";
    this.name = "Add a Prefix";
    this.description = "Adds a prefix to the input value.";
    this.ruleType = "formatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    var _a;
    const prefix = tools.getOptionConfig((_a = tools.getRule()) == null ? void 0 : _a.id, "prefix");
    return `${prefix}${input}`;
  }
  configTab(optionEL, rule, that, previewComponent) {
    optionEL.empty();
    that.setOptionConfigDefaults(rule.id, {
      prefix: ""
      // Default prefix
    });
    new import_obsidian13.Setting(optionEL).setName("Prefix").setDesc("Enter a prefix to be added at the beginning.").addText(
      (text) => text.setPlaceholder('e.g. "pre-"').setValue(that.getOptionConfig(rule.id, "prefix") || "").onChange(async (value) => {
        that.setOptionConfig(rule.id, "prefix", value);
        that.updatePreview(rule, previewComponent);
      })
    );
  }
};

// src/rules/addSuffix.ts
var import_obsidian14 = require("obsidian");
var RuleAddSuffix = class extends RulePrototype {
  constructor() {
    super();
    this.id = "addSuffix";
    this.name = "Add a Suffix";
    this.description = "Adds a suffix to the input value.";
    this.ruleType = "formatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    var _a;
    const suffix = tools.getOptionConfig((_a = tools.getRule()) == null ? void 0 : _a.id, "suffix");
    return `${input}${suffix}`;
  }
  configTab(optionEL, rule, that, previewComponent) {
    optionEL.empty();
    that.setOptionConfigDefaults(rule.id, {
      suffix: ""
      // Default suffix
    });
    new import_obsidian14.Setting(optionEL).setName("Suffix").setDesc("Enter a suffix to be added at the end.").addText(
      (text) => text.setPlaceholder('e.g. "_done"').setValue(that.getOptionConfig(rule.id, "suffix") || "").onChange(async (value) => {
        that.setOptionConfig(rule.id, "suffix", value);
        that.updatePreview(rule, previewComponent);
      })
    );
  }
};

// src/rules/automationAutoLink.ts
var import_obsidian18 = require("obsidian");

// src/suggesters/FolderSuggester.ts
var import_obsidian16 = require("obsidian");

// src/suggesters/suggest.ts
var import_obsidian15 = require("obsidian");

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect4 = _ref.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});

// src/suggesters/suggest.ts
var wrapAround = (value, size) => {
  return (value % size + size) % size;
};
var Suggest = class {
  constructor(owner, containerEl, scope) {
    this.owner = owner;
    this.containerEl = containerEl;
    containerEl.on(
      "click",
      ".suggestion-item",
      this.onSuggestionClick.bind(this)
    );
    containerEl.on(
      "mousemove",
      ".suggestion-item",
      this.onSuggestionMouseover.bind(this)
    );
    scope.register([], "ArrowUp", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem - 1, true);
        return false;
      }
    });
    scope.register([], "ArrowDown", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem + 1, true);
        return false;
      }
    });
    scope.register([], "Enter", (event) => {
      if (!event.isComposing) {
        this.useSelectedItem(event);
        return false;
      }
    });
  }
  onSuggestionClick(event, el) {
    event.preventDefault();
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
    this.useSelectedItem(event);
  }
  onSuggestionMouseover(_event, el) {
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
  }
  setSuggestions(values) {
    this.containerEl.empty();
    const suggestionEls = [];
    values.forEach((value) => {
      const suggestionEl = this.containerEl.createDiv("suggestion-item");
      this.owner.renderSuggestion(value, suggestionEl);
      suggestionEls.push(suggestionEl);
    });
    this.values = values;
    this.suggestions = suggestionEls;
    this.setSelectedItem(0, false);
  }
  useSelectedItem(event) {
    const currentValue = this.values[this.selectedItem];
    if (currentValue) {
      this.owner.selectSuggestion(currentValue, event);
    }
  }
  setSelectedItem(selectedIndex, scrollIntoView) {
    const normalizedIndex = wrapAround(
      selectedIndex,
      this.suggestions.length
    );
    const prevSelectedSuggestion = this.suggestions[this.selectedItem];
    const selectedSuggestion = this.suggestions[normalizedIndex];
    prevSelectedSuggestion == null ? void 0 : prevSelectedSuggestion.removeClass("is-selected");
    selectedSuggestion == null ? void 0 : selectedSuggestion.addClass("is-selected");
    this.selectedItem = normalizedIndex;
    if (scrollIntoView) {
      selectedSuggestion.scrollIntoView(false);
    }
  }
};
var TextInputSuggest = class {
  constructor(app, inputEl) {
    this.app = app;
    this.inputEl = inputEl;
    this.scope = new import_obsidian15.Scope();
    this.suggestEl = createDiv("suggestion-container");
    const suggestion = this.suggestEl.createDiv("suggestion");
    this.suggest = new Suggest(this, suggestion, this.scope);
    this.scope.register([], "Escape", this.close.bind(this));
    this.inputEl.addEventListener("input", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("focus", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("blur", this.close.bind(this));
    this.suggestEl.on(
      "mousedown",
      ".suggestion-container",
      (event) => {
        event.preventDefault();
      }
    );
  }
  onInputChanged() {
    const inputStr = this.inputEl.value;
    const suggestions = this.getSuggestions(inputStr);
    if (!suggestions) {
      this.close();
      return;
    }
    if (suggestions.length > 0) {
      this.suggest.setSuggestions(suggestions);
      this.open(this.app.dom.appContainerEl, this.inputEl);
    } else {
      this.close();
    }
  }
  open(container, inputEl) {
    this.app.keymap.pushScope(this.scope);
    container.appendChild(this.suggestEl);
    this.popper = createPopper(inputEl, this.suggestEl, {
      placement: "bottom-start",
      modifiers: [
        {
          name: "sameWidth",
          enabled: true,
          fn: ({ state, instance }) => {
            const targetWidth = `${state.rects.reference.width}px`;
            if (state.styles.popper.width === targetWidth) {
              return;
            }
            state.styles.popper.width = targetWidth;
            instance.update();
          },
          phase: "beforeWrite",
          requires: ["computeStyles"]
        }
      ]
    });
  }
  close() {
    this.app.keymap.popScope(this.scope);
    this.suggest.setSuggestions([]);
    if (this.popper)
      this.popper.destroy();
    this.suggestEl.detach();
  }
};

// src/suggesters/FolderSuggester.ts
var FolderSuggest = class extends TextInputSuggest {
  constructor(app, inputEl) {
    super(app, inputEl);
  }
  getSuggestions(inputStr) {
    const abstractFiles = this.app.vault.getAllLoadedFiles();
    const folders = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    abstractFiles.forEach((folder) => {
      if (folder instanceof import_obsidian16.TFolder && folder.path.toLowerCase().contains(lowerCaseInputStr)) {
        folders.push(folder);
      }
    });
    return folders.slice(0, 1e3);
  }
  renderSuggestion(file, el) {
    el.setText(file.path.replace(/^(?!\/)/, "/"));
  }
  selectSuggestion(file) {
    this.inputEl.value = file.path.replace(/^(?!\/)/, "/");
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/suggesters/FileSuggester.ts
var import_obsidian17 = require("obsidian");
var FileSuggest = class extends TextInputSuggest {
  constructor(inputEl, plugin, folder) {
    super(plugin.app, inputEl);
    this.inputEl = inputEl;
    this.plugin = plugin;
    this.folder = folder;
  }
  get_error_msg() {
    return `Folder ${this.folder} doesn't exist`;
  }
  getSuggestions(input_str) {
    const all_files = errorWrapperSync(
      () => getFilesFromFolder(
        this.plugin.app,
        this.folder
      ),
      this.get_error_msg()
    );
    if (!all_files) {
      return [];
    }
    const files = [];
    const lower_input_str = input_str.toLowerCase();
    all_files.forEach((file) => {
      if (file instanceof import_obsidian17.TFile && file.extension === "md" && file.path.toLowerCase().contains(lower_input_str)) {
        files.push(file);
      }
    });
    return files.slice(0, 1e3);
  }
  renderSuggestion(file, el) {
    el.setText(file.path);
  }
  selectSuggestion(file) {
    this.inputEl.value = file.path;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/rules/automationAutoLink.ts
var RuleAutomationAutoLink = class extends RulePrototype {
  constructor() {
    super();
    this.id = "autoLink";
    this.name = "Auto Link (advanced)";
    this.description = "Checks if a link exists in a specified folder. If not, it creates a new file based on a specified template and adds a link to it.";
    this.ruleType = "automation";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "multitext"];
    this.configElements = this.defaultConfigElements({ removeContent: false, inputProperty: false, addPrefix: false, spaceReplacement: false, specialCharacterReplacement: false, convertToLowerCase: false, resultAsLink: false, script: false });
  }
  /**
   * Function to create a link to a file. If the file does not exist, it creates a new file based on a template.
   * @param app - The Obsidian app instance.
   * @param file - The current file.
   * @param tools - The scripting tools instance.
   * @returns The new content for the frontmatter property.
   */
  async fx(app, file, tools) {
    const currentContent = tools.getCurrentContent();
    let newContent = new Array();
    const rule = tools.getRule();
    if (!rule) {
      logger.log(ERROR, `autoLink: rule not found, returning current content ${currentContent}`);
      return currentContent;
    }
    const options = tools.getOptionConfig(rule.id);
    const filesToCheck = tools.getFilesInVault(options.destinationFolder);
    let links = currentContent || [];
    if (typeof links === "object" && !Array.isArray(links)) {
      links = [];
    } else if (typeof links === "string") {
      links = [links];
    }
    for (const part of links) {
      let link = tools.extractLinkParts(part);
      let linkFile = tools.getTFileFromPath(link.path, filesToCheck);
      if (!linkFile) {
        if (options.askConfirmation) {
          const result = await new AlertModal(app, "Create new file", `File ${link.path} does not exist. Do you want to create it?`, "Create", "Cancel", "Don't ask again.").openAndGetValue();
          if (!result.proceed)
            return;
          options.askConfirmation = !result.data.askConfirmation;
        }
        link.path = options.destinationFolder + "/" + link.title + ".md";
        linkFile = await tools.createFileFromPath(link.path, options.addTemplate ? options.templateFile : void 0);
        tools.updateFrontmatter(rule.property, [`[[${tools.removeLeadingSlash(link.path)}|${link.title}]]`], linkFile);
      } else {
      }
      if (linkFile) {
        link.path = linkFile.path;
        newContent.push(`[[${tools.removeLeadingSlash(link.path)}|${link.title}]]`);
      }
    }
    tools.updateFrontmatter(rule.property, newContent);
    return newContent;
  }
  configTab(optionEL, rule, that, previewComponent) {
    optionEL.empty();
    that.setOptionConfigDefaults(rule.id, {
      addTemplate: true,
      askConfirmation: true,
      destinationFolder: "/",
      templateFile: ""
    });
    new import_obsidian18.Setting(optionEL).setName("Add template to new files").setDesc("Automatically add template to new files").addToggle((toggle) => toggle.setValue(that.getOptionConfig(rule.id, "addTemplate") || false).onChange(async (value) => {
      that.setOptionConfig(rule.id, "addTemplate", value);
    }));
    new import_obsidian18.Setting(optionEL).setName("Ask for confirmation").setDesc("Ask for confirmation before creating new files").addToggle((toggle) => toggle.setValue(that.getOptionConfig(rule.id, "askConfirmation") || false).onChange(async (value) => {
      that.setOptionConfig(rule.id, "askConfirmation", value);
    }));
    let destinationFolderEl;
    new import_obsidian18.Setting(optionEL).setName("Destination Folder").setDesc("Folder to place new files").addSearch((cb) => {
      destinationFolderEl = cb;
      new FolderSuggest(that.app, cb.inputEl);
      cb.setPlaceholder("enter folder or browse ...").setValue(that.getOptionConfig(rule.id, "destinationFolder") || "").onChange((newFolder) => {
        newFolder = newFolder.trim();
        newFolder = newFolder.replace(/\/$/, "");
        that.setOptionConfig(rule.id, "destinationFolder", newFolder);
      });
      cb.containerEl.addClass("frontmatter-automate-search");
    }).addExtraButton(
      (button) => button.setIcon("folder-tree").setTooltip("Select template folder").onClick(async () => {
        openDirectorySelectionModal(
          that.app,
          [that.getOptionConfig(rule.id, "destinationFolder")],
          [],
          {
            title: "Select folder to place new files",
            selectionMode: "include",
            displayMode: "folder",
            optionSelectionMode: false,
            optionShowFiles: false
          },
          (result) => {
            if (!result)
              return;
            if (result.folders.length === 0 || !result.folders[0] || typeof result.folders[0] !== "string")
              return;
            let selectedFolder = result.folders[0].trim().replace(/\/$/, "");
            if (selectedFolder === "")
              selectedFolder = "/";
            if (!selectedFolder)
              return;
            destinationFolderEl.setValue(selectedFolder);
            that.setOptionConfig(rule.id, "destinationFolder", selectedFolder);
          }
        );
      })
    );
    let destinationFileEl;
    new import_obsidian18.Setting(optionEL).setName("Template File").setDesc("Select a template file to add to new files").addSearch((cb) => {
      destinationFileEl = cb;
      new FileSuggest(cb.inputEl, that.plugin, "");
      cb.setPlaceholder("enter folder or browse ...").setValue(that.getOptionConfig(rule.id, "templateFile") || "").onChange((newFile) => {
        newFile = newFile.trim();
        newFile = newFile.replace(/\/$/, "");
        that.setOptionConfig(rule.id, "templateFile", newFile);
      });
      cb.containerEl.addClass("frontmatter-automate-search");
    }).addExtraButton(
      (button) => button.setIcon("folder-tree").setTooltip("Select template file").onClick(async () => {
        openDirectorySelectionModal(
          that.app,
          [],
          [that.getOptionConfig(rule.id, "templateFile")],
          {
            title: "Select template for new files",
            selectionMode: "include",
            displayMode: "file",
            optionSelectionMode: false,
            optionShowFiles: true
          },
          (result) => {
            if (!result)
              return;
            if (result.files.length === 0 || !result.files[0] || typeof result.files[0] !== "string")
              return;
            let selectedFile = result.files[0].trim().replace(/\/$/, "");
            if (!selectedFile)
              return;
            destinationFileEl.setValue(selectedFile);
            that.setOptionConfig(rule.id, "templateFile", selectedFile);
          }
        );
      })
    );
  }
};

// src/rules/buildInAutoCompleteModal.ts
var import_obsidian20 = require("obsidian");

// src/autocompleteModal.ts
var import_obsidian19 = require("obsidian");
var AutocompleteModal = class extends import_obsidian19.Modal {
  /**
   * Creates an instance of the DirectorySelectionModal.
   * @param app - The Obsidian App instance.
   * @param plugin - The plugin instance.
   * @param expectedType - Expected return type.
   * @param activeFile - The currently active file or folder.
   * @param frontmatter - Frontmatter data for the active file.
   * @param okCallback - Function to call when the user clicks "OK". Receives the selection result.
   */
  constructor(app, plugin, rule, options, activeFile, frontmatter, okCallback) {
    super(app);
    this.knownProperties = {};
    this.result = {};
    this.changeCallback = (propertyInfo, value) => {
      if (propertyInfo) {
        this.result[propertyInfo.name] = value;
      }
    };
    this.app = app;
    this.tools = new ScriptingTools(app, this.plugin, this.frontmatter);
    this.activeFile = activeFile;
    this.frontmatter = frontmatter;
    this.plugin = plugin;
    this.rule = rule;
    this.options = options;
    this.expectedType = rule.type;
    this.promise = new Promise((resolve) => {
      this.resolvePromise = resolve;
    });
    if (okCallback)
      this.okCallback = okCallback;
    this.resetToInitial();
  }
  /**
   * Resets the current selection state to the initial state provided at construction.
   */
  resetToInitial() {
  }
  /**
   * Resets the current selection state to empty.
   */
  resetToEmpty() {
  }
  /**
   * Called when the modal is opened. Builds the UI.
   */
  async onOpen() {
    var _a;
    this.knownProperties = await this.tools.fetchKnownProperties(this.app);
    const { contentEl } = this;
    if (contentEl.parentElement)
      contentEl.parentElement.style.width = "900px";
    contentEl.empty();
    contentEl.addClass("codeEditor-modal");
    contentEl.createEl("h2", { text: "Please complete the following properties" });
    contentEl.createEl("body", { text: `File: ${(_a = this.activeFile) == null ? void 0 : _a.path}` });
    this.contentRootElement = contentEl.createDiv({ cls: "codeEditor-container" });
    this.contentRootElement.style.overflowY = "auto";
    this.contentRootElement.style.padding = "10px";
    this.contentRootElement.style.marginTop = "10px";
    this.contentRootElement.style.marginBottom = "10px";
    const propertyContainerEl = contentEl.createDiv({ cls: "codeEditor-options" });
    propertyContainerEl.style.flexDirection = "column";
    for (const [key, value] of Object.entries(this.frontmatter)) {
      if (key.startsWith(this.rule.property + this.options.propertyDelimiter)) {
        const rowEl = propertyContainerEl.createDiv({ cls: "property-setting-row setting-item" });
        rowEl.style.width = "100%";
        const controlEl = rowEl.createDiv({ cls: "setting-item-control" });
        controlEl.style.display = "flex";
        controlEl.style.alignItems = "center";
        controlEl.style.justifyContent = "space-between";
        controlEl.style.width = "100%";
        controlEl.style.gap = "0px";
        const leftContainer = controlEl.createDiv({ cls: "property-left-container" });
        leftContainer.style.display = "flex";
        leftContainer.style.alignItems = "center";
        leftContainer.style.minWidth = "250px";
        const iconEl = leftContainer.createSpan({ cls: "property-icon setting-item-icon" });
        iconEl.style.marginRight = "8px";
        updatePropertyIcon(iconEl, this.knownProperties[key].type);
        const searchContainer = leftContainer.createDiv({ cls: "property-search-container" });
        const nameInput = new import_obsidian19.TextComponent(searchContainer).setValue(key).setPlaceholder("Property name").setDisabled(true);
        nameInput.inputEl.style.border = "none";
        const middleContainer = controlEl.createDiv({ cls: "property-middle-container" });
        const valueContainer = middleContainer.createDiv({ cls: "property-value-container" });
        valueContainer.style.width = "100%";
        let previewComponent = renderValueInput(valueContainer, this.knownProperties[key], this.frontmatter[key], this.changeCallback);
        previewComponent.inputEl.style.width = "100%";
        previewComponent.inputEl.style.backgroundColor = "transparent";
        const deleteButtonContainer = controlEl.createDiv({ cls: "property-right-container" });
        deleteButtonContainer.style.marginLeft = "auto";
      }
    }
    this.createActionButtons(contentEl);
  }
  /**
   * Creates the "OK" and "Reset" buttons.
   * @param containerEl - The HTML element to append the buttons to.
   */
  createActionButtons(containerEl) {
    const buttonsEl = containerEl.createDiv({ cls: "modal-buttons" });
    buttonsEl.style.marginTop = "15px";
    buttonsEl.style.display = "flex";
    buttonsEl.style.justifyContent = "flex-end";
    buttonsEl.style.gap = "10px";
    const resetButton = buttonsEl.createEl("button");
    (0, import_obsidian19.setIcon)(resetButton, "reset");
    resetButton.ariaLabel = "Reset selection";
    resetButton.onclick = () => {
      this.resetToInitial();
    };
    const emptyButton = buttonsEl.createEl("button");
    (0, import_obsidian19.setIcon)(emptyButton, "eraser");
    emptyButton.ariaLabel = "Clear selection";
    emptyButton.onclick = () => {
      this.resetToEmpty();
    };
    const cancelButton = buttonsEl.createEl("button", { text: "Cancel" });
    cancelButton.ariaLabel = "close and discard changes";
    cancelButton.onclick = () => {
      logger.log(DEBUG, "Cancel Clicked - Returning");
      this.resolvePromise(null);
      this.close();
    };
    const okButton = buttonsEl.createEl("button", { text: "OK", cls: "mod-cta" });
    cancelButton.ariaLabel = "close and save changes";
    okButton.onclick = () => {
      this.resolvePromise({ values: this.result });
      this.close();
    };
  }
  /**
   * Called when the modal is closed. Cleans up resources.
   */
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  openAndGetValues() {
    this.open();
    return this.promise;
  }
};
async function openAutocompleteModal(app, plugin, rule, options, activeFile, frontmatter) {
  if (!app) {
    logger.log(ERROR, "App is undefined");
    return null;
  }
  const modal = new AutocompleteModal(app, plugin, rule, options, activeFile, frontmatter);
  return await modal.openAndGetValues();
}

// src/rules/buildInAutoCompleteModal.ts
var RuleBuildInAutoCompleteModal = class extends RulePrototype {
  constructor() {
    super();
    this.id = "autoCompleteModal";
    this.ruleType = "autocomplete.modal";
    this.name = "Auto-Complete Modal";
    this.description = "Displays an auto-complete modal for the frontmatter parameter.";
    this.source = "function (app, file, tools) { // do not change this line!\n  const input = tools.getCurrentContent(); // Get the current content of property\n  return input; // Return the input unaltered\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    logger.log(DEBUG, `autocomplete modal, work in progress...`);
    const currentContent = tools.getCurrentContent();
    const rule = tools.getRule();
    if (!rule)
      return currentContent;
    const options = tools.getOptionConfig(rule.id);
    if (!rule)
      return tools.getCurrentContent() || "autocomplete.modal";
    const frontmatter = tools.getFrontmatter();
    const hasAutocompleteProperties = Object.keys(frontmatter).some(
      (key) => key.startsWith(rule.property + options.propertyDelimiter) && (frontmatter[key] === void 0 || frontmatter[key] === null || frontmatter[key] === "")
    );
    if (!hasAutocompleteProperties)
      return tools.getCurrentContent() || "autocomplete.modal";
    openAutocompleteModal(
      tools.app,
      tools.plugin,
      rule,
      options,
      tools.getActiveFile(),
      tools.getFrontmatter()
    ).then((result) => {
      logger.log(DEBUG, "autocomplete modal result", result, tools.getFrontmatter());
      if (result == null ? void 0 : result.values) {
        if (!tools.app) {
          logger.log(ERROR, "App is not defined");
          return tools.getCurrentContent() || "autocomplete.modal Error. See console for details.";
        }
        tools.app.fileManager.processFrontMatter(file, (frontmatter2) => {
          for (const [key, value] of Object.entries(result.values)) {
            frontmatter2[key] = value;
          }
        }, { "mtime": file.stat.mtime });
      }
      return tools.getCurrentContent();
    }).catch((error) => {
      logger.log(ERROR, "Error opening autocomplete modal:", error);
      return tools.getCurrentContent() || "autocomplete.modal Error. See console for details.";
    });
  }
  configTab(optionEL, rule, that, previewComponent) {
    optionEL.empty();
    that.setOptionConfigDefaults(rule.id, {
      propertyDelimiter: "."
    });
    new import_obsidian20.Setting(optionEL).setName("Delimiter").setDesc("Character to determine which property should appear in the modal").addText((text) => text.setValue(that.getOptionConfig(rule.id, "propertyDelimiter") || ".").onChange(async (value) => {
      that.setOptionConfig(rule.id, "propertyDelimiter", value);
    }));
  }
};

// src/rules/buildInConcatArrays.ts
var import_obsidian21 = require("obsidian");
var RuleBuildInConcatArrays = class extends RulePrototype {
  constructor() {
    super();
    this.id = "concatArrays";
    this.ruleType = "buildIn";
    this.name = "Concat Arrays";
    this.description = "Concatenates multiple Lists (Multitext, Tags, Aliases).";
    this.source = "function (app, file, tools) { // do not change this line!\n  const propertyIds = tools.getOptionConfig(tools.getRule()?.id,'inputProperties');\n  if (!Array.isArray(propertyIds) || propertyIds.length === 0) {\n    return 'No properties selected';\n  }\n  const delimiter = tools.getOptionConfig(tools.getRule()?.id,'delimiter');\n  const onlyWhenAllPropertiesExist = tools.getOptionConfig(tools.getRule()?.id, 'onlyWhenAllPropertiesExist') || false;\n  if (onlyWhenAllPropertiesExist) {\n    // Check if all properties exist\n    const allExist = propertyIds.every(id => { \n      if (id === undefined || id === null || id === '') {\n        return true; // Skip empty or undefined property IDs\n      }\n      const propertyValue = tools.getFrontmatterProperty(id);\n      const result = propertyValue !== undefined && propertyValue !== null && propertyValue !== '';\n      return result;\n    });\n    if (!allExist) {\n      return '';\n    }\n  }\n  const result = propertyIds.map(id => {\n    let value = tools.getFrontmatterProperty(id);\n    if (value === undefined || value === null || value === '') {\n      return ''; // Skip empty or undefined properties\n    }\n    return value.toString();\n  }).filter(res => res !== undefined).join(delimiter);\n  return result;\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    var _a, _b;
    const propertyIds = tools.getOptionConfig((_a = tools.getRule()) == null ? void 0 : _a.id, "inputProperties");
    if (!Array.isArray(propertyIds) || propertyIds.length === 0) {
      return "No properties selected";
    }
    const onlyWhenAllPropertiesExist = tools.getOptionConfig((_b = tools.getRule()) == null ? void 0 : _b.id, "onlyWhenAllPropertiesExist") || false;
    if (onlyWhenAllPropertiesExist) {
      const allExist = propertyIds.every((id) => {
        if (id === void 0 || id === null || id === "") {
          return true;
        }
        const propertyValue = tools.getFrontmatterProperty(id);
        const result = propertyValue !== void 0 && propertyValue !== null && propertyValue !== "";
        return result;
      });
      if (!allExist) {
        return [];
      }
    }
    let resultArray = [];
    propertyIds.forEach((id) => {
      let value = tools.getFrontmatterProperty(id);
      if (value === void 0 || value === null || value === "") {
        return;
      }
      resultArray = resultArray.concat(Array.isArray(value) ? value : [value.toString()]);
    });
    return resultArray;
  }
  configTab(optionEL, rule, that, previewComponent) {
    that.setOptionConfigDefaults(rule.id, {
      inputProperties: [],
      onlyWhenAllPropertiesExist: false
      // Default to false
    });
    const multiProp = new MultiPropertySetting(optionEL).setName("Input Properties").setDesc("Select properties as input. (text, tags, aliases or multitext)").setOptions(Object.keys(that.knownProperties).map((key) => {
      const prop = that.knownProperties[key];
      if (prop.type === "text" || prop.type === "tags" || prop.type === "aliases" || prop.type === "multitext") {
        return key;
      }
      return null;
    }).filter((item) => item !== null)).setValue(that.getOptionConfig(rule.id, "inputProperties") || []).onChange((arr) => {
      that.setOptionConfig(rule.id, "inputProperties", arr);
      that.updatePreview(rule, previewComponent);
    });
    new import_obsidian21.Setting(optionEL).setName("Only when all properties exist").setDesc("If enabled, the rule will only return a value if all selected properties exist and not empty.").addToggle(
      (toggle) => toggle.setValue(that.getOptionConfig(rule.id, "onlyWhenAllPropertiesExist")).onChange(async (value) => {
        that.setOptionConfig(rule.id, "onlyWhenAllPropertiesExist", value);
        that.updatePreview(rule, previewComponent);
      })
    );
  }
};

// src/rules/buildInConcatProperties.ts
var import_obsidian22 = require("obsidian");
var RuleBuildInConcatProperties = class extends RulePrototype {
  constructor() {
    super();
    this.id = "concatProperties";
    this.ruleType = "buildIn";
    this.name = "Concat Properties";
    this.description = "Concatenates multiple properties from the frontmatter.";
    this.source = "function (app, file, tools) { // do not change this line!\n  const propertyIds = tools.getOptionConfig(tools.getRule()?.id,'inputProperties');\n  if (!Array.isArray(propertyIds) || propertyIds.length === 0) {\n    return 'No properties selected';\n  }\n  const delimiter = tools.getOptionConfig(tools.getRule()?.id,'delimiter');\n  const onlyWhenAllPropertiesExist = tools.getOptionConfig(tools.getRule()?.id, 'onlyWhenAllPropertiesExist') || false;\n  if (onlyWhenAllPropertiesExist) {\n    // Check if all properties exist\n    const allExist = propertyIds.every(id => { \n      if (id === undefined || id === null || id === '') {\n        return true; // Skip empty or undefined property IDs\n      }\n      const propertyValue = tools.getFrontmatterProperty(id);\n      const result = propertyValue !== undefined && propertyValue !== null && propertyValue !== '';\n      return result;\n    });\n    if (!allExist) {\n      return '';\n    }\n  }\n  const result = propertyIds.map(id => {\n    let value = tools.getFrontmatterProperty(id);\n    if (value === undefined || value === null || value === '') {\n      return ''; // Skip empty or undefined properties\n    }\n    return value.toString();\n  }).filter(res => res !== undefined).join(delimiter);\n  return result;\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    var _a, _b, _c;
    const propertyIds = tools.getOptionConfig((_a = tools.getRule()) == null ? void 0 : _a.id, "inputProperties");
    if (!Array.isArray(propertyIds) || propertyIds.length === 0) {
      return "No properties selected";
    }
    const delimiter = tools.getOptionConfig((_b = tools.getRule()) == null ? void 0 : _b.id, "delimiter");
    const onlyWhenAllPropertiesExist = tools.getOptionConfig((_c = tools.getRule()) == null ? void 0 : _c.id, "onlyWhenAllPropertiesExist") || false;
    if (onlyWhenAllPropertiesExist) {
      const allExist = propertyIds.every((id) => {
        if (id === void 0 || id === null || id === "") {
          return true;
        }
        const propertyValue = tools.getFrontmatterProperty(id);
        const result2 = propertyValue !== void 0 && propertyValue !== null && propertyValue !== "";
        return result2;
      });
      if (!allExist) {
        return "";
      }
    }
    const result = propertyIds.map((id) => {
      let value = tools.getFrontmatterProperty(id);
      if (value === void 0 || value === null || value === "") {
        return "";
      }
      return value.toString();
    }).filter((res) => res !== void 0).join(delimiter);
    return result;
  }
  configTab(optionEL, rule, that, previewComponent) {
    that.setOptionConfigDefaults(rule.id, {
      delimiter: " ",
      // Default delimiter for concatenation
      inputProperties: [],
      onlyWhenAllPropertiesExist: true
      // Default to false
    });
    const multiProp = new MultiPropertySetting(optionEL).setName("Input Properties").setDesc("Select properties as input. Use 'Space replacement' as delimiter.").setOptions(Object.keys(that.knownProperties).map((key) => key)).setValue(that.getOptionConfig(rule.id, "inputProperties") || []).onChange((arr) => {
      that.setOptionConfig(rule.id, "inputProperties", arr);
      that.updatePreview(rule, previewComponent);
    });
    new import_obsidian22.Setting(optionEL).setName("Delimiter").setDesc("Specify a delimiter to use when concatenating properties. Default is a space.").addText(
      (text) => text.setValue(that.getOptionConfig(rule.id, "delimiter") || "").setPlaceholder("Enter delimiter").onChange(async (value) => {
        that.setOptionConfig(rule.id, "delimiter", value);
        that.updatePreview(rule, previewComponent);
      })
    );
    new import_obsidian22.Setting(optionEL).setName("Only when all properties exist").setDesc("If enabled, the rule will only return a value if all selected properties exist and not empty.").addToggle(
      (toggle) => toggle.setValue(that.getOptionConfig(rule.id, "onlyWhenAllPropertiesExist")).onChange(async (value) => {
        that.setOptionConfig(rule.id, "onlyWhenAllPropertiesExist", value);
        that.updatePreview(rule, previewComponent);
      })
    );
  }
};

// src/rules/buildInConstant.ts
var import_obsidian23 = require("obsidian");
var RuleBuildInConstant = class extends RulePrototype {
  constructor() {
    super();
    this.id = "constant";
    this.ruleType = "buildIn";
    this.name = "Constant value";
    this.description = "Returns a constant value instead of the frontmatter parameter.";
    this.source = "function (app, file, tools) { // do not change this line!\n  const result = tools.getOptionConfig(tools.getRule()?.id,'constantValue');\n  return result; // Return the constant value\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    var _a;
    const result = tools.getOptionConfig((_a = tools.getRule()) == null ? void 0 : _a.id, "constantValue");
    return result;
  }
  configTab(optionEL, rule, that, previewComponent) {
    optionEL.empty();
    that.setOptionConfigDefaults(rule.id, {
      constantValue: ""
    });
    new import_obsidian23.Setting(optionEL).setName("Constant value").setDesc("Enter a constant value to be used in the rule").addText(
      (text) => text.setValue(that.getOptionConfig(rule.id, "constantValue") || "").onChange(async (value) => {
        that.setOptionConfig(rule.id, "constantValue", value);
        that.updatePreview(rule, previewComponent);
      })
    );
  }
};

// src/rules/buildInDateTimeCreated.ts
var RuleBuildInDateTimeCreated = class extends RulePrototype {
  constructor() {
    super();
    this.id = "dateTimeCreated";
    this.ruleType = "buildIn";
    this.name = "Date (and Time) created";
    this.description = "This rule returns the date and time when the file was created, adjusted for local timezone.";
    this.source = "function(app: App | undefined, file: TFile, tools: ScriptingTools) { // do not change this line! \n const timeOffset = new Date(Date.now()).getTimezoneOffset()*60000; // get local time offset \n const result = new Date(file.stat.ctime-timeOffset); \n return result.toISOString().split('Z')[0]; // remove UTC symbol \n }";
    this.type = ["date", "datetime"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    const timeOffset = new Date(Date.now()).getTimezoneOffset() * 6e4;
    const result = new Date(file.stat.ctime - timeOffset);
    return result.toISOString().split("Z")[0];
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInDateTimeModified.ts
var RuleBuildInDateTimeModified = class extends RulePrototype {
  constructor() {
    super();
    this.id = "dateTimeModified";
    this.ruleType = "buildIn";
    this.name = "Date (and Time) modified";
    this.description = "This rule returns the date and time when the file was last modified, adjusted for local timezone.";
    this.source = "function(app: App | undefined, file: TFile, tools: ScriptingTools) { // do not change this line! \n const timeOffset = new Date(Date.now()).getTimezoneOffset()*60000; // get local time offset \n const result = new Date(file.stat.mtime-timeOffset); \n return result.toISOString().split('Z')[0]; // remove UTC symbol \n }";
    this.type = ["date", "datetime"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    const timeOffset = new Date(Date.now()).getTimezoneOffset() * 6e4;
    const result = new Date(file.stat.mtime - timeOffset);
    return result.toISOString().split("Z")[0];
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInDefault.ts
var RuleBuildInDefault = class extends RulePrototype {
  constructor() {
    super();
    this.id = "default";
    this.ruleType = "buildIn";
    this.name = "Pass parameter unaltered";
    this.description = "Pass the content of the frontmatter parameter unaltered.";
    this.source = "function (app, file, tools) { // do not change this line!\n  const input = tools.getCurrentContent(); // Get the current content of property\n  return input; // Return the input unaltered\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    const input = tools.getCurrentContent();
    return input;
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInFileSizeBytes.ts
var RuleBuildInFileSizeBytes = class extends RulePrototype {
  constructor() {
    super();
    this.id = "fileSizeBytes";
    this.ruleType = "buildIn";
    this.name = "File Size in Bytes";
    this.description = "This rule returns the size of the file in bytes.";
    this.source = "function(app: App | undefined, file: TFile, tools: ScriptingTools) { // do not change this line! \n const result = file.stat.size; \n return result; // return you result. \n }";
    this.type = ["number"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    const result = file.stat.size;
    return result;
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInFileSizeString.ts
var RuleBuildInFileSizeString = class extends RulePrototype {
  constructor() {
    super();
    this.id = "fileSizeString";
    this.ruleType = "buildIn";
    this.name = "File Size as String";
    this.description = "Converts the file size to a human-readable string (e.g., KB, MB, GB) with 2 decimal places precision.";
    this.source = "function(app: App | undefined, file: TFile, tools: ScriptingTools) { // do not change this line! \n let size =file.stat.size; \n const precision = 2; // number of decimal places \n if (size > 1024) { \n   size = size / 1024; \n   if (size > 1024) { \n     size = size / 1024; \n     if (size > 1024) { \n       size = size / 1024; \n       return size.toFixed(precision) + ' GB'; \n     } \n     return size.toFixed(precision) + ' MB'; \n   } \n   return size.toFixed(precision) + ' KB'; \n }   \n return size + ' Bytes'; // return you result. \n }";
    this.type = ["text"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    let size = file.stat.size;
    const precision = 2;
    if (size > 1024) {
      size = size / 1024;
      if (size > 1024) {
        size = size / 1024;
        if (size > 1024) {
          size = size / 1024;
          return size.toFixed(precision) + " GB";
        }
        return size.toFixed(precision) + " MB";
      }
      return size.toFixed(precision) + " KB";
    }
    return size + " Bytes";
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInFolder.ts
var RuleBuildInFolder = class extends RulePrototype {
  constructor() {
    super();
    this.id = "folder";
    this.ruleType = "buildIn";
    this.name = "Parent folder";
    this.description = "Returns the parent folder of the file.";
    this.source = "function (app, file, tools) { // do not change this line!\n  const input = tools.getCurrentContent(); // Get the current content of property\n  return input; // Return the input unaltered\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    const path = file.path;
    const parts = path.split("/");
    let result = "";
    if (parts.length > 1) {
      result = parts[parts.length - 2];
    }
    return result;
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInFolderFolderNotes.ts
var RuleBuildInFolderFolderNotes = class extends RulePrototype {
  constructor() {
    super();
    this.id = "folderFolderNotes";
    this.ruleType = "buildIn";
    this.name = 'Parent Folder (complies with "folder notes")';
    this.description = "Returns the parent folder of the file compatible with Folder Notes.";
    this.source = "function (app, file, tools) { // do not change this line!\n  // acquire file path\n  const path = file.path;const parts = file.path.split('/');\n  let index = parts.length-2; // index of parent folder\n  if (parts[parts.length-2]===file.basename) {\n      index--; // folder note parent is the child\n  }\n  if (index >= 0) {\n    return parts[index]; // file in folder\n  } else {\n    return tools.app?.vault?.getName() || 'Vault'; // file in root = vault\n  }\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    var _a, _b;
    const path = file.path;
    const parts = file.path.split("/");
    let index = parts.length - 2;
    if (parts[parts.length - 2] === file.basename) {
      index--;
    }
    if (index >= 0) {
      return parts[index];
    } else {
      return ((_b = (_a = tools.app) == null ? void 0 : _a.vault) == null ? void 0 : _b.getName()) || "Vault";
    }
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInFolders.ts
var RuleBuildInFolders = class extends RulePrototype {
  constructor() {
    super();
    this.id = "folders";
    this.ruleType = "buildIn";
    this.name = "All folders of the file as a list";
    this.description = "Returns all folders the file is stored in as a list.";
    this.source = "function (app, file, tools) { // do not change this line!\n  // acquire file path\n  const path = file.path;\n  const result = path.split('/');\n  result.pop(); // remove the file name\n  return result;\n}";
    this.type = ["tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    const path = file.path;
    const result = path.split("/");
    result.pop();
    return result;
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInFullPath.ts
var RuleBuildInFullPath = class extends RulePrototype {
  constructor() {
    super();
    this.id = "fullPath";
    this.ruleType = "buildIn";
    this.name = "Full path, filename";
    this.description = "Returns the full path of the file, including the filename.";
    this.source = "function (app, file, tools) { // do not change this line!\n  let parts = file.path.split('/');\n  parts.pop();\n  parts.push(file.basename);\n  return parts.join('/');\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    let parts = file.path.split("/");
    parts.pop();
    parts.push(file.basename);
    return parts.join("/");
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInFullPathExt.ts
var RuleBuildInFullPathExt = class extends RulePrototype {
  constructor() {
    super();
    this.id = "fullPathExt";
    this.ruleType = "buildIn";
    this.name = "Full path, filename and extension";
    this.description = "Returns the full path of the file, including its filename and extension.";
    this.source = "function (app, file, tools) { // do not change this line!\n  return `${file.path}`;\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    return `${file.path}`;
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInFullPathExtFolderNotes.ts
var RuleBuildInFullPathExtFolderNotes = class extends RulePrototype {
  constructor() {
    super();
    this.id = "fullPathExtFolderNotes";
    this.ruleType = "buildIn";
    this.name = 'Full Path with Extension (comply with "folder notes")';
    this.description = "Path with Extensions compatible with folder notes.";
    this.source = "function (app, file, tools) { // do not change this line!\n  let parts = file.path.split('/');\n  parts.pop();\n  if (parts[parts.length-1] === file.basename) parts.pop();\n  parts.push(file.basename);\n  return parts.join('/');\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    let parts = file.path.split("/");
    parts.pop();
    if (parts[parts.length - 1] === file.basename)
      parts.pop();
    parts.push(file.name);
    return parts.join("/");
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInFullPathFolderNotes.ts
var RuleBuildInFullPathFolderNotes = class extends RulePrototype {
  constructor() {
    super();
    this.id = "fullPathFolderNotes";
    this.ruleType = "buildIn";
    this.name = 'Full Path (comply with "folder notes")';
    this.description = "Path compatible compatible with folder notes.";
    this.source = "function (app, file, tools) { // do not change this line!\n  let parts = file.path.split('/');\n  parts.pop();\n  if (parts[parts.length-1] === file.basename) parts.pop();\n  parts.push(file.basename);\n  return parts.join('/');\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    let parts = file.path.split("/");
    parts.pop();
    if (parts[parts.length - 1] === file.basename)
      parts.pop();
    parts.push(file.basename);
    return parts.join("/");
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInGetProperty.ts
var import_obsidian24 = require("obsidian");
var RuleBuildInGetProperty = class extends RulePrototype {
  constructor() {
    super();
    this.id = "getProperty";
    this.ruleType = "buildIn";
    this.name = "Get property";
    this.description = "Gets a property from selected property.";
    this.source = "function(app: App | undefined, file: TFile, tools: ScriptingTools) { // do not change this line! \n const propertyId = tools.getOptionConfig(tools.getRule()?.id,'inputProperty'); \n if (propertyId === undefined || propertyId === '') { \n return 'Property not set'; \n } \n const result = tools.getFrontmatterProperty(propertyId); \n if (result === undefined) { \n return 'Property not found'; \n } \n return result; \n }";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    var _a;
    const propertyId = tools.getOptionConfig((_a = tools.getRule()) == null ? void 0 : _a.id, "inputProperty");
    if (propertyId === void 0 || propertyId === "") {
      return "Property not set";
    }
    const result = tools.getFrontmatterProperty(propertyId);
    if (result === void 0) {
      return "Property not found";
    }
    return result;
  }
  configTab(optionEL, rule, that, previewComponent) {
    that.setOptionConfigDefaults(rule.id, {
      inputProperty: ""
    });
    let inputPropertiesDropdown;
    new import_obsidian24.Setting(optionEL).setName("Input Property").setDesc("Select a property as input").addDropdown((dropdown) => {
      inputPropertiesDropdown = dropdown;
      dropdown.setValue(that.getOptionConfig(rule.id, "inputProperty") || "").onChange(async (value) => {
        if (value !== "") {
          that.setOptionConfig(rule.id, "inputProperty", value);
          that.updatePreview(rule, previewComponent);
        }
      });
    });
    Object.keys(that.knownProperties).forEach((key) => {
      const item = that.knownProperties[key];
      inputPropertiesDropdown.addOption(item.name, item.name);
    });
  }
};

// src/rules/buildInIsRoot.ts
var RuleBuildInIsRoot = class extends RulePrototype {
  constructor() {
    super();
    this.id = "isRoot";
    this.ruleType = "buildIn";
    this.name = "File in Root folder";
    this.description = "Check if the file is in the root folder.";
    this.source = "function (app, file, tools) { // do not change this line!\n  let parts = file.path.split('/');\n  return parts.length === 1;\n};";
    this.type = ["checkbox"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    let parts = file.path.split("/");
    return parts.length === 1;
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInLinkToFile.ts
var import_obsidian25 = require("obsidian");
var RuleBuildInLinkToFile = class extends RulePrototype {
  constructor() {
    super();
    this.id = "linkToFile";
    this.ruleType = "buildIn";
    this.name = "Create link to file";
    this.description = "Create a link to the file in the current vault. Can be configured to include the file extension.";
    this.source = "function (app, file, tools) { // do not change this line!\n  const parts = file.path.split('/');\n  const rule = tools.getRule();\n  if (!rule) return tools.getCurrentContent();\n  const addExtension = tools.getOptionConfig(rule.id,'addExtension') \n  parts.pop();\n  if (parts[parts.length-1] === file.basename) parts.pop();\n  let fileName = addExtension? file.basename + '.' + file.extension : file.basename; \n  return `[[${parts.join('/')}/${fileName}|${file.basename}]]`;\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    const parts = file.path.split("/");
    const rule = tools.getRule();
    if (!rule)
      return tools.getCurrentContent();
    const addExtension = tools.getOptionConfig(rule.id, "addExtension");
    parts.pop();
    if (parts[parts.length - 1] === file.basename)
      parts.pop();
    let fileName = addExtension ? file.basename + "." + file.extension : file.basename;
    return `[[${parts.join("/")}/${fileName}|${file.basename}]]`;
  }
  configTab(optionEL, rule, that, previewComponent) {
    that.setOptionConfigDefaults(rule.id, {
      addExtension: true
    });
    new import_obsidian25.Setting(optionEL).setName("Include file extension").setDesc("Add file extension to pathname").addToggle(
      (toggle) => toggle.setValue(that.getOptionConfig(rule.id, "addExtension") || false).onChange(async (value) => {
        that.setOptionConfig(rule.id, "addExtension", value);
        that.updatePreview(rule, previewComponent);
      })
    );
  }
};

// src/rules/buildInName.ts
var RuleBuildInName = class extends RulePrototype {
  constructor() {
    super();
    this.id = "name";
    this.ruleType = "buildIn";
    this.name = "File name without extension";
    this.description = "Returns the file name without all extensions. I.e. example.note.md => example";
    this.source = "function (app, file, tools) { // do not change this line!\n  // acquire file name\n  const result = tools.removeAllExtensions(file.name);\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    const result = tools.removeAllExtensions(file.name);
    return result;
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInNameExt.ts
var RuleBuildInNameExt = class extends RulePrototype {
  constructor() {
    super();
    this.id = "nameExt";
    this.ruleType = "buildIn";
    this.name = "File name with extension";
    this.description = "Returns the file name with extension.";
    this.source = "function (app, file, tools) { // do not change this line!\n  // acquire file name with extension\n  const result = file.name;\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    const result = file.name;
    return result;
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInPath.ts
var RuleBuildInPath = class extends RulePrototype {
  constructor() {
    super();
    this.id = "path";
    this.ruleType = "buildIn";
    this.name = "Full path";
    this.description = "Returns the folder path the file is stored in.";
    this.source = "function (app, file, tools) { // do not change this line!\n  let parts = file.path.split('/');\n  parts.pop();\n  return parts.join('/');\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    let parts = file.path.split("/");
    parts.pop();
    return parts.join("/");
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInPathFolderNotes.ts
var RuleBuildInPathFolderNotes = class extends RulePrototype {
  constructor() {
    super();
    this.id = "pathFolderNotes";
    this.ruleType = "buildIn";
    this.name = "Path (folder notes)";
    this.description = "Path compatible with folder notes.";
    this.source = "function (app, file, tools) { // do not change this line!\n  let parts = file.path.split('/');\n  parts.pop();\n  if (parts[parts.length-1] === file.basename) parts.pop(); // remove parent folder if same name as the file\n  return parts.join('/');\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    let parts = file.path.split("/");
    parts.pop();
    if (parts[parts.length - 1] === file.basename)
      parts.pop();
    return parts.join("/");
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInRootFolder.ts
var RuleBuildInRootFolder = class extends RulePrototype {
  constructor() {
    super();
    this.id = "rootFolder";
    this.ruleType = "buildIn";
    this.name = "Root folder";
    this.description = "Returns the root folder where the file is stored.";
    this.source = "function (app, file, tools) { // do not change this line!\n  // acquire file path\n  const path = file.path;\n  const parts = path.split('/');\n  return parts.length > 1 ? parts[0] : ''; // return root folder or empty string if in root\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    const path = file.path;
    const parts = path.split("/");
    let result = "";
    if (parts.length > 1) {
      result = parts[0];
    }
    return result;
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInScript.ts
var RuleBuildInScript = class extends RulePrototype {
  constructor() {
    super();
    this.id = "script";
    this.ruleType = "buildIn";
    this.name = "JavaScript function (advanced)";
    this.description = "Implement a JavaScript function to process the input content. The function should return the processed content.";
    this.source = "function (app, file, tools) { // do not change this line!\n  const input = tools.getCurrentContent(); // Get the current content of property\n  return input; // Return the input unaltered\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    const input = tools.getCurrentContent();
    return input;
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/replaceChars.ts
var import_obsidian26 = require("obsidian");
var RuleReplaceChars = class extends RulePrototype {
  constructor() {
    super();
    this.id = "replaceChars";
    this.name = "Replace Characters";
    this.description = "Replaces configurable characters in the input value with a specified text string. Supports text and regex replacements.";
    this.ruleType = "formatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    var _a, _b;
    const replace = tools.getOptionConfig((_a = tools.getRule()) == null ? void 0 : _a.id, "replace");
    if (!replace || replace === "") {
      return input;
    }
    const replaceBy = tools.getOptionConfig((_b = tools.getRule()) == null ? void 0 : _b.id, "replaceBy");
    try {
      const regex = new RegExp(replace, "g");
      return input.replace(regex, replaceBy);
    } catch (e) {
      logger.log(ERROR, `Error in RuleReplaceChars: Invalid regex pattern "${replace}"`, e);
      return input;
    }
  }
  configTab(optionEL, rule, that, previewComponent) {
    optionEL.empty();
    that.setOptionConfigDefaults(rule.id, {
      replace: "",
      // search for this string
      replaceBy: ""
      // replace with this string
    });
    new import_obsidian26.Setting(optionEL).setName("search for").setDesc("Character to search for in the input value (Regex supported)").addText(
      (text) => text.setPlaceholder("search for").setValue(that.getOptionConfig(rule.id, "replace") || "").onChange(async (value) => {
        that.setOptionConfig(rule.id, "replace", value);
        that.updatePreview(rule, previewComponent);
      })
    );
    new import_obsidian26.Setting(optionEL).setName("replace by").setDesc("Character to replace matches").addText(
      (text) => text.setPlaceholder("replace by").setValue(that.getOptionConfig(rule.id, "replaceBy") || "").onChange(async (value) => {
        that.setOptionConfig(rule.id, "replaceBy", value);
        that.updatePreview(rule, previewComponent);
      })
    );
  }
};

// src/rules/replaceSpaces.ts
var import_obsidian27 = require("obsidian");
var RuleReplaceSpaces = class extends RulePrototype {
  constructor() {
    super();
    this.id = "replaceSpaces";
    this.name = "Replace Spaces";
    this.description = "Replaces spaces in the input value with a specified character.";
    this.ruleType = "formatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    var _a;
    const spaceReplacement = tools.getOptionConfig((_a = tools.getRule()) == null ? void 0 : _a.id, "spaceReplacement");
    return input.replace(/\s+/g, spaceReplacement);
  }
  configTab(optionEL, rule, that, previewComponent) {
    optionEL.empty();
    that.setOptionConfigDefaults(rule.id, {
      spaceReplacement: ""
      // Default suffix
    });
    new import_obsidian27.Setting(optionEL).setName("Space replacement").setDesc('Character to replace spaces (suggested: "_")').addText(
      (text) => text.setPlaceholder("will remove spaces").setValue(that.getOptionConfig(rule.id, "spaceReplacement") || "").onChange(async (value) => {
        that.setOptionConfig(rule.id, "spaceReplacement", value);
        that.updatePreview(rule, previewComponent);
      })
    );
  }
};

// src/rules/replaceSpecialChars.ts
var import_obsidian28 = require("obsidian");
var RuleReplaceSpecialChars = class extends RulePrototype {
  constructor() {
    super();
    this.id = "replaceSpecialChars";
    this.name = "Replace Special Characters";
    this.description = 'Character to replace special characters (suggested: "-") - preserves letters with diacritics';
    this.ruleType = "formatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    var _a;
    const specialCharReplacement = tools.getOptionConfig((_a = tools.getRule()) == null ? void 0 : _a.id, "specialCharReplacement");
    return input.replace(/[^a-zA-Z0-9\-_\/äöüßÄÖÜáéíóúýÁÉÍÓÚÝàèìòùÀÈÌÒÙâêîôûÂÊÎÔÛãñõÃÑÕ]/g, specialCharReplacement);
  }
  configTab(optionEL, rule, that, previewComponent) {
    optionEL.empty();
    that.setOptionConfigDefaults(rule.id, {
      specialCharReplacement: ""
      // Default suffix
    });
    new import_obsidian28.Setting(optionEL).setName("Replace Special Characters").setDesc('Character to replace special characters (suggested: "-") - preserves letters with diacritics').addText(
      (text) => text.setPlaceholder("will remove special characters").setValue(that.getOptionConfig(rule.id, "specialCharReplacement") || "").onChange(async (value) => {
        that.setOptionConfig(rule.id, "specialCharReplacement", value);
        that.updatePreview(rule, previewComponent);
      })
    );
  }
};

// src/rules/toCamelCase.ts
var RuleToCamelCase = class extends RulePrototype {
  constructor() {
    super();
    this.id = "toCamelCase";
    this.name = "To Camel Case";
    this.description = "Convert the value to Camel Case.";
    this.ruleType = "formatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    const toCamelCase = (str) => {
      let textParts = str.split(" ");
      let convertedTextParts = [];
      textParts.forEach((text, index) => {
        let newTextPart = text.toLowerCase();
        if (index > 0)
          newTextPart = newTextPart.charAt(0).toUpperCase() + newTextPart.slice(1);
        convertedTextParts.push(newTextPart);
      });
      return convertedTextParts.join("");
    };
    if (typeof input === "string") {
      return toCamelCase(input);
    } else if (Array.isArray(input)) {
      return input.map((item) => toCamelCase(String(item)));
    } else if (input instanceof Date) {
      return toCamelCase(input.toISOString());
    } else if (typeof input === "object") {
      return toCamelCase(JSON.stringify(input));
    }
    return input;
  }
};

// src/rules/toLinkMarkdown.ts
var RuleToLinkMarkdown = class extends RulePrototype {
  constructor() {
    super();
    this.id = "toMarkdownLink";
    this.name = "to markdown link";
    this.description = "Format as a markdown link.";
    this.ruleType = "linkFormatter";
    this.source = "function (input: any, tools: ScriptingTools) { // do not change this line!\n  input = tools.toMarkdownLink(input); // Convert to markdown link format\n  return input;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    input = tools.toMarkdownLink(input);
    return input;
  }
};

// src/rules/toLinkOriginal.ts
var RuleToLinkOriginal = class extends RulePrototype {
  constructor() {
    super();
    this.id = "toOriginalLink";
    this.name = "no change";
    this.description = "Pass the input unaltered.";
    this.ruleType = "linkFormatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    return input;
  }
};

// src/rules/toLinkSimple.ts
var RuleToLinkSimple = class extends RulePrototype {
  constructor() {
    super();
    this.id = "toSimpleLink";
    this.name = "to simple link";
    this.description = "Format as a simple link by adding [[]].";
    this.ruleType = "linkFormatter";
    this.source = "function (app, file, tools, input) { // do not change this line!\n  if (input === undefined || input === null || input === '') {\n    return ''; // Return empty string if input is undefined, null, or empty\n  }\n         input = `[[${input}]]`; // Convert to simple Link\n  return input;\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    if (input === void 0 || input === null || input === "") {
      return "";
    }
    input = `[[${input}]]`;
    return input;
  }
};

// src/rules/toLinkWiki.ts
var RuleToLinkWiki = class extends RulePrototype {
  constructor() {
    super();
    this.id = "toWikiLink";
    this.name = "to wiki link";
    this.description = "Format as a wiki link.";
    this.ruleType = "linkFormatter";
    this.source = "function (input: any, tools: ScriptingTools) { // do not change this line!\n  input = tools.toWikiLink(input); // Convert to wiki link format\n  return input;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    input = tools.toWikiLink(input);
    return input;
  }
};

// src/rules/toLowerCase.ts
var RuleToLowerCase = class extends RulePrototype {
  constructor() {
    super();
    this.id = "toLowerCase";
    this.name = "To Lower Case";
    this.description = "Convert the value to lower case.";
    this.ruleType = "formatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    if (String.isString(input)) {
      return input.toLowerCase();
    } else if (Array.isArray(input)) {
      return input.map((item) => String(item).toLowerCase());
    } else if (input instanceof Date) {
      return input.toISOString().toLowerCase();
    } else if (typeof input === "object") {
      return JSON.stringify(input).toLowerCase();
    }
    return input;
  }
};

// src/rules/toOriginal.ts
var RuleToOriginal = class extends RulePrototype {
  constructor() {
    super();
    this.id = "toOriginal";
    this.name = "no change";
    this.description = "Pass the input unaltered.";
    this.ruleType = "formatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    return input;
  }
};

// src/rules/toPascalCase.ts
var RuleToPascalCase = class extends RulePrototype {
  constructor() {
    super();
    this.id = "toPascalCase";
    this.name = "To Pascal Case";
    this.description = "Convert the value to Pascal Case (Upper Camel Case).";
    this.ruleType = "formatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    const toPascalCase = (str) => {
      return str.replace(
        /(?:^\w|[A-Z]|\b\w|\s+)/g,
        (match) => match.toUpperCase()
      ).replace(/\s+/g, "").replace(/[^a-zA-Z0-9]/g, "");
    };
    if (typeof input === "string") {
      return toPascalCase(input);
    } else if (Array.isArray(input)) {
      return input.map((item) => toPascalCase(String(item)));
    } else if (input instanceof Date) {
      return toPascalCase(input.toISOString());
    } else if (typeof input === "object") {
      return toPascalCase(JSON.stringify(input));
    }
    return input;
  }
};

// src/rules/toTitleCase.ts
var RuleToTitleCase = class extends RulePrototype {
  constructor() {
    super();
    this.id = "toTitleCase";
    this.name = "To Title Case (Simple)";
    this.description = "Convert the value to Title Case.";
    this.ruleType = "formatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    const toTitleCase = (str) => {
      let textParts = str.split(" ");
      let convertedTextParts = [];
      textParts.forEach((text, index) => {
        let newTextPart = text.toLowerCase();
        newTextPart = newTextPart.charAt(0).toUpperCase() + newTextPart.slice(1);
        convertedTextParts.push(newTextPart);
      });
      return convertedTextParts.join(" ");
    };
    if (typeof input === "string") {
      return toTitleCase(input);
    } else if (Array.isArray(input)) {
      return input.map((item) => toTitleCase(String(item)));
    } else if (input instanceof Date) {
      return toTitleCase(input.toISOString());
    } else if (typeof input === "object") {
      return toTitleCase(JSON.stringify(input));
    }
    return input;
  }
};

// src/rules/toTitleCaseDE.ts
var import_obsidian29 = require("obsidian");
var RuleToTitleCaseDE = class extends RulePrototype {
  // Set to true for verbose logging
  constructor() {
    super();
    this.verboseLogging = false;
    this.small = "(der|die|das|den|dem|des|einer|eines|deren|ein|eine|einem|einer|eines|einer|und|oder|aber|denn|sondern|sowie|weder|noch|entweder|oder|dass|weil|obwohl|wenn|als|nachdem|bevor|w\xE4hrend|bis|damit|um|zu|sobald|solange|da|indem|so|dass|ohne|zu|durch|f\xFCr|gegen|ohne|um|bis|aus|au\xDFer|bei|gegen\xFCber|mit|nach|seit|von|zu|anstatt|aufgrund|au\xDFerhalb|innerhalb|trotz|w\xE4hrend|wegen|an|auf|hinter|in|neben|\xFCber|unter|vor|zwischen)";
    this.punctuation = "\\([!\"#$%&'()*+,./:;<=>?@[\\\\\\]^_`{|}~\\-]*\\)";
    this.id = "toTitleCaseDe";
    this.name = "To Title Case (German small words)";
    this.description = "Convert German value to Title Case.";
    this.ruleType = "formatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    const toTitleCase = (str) => {
      var _a;
      const ruleId = (_a = tools.getRule()) == null ? void 0 : _a.id;
      const doNotCapitalizeSmallWords = tools.getOptionConfig(ruleId, "doNotCapitalizeSmallWords");
      return this.titleCaps(str, doNotCapitalizeSmallWords ? tools.getOptionConfig(ruleId, "smallWords") : void 0);
    };
    let result = input;
    if (typeof input === "string") {
      result = toTitleCase(input);
    } else if (Array.isArray(input)) {
      result = input.map((item) => toTitleCase(String(item)));
    } else if (input instanceof Date) {
      result = toTitleCase(input.toISOString());
    } else if (typeof input === "object") {
      result = toTitleCase(JSON.stringify(input));
    }
    logger.log(DEBUG, `RuleToTitleCaseDE.fx - input:'${input}' result:'${result}'`);
    return result;
  }
  configTab(optionEL, rule, that, previewComponent) {
    optionEL.empty();
    that.setOptionConfigDefaults(rule.id, {
      smallWords: "der|die|das|den|dem|des|einer|eines|deren|ein|eine|einem|einer|eines|einer|und|oder|aber|denn|sondern|sowie|weder|noch|entweder|oder|dass|weil|obwohl|wenn|als|nachdem|bevor|w\xE4hrend|bis|damit|um|zu|sobald|solange|da|indem|so|dass|ohne|zu|durch|f\xFCr|gegen|ohne|um|bis|aus|au\xDFer|bei|gegen\xFCber|mit|nach|seit|von|zu|anstatt|aufgrund|au\xDFerhalb|innerhalb|trotz|w\xE4hrend|wegen|an|auf|hinter|in|neben|\xFCber|unter|vor|zwischen",
      doNotCapitalizeSmallWords: true
    });
    new import_obsidian29.Setting(optionEL).setName("Do not capitalize small words").setDesc("If enabled, small words will not be capitalized. If disabled, all words will be capitalized.").addToggle(
      (toggle) => toggle.setValue(that.getOptionConfig(rule.id, "doNotCapitalizeSmallWords") || false).onChange(async (value) => {
        that.setOptionConfig(rule.id, "doNotCapitalizeSmallWords", value);
        that.updatePreview(rule, previewComponent);
      })
    );
    new import_obsidian29.Setting(optionEL).setName("List of small words").setDesc('Enter a list of small words to be excluded from capitalization. Use "|" as separator.').addText(
      (text) => text.setValue(that.getOptionConfig(rule.id, "smallWords") || "").onChange(async (value) => {
        that.setOptionConfig(rule.id, "smallWords", value);
        that.updatePreview(rule, previewComponent);
      })
    );
  }
  titleCaps(title, smallWords) {
    const parts = [];
    const split = new RegExp(`[:.;?!] |(?: |^)["${this.punctuation}]`, "g");
    let index = 0;
    while (true) {
      const m = split.exec(title);
      const substring = title.substring(index, m ? m.index : title.length);
      logger.log(TRACE, "Processing substring:", substring);
      let isFirstWord = true;
      parts.push(
        substring.replace(/([\p{L}\p{M}]+(?:\.[\p{L}\p{M}]+)*)/gu, (all) => {
          logger.log(TRACE, "Matched word:", all);
          if (/[a-z][A-Z]|[A-Z][a-z]/.test(all)) {
            logger.log(TRACE, "Excluding mixed capitalization word:", all);
            isFirstWord = false;
            return all;
          }
          if (/^[A-ZÄÖÜß]+$/.test(all)) {
            logger.log(TRACE, "Excluding fully capitalized word:", all);
            isFirstWord = false;
            return all;
          }
          if (/[^\s]+\.[^\s]+/.test(all)) {
            logger.log(TRACE, "Excluding word with punctuation:", all);
            isFirstWord = false;
            return all;
          }
          const smallRegex = new RegExp(`^(${smallWords})$`, "iu");
          if (isFirstWord) {
            logger.log(TRACE, "Capitalizing first word of sentence:", all);
            isFirstWord = false;
            return this.upperDE(all);
          } else if (smallRegex.test(all)) {
            logger.log(TRACE, "Skipping capitalization for small word:", all);
            return this.lowerDE(all);
          }
          isFirstWord = false;
          return this.upperDE(all);
        })
      );
      index = split.lastIndex;
      if (m)
        parts.push(m[0]);
      else
        break;
    }
    return parts.join("");
  }
  lowerDE(word) {
    logger.log(TRACE, "Lowering:", word);
    return word.toLocaleLowerCase("de");
  }
  upperDE(word) {
    logger.log(TRACE, "Uppering:", word);
    return word.charAt(0).toLocaleUpperCase("de") + word.slice(1).toLocaleLowerCase("de");
  }
};

// src/rules/toTitleCaseEN.ts
var RuleToTitleCaseEN = class extends RulePrototype {
  constructor() {
    super();
    this.small = "(a|an|and|as|at|but|by|en|for|if|in|of|on|or|the|to|v[.]?|via|vs[.]?)";
    this.punctuation = "([!\"#$%&'()*+,./:;<=>?@[\\\\\\]^_`{|}~-]*)";
    this.id = "toTitleCaseEn";
    this.name = "To Title Case (English small words)";
    this.description = "Convert the value to Title Case.";
    this.ruleType = "formatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    const toTitleCase = (str) => {
      return this.titleCaps(str);
    };
    if (typeof input === "string") {
      return toTitleCase(input);
    } else if (Array.isArray(input)) {
      return input.map((item) => toTitleCase(String(item)));
    } else if (input instanceof Date) {
      return toTitleCase(input.toISOString());
    } else if (typeof input === "object") {
      return toTitleCase(JSON.stringify(input));
    }
    return input;
  }
  titleCaps(title) {
    var parts = [], split = /[:.;?!] |(?: |^)["Ò]/g, index = 0;
    while (true) {
      var m = split.exec(title);
      parts.push(title.substring(index, m ? m.index : title.length).replace(/\b([A-Za-z][a-z.'Õ]*)\b/g, (all) => {
        return /[A-Za-z]\.[A-Za-z]/.test(all) ? all : this.upper(all);
      }).replace(RegExp("\\b" + this.small + "\\b", "ig"), this.lower).replace(RegExp("^" + this.punctuation + this.small + "\\b", "ig"), (all, punct, word) => {
        return punct + this.upper(word);
      }).replace(RegExp("\\b" + this.small + this.punctuation + "$", "ig"), this.upper));
      index = split.lastIndex;
      if (m)
        parts.push(m[0]);
      else
        break;
    }
    return parts.join("").replace(/ V(s?)\. /ig, " v$1. ").replace(/(['Õ])S\b/ig, "$1s").replace(/\b(AT&T|Q&A)\b/ig, function(all) {
      return all.toUpperCase();
    });
  }
  lower(word) {
    return word.toLowerCase();
  }
  upper(word) {
    return word.substr(0, 1).toUpperCase() + word.substr(1);
  }
};

// src/rules/toUpperCase.ts
var RuleToUpperCase = class extends RulePrototype {
  constructor() {
    super();
    this.id = "toUpperCase";
    this.name = "To Upper Case";
    this.description = "Convert the value to upper case.";
    this.ruleType = "formatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    if (String.isString(input)) {
      return input.toUpperCase();
    } else if (Array.isArray(input)) {
      return input.map((item) => String(item).toUpperCase());
    } else if (input instanceof Date) {
      return input.toISOString().toUpperCase();
    } else if (typeof input === "object") {
      return JSON.stringify(input).toUpperCase();
    }
    return input;
  }
};

// src/rules/index.ts
var ruleClasses = [RuleAddPrefix, RuleAddSuffix, RuleAutomationAutoLink, RuleBuildInAutoCompleteModal, RuleBuildInConcatArrays, RuleBuildInConcatProperties, RuleBuildInConstant, RuleBuildInDateTimeCreated, RuleBuildInDateTimeModified, RuleBuildInDefault, RuleBuildInFileSizeBytes, RuleBuildInFileSizeString, RuleBuildInFolder, RuleBuildInFolderFolderNotes, RuleBuildInFolders, RuleBuildInFullPath, RuleBuildInFullPathExt, RuleBuildInFullPathExtFolderNotes, RuleBuildInFullPathFolderNotes, RuleBuildInGetProperty, RuleBuildInIsRoot, RuleBuildInLinkToFile, RuleBuildInName, RuleBuildInNameExt, RuleBuildInPath, RuleBuildInPathFolderNotes, RuleBuildInRootFolder, RuleBuildInScript, RuleReplaceChars, RuleReplaceSpaces, RuleReplaceSpecialChars, RuleToCamelCase, RuleToLinkMarkdown, RuleToLinkOriginal, RuleToLinkSimple, RuleToLinkWiki, RuleToLowerCase, RuleToOriginal, RuleToPascalCase, RuleToTitleCase, RuleToTitleCaseDE, RuleToTitleCaseEN, RuleToUpperCase];
ruleClasses.forEach((RuleClass) => {
  const ruleInstance = new RuleClass();
  rulesManager.registerRule(ruleInstance);
});

// main.ts
var FolderTagPlugin = class extends import_obsidian30.Plugin {
  constructor() {
    super(...arguments);
    this.fileInProgress = null;
  }
  // Track the file currently being processed
  //private oldFolderPaths = new Map<string, string | null>();
  async onload() {
    await this.loadSettings();
    logger.log(INFO, `Front Matter Automate ${versionString} loaded with settings: `, this.settings);
    logger.setLevel(this.settings.debugLevel);
    this.tools = new ScriptingTools(this.app, this);
    rulesManager.init(this.app, this, this.tools);
    let noticeMessage = `Front Matter Automate ${versionString}
 loading ...`;
    const loadingNotice = new import_obsidian30.Notice(noticeMessage, 0);
    noticeMessage = noticeMessage + "\n register events ...";
    loadingNotice.setMessage(noticeMessage);
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        logger.log(DEBUG, `Event creating file: ${file.path} starting in ${this.settings.delayCreateEvent}ms`);
        if (file instanceof import_obsidian30.TFile && file.extension === "md") {
          this.fileInProgress = file;
          setTimeout(
            () => {
              logger.log(DEBUG, `Event creating file started: `, file.path);
              this.updateFrontmatterParameters("create", file, this.settings.folderConfig);
              this.fileInProgress = null;
            },
            this.settings.delayCreateEvent
          );
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => {
        if (this.fileInProgress)
          return;
        if (file instanceof import_obsidian30.TFile && file.extension === "md") {
          this.updateFrontmatterParameters("rename", file, this.settings.folderConfig, oldPath);
        }
      })
    );
    this.registerEvent(
      this.app.metadataCache.on("changed", async (file, data, cache) => {
        if (this.fileInProgress)
          return;
        if (!checkIfFileAllowed(file, this.settings)) {
          logger.log(DEBUG, `file ${file.path} globally rejected!`);
          return;
        }
        if (!(file instanceof import_obsidian30.TFile) || file.extension !== "md") {
          logger.log(DEBUG, `Event metadata changed: ${file.path} not a markdown file!`);
          return;
        }
        if (file)
          this.updateFrontmatterParameters("metadata-changed", file, this.settings.folderConfig);
      })
    );
    noticeMessage = noticeMessage + "\n initial processing ...";
    loadingNotice.setMessage(noticeMessage);
    noticeMessage = noticeMessage + "\ndone!";
    loadingNotice.setMessage(noticeMessage);
    setTimeout(() => {
      loadingNotice.hide();
    }, 2e3);
    this.addSettingTab(new FolderTagSettingTab(this.app, this));
  }
  async loadSettings() {
    let data = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_FRONTMATTER_AUTOMATE_SETTINGS, data);
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  formatTagName(name) {
    if (name === null)
      return null;
    if (name === void 0)
      return void 0;
    let formatted = name.replace(/\s+/g, this.settings.spaceReplacement);
    formatted = formatted.replace(/[^a-zA-Z0-9\-_\/äöüßÄÖÜáéíóúýÁÉÍÓÚÝàèìòùÀÈÌÒÙâêîôûÂÊÎÔÛãñõÃÑÕ]/g, this.settings.specialCharReplacement);
    if (this.settings.lowercaseTags) {
      formatted = formatted.toLowerCase();
    }
    return formatted;
  }
  formatValue(value, type) {
    switch (type) {
      case "text":
      case "tags":
      case "aliases":
      case "multitext":
        return this.tools.toYamlSafeString(value);
      case "date":
      case "datetime":
        if (typeof value === "number") {
          return new Date(value).toISOString();
        }
        return value.toString();
      case "checkbox":
        return value ? "true" : "false";
      case "number":
        return Number(value);
      default:
        return this.tools.toYamlSafeString(value);
    }
  }
  updateFrontmatterParameters(eventName, file, ruleSettings, oldPath) {
    var _a;
    if (!checkIfFileAllowed(file, this.settings)) {
      logger.log(DEBUG, `file ${file.path} globally rejected!`);
      return;
    }
    const currentPathTag = this.formatTagName(this.tools.getFolderFromPath(file.path));
    const oldPathTag = this.formatTagName(this.tools.getFolderFromPath(oldPath));
    const rules = (_a = ruleSettings == null ? void 0 : ruleSettings.rows.flatMap((row) => {
      if (row.folderId) {
        const folder = ruleSettings.folders.find((folder2) => folder2.id === row.folderId);
        if (!folder) {
          row.folderId = void 0;
          logger.log(ERROR, `Event ${eventName}: Folder with id ${row.folderId} not found for rule ${row.payload.content}!`);
          return [row.payload];
        }
        return !folder.disabled ? [row.payload] : [];
      }
      return [row.payload];
    })) != null ? _a : [];
    if (!rules || rules.length === 0) {
      logger.log(DEBUG, `Event ${eventName}: No rules found for file ${file.path}`);
      return;
    }
    this.app.fileManager.processFrontMatter(file, (frontmatter) => {
      var _a2;
      logger.groupCollapsed(DEBUG, `Event ${eventName}: "${file.path}" ${rules.length}/${ruleSettings == null ? void 0 : ruleSettings.rows.length} active rules. Old file: "${oldPath}"`, frontmatter);
      let oldLocationResults = [];
      if (oldPath && oldPath !== file.path) {
        logger.groupCollapsed(DEBUG, `Event ${eventName}: Collecting results for old file path: "${oldPath}"`);
        for (let rule of rules) {
          if (!rule)
            continue;
          let result = executeRuleObject(eventName, this.app, this, this.settings, this.tools.getMockFileFromPath(oldPath), frontmatter[rule.property], rule, frontmatter);
          oldLocationResults.push({ ruleId: rule.id, result });
        }
        logger.log(DEBUG, `Old file path results:`, oldLocationResults);
        logger.groupEnd();
      }
      for (let rule of rules) {
        if (!rule)
          continue;
        let result = frontmatter[rule.property];
        logger.groupCollapsed(DEBUG, `Execute Rule: ${rule.property}(${rule.content})`, result, rule);
        if (!checkIfFileAllowed(file, this.settings, rule)) {
          logger.log(DEBUG, `file ${file.path} rejected by rule (${rule.property}|${rule.content}) settings`);
          logger.groupEnd();
          continue;
        }
        if (rule.onlyModify && !frontmatter.hasOwnProperty(rule.property)) {
          logger.log(DEBUG, `file "${file.path}" has not "${rule.property}"(Rule:${rule.content}) onlyModify set: skipped`);
          logger.groupEnd();
          continue;
        }
        switch ((_a2 = rulesManager.getRuleById(rule.content)) == null ? void 0 : _a2.ruleType) {
          case "buildIn":
          case "script":
            result = executeRuleObject(eventName, this.app, this, this.settings, file, frontmatter[rule.property], rule, frontmatter, oldLocationResults);
            break;
          default:
        }
        frontmatter[rule.property] = result;
        logger.groupEnd();
      }
      logger.log(DEBUG, "Frontmatter updated", frontmatter);
      logger.groupEnd();
    }, { "mtime": file.stat.mtime });
  }
  /*
      async removeFrontmatterParamsFromAllFiles(rule: FrontmatterAutomateRuleSettings){
          let count = {files:0, items: 0}
          this.app.vault.getMarkdownFiles().forEach(file => {
              count.files++;
              this.removeFrontmatterParameter(file, rule, count);
          });
          return count;
      }
  
      async removeFrontmatterParameter(file: TFile, rule: FrontmatterAutomateRuleSettings, count) {
          if (!checkIfFileAllowed(file, this.settings, rule)) return;
          const currentPathTag = this.formatTagName(this.tools.getFolderFromPath(file.path));
          let content = await this.app.vault.read(file);
          this.app.fileManager.processFrontMatter(file, (frontmatter) => {
              if (Array.isArray(frontmatter[rule.property])) count.items += frontmatter[rule.property].length;
              frontmatter[rule.property] = removeRule(this.app, this.settings, file, frontmatter[rule.property], rule, frontmatter);
              if (Array.isArray(frontmatter[rule.property])) count.items -= frontmatter[rule.property].length;
          },{'mtime':file.stat.mtime}); // do not change the modify time.
          return count;
      }
      */
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJzcmMvc2V0dGluZ3MudHMiLCAic3JjL2Zyb250bWF0dGVyLXRvb2xzLnRzIiwgInNyYy9Mb2cudHMiLCAic3JjL0Vycm9yLnRzIiwgInNyYy90b29scy50cyIsICJzcmMvYWxlcnRCb3gudHMiLCAic3JjL3J1bGVzL3J1bGVzLnRzIiwgInNyYy90eXBlcy50cyIsICJzcmMvZGlyZWN0b3J5U2VsZWN0aW9uTW9kYWwudHMiLCAic3JjL3NldHRpbmdzLXByb3BlcnRpZXMudHMiLCAic3JjL3J1bGVzLnRzIiwgInNyYy9lZGl0b3JNb2RhbC50cyIsICJzcmMvdWlFbGVtZW50cy50cyIsICJzcmMvdWlNdWx0aVByb3BlcnR5U2V0dGluZy50cyIsICJzcmMvdWlUcmVlSGllcmFyY2h5U29ydGFibGVTZXR0aW5ncy50cyIsICJzcmMvdWlNYXJrZG93bkhlbHBNb2RhbC50cyIsICJzcmMvcnVsZXMvYWRkUHJlZml4LnRzIiwgInNyYy9ydWxlcy9hZGRTdWZmaXgudHMiLCAic3JjL3J1bGVzL2F1dG9tYXRpb25BdXRvTGluay50cyIsICJzcmMvc3VnZ2VzdGVycy9Gb2xkZXJTdWdnZXN0ZXIudHMiLCAic3JjL3N1Z2dlc3RlcnMvc3VnZ2VzdC50cyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2VudW1zLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvdy5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21hdGguanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy91c2VyQWdlbnQuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNMYXlvdXRWaWV3cG9ydC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9jb250YWlucy5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzVGFibGVFbGVtZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRQYXJlbnROb2RlLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3dpdGhpbi5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcnJvdy5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldFZhcmlhdGlvbi5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGwuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsQmFyWC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRWaWV3cG9ydFJlY3QuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRSZWN0LmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzU2Nyb2xsUGFyZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFNjcm9sbFBhcmVudC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZU9mZnNldHMuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZXRlY3RPdmVyZmxvdy5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2ZsaXAuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaGlkZS5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9vZmZzZXQuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEFsdEF4aXMuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVTY3JvbGwuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGVib3VuY2UuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZUJ5TmFtZS5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2NyZWF0ZVBvcHBlci5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3BvcHBlci5qcyIsICJzcmMvc3VnZ2VzdGVycy9GaWxlU3VnZ2VzdGVyLnRzIiwgInNyYy9ydWxlcy9idWlsZEluQXV0b0NvbXBsZXRlTW9kYWwudHMiLCAic3JjL2F1dG9jb21wbGV0ZU1vZGFsLnRzIiwgInNyYy9ydWxlcy9idWlsZEluQ29uY2F0QXJyYXlzLnRzIiwgInNyYy9ydWxlcy9idWlsZEluQ29uY2F0UHJvcGVydGllcy50cyIsICJzcmMvcnVsZXMvYnVpbGRJbkNvbnN0YW50LnRzIiwgInNyYy9ydWxlcy9idWlsZEluRGF0ZVRpbWVDcmVhdGVkLnRzIiwgInNyYy9ydWxlcy9idWlsZEluRGF0ZVRpbWVNb2RpZmllZC50cyIsICJzcmMvcnVsZXMvYnVpbGRJbkRlZmF1bHQudHMiLCAic3JjL3J1bGVzL2J1aWxkSW5GaWxlU2l6ZUJ5dGVzLnRzIiwgInNyYy9ydWxlcy9idWlsZEluRmlsZVNpemVTdHJpbmcudHMiLCAic3JjL3J1bGVzL2J1aWxkSW5Gb2xkZXIudHMiLCAic3JjL3J1bGVzL2J1aWxkSW5Gb2xkZXJGb2xkZXJOb3Rlcy50cyIsICJzcmMvcnVsZXMvYnVpbGRJbkZvbGRlcnMudHMiLCAic3JjL3J1bGVzL2J1aWxkSW5GdWxsUGF0aC50cyIsICJzcmMvcnVsZXMvYnVpbGRJbkZ1bGxQYXRoRXh0LnRzIiwgInNyYy9ydWxlcy9idWlsZEluRnVsbFBhdGhFeHRGb2xkZXJOb3Rlcy50cyIsICJzcmMvcnVsZXMvYnVpbGRJbkZ1bGxQYXRoRm9sZGVyTm90ZXMudHMiLCAic3JjL3J1bGVzL2J1aWxkSW5HZXRQcm9wZXJ0eS50cyIsICJzcmMvcnVsZXMvYnVpbGRJbklzUm9vdC50cyIsICJzcmMvcnVsZXMvYnVpbGRJbkxpbmtUb0ZpbGUudHMiLCAic3JjL3J1bGVzL2J1aWxkSW5OYW1lLnRzIiwgInNyYy9ydWxlcy9idWlsZEluTmFtZUV4dC50cyIsICJzcmMvcnVsZXMvYnVpbGRJblBhdGgudHMiLCAic3JjL3J1bGVzL2J1aWxkSW5QYXRoRm9sZGVyTm90ZXMudHMiLCAic3JjL3J1bGVzL2J1aWxkSW5Sb290Rm9sZGVyLnRzIiwgInNyYy9ydWxlcy9idWlsZEluU2NyaXB0LnRzIiwgInNyYy9ydWxlcy9yZXBsYWNlQ2hhcnMudHMiLCAic3JjL3J1bGVzL3JlcGxhY2VTcGFjZXMudHMiLCAic3JjL3J1bGVzL3JlcGxhY2VTcGVjaWFsQ2hhcnMudHMiLCAic3JjL3J1bGVzL3RvQ2FtZWxDYXNlLnRzIiwgInNyYy9ydWxlcy90b0xpbmtNYXJrZG93bi50cyIsICJzcmMvcnVsZXMvdG9MaW5rT3JpZ2luYWwudHMiLCAic3JjL3J1bGVzL3RvTGlua1NpbXBsZS50cyIsICJzcmMvcnVsZXMvdG9MaW5rV2lraS50cyIsICJzcmMvcnVsZXMvdG9Mb3dlckNhc2UudHMiLCAic3JjL3J1bGVzL3RvT3JpZ2luYWwudHMiLCAic3JjL3J1bGVzL3RvUGFzY2FsQ2FzZS50cyIsICJzcmMvcnVsZXMvdG9UaXRsZUNhc2UudHMiLCAic3JjL3J1bGVzL3RvVGl0bGVDYXNlREUudHMiLCAic3JjL3J1bGVzL3RvVGl0bGVDYXNlRU4udHMiLCAic3JjL3J1bGVzL3RvVXBwZXJDYXNlLnRzIiwgInNyYy9ydWxlcy9pbmRleC50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIFBsdWdpbiwgTWFya2Rvd25WaWV3LCBNYXJrZG93blBvc3RQcm9jZXNzb3IsIFBsdWdpbk1hbmlmZXN0LCBURmlsZSwgVEZvbGRlciwgVmF1bHQsIHBhcnNlRnJvbnRNYXR0ZXJUYWdzLCBOb3RpY2V9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IEZvbGRlclRhZ1NldHRpbmdUYWIgfSBmcm9tICcuL3NyYy9zZXR0aW5ncyc7XG4vL2ltcG9ydCB7IEZvbGRlclRhZ1NldHRpbmdUYWIgfSBmcm9tICcuL3NyYy9zZXR0aW5ncy1wcm9wZXJ0aWVzJztcbmltcG9ydCB7IGNoZWNrSWZGaWxlQWxsb3dlZCwgZXhlY3V0ZVJ1bGVPYmplY3QgfSBmcm9tICcuL3NyYy9ydWxlcyc7XG5pbXBvcnQgeyBwYXJzZUpTQ29kZSwgU2NyaXB0aW5nVG9vbHMgfSBmcm9tICcuL3NyYy90b29scyc7XG5pbXBvcnQgeyB2ZXJzaW9uU3RyaW5nLCBGcm9udG1hdHRlckF1dG9tYXRlU2V0dGluZ3MsIERFRkFVTFRfRlJPTlRNQVRURVJfQVVUT01BVEVfU0VUVElOR1MsIEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIFByb3BlcnR5VHlwZUluZm99IGZyb20gJy4vc3JjL3R5cGVzJ1xuaW1wb3J0IFwiLi9zcmMvcnVsZXMvaW5kZXhcIjtcbmltcG9ydCB7IHJ1bGVzTWFuYWdlciB9IGZyb20gJy4vc3JjL3J1bGVzL3J1bGVzJztcbmltcG9ydCB7IERFQlVHLCBFUlJPUiwgSU5GTywgbG9nZ2VyIH0gZnJvbSAnLi9zcmMvTG9nJztcbmltcG9ydCB7IGxvZyB9IGZyb20gJ2NvbnNvbGUnO1xuaW1wb3J0IHsgVHJlZUhpZXJhcmNoeURhdGEgfSBmcm9tICcuL3NyYy91aVRyZWVIaWVyYXJjaHlTb3J0YWJsZVNldHRpbmdzJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZvbGRlclRhZ1BsdWdpbiBleHRlbmRzIFBsdWdpbiB7XG4gICAgc2V0dGluZ3MhOiBGcm9udG1hdHRlckF1dG9tYXRlU2V0dGluZ3M7XG4gICAgcHJpdmF0ZSB0b29scyE6IFNjcmlwdGluZ1Rvb2xzO1xuICAgIGZpbGVJblByb2dyZXNzOiBURmlsZSB8IG51bGwgPSBudWxsOyAvLyBUcmFjayB0aGUgZmlsZSBjdXJyZW50bHkgYmVpbmcgcHJvY2Vzc2VkXG4gICAgLy9wcml2YXRlIG9sZEZvbGRlclBhdGhzID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZyB8IG51bGw+KCk7XG5cbiAgICBhc3luYyBvbmxvYWQoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG4gICAgICAgIGxvZ2dlci5sb2coSU5GTyxgRnJvbnQgTWF0dGVyIEF1dG9tYXRlICR7dmVyc2lvblN0cmluZ30gbG9hZGVkIHdpdGggc2V0dGluZ3M6IGAsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICBsb2dnZXIuc2V0TGV2ZWwodGhpcy5zZXR0aW5ncy5kZWJ1Z0xldmVsKTtcbiAgICAgICAgdGhpcy50b29scyA9IG5ldyBTY3JpcHRpbmdUb29scyh0aGlzLmFwcCwgdGhpcyk7XG4gICAgICAgIHJ1bGVzTWFuYWdlci5pbml0KHRoaXMuYXBwLCB0aGlzLCB0aGlzLnRvb2xzKTtcbiAgICAgICAgbGV0IG5vdGljZU1lc3NhZ2UgPSBgRnJvbnQgTWF0dGVyIEF1dG9tYXRlICR7dmVyc2lvblN0cmluZ31cXG4gbG9hZGluZyAuLi5gO1xuICAgICAgICBjb25zdCBsb2FkaW5nTm90aWNlID0gbmV3IE5vdGljZShub3RpY2VNZXNzYWdlLDApXG5cbiAgICAgICAgbm90aWNlTWVzc2FnZSA9IG5vdGljZU1lc3NhZ2UgKyAnXFxuIHJlZ2lzdGVyIGV2ZW50cyAuLi4nO1xuICAgICAgICBsb2FkaW5nTm90aWNlLnNldE1lc3NhZ2Uobm90aWNlTWVzc2FnZSk7XG4gICAgICAgIC8vIEZpbGUgY3JlYXRpb24gaGFuZGxlclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRXZlbnQoXG4gICAgICAgICAgICB0aGlzLmFwcC52YXVsdC5vbignY3JlYXRlJywgKGZpbGUpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKERFQlVHLGBFdmVudCBjcmVhdGluZyBmaWxlOiAke2ZpbGUucGF0aH0gc3RhcnRpbmcgaW4gJHt0aGlzLnNldHRpbmdzLmRlbGF5Q3JlYXRlRXZlbnR9bXNgKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlICYmIGZpbGUuZXh0ZW5zaW9uID09PSAnbWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsZUluUHJvZ3Jlc3MgPSBmaWxlOyAvLyBTZXQgdGhlIGZpbGUgaW4gcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKERFQlVHLGBFdmVudCBjcmVhdGluZyBmaWxlIHN0YXJ0ZWQ6IGAsIGZpbGUucGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUZyb250bWF0dGVyUGFyYW1ldGVycygnY3JlYXRlJywgZmlsZSwgdGhpcy5zZXR0aW5ncy5mb2xkZXJDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maWxlSW5Qcm9ncmVzcyA9IG51bGw7IC8vIENsZWFyIHRoZSBmaWxlIGluIHByb2dyZXNzIGFmdGVyIHByb2Nlc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAsIHRoaXMuc2V0dGluZ3MuZGVsYXlDcmVhdGVFdmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBGaWxlIHJlbmFtZS9tb3ZlIGhhbmRsZXJcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KFxuICAgICAgICAgICAgdGhpcy5hcHAudmF1bHQub24oJ3JlbmFtZScsIChmaWxlLCBvbGRQYXRoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlsZUluUHJvZ3Jlc3MpIHJldHVybjsgLy8gSWdub3JlIGlmIGZpbGUgaXMgaW4gcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlICYmIGZpbGUuZXh0ZW5zaW9uID09PSAnbWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRnJvbnRtYXR0ZXJQYXJhbWV0ZXJzKCdyZW5hbWUnLCBmaWxlLCB0aGlzLnNldHRpbmdzLmZvbGRlckNvbmZpZywgb2xkUGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBGaWxlIGNsb3NlIGhhbmRsZXJcbiAgICAgICAgLypcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KFxuICAgICAgICAgICAgdGhpcy5hcHAud29ya3NwYWNlLm9uKCdhY3RpdmUtbGVhZi1jaGFuZ2UnLCAobGVhZikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsZWFmPy52aWV3IGluc3RhbmNlb2YgTWFya2Rvd25WaWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZUZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKERFQlVHLGBFdmVudCBhY3RpdmUtbGVhZi1jaGFuZ2UgZmlsZTogYCwgYWN0aXZlRmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmVGaWxlKSB0aGlzLnVwZGF0ZUZyb250bWF0dGVyUGFyYW1ldGVycygnYWN0aXZlLWxlYWYtY2hhbmdlJywgYWN0aXZlRmlsZSwgdGhpcy5zZXR0aW5ncy5ydWxlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgKi9cbiAgICAgICAgLy8gTWV0YWRhdGEgY2hhbmdlZCBoYW5kbGVyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJFdmVudChcbiAgICAgICAgICAgIHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUub24oJ2NoYW5nZWQnLCBhc3luYyAoZmlsZSwgZGF0YSwgY2FjaGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maWxlSW5Qcm9ncmVzcykgcmV0dXJuOyAvLyBJZ25vcmUgaWYgZmlsZSBpcyBpbiBwcm9ncmVzc1xuICAgICAgICAgICAgICAgIGlmICghY2hlY2tJZkZpbGVBbGxvd2VkKGZpbGUsIHRoaXMuc2V0dGluZ3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coREVCVUcsYGZpbGUgJHtmaWxlLnBhdGh9IGdsb2JhbGx5IHJlamVjdGVkIWApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB8fCBmaWxlLmV4dGVuc2lvbiAhPT0gJ21kJykge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKERFQlVHLGBFdmVudCBtZXRhZGF0YSBjaGFuZ2VkOiAke2ZpbGUucGF0aH0gbm90IGEgbWFya2Rvd24gZmlsZSFgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmlsZSkgdGhpcy51cGRhdGVGcm9udG1hdHRlclBhcmFtZXRlcnMoJ21ldGFkYXRhLWNoYW5nZWQnLCBmaWxlLCB0aGlzLnNldHRpbmdzLmZvbGRlckNvbmZpZyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICAgICAgXG4gICAgICAgIG5vdGljZU1lc3NhZ2UgPSBub3RpY2VNZXNzYWdlICsgJ1xcbiBpbml0aWFsIHByb2Nlc3NpbmcgLi4uJztcbiAgICAgICAgbG9hZGluZ05vdGljZS5zZXRNZXNzYWdlKG5vdGljZU1lc3NhZ2UpO1xuICAgICAgICBub3RpY2VNZXNzYWdlID0gbm90aWNlTWVzc2FnZSArICdcXG5kb25lISc7XG4gICAgICAgIGxvYWRpbmdOb3RpY2Uuc2V0TWVzc2FnZShub3RpY2VNZXNzYWdlKTtcbiAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgbG9hZGluZ05vdGljZS5oaWRlKCk7XG4gICAgICAgIH0sMjAwMClcblxuICAgICAgICAvLyBBZGQgc2V0dGluZ3MgdGFiXG4gICAgICAgIHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgRm9sZGVyVGFnU2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcykpO1xuICAgIH1cblxuICAgIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBhd2FpdCB0aGlzLmxvYWREYXRhKCk7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0ZST05UTUFUVEVSX0FVVE9NQVRFX1NFVFRJTkdTLCBkYXRhKTtcbiAgICB9XG4gICAgXG4gICAgYXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuICAgICAgICBhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZm9ybWF0VGFnTmFtZShuYW1lOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZHtcbiAgICAgICAgaWYgKG5hbWUgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBcbiAgICAgICAgLy8gRmlyc3QgcmVwbGFjZSBzcGFjZXMgYWNjb3JkaW5nIHRvIHNldHRpbmdzXG4gICAgICAgIGxldCBmb3JtYXR0ZWQgPSBuYW1lLnJlcGxhY2UoL1xccysvZywgdGhpcy5zZXR0aW5ncy5zcGFjZVJlcGxhY2VtZW50KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRoZW4gcmVwbGFjZSBzcGVjaWFsIGNoYXJhY3RlcnMgKHByZXNlcnZpbmcgbGV0dGVycyB3aXRoIGRpYWNyaXRpY3MpXG4gICAgICAgIGZvcm1hdHRlZCA9IGZvcm1hdHRlZC5yZXBsYWNlKC9bXmEtekEtWjAtOVxcLV9cXC9cdTAwRTRcdTAwRjZcdTAwRkNcdTAwREZcdTAwQzRcdTAwRDZcdTAwRENcdTAwRTFcdTAwRTlcdTAwRURcdTAwRjNcdTAwRkFcdTAwRkRcdTAwQzFcdTAwQzlcdTAwQ0RcdTAwRDNcdTAwREFcdTAwRERcdTAwRTBcdTAwRThcdTAwRUNcdTAwRjJcdTAwRjlcdTAwQzBcdTAwQzhcdTAwQ0NcdTAwRDJcdTAwRDlcdTAwRTJcdTAwRUFcdTAwRUVcdTAwRjRcdTAwRkJcdTAwQzJcdTAwQ0FcdTAwQ0VcdTAwRDRcdTAwREJcdTAwRTNcdTAwRjFcdTAwRjVcdTAwQzNcdTAwRDFcdTAwRDVdL2csIHRoaXMuc2V0dGluZ3Muc3BlY2lhbENoYXJSZXBsYWNlbWVudCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDb252ZXJ0IHRvIGxvd2VyY2FzZSBpZiBjb25maWd1cmVkXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmxvd2VyY2FzZVRhZ3MpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZCA9IGZvcm1hdHRlZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkO1xuICAgIH1cblxuICAgIGZvcm1hdFZhbHVlKHZhbHVlOmFueSwgdHlwZTpzdHJpbmcpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgIGNhc2UgJ3RhZ3MnOlxuICAgICAgICAgICAgY2FzZSAnYWxpYXNlcyc6XG4gICAgICAgICAgICBjYXNlICdtdWx0aXRleHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvb2xzLnRvWWFtbFNhZmVTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICBjYXNlICdkYXRldGltZSc6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9vbHMudG9ZYW1sU2FmZVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVGcm9udG1hdHRlclBhcmFtZXRlcnMoZXZlbnROYW1lOiAnY3JlYXRlJyB8ICdyZW5hbWUnIHwgJ2FjdGl2ZS1sZWFmLWNoYW5nZScgfCAnbWV0YWRhdGEtY2hhbmdlZCcsIGZpbGU6IFRGaWxlLCBydWxlU2V0dGluZ3M6IFRyZWVIaWVyYXJjaHlEYXRhLCBvbGRQYXRoPzogc3RyaW5nKSB7XG4gICAgICAgIGlmICghY2hlY2tJZkZpbGVBbGxvd2VkKGZpbGUsIHRoaXMuc2V0dGluZ3MpKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKERFQlVHLGBmaWxlICR7ZmlsZS5wYXRofSBnbG9iYWxseSByZWplY3RlZCFgKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQYXRoVGFnID0gdGhpcy5mb3JtYXRUYWdOYW1lKHRoaXMudG9vbHMuZ2V0Rm9sZGVyRnJvbVBhdGgoZmlsZS5wYXRoKSk7XG4gICAgICAgIGNvbnN0IG9sZFBhdGhUYWcgPSB0aGlzLmZvcm1hdFRhZ05hbWUodGhpcy50b29scy5nZXRGb2xkZXJGcm9tUGF0aChvbGRQYXRoKSlcbiAgICAgICAgY29uc3QgcnVsZXMgPSBydWxlU2V0dGluZ3M/LnJvd3MuZmxhdE1hcCgocm93KSA9PiB7XG4gICAgICAgICAgICBpZiAocm93LmZvbGRlcklkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9sZGVyID0gcnVsZVNldHRpbmdzLmZvbGRlcnMuZmluZCgoZm9sZGVyKSA9PiBmb2xkZXIuaWQgPT09IHJvdy5mb2xkZXJJZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFmb2xkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93LmZvbGRlcklkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKEVSUk9SLGBFdmVudCAke2V2ZW50TmFtZX06IEZvbGRlciB3aXRoIGlkICR7cm93LmZvbGRlcklkfSBub3QgZm91bmQgZm9yIHJ1bGUgJHtyb3cucGF5bG9hZC5jb250ZW50fSFgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtyb3cucGF5bG9hZCBhcyBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICFmb2xkZXIuZGlzYWJsZWQgPyBbcm93LnBheWxvYWQgYXMgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5nc10gOiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbcm93LnBheWxvYWQgYXMgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5nc107XG4gICAgICAgIH0pID8/IFtdO1xuICAgICAgICBpZiAoIXJ1bGVzIHx8IHJ1bGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhERUJVRyxgRXZlbnQgJHtldmVudE5hbWV9OiBObyBydWxlcyBmb3VuZCBmb3IgZmlsZSAke2ZpbGUucGF0aH1gKTtcbiAgICAgICAgICAgIHJldHVybjsgLy8gTm8gcnVsZXMgdG8gYXBwbHlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYXBwLmZpbGVNYW5hZ2VyLnByb2Nlc3NGcm9udE1hdHRlcihmaWxlLCAoZnJvbnRtYXR0ZXIpID0+IHtcbiAgICAgICAgICAgIC8vIGFwcGx5IGFsbCBydWxlcyB0byBmcm9udG1hdHRlclxuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKERFQlVHLGBFdmVudCAke2V2ZW50TmFtZX06IFwiJHtmaWxlLnBhdGh9XCIgJHtydWxlcy5sZW5ndGh9LyR7cnVsZVNldHRpbmdzPy5yb3dzLmxlbmd0aH0gYWN0aXZlIHJ1bGVzLiBPbGQgZmlsZTogXCIke29sZFBhdGh9XCJgLGZyb250bWF0dGVyKTtcbiAgICAgICAgICAgIGxldCBvbGRMb2NhdGlvblJlc3VsdHM6IHtydWxlSWQ6IHN0cmluZywgcmVzdWx0OiBhbnl9W10gPSBbXTtcblxuICAgICAgICAgICAgaWYgKG9sZFBhdGggJiYgb2xkUGF0aCAhPT0gZmlsZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKERFQlVHLGBFdmVudCAke2V2ZW50TmFtZX06IENvbGxlY3RpbmcgcmVzdWx0cyBmb3Igb2xkIGZpbGUgcGF0aDogXCIke29sZFBhdGh9XCJgKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBydWxlIG9mIHJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcnVsZSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBleGVjdXRlUnVsZU9iamVjdChldmVudE5hbWUsIHRoaXMuYXBwLCB0aGlzLCB0aGlzLnNldHRpbmdzLCB0aGlzLnRvb2xzLmdldE1vY2tGaWxlRnJvbVBhdGgob2xkUGF0aCksIGZyb250bWF0dGVyW3J1bGUucHJvcGVydHldLCBydWxlLCBmcm9udG1hdHRlcik7XG4gICAgICAgICAgICAgICAgICAgIG9sZExvY2F0aW9uUmVzdWx0cy5wdXNoKHsgcnVsZUlkOiBydWxlLmlkLCByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coREVCVUcsYE9sZCBmaWxlIHBhdGggcmVzdWx0czpgLCBvbGRMb2NhdGlvblJlc3VsdHMpO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgcnVsZSBvZiBydWxlcykge1xuICAgICAgICAgICAgICAgIGlmICghcnVsZSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGZyb250bWF0dGVyW3J1bGUucHJvcGVydHldO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChERUJVRyxgRXhlY3V0ZSBSdWxlOiAke3J1bGUucHJvcGVydHl9KCR7cnVsZS5jb250ZW50fSlgLHJlc3VsdCwgcnVsZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGVja0lmRmlsZUFsbG93ZWQoZmlsZSwgdGhpcy5zZXR0aW5ncywgcnVsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhERUJVRyxgZmlsZSAke2ZpbGUucGF0aH0gcmVqZWN0ZWQgYnkgcnVsZSAoJHtydWxlLnByb3BlcnR5fXwke3J1bGUuY29udGVudH0pIHNldHRpbmdzYCk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gb25seSBtb2RpZnkgaWYgZmlsZSBpcyBhbGxvd2VkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChydWxlLm9ubHlNb2RpZnkgJiYgIWZyb250bWF0dGVyLmhhc093blByb3BlcnR5KHJ1bGUucHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coREVCVUcsYGZpbGUgXCIke2ZpbGUucGF0aH1cIiBoYXMgbm90IFwiJHtydWxlLnByb3BlcnR5fVwiKFJ1bGU6JHtydWxlLmNvbnRlbnR9KSBvbmx5TW9kaWZ5IHNldDogc2tpcHBlZGApO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIG9ubHkgbW9kaWZ5IGlmIHByb3BlcnR5IGV4aXN0c1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJ1bGVzTWFuYWdlci5nZXRSdWxlQnlJZChydWxlLmNvbnRlbnQpPy5ydWxlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdidWlsZEluJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2NyaXB0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV4ZWN1dGVSdWxlT2JqZWN0KGV2ZW50TmFtZSwgdGhpcy5hcHAsIHRoaXMsIHRoaXMuc2V0dGluZ3MsIGZpbGUsIGZyb250bWF0dGVyW3J1bGUucHJvcGVydHldLCBydWxlLCBmcm9udG1hdHRlciwgb2xkTG9jYXRpb25SZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmcm9udG1hdHRlcltydWxlLnByb3BlcnR5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5sb2coREVCVUcsJ0Zyb250bWF0dGVyIHVwZGF0ZWQnLGZyb250bWF0dGVyKTtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICB9LHsnbXRpbWUnOmZpbGUuc3RhdC5tdGltZX0pOyAvLyBkbyBub3QgY2hhbmdlIHRoZSBtb2RpZnkgdGltZS5cbiAgICB9XG4gICAgLypcbiAgICBhc3luYyByZW1vdmVGcm9udG1hdHRlclBhcmFtc0Zyb21BbGxGaWxlcyhydWxlOiBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzKXtcbiAgICAgICAgbGV0IGNvdW50ID0ge2ZpbGVzOjAsIGl0ZW1zOiAwfVxuICAgICAgICB0aGlzLmFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCkuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgICAgICAgIGNvdW50LmZpbGVzKys7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUZyb250bWF0dGVyUGFyYW1ldGVyKGZpbGUsIHJ1bGUsIGNvdW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG5cbiAgICBhc3luYyByZW1vdmVGcm9udG1hdHRlclBhcmFtZXRlcihmaWxlOiBURmlsZSwgcnVsZTogRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgY291bnQpIHtcbiAgICAgICAgaWYgKCFjaGVja0lmRmlsZUFsbG93ZWQoZmlsZSwgdGhpcy5zZXR0aW5ncywgcnVsZSkpIHJldHVybjtcbiAgICAgICAgY29uc3QgY3VycmVudFBhdGhUYWcgPSB0aGlzLmZvcm1hdFRhZ05hbWUodGhpcy50b29scy5nZXRGb2xkZXJGcm9tUGF0aChmaWxlLnBhdGgpKTtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGZpbGUpO1xuICAgICAgICB0aGlzLmFwcC5maWxlTWFuYWdlci5wcm9jZXNzRnJvbnRNYXR0ZXIoZmlsZSwgKGZyb250bWF0dGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmcm9udG1hdHRlcltydWxlLnByb3BlcnR5XSkpIGNvdW50Lml0ZW1zICs9IGZyb250bWF0dGVyW3J1bGUucHJvcGVydHldLmxlbmd0aDtcbiAgICAgICAgICAgIGZyb250bWF0dGVyW3J1bGUucHJvcGVydHldID0gcmVtb3ZlUnVsZSh0aGlzLmFwcCwgdGhpcy5zZXR0aW5ncywgZmlsZSwgZnJvbnRtYXR0ZXJbcnVsZS5wcm9wZXJ0eV0sIHJ1bGUsIGZyb250bWF0dGVyKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZyb250bWF0dGVyW3J1bGUucHJvcGVydHldKSkgY291bnQuaXRlbXMgLT0gZnJvbnRtYXR0ZXJbcnVsZS5wcm9wZXJ0eV0ubGVuZ3RoO1xuICAgICAgICB9LHsnbXRpbWUnOmZpbGUuc3RhdC5tdGltZX0pOyAvLyBkbyBub3QgY2hhbmdlIHRoZSBtb2RpZnkgdGltZS5cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cbiAgICAqL1xufVxuIiwgImltcG9ydCB7IEFwcCwgQnV0dG9uQ29tcG9uZW50LCBEcm9wZG93bkNvbXBvbmVudCwgTm90aWNlLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nLCBUZXh0Q29tcG9uZW50LCBURmlsZSB9IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0ICogYXMgZm1Ub29scyBmcm9tICcuL2Zyb250bWF0dGVyLXRvb2xzJztcclxuaW1wb3J0IHsgcGFyc2VKU0NvZGUsIFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSAnLi90b29scyc7XHJcbmltcG9ydCB7IHZlcnNpb25TdHJpbmcsIEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIERFRkFVTFRfUlVMRV9ERUZJTklUSU9OLCBQcm9wZXJ0eVR5cGVJbmZvLCBPYnNpZGlhblByb3BlcnR5VHlwZXN9IGZyb20gJy4vdHlwZXMnO1xyXG5pbXBvcnQgeyBBbGVydE1vZGFsIH0gZnJvbSAnLi9hbGVydEJveCc7XHJcbmltcG9ydCB7IG9wZW5EaXJlY3RvcnlTZWxlY3Rpb25Nb2RhbCwgRGlyZWN0b3J5U2VsZWN0aW9uUmVzdWx0IH0gZnJvbSAnLi9kaXJlY3RvcnlTZWxlY3Rpb25Nb2RhbCc7XHJcbmltcG9ydCB7IHJhbmRvbVVVSUQgfSBmcm9tICdjcnlwdG8nO1xyXG5pbXBvcnQgeyBSdWxlc1RhYmxlIH0gZnJvbSAnLi9zZXR0aW5ncy1wcm9wZXJ0aWVzJztcclxuaW1wb3J0IHsgU29ydGFibGVMaXN0Q29tcG9uZW50IH0gZnJvbSAnLi9Tb3J0YWJsZUxpc3RDb21wb25lbnQnO1xyXG5pbXBvcnQgeyBydWxlc01hbmFnZXIgfSBmcm9tICcuL3J1bGVzL3J1bGVzJztcclxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi9Mb2cnO1xyXG5pbXBvcnQgeyBsb2cgfSBmcm9tICdjb25zb2xlJztcclxuaW1wb3J0IHsgZmV0Y2hNYXJrZG93bkZyb21HaXRIdWIsIE1hcmtkb3duSGVscE1vZGFsLCByZWFkUGx1Z2luRG9jRmlsZSB9IGZyb20gJy4vdWlNYXJrZG93bkhlbHBNb2RhbCc7XHJcblxyXG5leHBvcnQgY2xhc3MgRm9sZGVyVGFnU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xyXG4gICAgcGx1Z2luOiBhbnk7IC8vRm9sZGVyVGFnUGx1Z2luO1xyXG4gICAgcnVsZXNEaXYhOiBIVE1MRGl2RWxlbWVudDtcclxuICAgIHJ1bGVzQ29udGFpbmVyITogSFRNTERpdkVsZW1lbnQ7XHJcbiAgICBydWxlc0NvbnRyb2whOiBIVE1MRGl2RWxlbWVudDtcclxuICAgIGtub3duUHJvcGVydGllcyE6IFByb3BlcnR5VHlwZUluZm9bXTtcclxuICAgIGtub3duVHlwZXMhOiBhbnk7XHJcbiAgICBzY3JpcHRpbmdUb29scyE6IFNjcmlwdGluZ1Rvb2xzO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IGFueSAvKkZvbGRlclRhZ1BsdWdpbiovKSB7XHJcbiAgICAgICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xyXG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG4gICAgICAgIHRoaXMuc2NyaXB0aW5nVG9vbHMgPSBuZXcgU2NyaXB0aW5nVG9vbHMoYXBwLCBwbHVnaW4pO1xyXG4gICAgfVxyXG4gICAgaGlkZSgpOiB2b2lkIHtcclxuICAgICAgICAvLyB1cGRhdGUgdGhlIHJ1bGVzIHRvIHJlbW92ZSB0aGUgb25lcyB0aGF0IGFyZSBub3QgbGl2ZSBhbnltb3JlXHJcbiAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MubGl2ZVJ1bGVzPVtdO1xyXG4gICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnJ1bGVzLmZvckVhY2goKHJ1bGU6IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MpID0+IHtcclxuICAgICAgICAgICAgbGV0IHJ1bGVGdW5jdGlvbiA9IHJ1bGVzTWFuYWdlci5nZXRSdWxlQnlJZChydWxlLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICBpZiAoIXJ1bGVGdW5jdGlvbikgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZiAocnVsZUZ1bmN0aW9uLmlzTGl2ZVJ1bGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmxpdmVSdWxlcy5wdXNoKHJ1bGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAvLyB1cGRhdGUgYWN0aXZlIGZpbGUgaWYgaXQgaXMgb3BlblxyXG4gICAgICAgIGNvbnN0IGFjdGl2ZUZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xyXG4gICAgICAgIGlmIChhY3RpdmVGaWxlICYmIGFjdGl2ZUZpbGUuZXh0ZW5zaW9uID09PSAnbWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnVwZGF0ZUZyb250bWF0dGVyUGFyYW1ldGVycygnYWN0aXZlLWxlYWYtY2hhbmdlJywgYWN0aXZlRmlsZSwgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9sZGVyQ29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkaXNwbGF5KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMua25vd25Qcm9wZXJ0aWVzID0gZm1Ub29scy5nZXRQcm9wZXJ0aWVzRnJvbU1ldGFkYXRhTWFuYWdlcih0aGlzLmFwcCk7XHJcbiAgICAgICAgdGhpcy5rbm93blR5cGVzID0gZm1Ub29scy5nZXRUeXBlc0Zyb21NZXRhZGF0YU1hbmFnZXIodGhpcy5hcHApO1xyXG4gICAgICAgIGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XHJcblxyXG4gICAgICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XHJcblxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZShgRnJvbnQgbWF0dGVyIGF1dG9tYXRlIFYke3ZlcnNpb25TdHJpbmd9YClcclxuICAgICAgICAgICAgLnNldERlc2MoYFRoaXMgcGx1Z2luIGF1dG9tYXRlcyB0aGUgbWFuYWdlbWVudCBvZiBmcm9udCBtYXR0ZXIgaW4geW91ciBPYnNpZGlhbiBub3Rlcy4gSXQgYWxsb3dzIHlvdSB0byBzZXQgcnVsZXMgZm9yIGF1dG9tYXRpY2FsbHkgYWRkaW5nLCBtb2RpZnlpbmcsIG9yIHJlbW92aW5nIGZyb250IG1hdHRlciBwcm9wZXJ0aWVzIGJhc2VkIG9uIHZhcmlvdXMgZXZlbnRzIGxpa2UgZmlsZSBjcmVhdGlvbiwgcmVuYW1pbmcsIG9yIGFjdGl2ZSBsZWFmIGNoYW5nZXMuYClcclxuICAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAuc2V0SWNvbihcImNpcmNsZS1oZWxwXCIpXHJcbiAgICAgICAgICAgICAgICAuc2V0VG9vbHRpcChcIk9ubGluZSBIZWxwXCIpXHJcbiAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hcmtkb3duID0gXCJDb3VsZCBub3QgbG9hZCBoZWxwIGZyb20gR2l0SHViLlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtkb3duID0gYXdhaXQgZmV0Y2hNYXJrZG93bkZyb21HaXRIdWIoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9DaHJpc3RpYW4tTWUvb2JzaWRpYW4tZnJvbnQtbWF0dGVyLWF1dG9tYXRlL21haW4vcmVhZG1lLm1kXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBNYXJrZG93bkhlbHBNb2RhbCh0aGlzLmFwcCwgbWFya2Rvd24sIFwicmVhZG1lLm1kXCIpLm9wZW4oKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgIC5zZXROYW1lKCdFeGNsdWRlIEZpbGVzIGFuZCBGb2xkZXJzIGdsb2JhbGx5JylcclxuICAgICAgICAuc2V0RGVzYyhgQ3VycmVudGx5ICR7dGhpcy5wbHVnaW4uc2V0dGluZ3MuZXhjbHVkZS5zZWxlY3RlZEZvbGRlcnMubGVuZ3RofSBmb2xkZXJzIGFuZCAke3RoaXMucGx1Z2luLnNldHRpbmdzLmV4Y2x1ZGUuc2VsZWN0ZWRGaWxlcy5sZW5ndGh9IGZpbGVzIHdpbGwgYmUgJHt0aGlzLnBsdWdpbi5zZXR0aW5ncy5leGNsdWRlLm1vZGV9ZC5gKVxyXG4gICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IHtcclxuICAgICAgICAgICAgYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAuc2V0SWNvbignZm9sZGVyLXgnKVxyXG4gICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoJ0V4Y2x1ZGUnKVxyXG4gICAgICAgICAgICAgICAgLnNldEN0YSgpIC8vIE1ha2VzIHRoZSBidXR0b24gbW9yZSBwcm9taW5lbnRcclxuICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBvcGVuRGlyZWN0b3J5U2VsZWN0aW9uTW9kYWwoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5leGNsdWRlLnNlbGVjdGVkRm9sZGVycyB8fCBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZXhjbHVkZS5zZWxlY3RlZEZpbGVzIHx8IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uTW9kZTogdGhpcy5wbHVnaW4uc2V0dGluZ3MuZXhjbHVkZS5tb2RlIHx8ICdleGNsdWRlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlNb2RlOiB0aGlzLnBsdWdpbi5zZXR0aW5ncy5leGNsdWRlLmRpc3BsYXkgfHwgJ2ZvbGRlcnMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uU2VsZWN0aW9uTW9kZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25TaG93RmlsZXM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChyZXN1bHQ6IERpcmVjdG9yeVNlbGVjdGlvblJlc3VsdCB8IG51bGwpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5leGNsdWRlLnNlbGVjdGVkRm9sZGVycyA9IHJlc3VsdC5mb2xkZXJzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZXhjbHVkZS5zZWxlY3RlZEZpbGVzID0gcmVzdWx0LmZpbGVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZXhjbHVkZS5tb2RlID0gcmVzdWx0Lm1vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5leGNsdWRlLmRpc3BsYXkgPSByZXN1bHQuZGlzcGxheTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpOyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pOyAgXHJcblxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgIC5zZXROYW1lKCdJbmNsdWRlIEZpbGVzIGFuZCBGb2xkZXJzIGdsb2JhbGx5JylcclxuICAgICAgICAuc2V0RGVzYyhgQ3VycmVudGx5ICR7dGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5jbHVkZS5zZWxlY3RlZEZvbGRlcnMubGVuZ3RofSBmb2xkZXJzIGFuZCAke3RoaXMucGx1Z2luLnNldHRpbmdzLmluY2x1ZGUuc2VsZWN0ZWRGaWxlcy5sZW5ndGh9IGZpbGVzIHdpbGwgYmUgJHt0aGlzLnBsdWdpbi5zZXR0aW5ncy5pbmNsdWRlLm1vZGV9ZCBldmVuIGlmIHRoZXkgYXJlIGV4Y2x1ZGVkLmApXHJcbiAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4ge1xyXG4gICAgICAgICAgICBidXR0b25cclxuICAgICAgICAgICAgICAgIC5zZXRJY29uKCdmb2xkZXItY2hlY2snKVxyXG4gICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoJ0luY2x1ZGUnKVxyXG4gICAgICAgICAgICAgICAgLnNldEN0YSgpIC8vIE1ha2VzIHRoZSBidXR0b24gbW9yZSBwcm9taW5lbnRcclxuICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBvcGVuRGlyZWN0b3J5U2VsZWN0aW9uTW9kYWwoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5pbmNsdWRlLnNlbGVjdGVkRm9sZGVycyB8fCBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5jbHVkZS5zZWxlY3RlZEZpbGVzIHx8IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uTW9kZTogdGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5jbHVkZS5tb2RlIHx8ICdpbmNsdWRlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlNb2RlOiB0aGlzLnBsdWdpbi5zZXR0aW5ncy5pbmNsdWRlLmRpc3BsYXkgfHwgJ2ZvbGRlcnMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uU2VsZWN0aW9uTW9kZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25TaG93RmlsZXM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChyZXN1bHQ6IERpcmVjdG9yeVNlbGVjdGlvblJlc3VsdCB8IG51bGwpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5pbmNsdWRlLnNlbGVjdGVkRm9sZGVycyA9IHJlc3VsdC5mb2xkZXJzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5jbHVkZS5zZWxlY3RlZEZpbGVzID0gcmVzdWx0LmZpbGVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5jbHVkZS5tb2RlID0gcmVzdWx0Lm1vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5pbmNsdWRlLmRpc3BsYXkgPSByZXN1bHQuZGlzcGxheTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpOyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pOyAgICBcclxuICAgICAgICBcclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ0RlYnVnJylcclxuICAgICAgICAgICAgLnNldERlc2MoJ1NlbGVjdCB0aGUgZGVidWcgbGV2ZWwgdG8gc2hvdyBpbiB0aGUgY29uc29sZScpXHJcbiAgICAgICAgICAgIC5hZGREcm9wZG93bigoZHJvcGRvd246IERyb3Bkb3duQ29tcG9uZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBkcm9wZG93bi5hZGRPcHRpb25zKFxyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5mcm9tRW50cmllcyhsb2dnZXIuZ2V0TGV2ZWxOYW1lcygpLm1hcChsZXZlbCA9PiBbbGV2ZWwsIGxldmVsXSkpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgZHJvcGRvd24uc2V0VmFsdWUobG9nZ2VyLmdldExldmVsTmFtZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZWJ1Z0xldmVsKSk7XHJcbiAgICAgICAgICAgICAgICBkcm9wZG93bi5vbkNoYW5nZSgodmFsdWU6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmRlYnVnTGV2ZWwgPSBsb2dnZXIuZ2V0TGV2ZWxCeU5hbWUodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5zZXRMZXZlbCh0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZWJ1Z0xldmVsKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcbiAgXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdEZWxheSBjcmVhdGUgZXZlbnQgKHVudGlsIGJldHRlciBzb2x1dGlvbiBpcyBmb3VuZCknKSAvL1RPRE86IHJlbW92ZSB0aGlzIHNldHRpbmcgd2hlbiBhIGJldHRlciBzb2x1dGlvbiBpcyBmb3VuZFxyXG4gICAgICAgICAgICAuc2V0RGVzYygnU2V0IGEgZGVsYXkgYmVmb3JlIHRyaWdnZXJpbmcgdGhlIGNyZWF0ZSBldmVudCB0byBhbGxvdyBmb3IgZmlsZSBjcmVhdGlvbiB0byBjb21wbGV0ZS4gKGluIG1pbGxpc2Vjb25kcyknKVxyXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHtcclxuICAgICAgICAgICAgICAgIHRleHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZGVsYXlDcmVhdGVFdmVudC50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgIHRleHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZGVsYXlDcmVhdGVFdmVudCA9IHBhcnNlSW50KHZhbHVlKSB8fCAwOyAvLyBFbnN1cmUgaXQncyBhIG51bWJlclxyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMucnVsZXNDb250YWluZXIgPSBjb250YWluZXJFbC5jcmVhdGVEaXYoJ3Byb3BlcnRpZXMtbGlzdCcpO1xyXG4gICAgICAgIGNvbnN0IHJ1bGVzVGFibGUgPSBuZXcgUnVsZXNUYWJsZSh0aGlzLmFwcCwgdGhpcy5wbHVnaW4sdGhpcy5ydWxlc0NvbnRhaW5lcix0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJDb25maWcpO1xyXG4gICAgICAgIHJ1bGVzVGFibGUuZGlzcGxheSgpO1xyXG5cclxuICAgICAgICAvLyAtLS0gQmFja3VwIGFuZCBSZXN0b3JlIEJ1dHRvbnMgLS0tXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKFwiQmFja3VwICYgUmVzdG9yZSBDb25maWd1cmF0aW9uXCIpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKFwiRXhwb3J0IHlvdXIgY3VycmVudCBjb25maWcgYXMgYSBKU09OIGZpbGUgb3IgcmVzdG9yZSBmcm9tIGEgYmFja3VwLlwiKVxyXG4gICAgICAgICAgICAuYWRkQnV0dG9uKGJ0biA9PiB7XHJcbiAgICAgICAgICAgICAgICBidG4uc2V0QnV0dG9uVGV4dChcIkJhY2t1cFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRJY29uKFwiZG93bmxvYWRcIilcclxuICAgICAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFTdHIgPSBKU09OLnN0cmluZ2lmeSh0aGlzLnBsdWdpbi5zZXR0aW5ncywgbnVsbCwgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbZGF0YVN0cl0sIHsgdHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuaHJlZiA9IHVybDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYS5kb3dubG9hZCA9IFwiZnJvbnRtYXR0ZXItYXV0b21hdGUtYmFja3VwLmpzb25cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYS5jbGljaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hZGRCdXR0b24oYnRuID0+IHtcclxuICAgICAgICAgICAgICAgIGJ0bi5zZXRCdXR0b25UZXh0KFwiUmVzdG9yZVwiKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRJY29uKFwidXBsb2FkXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQudHlwZSA9IFwiZmlsZVwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5hY2NlcHQgPSBcIi5qc29uLGFwcGxpY2F0aW9uL2pzb25cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQub25jaGFuZ2UgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlucHV0LmZpbGVzIHx8IGlucHV0LmZpbGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsZSA9IGlucHV0LmZpbGVzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IGZpbGUudGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZSh0ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcHRpb25hbGx5IHZhbGlkYXRlIGRhdGEgaGVyZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiRnJvbnRtYXR0ZXIgQXV0b21hdGVcXG5Db25maWd1cmF0aW9uIHJlc3RvcmVkIGZyb20gYmFja3VwLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiRnJvbnRtYXR0ZXIgQXV0b21hdGVcXG5GYWlsZWQgdG8gcmVzdG9yZTogSW52YWxpZCBKU09OIGZpbGUuXCIsMjAwMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LmNsaWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgIH1cclxufSIsICJpbXBvcnQgeyBBcHAsIE5vdGljZSwgU3VnZ2VzdE1vZGFsLCBURmlsZSB9IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IHsgUHJvcGVydHlUeXBlSW5mbywgUHJvcGVydHlUeXBlLCBPYnNpZGlhblByb3BlcnR5VHlwZXN9IGZyb20gJy4vdHlwZXMnO1xyXG5pbXBvcnQgeyBERUJVRywgRVJST1IsIGxvZ2dlciB9IGZyb20gJy4vTG9nJztcclxuXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX1BST1BFUlRZX1RZUEVfSU5GTzogUHJvcGVydHlUeXBlSW5mbyA9IHtcclxuICAgIG5hbWUgOiBcIlwiLFxyXG4gICAgdHlwZSA6ICd0ZXh0JyxcclxuICAgIGlzQXJyYXk6IGZhbHNlLFxyXG4gICAgdmFsdWVzOiBbXSxcclxuICAgIHNvdXJjZTogJ3JlZ2lzdGVyZWQnLFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgYWxsIGF2YWlsYWJsZSBwcm9wZXJ0aWVzIHdpdGggdGhlaXIgdHlwZSBpbmZvcm1hdGlvblxyXG4gKiBAcGFyYW0gYXBwIFRoZSBPYnNpZGlhbiBBcHAgaW5zdGFuY2VcclxuICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGFycmF5IG9mIFByb3BlcnR5VHlwZUluZm9cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbGxQcm9wZXJ0aWVzV2l0aFR5cGVzKGFwcDogQXBwKTogUHJvbWlzZTxQcm9wZXJ0eVR5cGVJbmZvW10+IHtcclxuICAgIC8vIFRyeSB0byBnZXQgcmVnaXN0ZXJlZCBwcm9wZXJ0aWVzIChmYWxsYmFjayB0byBlbXB0eSBhcnJheSBpZiBBUEkgY2hhbmdlZClcclxuICAgIGNvbnN0IHJlZ2lzdGVyZWRQcm9wcyA9IGF3YWl0IGdldFJlZ2lzdGVyZWRQcm9wZXJ0aWVzU2FmZShhcHApO1xyXG4gICAgXHJcbiAgICAvLyBHZXQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGZvdW5kIGluIG5vdGVzXHJcbiAgICBjb25zdCBmaWxlUHJvcHMgPSBhd2FpdCBnZXRQcm9wZXJ0aWVzRnJvbUZpbGVzKGFwcCk7XHJcbiAgICBcclxuICAgIC8vIENvbWJpbmUgcmVzdWx0cyAoZmF2b3IgcmVnaXN0ZXJlZCBwcm9wZXJ0aWVzIHdoZW4gZHVwbGljYXRlcyBleGlzdClcclxuICAgIGNvbnN0IGNvbWJpbmVkID0gbmV3IE1hcDxzdHJpbmcsIFByb3BlcnR5VHlwZUluZm8+KCk7XHJcbiAgICBcclxuICAgIC8vIEFkZCBwcm9wZXJ0aWVzIGZvdW5kIGluIGZpbGVzIGZpcnN0XHJcbiAgICBmaWxlUHJvcHMuZm9yRWFjaChwcm9wID0+IHtcclxuICAgICAgICBjb21iaW5lZC5zZXQocHJvcC5uYW1lLCBwcm9wKTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBUaGVuIG92ZXJyaWRlIHdpdGggcmVnaXN0ZXJlZCBwcm9wZXJ0aWVzICh3aGljaCBoYXZlIG1vcmUgY29tcGxldGUgdHlwZSBpbmZvKVxyXG4gICAgcmVnaXN0ZXJlZFByb3BzLmZvckVhY2gocHJvcCA9PiB7XHJcbiAgICAgICAgY29tYmluZWQuc2V0KHByb3AubmFtZSwgcHJvcCk7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIEFycmF5LmZyb20oY29tYmluZWQudmFsdWVzKCkpLnNvcnQoKGEsIGIpID0+IGEubmFtZS5sb2NhbGVDb21wYXJlKGIubmFtZSkpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IFByb3BlcnRpZXMgZnJvbSBNZXRhZGF0YU1hbmFnZXJcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9wZXJ0aWVzRnJvbU1ldGFkYXRhTWFuYWdlcihhcHA6IEFwcCk6IFByb3BlcnR5VHlwZUluZm9bXSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhTWFuYWdlciA9IChhcHAgYXMgYW55KS5tZXRhZGF0YVR5cGVNYW5hZ2VyO1xyXG4gICAgICAgIGxvZ2dlci5sb2coREVCVUcsXCJnZXQgcHJvcGVydGllczpcIixtZXRhZGF0YU1hbmFnZXIpO1xyXG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKG1ldGFkYXRhTWFuYWdlci5wcm9wZXJ0aWVzKS5tYXAoICh2YWx1ZTphbnkpOlByb3BlcnR5VHlwZUluZm8gPT4gKHtcclxuICAgICAgICAgICAgbmFtZTogdmFsdWUubmFtZSxcclxuICAgICAgICAgICAgdHlwZTogdmFsdWUudHlwZSxcclxuICAgICAgICAgICAgY291bnQ6IHZhbHVlLmNvdW50LFxyXG4gICAgICAgICAgICBzb3VyY2U6ICdyZWdpc3RlcmVkJ1xyXG4gICAgICAgIH0pKS5zb3J0KChhLCBiKSA9PiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpKTtcclxuXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhFUlJPUixcIkNvdWxkbid0IGFjY2VzcyBwcm9wZXJ0aWVzIGZyb20gTWV0YWRhdGEgTWFuYWdlclwiLCBlKTtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEdldCBUeXBlcyBmcm9tIE1ldGFkYXRhTWFuYWdlclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFR5cGVzRnJvbU1ldGFkYXRhTWFuYWdlcihhcHA6IEFwcCk6IGFueSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhTWFuYWdlciA9IChhcHAgYXMgYW55KS5tZXRhZGF0YVR5cGVNYW5hZ2VyO1xyXG4gICAgICAgIGxvZ2dlci5sb2coREVCVUcsXCJnZXQgdHlwZXM6XCIsbWV0YWRhdGFNYW5hZ2VyKTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhtZXRhZGF0YU1hbmFnZXIucmVnaXN0ZXJlZFR5cGVXaWRnZXRzKS5tYXAoICh2YWx1ZTphbnksIGluZGV4LCBhcnJheSk6UHJvcGVydHlUeXBlICA9PiAoe1xyXG4gICAgICAgICAgICB0eXBlOiB2YWx1ZS50eXBlLFxyXG4gICAgICAgICAgICBpY29uOiB2YWx1ZS5pY29uLFxyXG4gICAgICAgICAgICBqc1R5cGU6ICcnLFxyXG4gICAgICAgIH0pKS5zb3J0KChhLCBiKSA9PiBhLnR5cGUubG9jYWxlQ29tcGFyZShiLnR5cGUpKTtcclxuXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhFUlJPUixcIkNvdWxkbid0IGFjY2VzcyBwcm9wZXJ0aWVzIGZyb20gTWV0YWRhdGEgTWFuYWdlclwiLCBlKTtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFNhZmUgbWV0aG9kIHRvIGdldCByZWdpc3RlcmVkIHByb3BlcnRpZXMgdGhhdCB3b24ndCB0aHJvdyBpZiBBUEkgY2hhbmdlc1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZFByb3BlcnRpZXNTYWZlKGFwcDogQXBwKTogUHJvbWlzZTxQcm9wZXJ0eVR5cGVJbmZvW10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgbWV0YWRhdGFNYW5hZ2VyID0gKGFwcCBhcyBhbnkpLm1ldGFkYXRhVHlwZU1hbmFnZXI7XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhERUJVRyxtZXRhZGF0YU1hbmFnZXIpO1xyXG4gICAgICAgIGlmICghbWV0YWRhdGFNYW5hZ2VyKSByZXR1cm4gW107XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVHJ5IGRpZmZlcmVudCB3YXlzIHRvIGdldCBwcm9wZXJ0aWVzIGJhc2VkIG9uIE9ic2lkaWFuIHZlcnNpb25cclxuICAgICAgICBpZiAodHlwZW9mIG1ldGFkYXRhTWFuYWdlci5nZXRBbGxGcm9udG1hdHRlclR5cGVzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIC8vIE9sZGVyIE9ic2lkaWFuIHZlcnNpb25zXHJcbiAgICAgICAgICAgIGNvbnN0IGZyb250bWF0dGVyVHlwZXMgPSBtZXRhZGF0YU1hbmFnZXIuZ2V0QWxsRnJvbnRtYXR0ZXJUeXBlcygpO1xyXG4gICAgICAgICAgICByZXR1cm4gZnJvbnRtYXR0ZXJUeXBlcy5tYXAoKG5hbWU6IHN0cmluZykgPT4gKHtcclxuICAgICAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsIC8vIERlZmF1bHQgdHlwZSBpZiB3ZSBjYW4ndCBnZXQgbW9yZSBpbmZvXHJcbiAgICAgICAgICAgICAgICBzb3VyY2U6ICdyZWdpc3RlcmVkJ1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbWV0YWRhdGFNYW5hZ2VyLmdldFByb3BlcnRpZXMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgLy8gTmV3ZXIgT2JzaWRpYW4gdmVyc2lvbnMgbWlnaHQgdXNlIHRoaXNcclxuICAgICAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IG1ldGFkYXRhTWFuYWdlci5nZXRQcm9wZXJ0aWVzKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhwcm9wZXJ0aWVzKS5tYXAoKFtuYW1lLCB0eXBlXTogW3N0cmluZywgYW55XSkgPT4gKHtcclxuICAgICAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICAgICAgc291cmNlOiAncmVnaXN0ZXJlZCdcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBsb2dnZXIubG9nKEVSUk9SLFwiQ291bGRuJ3QgYWNjZXNzIHJlZ2lzdGVyZWQgcHJvcGVydGllczpcIiwgZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTY2FucyBmaWxlcyBmb3IgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHdpdGggdHlwZSBpbmZlcmVuY2VcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGdldFByb3BlcnRpZXNGcm9tRmlsZXMoYXBwOiBBcHApOiBQcm9taXNlPFByb3BlcnR5VHlwZUluZm9bXT4ge1xyXG4gICAgY29uc3QgZmlsZXMgPSBhcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpO1xyXG4gICAgY29uc3QgcHJvcGVydHlNYXAgPSBuZXcgTWFwPHN0cmluZywgeyB2YWx1ZXM6IFNldDxhbnk+LCB0eXBlczogU2V0PHN0cmluZz4gfT4oKTtcclxuICAgIFxyXG4gICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzLnNsaWNlKDAsIDEwMDApKSB7IC8vIExpbWl0IHRvIDEwMDAgZmlsZXMgZm9yIHBlcmZvcm1hbmNlXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgY2FjaGUgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk7XHJcbiAgICAgICAgICAgIGlmIChjYWNoZT8uZnJvbnRtYXR0ZXIpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGNhY2hlLmZyb250bWF0dGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdwb3NpdGlvbicpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJvcGVydHlNYXAuaGFzKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlNYXAuc2V0KGtleSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBuZXcgU2V0KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlczogbmV3IFNldCgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wRGF0YSA9IHByb3BlcnR5TWFwLmdldChrZXkpITtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wRGF0YS52YWx1ZXMuYWRkKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wRGF0YS50eXBlcy5hZGQoaW5mZXJUeXBlRnJvbVZhbHVlKHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBsb2dnZXIubG9nKEVSUk9SLGBFcnJvciBwcm9jZXNzaW5nIGZpbGUgJHtmaWxlLnBhdGh9OmAsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBBcnJheS5mcm9tKHByb3BlcnR5TWFwLmVudHJpZXMoKSkubWFwKChbbmFtZSwgZGF0YV0pID0+IHtcclxuICAgICAgICBjb25zdCB0eXBlID0gZGV0ZXJtaW5lUHJpbWFyeVR5cGUoZGF0YS50eXBlcyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgaXNBcnJheTogZGF0YS50eXBlcy5oYXMoJ2FycmF5JyksXHJcbiAgICAgICAgICAgIHZhbHVlczogZGF0YS52YWx1ZXMuc2l6ZSA+IDAgPyBBcnJheS5mcm9tKGRhdGEudmFsdWVzKS5tYXAoU3RyaW5nKSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgc291cmNlOiAnaW5mZXJyZWQnXHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lcyB0aGUgcHJpbWFyeSB0eXBlIGZyb20gYSBTZXQgb2Ygb2JzZXJ2ZWQgdHlwZXNcclxuICogQHBhcmFtIHR5cGVzIFNldCBvZiBvYnNlcnZlZCB0eXBlcyBmb3IgYSBwcm9wZXJ0eVxyXG4gKiBAcmV0dXJucyBUaGUgbW9zdCBzcGVjaWZpYyB0eXBlIHdlIGNhbiBkZXRlcm1pbmVcclxuICovXHJcbmZ1bmN0aW9uIGRldGVybWluZVByaW1hcnlUeXBlKHR5cGVzOiBTZXQ8c3RyaW5nPik6IE9ic2lkaWFuUHJvcGVydHlUeXBlcyB7XHJcbiAgICAvLyBIYW5kbGUgZW1wdHkgY2FzZSAoc2hvdWxkbid0IGhhcHBlbiBidXQgVHlwZVNjcmlwdCB3YW50cyB1cyB0byBjaGVjaylcclxuICAgIGlmICh0eXBlcy5zaXplID09PSAwKSByZXR1cm4gJ3RleHQnO1xyXG4gICAgXHJcbiAgICAvLyBJZiBvbmx5IG9uZSB0eXBlIG9ic2VydmVkLCB1c2UgdGhhdFxyXG4gICAgaWYgKHR5cGVzLnNpemUgPT09IDEpIHtcclxuICAgICAgICBjb25zdCBvbmx5VHlwZSA9IHR5cGVzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcclxuICAgICAgICByZXR1cm4gKG9ubHlUeXBlICE9PSB1bmRlZmluZWQgPyBvbmx5VHlwZSA6ICd0ZXh0JykgYXMgT2JzaWRpYW5Qcm9wZXJ0eVR5cGVzO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBQcmlvcml0eSBvcmRlciBmb3IgdHlwZSByZXNvbHV0aW9uXHJcbiAgICBjb25zdCB0eXBlUHJpb3JpdHk6IE9ic2lkaWFuUHJvcGVydHlUeXBlc1tdID0gW1xyXG4gICAgICAgICdkYXRlJyxcclxuICAgICAgICAnZGF0ZXRpbWUnLFxyXG4gICAgICAgICdjaGVja2JveCcsXHJcbiAgICAgICAgJ251bWJlcicsXHJcbiAgICAgICAgJ3RhZ3MnLFxyXG4gICAgICAgICdhbGlhc2VzJyxcclxuICAgICAgICAnbXVsdGl0ZXh0JyxcclxuICAgICAgICAndGV4dCcgLy8gZmFsbGJhY2tcclxuICAgIF07XHJcbiAgICBcclxuICAgIC8vIFJldHVybiB0aGUgaGlnaGVzdCBwcmlvcml0eSB0eXBlIHdlIGZpbmRcclxuICAgIGZvciAoY29uc3QgdHlwZSBvZiB0eXBlUHJpb3JpdHkpIHtcclxuICAgICAgICBpZiAodHlwZXMuaGFzKHR5cGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gRmluYWwgZmFsbGJhY2tcclxuICAgIHJldHVybiAndGV4dCc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbmhhbmNlZCB0eXBlIGluZmVyZW5jZSB3aXRoIGJldHRlciBkYXRlIGRldGVjdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gaW5mZXJUeXBlRnJvbVZhbHVlKHZhbHVlOiBhbnkpOiBzdHJpbmcge1xyXG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gJ251bGwnO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBDaGVjayBhcnJheSBmaXJzdFxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgYXJyYXkgZWxlbWVudCB0eXBlc1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50VHlwZXMgPSBuZXcgU2V0KHZhbHVlLm1hcChpbmZlclR5cGVGcm9tVmFsdWUpKTtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnRUeXBlcy5zaXplID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYGFycmF5PCR7ZWxlbWVudFR5cGVzLnZhbHVlcygpLm5leHQoKS52YWx1ZX0+YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJ2FycmF5JztcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQ2hlY2sgYmFzaWMgdHlwZXNcclxuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XHJcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6IHJldHVybiAnYm9vbGVhbic7XHJcbiAgICAgICAgY2FzZSAnbnVtYmVyJzogcmV0dXJuICdudW1iZXInO1xyXG4gICAgICAgIGNhc2UgJ29iamVjdCc6IHJldHVybiAnb2JqZWN0JzsgLy8gZm9yIGZ1dHVyZSBleHBhbnNpb25cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gTXVzdCBiZSBzdHJpbmcgYXQgdGhpcyBwb2ludCAtIGNoZWNrIGZvciBzcGVjaWFsIHN0cmluZyBmb3JtYXRzXHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIC8vIElTTyBEYXRlIChZWVlZLU1NLUREKVxyXG4gICAgICAgIGlmICgvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9JC8udGVzdCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdkYXRlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gSVNPIERhdGVUaW1lXHJcbiAgICAgICAgaWYgKC9eXFxkezR9LVxcZHsyfS1cXGR7Mn1bVCBdXFxkezJ9OlxcZHsyfTpcXGR7Mn0vLnRlc3QodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnZGF0ZXRpbWUnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBPYnNpZGlhbiB0YWdcclxuICAgICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aCgnIycpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAndGFnJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIERlZmF1bHQgdG8gc3RyaW5nXHJcbiAgICByZXR1cm4gJ3N0cmluZyc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHZhbHVlKHZhbHVlOiB1bmtub3duLCBpbmRleDogbnVtYmVyLCBhcnJheTogdW5rbm93bltdKTogdW5rbm93biB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZC4nKTtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFNlbGVjdFByb3BlcnR5IGV4dGVuZHMgU3VnZ2VzdE1vZGFsPFByb3BlcnR5VHlwZUluZm8+IHtcclxuICAgIHByaXZhdGUgb25TdWJtaXQ6IChyZXN1bHQ6IFByb3BlcnR5VHlwZUluZm8pID0+IHZvaWQ7XHJcbiAgICBwcm9wZXJ0eTogUHJvcGVydHlUeXBlSW5mbyB8IHVuZGVmaW5lZDtcclxuICAgIGtub3duUHJvcGVydGllczpQcm9wZXJ0eVR5cGVJbmZvW107XHJcbiAgICB0eXBlZFRleHQ6IHN0cmluZztcclxuICAgIG5ld1RleHRGbGFnOiBCb29sZWFuO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yIChhcHA6QXBwLCBrbm93blByb3BlcnRpZXM6UHJvcGVydHlUeXBlSW5mb1tdLCBwcm9wZXJ0eTogUHJvcGVydHlUeXBlSW5mbyB8IHVuZGVmaW5lZCwgb25TdWJtaXQ6IChyZXN1bHQ6IFByb3BlcnR5VHlwZUluZm8pID0+IHZvaWQpIHtcclxuICAgICAgICBzdXBlcihhcHApO1xyXG4gICAgICAgIHRoaXMub25TdWJtaXQgPSBvblN1Ym1pdDtcclxuICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XHJcbiAgICAgICAgdGhpcy50eXBlZFRleHQgPSAnJztcclxuICAgICAgICB0aGlzLm5ld1RleHRGbGFnID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmtub3duUHJvcGVydGllcyA9IGtub3duUHJvcGVydGllcztcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgYWxsIGF2YWlsYWJsZSBzdWdnZXN0aW9ucy5cclxuICAgIGdldFN1Z2dlc3Rpb25zKHF1ZXJ5OiBzdHJpbmcpOiBQcm9wZXJ0eVR5cGVJbmZvW10ge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMua25vd25Qcm9wZXJ0aWVzLmZpbHRlcigocHJvcGVydHkpID0+IHByb3BlcnR5Lm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhxdWVyeS50b0xvd2VyQ2FzZSgpKSk7XHJcbiAgICAgICAgdGhpcy5uZXdUZXh0RmxhZyA9IChyZXN1bHQubGVuZ3RoID09PSAwKTtcclxuICAgICAgICB0aGlzLnR5cGVkVGV4dCA9IHF1ZXJ5O1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBvbk9wZW4oKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvcGVydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRQbGFjZWhvbGRlcih0aGlzLnByb3BlcnR5Lm5hbWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UGxhY2Vob2xkZXIoJ25vIHByb3BlcnR5IHNlbGVjdGVkIScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldFRpdGxlKCdTZWxlY3Qgb3IgdHlwZSBhIHByb3BlcnR5IG5hbWUnKTtcclxuICAgIH1cclxuICAgIC8vIFJlbmRlcnMgZWFjaCBzdWdnZXN0aW9uIGl0ZW0uXHJcbiAgICByZW5kZXJTdWdnZXN0aW9uKHByb3BlcnR5OiBQcm9wZXJ0eVR5cGVJbmZvLCBlbDogSFRNTEVsZW1lbnQpIHtcclxuICAgICAgZWwuY3JlYXRlRWwoJ2RpdicsIHsgdGV4dDogcHJvcGVydHkubmFtZSB9KTtcclxuICAgICAgZWwuY3JlYXRlRWwoJ3NtYWxsJywgeyB0ZXh0OiBwcm9wZXJ0eS50eXBlIH0pO1xyXG4gICAgfVxyXG4gICAgb25DbG9zZSgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5uZXdUZXh0RmxhZyAmJiB0aGlzLnByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydHkubmFtZSA9IHRoaXMudHlwZWRUZXh0O1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnR5LnR5cGUgPSAndGV4dCc7XHJcbiAgICAgICAgICAgIHRoaXMub25TdWJtaXQodGhpcy5wcm9wZXJ0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFBlcmZvcm0gYWN0aW9uIG9uIHRoZSBzZWxlY3RlZCBzdWdnZXN0aW9uLlxyXG4gICAgb25DaG9vc2VTdWdnZXN0aW9uKHByb3BlcnR5OiBQcm9wZXJ0eVR5cGVJbmZvLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGV2dCBpbnN0YW5jZW9mIEtleWJvYXJkRXZlbnQpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmxvZyhERUJVRyxga2V5Ym9hcmQgJHt0aGlzLnR5cGVkVGV4dH0gJHt0aGlzLm5ld1RleHRGbGFnfWAsIHByb3BlcnR5KVxyXG4gICAgICAgIH1cclxuICAgICAgICBsb2dnZXIubG9nKERFQlVHLCdvbkNob29zZVN1Z2dlc3Rpb24nLCBldnQpXHJcbiAgICAgICAgdGhpcy5vblN1Ym1pdChwcm9wZXJ0eSk7XHJcbiAgICB9XHJcbiAgfVxyXG4iLCAiaW1wb3J0IHsgTm90aWNlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBFcnJvck1hbmFnZXIgfSBmcm9tIFwiLi9FcnJvclwiO1xuXG4vLyBOdW1lcmljIGxvZyBsZXZlbHMgZm9yIGVhc3kgY29tcGFyaXNvbiBhbmQgdXNhZ2VcbmV4cG9ydCBjb25zdCBMT0cgPSAwO1xuZXhwb3J0IGNvbnN0IEFMRVJUID0gMTtcbmV4cG9ydCBjb25zdCBFUlJPUiA9IDI7XG5leHBvcnQgY29uc3QgV0FSTklORyA9IDM7XG5leHBvcnQgY29uc3QgSU5GTyA9IDQ7XG5leHBvcnQgY29uc3QgREVCVUcgPSA1O1xuZXhwb3J0IGNvbnN0IFRSQUNFID0gNjtcblxuZXhwb3J0IHR5cGUgTG9nTGV2ZWwgPSAwIHwgMSB8IDIgfCAzIHwgNCB8IDUgfCA2O1xuXG5leHBvcnQgZW51bSBMb2dEZXZpY2VzIHtcbiAgICBDT05TT0xFID0gXCJjb25zb2xlXCIsXG4gICAgTk9USUZJQ0FUSU9OID0gXCJub3RpZmljYXRpb25cIixcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZ1VwZGF0ZShtc2c6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IG5vdGljZSA9IG5ldyBOb3RpY2UoXCJcIiwgMTUwMDApO1xuICAgIG5vdGljZS5tZXNzYWdlRWwuaW5uZXJIVE1MID0gYDxiPkZyb250bWF0dGVyIEF1dG9tYXRlIHVwZGF0ZTwvYj46PGJyLz4ke21zZ31gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9nRXJyb3IoZTogRXJyb3IgfCBFcnJvck1hbmFnZXIpOiB2b2lkIHtcbiAgICBjb25zdCBub3RpY2UgPSBuZXcgTm90aWNlKFwiXCIsIDgwMDApO1xuICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3JNYW5hZ2VyICYmIGUuY29uc29sZV9tc2cpIHtcbiAgICAgICAgbm90aWNlLm1lc3NhZ2VFbC5pbm5lckhUTUwgPSBgPGI+RnJvbnRtYXR0ZXIgQXV0b21hdGUgRXJyb3I8L2I+Ojxici8+JHtlLm1lc3NhZ2V9PGJyLz5DaGVjayBjb25zb2xlIGZvciBtb3JlIGluZm9ybWF0aW9uYDtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRnJvbnRtYXR0ZXIgRXJyb3I6YCwgZS5tZXNzYWdlLCBcIlxcblwiLCBlLmNvbnNvbGVfbXNnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBub3RpY2UubWVzc2FnZUVsLmlubmVySFRNTCA9IGA8Yj5Gcm9udG1hdHRlciBBdXRvbWF0ZSBFcnJvcjwvYj46PGJyLz4ke2UubWVzc2FnZX1gO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIExvZ2dlciB7XG4gICAgcHJpdmF0ZSBsb2dMZXZlbDogTG9nTGV2ZWwgPSBJTkZPO1xuXG4gICAgc2V0TGV2ZWwobGV2ZWw6IHN0cmluZyB8IG51bWJlcikge1xuICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ0xldmVsID0gbGV2ZWwgYXMgTG9nTGV2ZWw7XG4gICAgICAgICAgICB0aGlzLmxvZyhMT0csIGBMb2cgbGV2ZWwgc2V0IHRvICR7dGhpcy5nZXRMZXZlbE5hbWUodGhpcy5sb2dMZXZlbCl9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBsZXZlbE5hbWUgPSBsZXZlbC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgbGV2ZWxJbmRleCA9IHRoaXMuZ2V0TGV2ZWxOYW1lcygpLmluZGV4T2YobGV2ZWxOYW1lKSArIDEgYXMgTG9nTGV2ZWw7XG4gICAgICAgICAgICBpZiAobGV2ZWxJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRMZXZlbChsZXZlbEluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2coV0FSTklORyxgSW52YWxpZCBsb2cgbGV2ZWwgbmFtZTogJHtsZXZlbE5hbWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRMZXZlbCgpOiBMb2dMZXZlbCB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZ0xldmVsO1xuICAgIH1cblxuICAgIGdldExldmVsQnlOYW1lKGxldmVsTmFtZTogc3RyaW5nKTogTG9nTGV2ZWwge1xuICAgICAgICBjb25zdCBsZXZlbEluZGV4ID0gdGhpcy5nZXRMZXZlbE5hbWVzKCkuaW5kZXhPZihsZXZlbE5hbWUudG9VcHBlckNhc2UoKSkgKyAxO1xuICAgICAgICBpZiAobGV2ZWxJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbGV2ZWxJbmRleCBhcyBMb2dMZXZlbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nKFdBUk5JTkcsYEludmFsaWQgbG9nIGxldmVsIG5hbWU6ICR7bGV2ZWxOYW1lfWApO1xuICAgICAgICAgICAgcmV0dXJuIElORk87IC8vIERlZmF1bHQgdG8gSU5GTyBpZiBpbnZhbGlkXG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TGV2ZWxCeUluZGV4KGxldmVsSW5kZXg6IG51bWJlcik6IExvZ0xldmVsIHtcbiAgICAgICAgaWYgKGxldmVsSW5kZXggPj0gQUxFUlQgJiYgbGV2ZWxJbmRleCA8PSBUUkFDRSkge1xuICAgICAgICAgICAgcmV0dXJuIGxldmVsSW5kZXggYXMgTG9nTGV2ZWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhXQVJOSU5HLGBJbnZhbGlkIGxvZyBsZXZlbCBpbmRleDogJHtsZXZlbEluZGV4fWApO1xuICAgICAgICAgICAgcmV0dXJuIElORk87IC8vIERlZmF1bHQgdG8gSU5GTyBpZiBpbnZhbGlkXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRMZXZlbEJ5VmFsdWUobGV2ZWxWYWx1ZTogbnVtYmVyKTogTG9nTGV2ZWwge1xuICAgICAgICBpZiAobGV2ZWxWYWx1ZSA+PSBBTEVSVCAmJiBsZXZlbFZhbHVlIDw9IFRSQUNFKSB7XG4gICAgICAgICAgICByZXR1cm4gbGV2ZWxWYWx1ZSBhcyBMb2dMZXZlbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nKFdBUk5JTkcsYEludmFsaWQgbG9nIGxldmVsIHZhbHVlOiAke2xldmVsVmFsdWV9YCk7XG4gICAgICAgICAgICByZXR1cm4gSU5GTzsgLy8gRGVmYXVsdCB0byBJTkZPIGlmIGludmFsaWRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc2hvdWxkTG9nKGxldmVsOiBMb2dMZXZlbCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAobGV2ZWwgPT09IDApIHJldHVybiB0cnVlOyAvLyBBbHdheXMgbG9nIGxldmVsIDBcbiAgICAgICAgcmV0dXJuIGxldmVsIDw9IHRoaXMubG9nTGV2ZWw7XG4gICAgfVxuXG4gICAgZ2V0TGV2ZWxOYW1lKGxldmVsOiBMb2dMZXZlbCk6IHN0cmluZyB7XG4gICAgICAgIHN3aXRjaCAobGV2ZWwpIHtcbiAgICAgICAgICAgIGNhc2UgQUxFUlQ6IHJldHVybiBcIkFMRVJUXCI7XG4gICAgICAgICAgICBjYXNlIEVSUk9SOiByZXR1cm4gXCJFUlJPUlwiO1xuICAgICAgICAgICAgY2FzZSBXQVJOSU5HOiByZXR1cm4gXCJXQVJOSU5HXCI7XG4gICAgICAgICAgICBjYXNlIElORk86IHJldHVybiBcIklORk9cIjtcbiAgICAgICAgICAgIGNhc2UgREVCVUc6IHJldHVybiBcIkRFQlVHXCI7XG4gICAgICAgICAgICBjYXNlIFRSQUNFOiByZXR1cm4gXCJUUkFDRVwiO1xuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIFwiTE9HXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRMZXZlbE5hbWVzKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIChbQUxFUlQsIEVSUk9SLCBXQVJOSU5HLCBJTkZPLCBERUJVRywgVFJBQ0VdIGFzIExvZ0xldmVsW10pLm1hcChsZXZlbCA9PiB0aGlzLmdldExldmVsTmFtZShsZXZlbCkpO1xuICAgIH1cbiAgICBcbiAgICBsb2cobGV2ZWw6IExvZ0xldmVsLCAuLi5tc2c6IGFueVtdKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5zaG91bGRMb2cobGV2ZWwpKSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgbGV2ZWxOYW1lID0gdGhpcy5nZXRMZXZlbE5hbWUobGV2ZWwpO1xuICAgICAgICBsZXQgY29sb3IgPSBcIlwiO1xuICAgICAgICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgICAgICAgICBjYXNlIEFMRVJUOiAgIGNvbG9yID0gXCJiYWNrZ3JvdW5kOiAjZDMyZjJmOyBjb2xvcjogd2hpdGU7IGZvbnQtd2VpZ2h0OiBib2xkXCI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBFUlJPUjogICBjb2xvciA9IFwiY29sb3I6ICNkMzJmMmY7IGZvbnQtd2VpZ2h0OiBib2xkXCI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBXQVJOSU5HOiBjb2xvciA9IFwiY29sb3I6ICNmYmMwMmQ7IGZvbnQtd2VpZ2h0OiBib2xkXCI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBJTkZPOiAgICBjb2xvciA9IFwiY29sb3I6ICMxOTc2ZDI7IGZvbnQtd2VpZ2h0OiBib2xkXCI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBERUJVRzogICBjb2xvciA9IFwiY29sb3I6ICMzODhlM2M7XCI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBUUkFDRTogICBjb2xvciA9IFwiY29sb3I6ICM2MTYxNjE7XCI7IGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDogICAgICBjb2xvciA9IFwiXCI7IGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGAlY1ske2xldmVsTmFtZX1dYDtcblxuICAgICAgICAvLyBHZXQgdGhlIGNhbGxlciBsaW5lIChzdGFjayBsaW5lIDIpXG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcigpO1xuICAgICAgICBsZXQgY2FsbGVyID0gXCJcIjtcbiAgICAgICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgICAgICAgY29uc3Qgc3RhY2tMaW5lcyA9IGVyci5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgIGlmIChzdGFja0xpbmVzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICAgICAgY2FsbGVyID0gc3RhY2tMaW5lc1syXS50cmltKCk7IC8vIDA6RXJyb3IsIDE6dGhpcyBmdW5jdGlvbiwgMjpjYWxsZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9ubHkgc3R5bGUgdGhlIHByZWZpeCwgbm90IHRoZSBjYWxsZXJcbiAgICAgICAgc3dpdGNoIChsZXZlbCkge1xuICAgICAgICAgICAgY2FzZSBBTEVSVDpcbiAgICAgICAgICAgIGNhc2UgRVJST1I6XG4gICAgICAgICAgICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZChwcmVmaXgsIGNvbG9yLCAuLi5tc2cpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ2FsbGVyIFN0YWNrOlwiLCBlcnIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgV0FSTklORzpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKHByZWZpeCwgY29sb3IsIC4uLm1zZyk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDYWxsZXIgU3RhY2s6XCIsIGVycik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBJTkZPOlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhwcmVmaXgsIGNvbG9yLCAuLi5tc2cpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBERUJVRzpcbiAgICAgICAgICAgIGNhc2UgVFJBQ0U6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQocHJlZml4LCBjb2xvciwgLi4ubXNnKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNhbGxlciBTdGFjazpcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxldmVsID09PSBBTEVSVCB8fCBsZXZlbCA9PT0gRVJST1IpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYDxiPkZyb250bWF0dGVyIEF1dG9tYXRlICR7bGV2ZWxOYW1lfTwvYj46PGJyLz4ke21zZy5qb2luKFwiIFwiKX1gLCA4MDAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdyb3VwQ29sbGFwc2VkKGxldmVsOiBMb2dMZXZlbCwgLi4ubXNnOiBhbnlbXSk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuc2hvdWxkTG9nKGxldmVsKSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBsZXZlbE5hbWUgPSB0aGlzLmdldExldmVsTmFtZShsZXZlbCk7XG4gICAgICAgIGxldCBjb2xvciA9IFwiXCI7XG4gICAgICAgIHN3aXRjaCAobGV2ZWwpIHtcbiAgICAgICAgICAgIGNhc2UgQUxFUlQ6ICAgY29sb3IgPSBcImJhY2tncm91bmQ6ICNkMzJmMmY7IGNvbG9yOiB3aGl0ZTsgZm9udC13ZWlnaHQ6IGJvbGRcIjsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEVSUk9SOiAgIGNvbG9yID0gXCJjb2xvcjogI2QzMmYyZjsgZm9udC13ZWlnaHQ6IGJvbGRcIjsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdBUk5JTkc6IGNvbG9yID0gXCJjb2xvcjogI2ZiYzAyZDsgZm9udC13ZWlnaHQ6IGJvbGRcIjsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIElORk86ICAgIGNvbG9yID0gXCJjb2xvcjogIzE5NzZkMjsgZm9udC13ZWlnaHQ6IGJvbGRcIjsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERFQlVHOiAgIGNvbG9yID0gXCJjb2xvcjogIzM4OGUzYztcIjsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFRSQUNFOiAgIGNvbG9yID0gXCJjb2xvcjogIzYxNjE2MTtcIjsgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OiAgICAgIGNvbG9yID0gXCJcIjsgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlZml4ID0gYCVjWyR7bGV2ZWxOYW1lfV1gO1xuICAgICAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKHByZWZpeCwgY29sb3IsIC4uLm1zZyk7XG4gICAgfVxuXG4gICAgZ3JvdXBFbmQoKTogdm9pZCB7XG4gICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICB9XG5cbiAgICBsb2dVcGRhdGUobXNnOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgbmV3IE5vdGljZShgPGI+RnJvbnRtYXR0ZXIgQXV0b21hdGUgdXBkYXRlPC9iPjo8YnIvPiR7bXNnfWAsIDE1MDAwKTtcbiAgICB9XG5cbiAgICBsb2dFcnJvcihlOiBFcnJvciB8IEVycm9yTWFuYWdlcik6IHZvaWQge1xuICAgICAgICBjb25zdCBub3RpY2UgPSBuZXcgTm90aWNlKFwiXCIsIDgwMDApO1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yTWFuYWdlciAmJiBlLmNvbnNvbGVfbXNnKSB7XG4gICAgICAgICAgICBub3RpY2UubWVzc2FnZUVsLmlubmVySFRNTCA9IGA8Yj5Gcm9udG1hdHRlciBBdXRvbWF0ZSBFcnJvcjwvYj46PGJyLz4ke2UubWVzc2FnZX08YnIvPkNoZWNrIGNvbnNvbGUgZm9yIG1vcmUgaW5mb3JtYXRpb25gO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhFUlJPUixgRnJvbnRtYXR0ZXIgRXJyb3I6YCwgZS5tZXNzYWdlLCBcIlxcblwiLCBlLmNvbnNvbGVfbXNnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vdGljZS5tZXNzYWdlRWwuaW5uZXJIVE1MID0gYDxiPkZyb250bWF0dGVyIEF1dG9tYXRlIEVycm9yPC9iPjo8YnIvPiR7ZS5tZXNzYWdlfWA7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIEV4cG9ydCBhIHNpbmdsZXRvbiBsb2dnZXIgaW5zdGFuY2UgYW5kIHRoZSBsb2cgbGV2ZWwgY29uc3RhbnRzXG5leHBvcnQgY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcigpOyIsICJpbXBvcnQgeyBsb2dFcnJvciB9IGZyb20gXCIuL0xvZ1wiO1xuXG5leHBvcnQgY2xhc3MgRXJyb3JNYW5hZ2VyIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1zZzogc3RyaW5nLCBwdWJsaWMgY29uc29sZV9tc2c/OiBzdHJpbmcpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXJyb3JXcmFwcGVyPFQ+KFxuICAgIGZuOiAoKSA9PiBQcm9taXNlPFQ+LFxuICAgIG1zZzogc3RyaW5nXG4pOiBQcm9taXNlPFQ+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgZm4oKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBFcnJvck1hbmFnZXIpKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSAoZSAmJiB0eXBlb2YgZSA9PT0gXCJvYmplY3RcIiAmJiBcIm1lc3NhZ2VcIiBpbiBlKSA/IChlIGFzIHsgbWVzc2FnZTogc3RyaW5nIH0pLm1lc3NhZ2UgOiBTdHJpbmcoZSk7XG4gICAgICAgICAgICBsb2dFcnJvcihuZXcgRXJyb3JNYW5hZ2VyKG1zZywgZXJyb3JNZXNzYWdlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dFcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbCBhcyBUO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVycm9yV3JhcHBlclN5bmM8VD4oZm46ICgpID0+IFQsIG1zZzogc3RyaW5nKTogVCB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBsb2dFcnJvcihuZXcgRXJyb3JNYW5hZ2VyKG1zZywgZS5tZXNzYWdlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dFcnJvcihuZXcgRXJyb3JNYW5hZ2VyKG1zZywgU3RyaW5nKGUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGwgYXMgVDtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgQXBwLCBub3JtYWxpemVQYXRoLCBUQWJzdHJhY3RGaWxlLCBURmlsZSwgVEZvbGRlciwgVmF1bHQgfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCB7IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIEZyb250bWF0dGVyQXV0b21hdGVTZXR0aW5ncywgUHJvcGVydHlJbmZvLCBQcm9wZXJ0eVR5cGVJbmZvIH0gZnJvbSAnLi90eXBlcydcclxuaW1wb3J0IHsgRXJyb3JNYW5hZ2VyIH0gZnJvbSBcIi4vRXJyb3JcIjtcclxuaW1wb3J0IHsgQWxlcnRNb2RhbCB9IGZyb20gJy4vYWxlcnRCb3gnO1xyXG5pbXBvcnQgeyBkZWxpbWl0ZXIgfSBmcm9tICdwYXRoJztcclxuaW1wb3J0IHsgcnVsZXNNYW5hZ2VyIH0gZnJvbSAnLi9ydWxlcy9ydWxlcyc7XHJcbmltcG9ydCB7IERFQlVHLCBFUlJPUiwgbG9nZ2VyLCBUUkFDRSwgV0FSTklORyB9IGZyb20gJy4vTG9nJztcclxuLyoqXHJcbiAqIFBhcnNlIGEgSmF2YVNjcmlwdCBmdW5jdGlvbiwgY2xlYW4gY29tbWVudHMgYW5kIGRlZmluZSB0aGUgZnVuY3Rpb24gXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBqc0NvZGVcclxuICogQHJldHVybiB7Kn0gIHsoRnVuY3Rpb24gfCBzdHJpbmcgfCB1bmRlZmluZWQpfVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSlNDb2RlKGpzQ29kZTpzdHJpbmcpOiBGdW5jdGlvbiB8IHN0cmluZyB8IHVuZGVmaW5lZCB7XHJcbiAgICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uIChqc0NvZGU6IHN0cmluZyk6IEZ1bmN0aW9uIHwgc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgIGpzQ29kZSA9IGNsZWFuQ29kZVN0cmluZyhqc0NvZGUpO1xyXG4gICAgICAgIHZhciBmdW5jUmVnID0gL2Z1bmN0aW9uICpcXCgoW14oKV0qKVxcKVsgXFxuXFx0XSp7KC4qKX0vZ21pO1xyXG4gICAgICAgIHZhciBtYXRjaCA9IGZ1bmNSZWcuZXhlYyhqc0NvZGUucmVwbGFjZSgvXFxuL2csICcgJykpO1xyXG4gICAgICAgIGlmICghbWF0Y2gpIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBtYXRjaFsxXS5zcGxpdCgnLCcpO1xyXG4gICAgICAgIGFyZ3MucHVzaChtYXRjaFsyXSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbiguLi5hcmdzKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBsb2dnZXIubG9nKEVSUk9SLCdlcnJvciBwYXJzaW5nIEpTIGZ1bmN0aW9uIScsIGVycm9yKTtcclxuICAgICAgICAgICAgcmV0dXJuIChlcnJvciBhcyBFcnJvcikubWVzc2FnZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHBhcnNlRnVuY3Rpb24oanNDb2RlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENsZWFucyBhIEphdmFTY3JpcHQvVHlwZVNjcmlwdCBjb2RlIHN0cmluZyBieSByZW1vdmluZyBjb21tZW50cy5cclxuICogVGhpcyBmdW5jdGlvbiBoYW5kbGVzIGJvdGggc2luZ2xlLWxpbmUgY29tbWVudHMgKGAvLyAuLi5gKSBhbmRcclxuICogbXVsdGktbGluZSBjb21tZW50cyAoYC8qIC4uLiAqXFwvYCkuIEl0IGFsc28gY29ycmVjdGx5IGhhbmRsZXNcclxuICogY29tbWVudHMgd2l0aGluIHN0cmluZ3MgYW5kIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlU3RyaW5nIFRoZSBjb2RlIHN0cmluZyB0byBjbGVhbi5cclxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNsZWFuZWQgY29kZSBzdHJpbmcgd2l0aCBjb21tZW50cyByZW1vdmVkLlxyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHRoZSBpbnB1dCBpcyBub3QgYSBzdHJpbmcuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2xlYW5Db2RlU3RyaW5nKGNvZGVTdHJpbmc6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAvLyBFbnN1cmUgdGhlIGlucHV0IGlzIGEgc3RyaW5nXHJcbiAgICBpZiAodHlwZW9mIGNvZGVTdHJpbmcgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IG11c3QgYmUgYSBzdHJpbmcuJyk7XHJcbiAgICB9XHJcbiAgXHJcbiAgICAvLyBGbGFncyB0byB0cmFjayB0aGUgY3VycmVudCBwYXJzaW5nIGNvbnRleHRcclxuICAgIGxldCBpbk11bHRpTGluZUNvbW1lbnQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIGxldCBpblNpbmdsZUxpbmVDb21tZW50OiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBsZXQgaW5TdHJpbmc6ICdcIicgfCBcIidcIiB8IG51bGwgPSBudWxsOyAvLyBUcmFja3MgaWYgaW5zaWRlIHNpbmdsZSBvciBkb3VibGUgcXVvdGVzXHJcbiAgICBsZXQgaW5SZWdFeHA6IGJvb2xlYW4gPSBmYWxzZTsgLy8gVHJhY2tzIGlmIGluc2lkZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsXHJcbiAgXHJcbiAgICAvLyBUaGUgcmVzdWx0aW5nIHN0cmluZyB3aXRob3V0IGNvbW1lbnRzXHJcbiAgICBsZXQgY2xlYW5lZENvZGU6IHN0cmluZyA9ICcnO1xyXG4gICAgLy8gQ3VycmVudCBpbmRleCBpbiB0aGUgaW5wdXQgc3RyaW5nXHJcbiAgICBsZXQgaTogbnVtYmVyID0gMDtcclxuICBcclxuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgaW5wdXQgc3RyaW5nIGNoYXJhY3RlciBieSBjaGFyYWN0ZXJcclxuICAgIHdoaWxlIChpIDwgY29kZVN0cmluZy5sZW5ndGgpIHtcclxuICAgICAgY29uc3QgY2hhcjogc3RyaW5nID0gY29kZVN0cmluZ1tpXTtcclxuICAgICAgY29uc3QgbmV4dENoYXI6IHN0cmluZyB8IHVuZGVmaW5lZCA9IGNvZGVTdHJpbmdbaSArIDFdOyAvLyBVc2UgdW5kZWZpbmVkIGZvciBwb3RlbnRpYWwgZW5kIG9mIHN0cmluZ1xyXG4gIFxyXG4gICAgICAvLyAtLS0gU3RhdGU6IEluc2lkZSBhIG11bHRpLWxpbmUgY29tbWVudCAtLS1cclxuICAgICAgaWYgKGluTXVsdGlMaW5lQ29tbWVudCkge1xyXG4gICAgICAgIC8vIENoZWNrIGZvciB0aGUgZW5kIG9mIHRoZSBtdWx0aS1saW5lIGNvbW1lbnQgJyovJ1xyXG4gICAgICAgIGlmIChjaGFyID09PSAnKicgJiYgbmV4dENoYXIgPT09ICcvJykge1xyXG4gICAgICAgICAgaW5NdWx0aUxpbmVDb21tZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICBpICs9IDI7IC8vIFNraXAgdGhlICcqLydcclxuICAgICAgICAgIGNvbnRpbnVlOyAvLyBNb3ZlIHRvIHRoZSBuZXh0IGl0ZXJhdGlvblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpKys7IC8vIFNraXAgdGhlIGNoYXJhY3RlciBpbnNpZGUgdGhlIGNvbW1lbnRcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvLyAtLS0gU3RhdGU6IEluc2lkZSBhIHNpbmdsZS1saW5lIGNvbW1lbnQgLS0tXHJcbiAgICAgIGlmIChpblNpbmdsZUxpbmVDb21tZW50KSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBlbmQgb2YgdGhlIGxpbmUgKG5ld2xpbmUgb3IgY2FycmlhZ2UgcmV0dXJuKVxyXG4gICAgICAgIGlmIChjaGFyID09PSAnXFxuJyB8fCBjaGFyID09PSAnXFxyJykge1xyXG4gICAgICAgICAgaW5TaW5nbGVMaW5lQ29tbWVudCA9IGZhbHNlO1xyXG4gICAgICAgICAgY2xlYW5lZENvZGUgKz0gY2hhcjsgLy8gS2VlcCB0aGUgbmV3bGluZSBjaGFyYWN0ZXJcclxuICAgICAgICAgIGkrKztcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpKys7IC8vIFNraXAgdGhlIGNoYXJhY3RlciBpbnNpZGUgdGhlIGNvbW1lbnRcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvLyAtLS0gU3RhdGU6IEluc2lkZSBhIHN0cmluZyBsaXRlcmFsIC0tLVxyXG4gICAgICBpZiAoaW5TdHJpbmcpIHtcclxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgY3VycmVudCBjaGFyYWN0ZXIgY2xvc2VzIHRoZSBzdHJpbmdcclxuICAgICAgICBpZiAoY2hhciA9PT0gaW5TdHJpbmcpIHtcclxuICAgICAgICAgIGluU3RyaW5nID0gbnVsbDsgLy8gRXhpdCBzdHJpbmcgc3RhdGVcclxuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICdcXFxcJykge1xyXG4gICAgICAgICAgLy8gSGFuZGxlIGVzY2FwZWQgY2hhcmFjdGVycyB3aXRoaW4gc3RyaW5ncyAoZS5nLiwgXCJpdFxcJ3NcIilcclxuICAgICAgICAgIGNsZWFuZWRDb2RlICs9IGNoYXI7IC8vIEFkZCB0aGUgYmFja3NsYXNoXHJcbiAgICAgICAgICBpKys7IC8vIE1vdmUgdG8gdGhlIG5leHQgY2hhcmFjdGVyICh0aGUgZXNjYXBlZCBvbmUpXHJcbiAgICAgICAgICBpZiAoaSA8IGNvZGVTdHJpbmcubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICBjbGVhbmVkQ29kZSArPSBjb2RlU3RyaW5nW2ldOyAvLyBBZGQgdGhlIGVzY2FwZWQgY2hhcmFjdGVyXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpKys7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkIHRoZSBjaGFyYWN0ZXIgdG8gdGhlIHJlc3VsdCBpZiBpdCdzIHBhcnQgb2YgdGhlIHN0cmluZ1xyXG4gICAgICAgIGNsZWFuZWRDb2RlICs9IGNoYXI7XHJcbiAgICAgICAgaSsrO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgICAvLyAtLS0gU3RhdGU6IEluc2lkZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsIC0tLVxyXG4gICAgICAgaWYgKGluUmVnRXhwKSB7XHJcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY3VycmVudCBjaGFyYWN0ZXIgY2xvc2VzIHRoZSByZWdleCBsaXRlcmFsXHJcbiAgICAgICAgICAvLyBOb3RlOiBUaGlzIGRvZXNuJ3QgaGFuZGxlIHJlZ2V4IGZsYWdzIHBlcmZlY3RseSBidXQgY292ZXJzIGJhc2ljIGNhc2VzLlxyXG4gICAgICAgICAgaWYgKGNoYXIgPT09ICcvJykge1xyXG4gICAgICAgICAgICAgIGluUmVnRXhwID0gZmFsc2U7IC8vIEV4aXQgcmVnZXggc3RhdGVcclxuICAgICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJ1xcXFwnKSB7XHJcbiAgICAgICAgICAgICAgLy8gSGFuZGxlIGVzY2FwZWQgY2hhcmFjdGVycyB3aXRoaW4gcmVnZXggKGUuZy4sIC9cXC8vKVxyXG4gICAgICAgICAgICAgIGNsZWFuZWRDb2RlICs9IGNoYXI7IC8vIEFkZCB0aGUgYmFja3NsYXNoXHJcbiAgICAgICAgICAgICAgaSsrOyAvLyBNb3ZlIHRvIHRoZSBuZXh0IGNoYXJhY3RlclxyXG4gICAgICAgICAgICAgIGlmIChpIDwgY29kZVN0cmluZy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICBjbGVhbmVkQ29kZSArPSBjb2RlU3RyaW5nW2ldOyAvLyBBZGQgdGhlIGVzY2FwZWQgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIEFkZCB0aGUgY2hhcmFjdGVyIHRvIHRoZSByZXN1bHQgaWYgaXQncyBwYXJ0IG9mIHRoZSByZWdleFxyXG4gICAgICAgICAgY2xlYW5lZENvZGUgKz0gY2hhcjtcclxuICAgICAgICAgIGkrKztcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgfVxyXG4gIFxyXG4gICAgICAvLyAtLS0gRGVmYXVsdCBTdGF0ZTogQ2hlY2sgZm9yIGNvbW1lbnQvc3RyaW5nL3JlZ2V4IHN0YXJ0cyAtLS1cclxuICBcclxuICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBzdGFydCBvZiBhIG11bHRpLWxpbmUgY29tbWVudCAnLyonXHJcbiAgICAgIGlmIChjaGFyID09PSAnLycgJiYgbmV4dENoYXIgPT09ICcqJykge1xyXG4gICAgICAgIGluTXVsdGlMaW5lQ29tbWVudCA9IHRydWU7XHJcbiAgICAgICAgaSArPSAyOyAvLyBTa2lwIHRoZSAnLyonXHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBzdGFydCBvZiBhIHNpbmdsZS1saW5lIGNvbW1lbnQgJy8vJ1xyXG4gICAgICBpZiAoY2hhciA9PT0gJy8nICYmIG5leHRDaGFyID09PSAnLycpIHtcclxuICAgICAgICBpblNpbmdsZUxpbmVDb21tZW50ID0gdHJ1ZTtcclxuICAgICAgICBpICs9IDI7IC8vIFNraXAgdGhlICcvLydcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvLyBDaGVjayBmb3IgdGhlIHN0YXJ0IG9mIGEgc3RyaW5nIGxpdGVyYWwgKCcgb3IgXCIpXHJcbiAgICAgIGlmIChjaGFyID09PSAnXCInIHx8IGNoYXIgPT09IFwiJ1wiKSB7XHJcbiAgICAgICAgaW5TdHJpbmcgPSBjaGFyOyAvLyBFbnRlciBzdHJpbmcgc3RhdGUsIHJlbWVtYmVyaW5nIHRoZSBxdW90ZSB0eXBlXHJcbiAgICAgICAgY2xlYW5lZENvZGUgKz0gY2hhcjsgLy8gQWRkIHRoZSBvcGVuaW5nIHF1b3RlXHJcbiAgICAgICAgaSsrO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIC8vIENoZWNrIGZvciB0aGUgc3RhcnQgb2YgYSByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbCAnLydcclxuICAgICAgLy8gQmFzaWMgY2hlY2s6IGFzc3VtZXMgJy8nIGluZGljYXRlcyBhIHJlZ2V4IHN0YXJ0IGlmIG5vdCBwcmVjZWRlZCBieSBvcGVyYXRvcnMva2V5d29yZHNcclxuICAgICAgLy8gQSBtb3JlIHJvYnVzdCBzb2x1dGlvbiB3b3VsZCByZXF1aXJlIG1vcmUgY29tcGxleCBwYXJzaW5nLlxyXG4gICAgICBpZiAoY2hhciA9PT0gJy8nKSB7XHJcbiAgICAgICAgICAvLyBWZXJ5IGJhc2ljIGNoZWNrIHRvIGRpZmZlcmVudGlhdGUgZGl2aXNpb24gZnJvbSByZWdleCBzdGFydC5cclxuICAgICAgICAgIC8vIFRoaXMgbWlnaHQgbmVlZCByZWZpbmVtZW50IGZvciBjb21wbGV4IGNhc2VzLlxyXG4gICAgICAgICAgY29uc3QgcHJldk1lYW5pbmdmdWxDaGFyID0gY2xlYW5lZENvZGUudHJpbSgpLnNsaWNlKC0xKTtcclxuICAgICAgICAgIGlmIChwcmV2TWVhbmluZ2Z1bENoYXIgPT09ICcnIHx8IFsnKCcsICcsJywgJz0nLCAnOicsICdbJywgJyEnLCAnJicsICd8JywgJz8nLCAneycsICc7JywgJ1xcbicsICdcXHInXS5pbmNsdWRlcyhwcmV2TWVhbmluZ2Z1bENoYXIpKSB7XHJcbiAgICAgICAgICAgICAgaW5SZWdFeHAgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIGNsZWFuZWRDb2RlICs9IGNoYXI7XHJcbiAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIC8vIElmIG5vbmUgb2YgdGhlIGFib3ZlLCBpdCdzIHJlZ3VsYXIgY29kZTsgYWRkIGl0IHRvIHRoZSByZXN1bHRcclxuICAgICAgY2xlYW5lZENvZGUgKz0gY2hhcjtcclxuICAgICAgaSsrO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgLy8gUmV0dXJuIHRoZSBhY2N1bXVsYXRlZCBjbGVhbmVkIGNvZGUgc3RyaW5nXHJcbiAgICByZXR1cm4gY2xlYW5lZENvZGU7XHJcbiAgfVxyXG4gIGV4cG9ydCBmdW5jdGlvbiByZXNvbHZlRm9sZGVyKGFwcDogQXBwLCBmb2xkZXJfc3RyOiBzdHJpbmcpOiBURm9sZGVyIHtcclxuICAgIGZvbGRlcl9zdHIgPSBub3JtYWxpemVQYXRoKGZvbGRlcl9zdHIpO1xyXG5cclxuICAgIGNvbnN0IGZvbGRlciA9IGFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZm9sZGVyX3N0cik7XHJcbiAgICBpZiAoIWZvbGRlcikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvck1hbmFnZXIoYEZvbGRlciBcIiR7Zm9sZGVyX3N0cn1cIiBkb2Vzbid0IGV4aXN0YCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIShmb2xkZXIgaW5zdGFuY2VvZiBURm9sZGVyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvck1hbmFnZXIoYCR7Zm9sZGVyX3N0cn0gaXMgYSBmaWxlLCBub3QgYSBmb2xkZXJgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZm9sZGVyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUZpbGUoYXBwOiBBcHAsIGZpbGVfc3RyOiBzdHJpbmcpOiBURmlsZSB7XHJcbiAgICBmaWxlX3N0ciA9IG5vcm1hbGl6ZVBhdGgoZmlsZV9zdHIpO1xyXG5cclxuICAgIGNvbnN0IGZpbGUgPSBhcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGZpbGVfc3RyKTtcclxuICAgIGlmICghZmlsZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvck1hbmFnZXIoYEZpbGUgXCIke2ZpbGVfc3RyfVwiIGRvZXNuJ3QgZXhpc3RgKTtcclxuICAgIH1cclxuICAgIGlmICghKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3JNYW5hZ2VyKGAke2ZpbGVfc3RyfSBpcyBhIGZvbGRlciwgbm90IGEgZmlsZWApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmaWxlO1xyXG59XHJcbiAgZXhwb3J0IGZ1bmN0aW9uIGdldEZpbGVzRnJvbUZvbGRlcihcclxuICAgIGFwcDogQXBwLFxyXG4gICAgZm9sZGVyX3N0cjogc3RyaW5nXHJcbiAgKTogQXJyYXk8VEZpbGU+IHtcclxuICAgIGNvbnN0IGZvbGRlciA9IHJlc29sdmVGb2xkZXIoYXBwLCBmb2xkZXJfc3RyKTtcclxuXHJcbiAgICBjb25zdCBmaWxlczogQXJyYXk8VEZpbGU+ID0gW107XHJcbiAgICBWYXVsdC5yZWN1cnNlQ2hpbGRyZW4oZm9sZGVyLCAoZmlsZTogVEFic3RyYWN0RmlsZSkgPT4ge1xyXG4gICAgICAgIGlmIChmaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuICAgICAgICAgICAgZmlsZXMucHVzaChmaWxlKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBmaWxlcy5zb3J0KChhLCBiKSA9PiB7ICBcclxuICAgICAgICByZXR1cm4gYS5wYXRoLmxvY2FsZUNvbXBhcmUoYi5wYXRoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBmaWxlcztcclxufVxyXG4gIGV4cG9ydCBjbGFzcyBTY3JpcHRpbmdUb29scyB7XHJcbiAgICBhcHA6IEFwcCB8IHVuZGVmaW5lZDtcclxuICAgIHBsdWdpbjogYW55OyAvL0ZvbGRlclRhZ1BsdWdpbjtcclxuICAgIHNldHRpbmdzOiBGcm9udG1hdHRlckF1dG9tYXRlU2V0dGluZ3MgfCB1bmRlZmluZWQ7XHJcbiAgICBydWxlOiBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzIHwgdW5kZWZpbmVkO1xyXG4gICAgZnJvbnRtYXR0ZXI6IGFueTtcclxuICAgIGN1cnJlbnRDb250ZW50OiBhbnk7XHJcbiAgICBhY3RpdmVGaWxlOiBURmlsZSB8IHVuZGVmaW5lZDtcclxuICAgIGtub3duUHJvcGVydGllczogUmVjb3JkPHN0cmluZywgUHJvcGVydHlJbmZvPiA9IHt9O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFwcD86QXBwLCBwbHVnaW4/OmFueSwgc2V0dGluZ3M/OkZyb250bWF0dGVyQXV0b21hdGVTZXR0aW5ncywgcnVsZT86IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIGZyb250bWF0dGVyPzogYW55LCBhY3RpdmVGaWxlPzogVEZpbGUpIHtcclxuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcclxuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3NcclxuICAgICAgICB0aGlzLnJ1bGUgPSBydWxlO1xyXG4gICAgICAgIHRoaXMuZnJvbnRtYXR0ZXIgPSBmcm9udG1hdHRlcjtcclxuICAgICAgICB0aGlzLmFjdGl2ZUZpbGUgPSBhY3RpdmVGaWxlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGZyb250bWF0dGVyIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgaW5zdGFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIGZyb250bWF0dGVyIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGdldEZyb250bWF0dGVyKCkgeyBcclxuICAgICAgcmV0dXJuIHRoaXMuZnJvbnRtYXR0ZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGZyb250bWF0dGVyIHByb3BlcnR5IGZvciB0aGUgY3VycmVudCBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZnJvbnRtYXR0ZXIgLSBUaGUgZnJvbnRtYXR0ZXIgb2JqZWN0IHRvIGFzc2lnbi5cclxuICAgICAqL1xyXG4gICAgc2V0RnJvbnRtYXR0ZXIoZnJvbnRtYXR0ZXI6YW55KSB7XHJcbiAgICAgICAgdGhpcy5mcm9udG1hdHRlciA9IGZyb250bWF0dGVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGEgcHJvcGVydHkgaW4gdGhlIGZyb250bWF0dGVyIG9iamVjdC4gSWYgdGhlIGZyb250bWF0dGVyIGRvZXMgbm90IGV4aXN0LCBpdCBpbml0aWFsaXplcyBpdCBhcyBhbiBlbXB0eSBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSBwcm9wZXJ0eSBuYW1lIHRvIHNldCBpbiB0aGUgZnJvbnRtYXR0ZXIuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYXNzaWduIHRvIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkuXHJcbiAgICAgKi9cclxuICAgIHNldEZyb250bWF0dGVyUHJvcGVydHkoa2V5OnN0cmluZywgdmFsdWU6YW55KSB7XHJcbiAgICAgIGlmICghdGhpcy5mcm9udG1hdHRlcikgdGhpcy5mcm9udG1hdHRlciA9IHt9O1xyXG4gICAgICB0aGlzLmZyb250bWF0dGVyW2tleV0gPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSB2YWx1ZSBvZiBhIHNwZWNpZmllZCBwcm9wZXJ0eSBmcm9tIHRoZSBmcm9udG1hdHRlciBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byByZXRyaWV2ZSBmcm9tIHRoZSBmcm9udG1hdHRlci5cclxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBrZXkgaW4gdGhlIGZyb250bWF0dGVyLCBvciBgdW5kZWZpbmVkYCBpZiB0aGUga2V5IGRvZXMgbm90IGV4aXN0LlxyXG4gICAgICovXHJcbiAgICBnZXRGcm9udG1hdHRlclByb3BlcnR5KGtleTpzdHJpbmcpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZnJvbnRtYXR0ZXJba2V5XVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50bHkgYWN0aXZlIGZpbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZpbGUgLSBUaGUgZmlsZSB0byBzZXQgYXMgYWN0aXZlLiBNdXN0IGJlIGFuIGluc3RhbmNlIG9mIGBURmlsZWAuXHJcbiAgICAgKi9cclxuICAgIHNldEFjdGl2ZUZpbGUoZmlsZTpURmlsZSkge1xyXG4gICAgICB0aGlzLmFjdGl2ZUZpbGUgPSBmaWxlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgYWN0aXZlIGZpbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIGFjdGl2ZSBmaWxlIG9iamVjdCwgb3IgYHVuZGVmaW5lZGAgaWYgbm8gZmlsZSBpcyBhY3RpdmUuXHJcbiAgICAgKi9cclxuICAgIGdldEFjdGl2ZUZpbGUoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmFjdGl2ZUZpbGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgcnVsZSBjb25maWd1cmF0aW9uIGZvciB0aGUgZnJvbnRtYXR0ZXIgYXV0b21hdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcnVsZSAtIFRoZSBydWxlIHNldHRpbmdzIHRvIGFwcGx5LCByZXByZXNlbnRlZCBieSBhIGBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzYCBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHNldFJ1bGUocnVsZTpGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzKSB7XHJcbiAgICAgIHRoaXMucnVsZSA9IHJ1bGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBydWxlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBydWxlIG9iamVjdCBvciB2YWx1ZSBzdG9yZWQgaW4gdGhlIGBydWxlYCBwcm9wZXJ0eS5cclxuICAgICAqL1xyXG4gICAgZ2V0UnVsZSgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucnVsZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIGEgcnVsZSBmdW5jdGlvbiBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgcnVsZSBzZXR0aW5ncy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcnVsZSAtIE9wdGlvbmFsLiBUaGUgcnVsZSBzZXR0aW5ncyB0byB1c2UgZm9yIHJldHJpZXZpbmcgdGhlIHJ1bGUgZnVuY3Rpb24uXHJcbiAgICAgKiAgICAgICAgICAgICAgIElmIG5vdCBwcm92aWRlZCwgdGhlIG1ldGhvZCB1c2VzIHRoZSBpbnN0YW5jZSdzIGRlZmF1bHQgcnVsZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBydWxlIGZ1bmN0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIHJ1bGUgc2V0dGluZ3MsIG9yIGB1bmRlZmluZWRgIGlmIG5vIHJ1bGUgaXMgZm91bmQuXHJcbiAgICAgKi9cclxuICAgIGdldFJ1bGVGdW5jdGlvbihydWxlPzpGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzKSB7XHJcbiAgICAgIGlmICghcnVsZSkgcnVsZSA9IHRoaXMucnVsZTtcclxuICAgICAgaWYgKHJ1bGUpIHtcclxuICAgICAgICByZXR1cm4gcnVsZXNNYW5hZ2VyLmdldFJ1bGVCeUlkKHJ1bGUuY29udGVudCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgY3VycmVudCBjb250ZW50IHRvIHRoZSBwcm92aWRlZCB2YWx1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29udGVudCAtIFRoZSBjb250ZW50IHRvIHNldCBhcyB0aGUgY3VycmVudCBjb250ZW50LiBDYW4gYmUgb2YgYW55IHR5cGUuXHJcbiAgICAgKi9cclxuICAgIHNldEN1cnJlbnRDb250ZW50KGNvbnRlbnQ6YW55KSB7XHJcbiAgICAgIHRoaXMuY3VycmVudENvbnRlbnQgPSBjb250ZW50O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnQgY29udGVudCBzdG9yZWQgaW4gdGhlIGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IGNvbnRlbnQuXHJcbiAgICAgKi9cclxuICAgIGdldEN1cnJlbnRDb250ZW50KCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50Q29udGVudDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgc3BlY2lmaWVkIGZyb250bWF0dGVyIHByb3BlcnR5IG9mIGEgZ2l2ZW4gZmlsZSB3aXRoIG5ldyBjb250ZW50LlxyXG4gICAgICpcclxuICAgICAqIElmIG5vIGZpbGUgaXMgcHJvdmlkZWQsIHRoZSBjdXJyZW50bHkgYWN0aXZlIGZpbGUgaXMgdXNlZC4gSWYgbmVpdGhlciBpcyBhdmFpbGFibGUsIHRoZSBtZXRob2QgcmV0dXJucyBlYXJseS5cclxuICAgICAqIFRoZSBtZXRob2QgbG9ncyB0aGUgdXBkYXRlIG9wZXJhdGlvbiBhbmQgb25seSBzdXBwb3J0cyB1cGRhdGluZyBwcm9wZXJ0aWVzIHdpdGggcHJpbWl0aXZlIHZhbHVlcyBvciBhcnJheXMuXHJcbiAgICAgKiBJZiBgbmV3Q29udGVudGAgaXMgYW4gb2JqZWN0IChidXQgbm90IGFuIGFycmF5KSwgYSB3YXJuaW5nIGlzIGlzc3VlZCBhbmQgdGhlIHVwZGF0ZSBpcyBub3QgcGVyZm9ybWVkLlxyXG4gICAgICogVGhlIGZpbGUncyBtb2RpZmljYXRpb24gdGltZSAoYG10aW1lYCkgaXMgcHJlc2VydmVkIGFuZCBub3QgY2hhbmdlZCBkdXJpbmcgdGhlIHVwZGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydHkgLSBUaGUgZnJvbnRtYXR0ZXIgcHJvcGVydHkgdG8gdXBkYXRlLlxyXG4gICAgICogQHBhcmFtIG5ld0NvbnRlbnQgLSBUaGUgbmV3IHZhbHVlIHRvIGFzc2lnbiB0byB0aGUgcHJvcGVydHkuIE9iamVjdHMgKGV4Y2VwdCBhcnJheXMpIGFyZSBub3Qgc3VwcG9ydGVkLlxyXG4gICAgICogQHBhcmFtIGZpbGUgLSAoT3B0aW9uYWwpIFRoZSBmaWxlIHdob3NlIGZyb250bWF0dGVyIHNob3VsZCBiZSB1cGRhdGVkLiBJZiBvbWl0dGVkLCB0aGUgYWN0aXZlIGZpbGUgaXMgdXNlZC5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlRnJvbnRtYXR0ZXIocHJvcGVydHk6c3RyaW5nLCBuZXdDb250ZW50OmFueSwgZmlsZT86VEZpbGUpIHtcclxuICAgICAgaWYgKCF0aGlzLmFwcCkgcmV0dXJuO1xyXG4gICAgICBpZiAoIWZpbGUpIGZpbGUgPSB0aGlzLmFjdGl2ZUZpbGU7XHJcbiAgICAgIGlmICghZmlsZSkgcmV0dXJuO1xyXG4gICAgICB0aGlzLmFwcC5maWxlTWFuYWdlci5wcm9jZXNzRnJvbnRNYXR0ZXIoZmlsZSwgKGZyb250bWF0dGVyKSA9PiB7XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhERUJVRyxgdXBkYXRlRnJvbnRtYXR0ZXIgJyR7ZmlsZS5wYXRofScgZnJvbnRtYXR0ZXIgJyR7cHJvcGVydHl9JyB0byAnJHtuZXdDb250ZW50LnRvU3RyaW5nKCl9J2ApO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmV3Q29udGVudCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkobmV3Q29udGVudCkpIHtcclxuICAgICAgICAgIGxvZ2dlci5sb2coV0FSTklORyxgdXBkYXRlRnJvbnRtYXR0ZXIgJyR7ZmlsZS5wYXRofSd8JyR7cHJvcGVydHl9JyBvYmplY3Qgbm90IHN1cHBvcnRlZCFgKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZnJvbnRtYXR0ZXJbcHJvcGVydHldID0gbmV3Q29udGVudDtcclxuICAgICAgICB9XHJcbiAgICAgIH0seydtdGltZSc6ZmlsZS5zdGF0Lm10aW1lfSk7IC8vIGRvIG5vdCBjaGFuZ2UgdGhlIG1vZGlmeSB0aW1lLlxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwbGF5cyBhIGNvbmZpcm1hdGlvbiBkaWFsb2cgd2l0aCBjdXN0b21pemFibGUgbWVzc2FnZSwgdGl0bGUsIGFuZCBidXR0b24gbGFiZWxzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIG1lc3NhZ2UgdG8gZGlzcGxheSBpbiB0aGUgY29uZmlybWF0aW9uIGRpYWxvZy5cclxuICAgICAqIEBwYXJhbSB0aXRsZSAtIFRoZSB0aXRsZSBvZiB0aGUgZGlhbG9nIHdpbmRvdy4gRGVmYXVsdHMgdG8gJ0NvbmZpcm0nLlxyXG4gICAgICogQHBhcmFtIGJ1dHRvbjEgLSBUaGUgbGFiZWwgZm9yIHRoZSBjb25maXJtYXRpb24gYnV0dG9uLiBEZWZhdWx0cyB0byAnWWVzJy5cclxuICAgICAqIEBwYXJhbSBidXR0b24yIC0gVGhlIGxhYmVsIGZvciB0aGUgY2FuY2VsbGF0aW9uIGJ1dHRvbi4gRGVmYXVsdHMgdG8gJ05vJy5cclxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHVzZXIgY29uZmlybWVkICh0cnVlKSBvciBjYW5jZWxsZWQgKGZhbHNlKS5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgc2hvd0NvbmZpcm1EaWFsb2cobWVzc2FnZTpzdHJpbmcsIHRpdGxlOnN0cmluZyA9ICdDb25maXJtJywgYnV0dG9uMTpzdHJpbmcgPSAnWWVzJywgYnV0dG9uMjpzdHJpbmcgPSAnTm8nKSB7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9ICBhd2FpdCBuZXcgQWxlcnRNb2RhbCh0aGlzLmFwcCEsIHRpdGxlLCBtZXNzYWdlLCBidXR0b24xLCBidXR0b24yKS5vcGVuQW5kR2V0VmFsdWUoKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdC5wcm9jZWVkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAqIEdldCB0aGUgb3B0aW9uIGNvbmZpZyBmb3IgYSBzcGVjaWZpYyBydWxlLiBPcHRpb25hbCB0aGUgc3BlY2lmaWMgcGFyYW1ldGVyIGJ5IHByb3ZpZGluZyBhbiBvcHRpb24gSUQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJ1bGVJZFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25JZF1cclxuICAgICAqIEByZXR1cm4geyp9IFxyXG4gICAgICovXHJcbiAgICBnZXRPcHRpb25Db25maWcocnVsZUlkOnN0cmluZ3x1bmRlZmluZWQsIG9wdGlvbklkPzpzdHJpbmcpe1xyXG4gICAgICBpZiAoIXJ1bGVJZCB8fCBydWxlSWQgPT09IHVuZGVmaW5lZCB8fCAhdGhpcy5zZXR0aW5ncyApIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIGNvbnN0IHJ1bGUgPSB0aGlzLnNldHRpbmdzLnJ1bGVzLmZpbmQoKHJ1bGU6IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MpID0+IHJ1bGUuaWQgPT09IHJ1bGVJZCk7XHJcbiAgICAgIGlmIChydWxlICYmIHJ1bGUuaGFzT3duUHJvcGVydHkoJ29wdGlvbnNDb25maWcnKSkge1xyXG4gICAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgICBjb25zdCBvcHRpb25Db25maWcgPSBydWxlLm9wdGlvbnNDb25maWdbcnVsZUlkXVxyXG4gICAgICAgICAgaWYgKG9wdGlvbkNvbmZpZykge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9uSWQpIHtcclxuICAgICAgICAgICAgICBsb2dnZXIubG9nKFRSQUNFLGBnZXRPcHRpb25Db25maWc6ICR7cnVsZUlkfSBvcHRpb24gJyR7b3B0aW9uSWR9J2AsIHJ1bGUsIG9wdGlvbkNvbmZpZ1tvcHRpb25JZF0pO1xyXG4gICAgICAgICAgICAgIHJldHVybiBvcHRpb25Db25maWdbb3B0aW9uSWRdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJldHVybiBvcHRpb25Db25maWc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYWxsIG1hcmtkb3duIGZpbGVzIGluIHRoZSB2YXVsdCB3aG9zZSBwYXRocyBpbmNsdWRlIHRoZSBzcGVjaWZpZWQgbWF0Y2hpbmcgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBgbWF0Y2hpbmdgIHBhcmFtZXRlciBpcyBub3JtYWxpemVkIHRvIGVuc3VyZSBpdCBlbmRzIHdpdGggYSBzaW5nbGUgJy8nIGNoYXJhY3RlcixcclxuICAgICAqIGFuZCBpcyB1c2VkIHRvIGZpbHRlciBmaWxlcyB3aG9zZSBwYXRocyBjb250YWluIHRoaXMgc3Vic3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmb2xkZXJQYXRoIC0gVGhlIGZvbGRlciBwYXRoIG9yIHN1YnN0cmluZyB0byBtYXRjaCB3aXRoaW4gZmlsZSBwYXRocy5cclxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGBURmlsZWAgb2JqZWN0cyB3aG9zZSBwYXRocyBpbmNsdWRlIHRoZSBub3JtYWxpemVkIGBtYXRjaGluZ2Agc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBnZXRGaWxlc0luVmF1bHQoZm9sZGVyUGF0aDogc3RyaW5nKTogVEZpbGVbXSB7XHJcbiAgICAgICAgZm9sZGVyUGF0aCA9IGZvbGRlclBhdGgucmVwbGFjZSgvXlxcL3xcXC8kL2csIFwiXCIpICsgJy8nOyAvLyBFbnN1cmUgaXQgZW5kcyB3aXRoIGEgJy8nXHJcbiAgICAgICAgY29uc3QgZmlsZXMgPSB0aGlzLmFwcCEudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpOyAvLyBSZXRyaWV2ZSBhbGwgbWFya2Rvd24gZmlsZXNcclxuICAgICAgICBjb25zdCBtYXRjaGluZ0ZpbGVzID0gZmlsZXMuZmlsdGVyKGZpbGUgPT4gZmlsZSBpbnN0YW5jZW9mIFRGaWxlICYmIGZpbGUucGF0aC5pbmNsdWRlcyhmb2xkZXJQYXRoKSk7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoaW5nRmlsZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBtb2NrIGBURmlsZWAgb2JqZWN0IGZyb20gYSBnaXZlbiBmaWxlIHBhdGggc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIHBhcnNlcyB0aGUgcHJvdmlkZWQgcGF0aCB0byBjb25zdHJ1Y3QgYSBgVEZpbGVgLWxpa2Ugb2JqZWN0LFxyXG4gICAgICogZXh0cmFjdGluZyB0aGUgZmlsZSBuYW1lLCBleHRlbnNpb24sIGFuZCBiYXNlIG5hbWUuIFRoZSByZXR1cm5lZCBvYmplY3RcclxuICAgICAqIGNvbnRhaW5zIHBsYWNlaG9sZGVyIHZhbHVlcyBmb3IgZmlsZSBzdGF0aXN0aWNzIGFuZCBwYXJlbnQsIGFzIHRoZXNlIGRldGFpbHNcclxuICAgICAqIGFyZSB1bmtub3duLiBJZiB0aGUgaW5wdXQgcGF0aCBpcyBlbXB0eSBvciB1bmRlZmluZWQsIHRoZSBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBmaWxlIHBhdGggc3RyaW5nIHRvIGdlbmVyYXRlIHRoZSBtb2NrIGBURmlsZWAgZnJvbS5cclxuICAgICAqIEByZXR1cm5zIEEgbW9jayBgVEZpbGVgIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGZpbGUgYXQgdGhlIGdpdmVuIHBhdGgsIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBwYXRoIGlzIGludmFsaWQuXHJcbiAgICAgKi9cclxuICAgIGdldE1vY2tGaWxlRnJvbVBhdGgocGF0aDogc3RyaW5nfHVuZGVmaW5lZCk6IFRGaWxlIHx1bmRlZmluZWQge1xyXG4gICAgICBpZiAoIXBhdGgpIHJldHVybiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICBsZXQgb2xkRmlsZTpURmlsZTtcclxuICAgICAgbGV0IG9sZEZpbGVQYXJ0cyA9IHBhdGguc3BsaXQoJy8nKTtcclxuICAgICAgb2xkRmlsZSA9IHtcclxuICAgICAgICBwYXRoOiBwYXRoLFxyXG4gICAgICAgIGV4dGVuc2lvbjogb2xkRmlsZVBhcnRzW29sZEZpbGVQYXJ0cy5sZW5ndGgtMV0uc3BsaXQoJy4nKVsxXSxcclxuICAgICAgICBuYW1lOiBvbGRGaWxlUGFydHNbb2xkRmlsZVBhcnRzLmxlbmd0aC0xXSxcclxuICAgICAgICBzdGF0OiB7bXRpbWU6IDAsIGN0aW1lOiAwLCBzaXplOiAwfSwgLy8gc3RhdHMgYXJlIHVua25vd25cclxuICAgICAgICBiYXNlbmFtZTogdGhpcy5yZW1vdmVBbGxFeHRlbnNpb25zKG9sZEZpbGVQYXJ0c1tvbGRGaWxlUGFydHMubGVuZ3RoLTFdKSxcclxuICAgICAgICB2YXVsdDogdGhpcy5hcHAhLnZhdWx0LFxyXG4gICAgICAgIHBhcmVudDogbnVsbCAvLyBwYXJlbnQgaXMgdW5rbm93blxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gb2xkRmlsZVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYSBgVEZpbGVgIG9iamVjdCBmcm9tIGEgZ2l2ZW4gZmlsZSBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIGZpbGUgcGF0aCB0byBzZWFyY2ggZm9yLiBJZiBgdW5kZWZpbmVkYCwgdGhlIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAuXHJcbiAgICAgKiBAcGFyYW0gZmlsZXNDaGVjayAtIEFuIG9wdGlvbmFsIGFycmF5IG9mIGBURmlsZWAgb2JqZWN0cyB0byBzZWFyY2ggd2l0aGluLiBJZiBub3QgcHJvdmlkZWQsIGFsbCBtYXJrZG93biBmaWxlcyBpbiB0aGUgdmF1bHQgYXJlIHVzZWQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbWF0Y2hpbmcgYFRGaWxlYCBpZiBmb3VuZDsgb3RoZXJ3aXNlLCBgdW5kZWZpbmVkYC5cclxuICAgICAqL1xyXG4gICAgZ2V0VEZpbGVGcm9tUGF0aChwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQsIGZpbGVzQ2hlY2s6IFRGaWxlW10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQpIHtcclxuICAgICAgaWYgKCFwYXRoKSByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICBjb25zdCBmaWxlcyA9IGZpbGVzQ2hlY2sgPyBmaWxlc0NoZWNrIDogdGhpcy5hcHAhLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKTsgLy8gUmV0cmlldmUgYWxsIG1hcmtkb3duIGZpbGVzXHJcbiAgICAgIGNvbnN0IG1hdGNoaW5nRmlsZXMgPSBmaWxlcy5maWx0ZXIoZmlsZSA9PiBcclxuICAgICAgICBmaWxlIGluc3RhbmNlb2YgVEZpbGUgJiYgXHJcbiAgICAgICAgZmlsZS5wYXRoLnRvTG9jYWxlTG93ZXJDYXNlKCkgPT09IHBhdGgudG9Mb2NhbGVMb3dlckNhc2UoKVxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gbWF0Y2hpbmdGaWxlcy5sZW5ndGggPiAwID8gbWF0Y2hpbmdGaWxlc1swXSA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBmaWxlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aCB1c2luZyB0aGUgY29udGVudCBmcm9tIGEgdGVtcGxhdGUgZmlsZS5cclxuICAgICAqIElmIHRoZSBmaWxlIGFscmVhZHkgZXhpc3RzLCByZXR1cm5zIHRoZSBleGlzdGluZyBmaWxlIGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgb25lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmaWxlTmFtZVdpdGhQYXRoIC0gVGhlIGZ1bGwgcGF0aCAoaW5jbHVkaW5nIGZpbGUgbmFtZSkgd2hlcmUgdGhlIG5ldyBmaWxlIHNob3VsZCBiZSBjcmVhdGVkLlxyXG4gICAgICogQHBhcmFtIHRlbXBsYXRlRmlsZVdpdGhQYXRoIC0gVGhlIGZ1bGwgcGF0aCB0byB0aGUgdGVtcGxhdGUgZmlsZSB3aG9zZSBjb250ZW50IHdpbGwgYmUgdXNlZC5cclxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBuZXdseSBjcmVhdGVkIGZpbGUgb3IgdGhlIGV4aXN0aW5nIGZpbGUgaWYgaXQgYWxyZWFkeSBleGlzdHMuXHJcbiAgICAgKiBAdGhyb3dzIHtFcnJvck1hbmFnZXJ9IElmIHRoZSBmb2xkZXIgcGF0aCBpcyBpbnZhbGlkLCBkb2VzIG5vdCBleGlzdCwgb3IgaXMgbm90IGEgZm9sZGVyLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBjcmVhdGVGaWxlRnJvbVBhdGgoZmlsZU5hbWVXaXRoUGF0aDpzdHJpbmcsIHRlbXBsYXRlRmlsZVdpdGhQYXRoOnN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gZmlsZU5hbWVXaXRoUGF0aC5yZXBsYWNlKC9eXFwvfFxcLyQvZywgXCJcIik7IC8vIFJlbW92ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzXHJcbiAgICAgICAgY29uc3QgdGVtcGxhdGVGaWxlID0gdGVtcGxhdGVGaWxlV2l0aFBhdGgucmVwbGFjZSgvXlxcL3xcXC8kL2csIFwiXCIpOyAvLyBSZW1vdmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlc1xyXG4gICAgICAgIGNvbnN0IGZvbGRlclBhdGggPSB0aGlzLmdldEZvbGRlckZyb21QYXRoKGZpbGVOYW1lKTtcclxuICAgICAgICBjb25zdCBmaWxlTmFtZU9ubHkgPSBmaWxlTmFtZS5zcGxpdCgnLycpLnBvcCgpIHx8IGZpbGVOYW1lOyAvLyBHZXQgdGhlIGxhc3QgcGFydCBvZiB0aGUgcGF0aCBhcyB0aGUgZmlsZSBuYW1lXHJcbiAgICAgICAgaWYgKCFmb2xkZXJQYXRoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvck1hbmFnZXIoYEludmFsaWQgZm9sZGVyIHBhdGg6IFwiJHtmb2xkZXJQYXRofVwiYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZvbGRlciA9IHRoaXMuYXBwIS52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZm9sZGVyUGF0aCkgYXMgVEZvbGRlcjtcclxuICAgICAgICBpZiAoIWZvbGRlcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JNYW5hZ2VyKGBGb2xkZXIgXCIke2ZvbGRlclBhdGh9XCIgZG9lc24ndCBleGlzdGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIShmb2xkZXIgaW5zdGFuY2VvZiBURm9sZGVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JNYW5hZ2VyKGAke2ZvbGRlclBhdGh9IGlzIGEgZmlsZSwgbm90IGEgZm9sZGVyYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRlbXBsYXRlQ29udGVudCA9IGF3YWl0IHRoaXMuYXBwIS52YXVsdC5yZWFkKHRoaXMuYXBwIS52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGVtcGxhdGVGaWxlKSBhcyBURmlsZSk7XHJcbiAgICAgICAgY29uc3QgZmlsZUV4aXN0cyA9IHRoaXMuYXBwIS52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZmlsZU5hbWVXaXRoUGF0aCkgYXMgVEZpbGU7XHJcbiAgICAgICAgaWYgKCFmaWxlRXhpc3RzKSB7XHJcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5hcHAhLnZhdWx0LmNyZWF0ZShmb2xkZXIucGF0aCArICcvJyArIGZpbGVOYW1lT25seSwgdGVtcGxhdGVDb250ZW50KTsgLy8gY3JlYXRlIHRoZSBmaWxlIGZyb20gdGhlIHRlbXBsYXRlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmaWxlRXhpc3RzOyAvLyByZXR1cm4gdGhlIGZpbGUgaWYgaXQgYWxyZWFkeSBleGlzdHNcclxuICAgIH07IC8vIGNyZWF0ZSB0aGUgZmlsZSBpZiBpdCBkb2VzIG5vdCBleGlzdFxyXG4gICAgLyoqXHJcbiAgICAgKiAqIEZldGNoZXMgY3VzdG9tIHByb3BlcnR5IGluZm9ybWF0aW9uIGZyb20gYWxsIG1hcmtkb3duIGZpbGVzIGluIHRoZSB2YXVsdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHsqfSBcclxuICAgICAqL1xyXG4gICAgZmV0Y2hDdXN0b21Qcm9wZXJ0eUluZm9zKGFwcDpBcHApOiBSZWNvcmQ8c3RyaW5nLCBQcm9wZXJ0eUluZm8+IHtcclxuICAgICAgICBjb25zdCBwcm9wZXJ0eUluZm9zOiBSZWNvcmQ8c3RyaW5nLCBQcm9wZXJ0eUluZm8+ID0ge307XHJcblxyXG4gICAgICAgIGNvbnN0IGZpbGVzID0gYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKTsgLy8gUmV0cmlldmUgYWxsIG1hcmtkb3duIGZpbGVzXHJcbiAgICAgICAgZmlsZXMuZm9yRWFjaChmaWxlID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk7XHJcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YT8uZnJvbnRtYXR0ZXIpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG1ldGFkYXRhLmZyb250bWF0dGVyKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wZXJ0eUluZm9zW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlJbmZvc1trZXldID0geyBuYW1lOiBrZXksIHR5cGU6ICd0ZXh0JyB9OyAvLyBEZWZhdWx0IHR5cGUgYXMgJ3RleHQnXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5SW5mb3M7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZldGNoZXMga25vd24gcHJvcGVydGllcyBmcm9tIHRoZSBtZXRhZGF0YSBjYWNoZS5cclxuICAgICAqIElmIHRoZSBtZXRob2QgZ2V0QWxsUHJvcGVydHlJbmZvcyBpcyBub3QgYXZhaWxhYmxlLCBpdCBmYWxscyBiYWNrIHRvIGZldGNoQ3VzdG9tUHJvcGVydHlJbmZvcy5cclxuICAgICAqIEBwYXJhbSBhcHAgVGhlIE9ic2lkaWFuIGFwcCBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZmV0Y2hLbm93blByb3BlcnRpZXMoYXBwOkFwcCkge1xyXG4gICAgICBsZXQgcHJvcGVydHlJbmZvczogUmVjb3JkPHN0cmluZywgUHJvcGVydHlJbmZvPiA9IHt9O1xyXG4gICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgIGlmICh0eXBlb2YgYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0QWxsUHJvcGVydHlJbmZvcyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgcHJvcGVydHlJbmZvcyA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEFsbFByb3BlcnR5SW5mb3MoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwcm9wZXJ0eUluZm9zID0gdGhpcy5mZXRjaEN1c3RvbVByb3BlcnR5SW5mb3MoYXBwKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBzb3J0IHRoZSBwcm9wZXJ0aWVzIGJ5IG5hbWVcclxuICAgICAgcHJvcGVydHlJbmZvcyA9IE9iamVjdC5mcm9tRW50cmllcyhcclxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHByb3BlcnR5SW5mb3MpLnNvcnQoKFtrZXlBXSwgW2tleUJdKSA9PiBrZXlBLmxvY2FsZUNvbXBhcmUoa2V5QikpXHJcbiAgICAgICk7XHJcbiAgICAgIC8vIHJlc3RvcmUgdG8ga2VlcCBwcm9wZXJ0aWVzIHRvIGNhc2Ugc2Vuc2l0aXZlXHJcbiAgICAgIHRoaXMua25vd25Qcm9wZXJ0aWVzID0ge307XHJcbiAgICAgIE9iamVjdC5rZXlzKHByb3BlcnR5SW5mb3MpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICB0aGlzLmtub3duUHJvcGVydGllc1twcm9wZXJ0eUluZm9zW2tleV0ubmFtZV0gPSBwcm9wZXJ0eUluZm9zW2tleV07XHJcbiAgICAgIH0pO1xyXG4gICAgICBsb2dnZXIubG9nKERFQlVHLHRoaXMua25vd25Qcm9wZXJ0aWVzKTtcclxuICAgICAgcmV0dXJuIHRoaXMua25vd25Qcm9wZXJ0aWVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGtub3duIHByb3BlcnRpZXMsIGluaXRpYWxpemluZyB0aGVtIGlmIHRoZXkgaGF2ZSBub3QgYmVlbiBsb2FkZWQgeWV0LlxyXG4gICAgICogSWYgdGhlIHByb3BlcnRpZXMgYXJlIG5vdCBhbHJlYWR5IGNhY2hlZCwgdGhpcyBtZXRob2QgZmV0Y2hlcyB0aGVtIHVzaW5nIGBmZXRjaEN1c3RvbVByb3BlcnR5SW5mb3NgXHJcbiAgICAgKiBhbmQgc3RvcmVzIHRoZW0gZm9yIGZ1dHVyZSBhY2Nlc3MuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIGNhY2hlZCBvciBuZXdseSBmZXRjaGVkIGtub3duIHByb3BlcnRpZXMuXHJcbiAgICAgKi9cclxuICAgIGdldEtub3duUHJvcGVydGllcygpIHtcclxuICAgICAgICBpZiAoIXRoaXMua25vd25Qcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMua25vd25Qcm9wZXJ0aWVzID0gdGhpcy5mZXRjaEN1c3RvbVByb3BlcnR5SW5mb3ModGhpcy5hcHAhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMua25vd25Qcm9wZXJ0aWVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRyYWN0cyB0aGUgcGF0aCBhbmQgdGl0bGUgZnJvbSBhIGdpdmVuIGxpbmsgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBpbnB1dCBsaW5rIGlzIGV4cGVjdGVkIHRvIGJlIGluIHRoZSBmb3JtYXQgYFtbcGF0aHx0aXRsZV1dYCBvciBgW1twYXRoXV1gLlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiByZW1vdmVzIHNxdWFyZSBicmFja2V0cywgc3BsaXRzIHRoZSBsaW5rIGJ5IHRoZSBgfGAgY2hhcmFjdGVyLFxyXG4gICAgICogYW5kIGRldGVybWluZXMgdGhlIHBhdGggYW5kIHRpdGxlLiBJZiB0aGUgdGl0bGUgaXMgbm90IHByb3ZpZGVkLCB0aGUgcGF0aCBpc1xyXG4gICAgICogdXNlZCBhcyB0aGUgdGl0bGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxpbmsgLSBUaGUgbGluayBzdHJpbmcgdG8gZXh0cmFjdCBwYXJ0cyBmcm9tLCB0eXBpY2FsbHkgaW4gdGhlIGZvcm1hdCBgW1twYXRofHRpdGxlXV1gIG9yIGBbW3BhdGhdXWAuXHJcbiAgICAgKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgYHBhdGhgIGFuZCBgdGl0bGVgIGV4dHJhY3RlZCBmcm9tIHRoZSBsaW5rLlxyXG4gICAgICovXHJcbiAgICBleHRyYWN0TGlua1BhcnRzKGxpbms6IHN0cmluZyk6IHsgcGF0aDogc3RyaW5nOyB0aXRsZTogc3RyaW5nIH0ge1xyXG4gICAgICAvLyBSZW1vdmUgYWxsIHNxdWFyZSBicmFja2V0cyBmcm9tIHRoZSBzdHJpbmdcclxuICAgICAgY29uc3QgY2xlYW5lZExpbmsgPSBsaW5rLnJlcGxhY2UoL1tcXFtcXF1dL2csIFwiXCIpO1xyXG4gIFxyXG4gICAgICAvLyBTcGxpdCB0aGUgc3RyaW5nIGJ5IHRoZSBcInxcIiBjaGFyYWN0ZXJcclxuICAgICAgY29uc3QgcGFydHMgPSBjbGVhbmVkTGluay5zcGxpdChcInxcIik7XHJcbiAgXHJcbiAgICAgIC8vIElmIG9ubHkgb25lIHBhcnQgZXhpc3RzLCB1c2UgaXQgYXMgYm90aCBwYXRoIGFuZCB0aXRsZVxyXG4gICAgICBjb25zdCBwYXRoID0gcGFydHNbMF0udHJpbSgpO1xyXG4gICAgICBjb25zdCB0aXRsZSA9IHBhcnRzLmxlbmd0aCA+IDEgPyBwYXJ0c1sxXS50cmltKCkgOiBwYXRoO1xyXG4gICAgICAvL2xvZ2dlci5sb2coREVCVUcsYGV4dHJhY3RMaW5rUGFydHMoJHtsaW5rfSkgLT4gcGF0aDogJHtwYXRofSwgdGl0bGU6ICR7dGl0bGV9YCk7XHJcbiAgICAgIHJldHVybiB7IHBhdGgsIHRpdGxlIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4dHJhY3RzIHRoZSBwYXRoLCB0aXRsZSwgYW5kIGZpbGUgbmFtZSBmcm9tIGEgZ2l2ZW4gZmlsZSBsaW5rIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBTcGxpdHMgdGhlIGlucHV0IHN0cmluZyBieSB0aGUgXCIvXCIgY2hhcmFjdGVyIHRvIHNlcGFyYXRlIHRoZSBmaWxlIG5hbWUgZnJvbSBpdHMgcGF0aC5cclxuICAgICAqIFRoZSB0aXRsZSBpcyBkZXJpdmVkIGZyb20gdGhlIGZpbGUgbmFtZSBieSByZW1vdmluZyBhbGwgZXh0ZW5zaW9ucyBhbmQgdHJpbW1pbmcgd2hpdGVzcGFjZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGluayAtIFRoZSBmaWxlIGxpbmsgc3RyaW5nIHRvIGV4dHJhY3QgcGFydHMgZnJvbS5cclxuICAgICAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nOlxyXG4gICAgICogICAtIGBwYXRoYDogVGhlIGRpcmVjdG9yeSBwYXRoIHBvcnRpb24gb2YgdGhlIGxpbmsgKGV4Y2x1ZGluZyB0aGUgZmlsZSBuYW1lKS5cclxuICAgICAqICAgLSBgdGl0bGVgOiBUaGUgZmlsZSBuYW1lIHdpdGhvdXQgZXh0ZW5zaW9ucyBhbmQgdHJpbW1lZC5cclxuICAgICAqICAgLSBgZmlsZU5hbWVgOiBUaGUgZnVsbCBmaWxlIG5hbWUgKHdpdGggZXh0ZW5zaW9ucywgaWYgYW55KS5cclxuICAgICAqL1xyXG4gICAgZXh0cmFjdFBhdGhQYXJ0cyhsaW5rOiBzdHJpbmcpOiB7IHBhdGg6IHN0cmluZzsgdGl0bGU6IHN0cmluZzsgZmlsZU5hbWU6IHN0cmluZyB9IHtcclxuIFxyXG4gICAgICAvLyBTcGxpdCB0aGUgc3RyaW5nIGJ5IHRoZSBcIi9cIiBjaGFyYWN0ZXJcclxuICAgICAgY29uc3QgcGFydHMgPSBsaW5rLnNwbGl0KFwiL1wiKTtcclxuICBcclxuICAgICAgLy8gSWYgb25seSBvbmUgcGFydCBleGlzdHMsIHVzZSBpdCBhcyBib3RoIHBhdGggYW5kIHRpdGxlXHJcbiAgICAgIGNvbnN0IGZpbGVOYW1lID0gcGFydHMucG9wKCkgfHwgXCJcIjtcclxuICAgICAgY29uc3QgdGl0bGUgPSB0aGlzLnJlbW92ZUFsbEV4dGVuc2lvbnMoZmlsZU5hbWUpLnRyaW0oKTtcclxuICAgICAgY29uc3QgcGF0aCA9IHBhcnRzLmpvaW4oXCIvXCIpLnRyaW0oKTtcclxuICAgICAgLy9sb2dnZXIubG9nKERFQlVHLGBleHRyYWN0TGlua1BhcnRzKCR7bGlua30pIC0+IHBhdGg6ICR7cGF0aH0sIHRpdGxlOiAke3RpdGxlfWApO1xyXG4gICAgICByZXR1cm4geyBwYXRoLCB0aXRsZSwgZmlsZU5hbWUgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgb25lIG9yIG1vcmUgbGVhZGluZyBzbGFzaGVzIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhdGggLSBUaGUgaW5wdXQgc3RyaW5nIGZyb20gd2hpY2ggdG8gcmVtb3ZlIGxlYWRpbmcgc2xhc2hlcy5cclxuICAgICAqIEByZXR1cm5zIFRoZSBpbnB1dCBzdHJpbmcgd2l0aG91dCBhbnkgbGVhZGluZyBzbGFzaGVzLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVMZWFkaW5nU2xhc2gocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXlxcLysvLCBcIlwiKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW5zdXJlcyB0aGF0IHRoZSBnaXZlbiBwYXRoIHN0cmluZyBzdGFydHMgd2l0aCBhIGxlYWRpbmcgc2xhc2ggKCcvJykuXHJcbiAgICAgKiBJZiB0aGUgcGF0aCBhbHJlYWR5IGJlZ2lucyB3aXRoIGEgc2xhc2gsIGl0IGlzIHJldHVybmVkIHVuY2hhbmdlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBpbnB1dCBwYXRoIHN0cmluZyB0byBtb2RpZnkuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgcGF0aCBzdHJpbmcgZ3VhcmFudGVlZCB0byBzdGFydCB3aXRoIGEgbGVhZGluZyBzbGFzaC5cclxuICAgICAqL1xyXG4gICAgYWRkTGVhZGluZ1NsYXNoKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL14oPyFcXC8pLywgXCIvXCIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiBhIHN0cmluZyBjb21wbGllcyB3aXRoIElTTyBTdGFuZGFyZFxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0gc3RyIEFueSBzdHJpbmdcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gbG9vayBmb3JcclxuICAgICAqIEByZXR1cm5zIFxyXG4gICAgICovXHJcbiAgICBpc0lTT1N0cmluZyhcclxuICAgICAgc3RyOiBzdHJpbmcsXHJcbiAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICB3aXRoTWlsbGlzZWNvbmRzPzogYm9vbGVhbjtcclxuICAgICAgICB3aXRoVGltZXpvbmU/OiBib29sZWFuO1xyXG4gICAgICAgIHdpdGhUaW1lPzogYm9vbGVhbjtcclxuICAgICAgICB3aXRoRGF0ZT86IGJvb2xlYW47IFxyXG4gICAgICB9ID0ge31cclxuICAgICk6IGJvb2xlYW4ge1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgd2l0aE1pbGxpc2Vjb25kcyA9IGZhbHNlLFxyXG4gICAgICAgIHdpdGhUaW1lem9uZSA9IGZhbHNlLFxyXG4gICAgICAgIHdpdGhUaW1lID0gdHJ1ZSxcclxuICAgICAgICB3aXRoRGF0ZSA9IHRydWUsIFxyXG4gICAgICB9ID0gb3B0aW9ucztcclxuICAgIFxyXG4gICAgICBsZXQgZGF0ZVJlZ2V4U3RyID0gXCJeKD86XFxcXGR7NH0tKD86MFsxLTldfDFbMC0yXSktKD86MFsxLTldfFsxMl1cXFxcZHwzWzAxXSkpXCI7XHJcbiAgICAgIGxldCB0aW1lUmVnZXhTdHIgPSBcIig/OlQoPzpbMDFdXFxcXGR8MlswLTNdKTpbMC01XVxcXFxkOlswLTVdXFxcXGRcIjtcclxuICAgIFxyXG4gICAgICBpZiAod2l0aE1pbGxpc2Vjb25kcykge1xyXG4gICAgICAgIHRpbWVSZWdleFN0ciArPSBcIlxcXFwuXFxcXGR7M31cIjtcclxuICAgICAgfVxyXG4gICAgXHJcbiAgICAgIGlmICh3aXRoVGltZXpvbmUpIHtcclxuICAgICAgICB0aW1lUmVnZXhTdHIgKz0gXCIoPzpafFsrLV0oPzpbMDFdXFxcXGR8MlswLTNdKTpbMC01XVxcXFxkKT8pP1wiO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRpbWVSZWdleFN0ciArPSBcIik/XCI7XHJcbiAgICAgIH1cclxuICAgIFxyXG4gICAgICBsZXQgcmVnZXhTdHIgPSBcIlwiO1xyXG4gICAgICBpZiAod2l0aERhdGUgJiYgd2l0aFRpbWUpIHtcclxuICAgICAgICByZWdleFN0ciA9IGAke2RhdGVSZWdleFN0cn0ke3RpbWVSZWdleFN0cn0kYDtcclxuICAgICAgfSBlbHNlIGlmICh3aXRoRGF0ZSkge1xyXG4gICAgICAgIHJlZ2V4U3RyID0gYCR7ZGF0ZVJlZ2V4U3RyfSRgO1xyXG4gICAgICB9IGVsc2UgaWYgKHdpdGhUaW1lKSB7XHJcbiAgICAgICAgcmVnZXhTdHIgPSBgXiR7dGltZVJlZ2V4U3RyLnNsaWNlKDQpfSRgOyBcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7IFxyXG4gICAgICB9XHJcbiAgICBcclxuICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4U3RyKTtcclxuICAgICAgcmV0dXJuIHJlZ2V4LnRlc3Qoc3RyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJ5IHRvIGNvbnZlcnQgQW55IFR5cGVzIHRvIGEgc3BlY2lmaWMgVHlwZVxyXG4gICAgICogQHBhcmFtIGlucHV0IFxyXG4gICAgICogQHBhcmFtIHR5cGVTdHJpbmcgJ3N0cmluZycgfCAnbnVtYmVyJyB8ICdib29sZWFuJyB8ICdzdHJpbmdbXSdcclxuICAgICAqIEByZXR1cm5zIFxyXG4gICAgICovXHJcbiAgICB0cnlDb252ZXJ0KGlucHV0OiBhbnksIHR5cGVTdHJpbmc6ICdzdHJpbmcnIHwgJ251bWJlcicgfCAnYm9vbGVhbicgfCAnc3RyaW5nW10nKTogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IHN0cmluZ1tdIHwgdW5kZWZpbmVkIHtcclxuICAgICAgc3dpdGNoICh0eXBlU3RyaW5nKSB7XHJcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcclxuICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgICAgIGNvbnN0IG51bSA9IE51bWJlcihpbnB1dCk7XHJcbiAgICAgICAgICBpZiAoIWlzTmFOKG51bSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICAgIHJldHVybiBpbnB1dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGxvd2VyVmFsdWUgPSBpbnB1dC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgIGlmIChsb3dlclZhbHVlID09PSAndHJ1ZScpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAobG93ZXJWYWx1ZSA9PT0gJ2ZhbHNlJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIGNhc2UgJ3N0cmluZ1tdJzpcclxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSAmJiBpbnB1dC5ldmVyeShpdGVtID0+IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIFxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3JtYXRzIGEgZ2l2ZW4gdGV4dCBzdHJpbmcgdG8gYmUgc2FmZSBmb3IgdXNlIGluIFlBTUwgYnkgcmVwbGFjaW5nIHNwZWNpYWwgY2hhcmFjdGVycy5cclxuICAgICAqXHJcbiAgICAgKiBSZXBsYWNlcyBhbGwgY2hhcmFjdGVycyB0aGF0IGFyZSBub3QgYWxwaGFudW1lcmljLCBkYXNoLCB1bmRlcnNjb3JlLCBzbGFzaCwgb3IgY2VydGFpbiBhY2NlbnRlZCBjaGFyYWN0ZXJzXHJcbiAgICAgKiB3aXRoIGEgc3BlY2lmaWVkIHJlcGxhY2VtZW50IHN0cmluZy4gSWYgbm8gcmVwbGFjZW1lbnQgc3RyaW5nIGlzIHByb3ZpZGVkLCBpdCB1c2VzIHRoZSB2YWx1ZSBmcm9tIHNldHRpbmdzLFxyXG4gICAgICogb3IgZGVmYXVsdHMgdG8gYCctJ2AuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRleHQgLSBUaGUgaW5wdXQgc3RyaW5nIHRvIGZvcm1hdC5cclxuICAgICAqIEBwYXJhbSByZXBsYWNlQnkgLSBPcHRpb25hbC4gVGhlIHN0cmluZyB0byByZXBsYWNlIHNwZWNpYWwgY2hhcmFjdGVycyB3aXRoLiBJZiBub3QgcHJvdmlkZWQsIHVzZXMgdGhlIHZhbHVlIGZyb20gc2V0dGluZ3Mgb3IgYCctJ2AuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZm9ybWF0dGVkIHN0cmluZyBzYWZlIGZvciBZQU1MIHVzYWdlLlxyXG4gICAgICovXHJcbiAgICBmb3JtYXRUb1lBTUxTYXZlU3RyaW5nKHRleHQ6c3RyaW5nLCByZXBsYWNlQnk6c3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkKTpzdHJpbmcge1xyXG4gICAgICBsZXQgcmVwbGFjZVN0cmluZyA9ICctJztcclxuICAgICAgaWYgKCFyZXBsYWNlQnkgJiYgdGhpcy5zZXR0aW5ncykge1xyXG4gICAgICAgIHJlcGxhY2VTdHJpbmcgPSB0aGlzLnNldHRpbmdzLnNwZWNpYWxDaGFyUmVwbGFjZW1lbnQgfHwgJy0nO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChyZXBsYWNlQnkpIHJlcGxhY2VTdHJpbmcgPSByZXBsYWNlQnk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRleHQucmVwbGFjZSgvW15hLXpBLVowLTlcXC1fXFwvXHUwMEU0XHUwMEY2XHUwMEZDXHUwMERGXHUwMEM0XHUwMEQ2XHUwMERDXHUwMEUxXHUwMEU5XHUwMEVEXHUwMEYzXHUwMEZBXHUwMEZEXHUwMEMxXHUwMEM5XHUwMENEXHUwMEQzXHUwMERBXHUwMEREXHUwMEUwXHUwMEU4XHUwMEVDXHUwMEYyXHUwMEY5XHUwMEMwXHUwMEM4XHUwMENDXHUwMEQyXHUwMEQ5XHUwMEUyXHUwMEVBXHUwMEVFXHUwMEY0XHUwMEZCXHUwMEMyXHUwMENBXHUwMENFXHUwMEQ0XHUwMERCXHUwMEUzXHUwMEYxXHUwMEY1XHUwMEMzXHUwMEQxXHUwMEQ1XS9nLCByZXBsYWNlU3RyaW5nKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIHRvIGEgWUFNTC1zYWZlIGZvcm1hdCBieSBhZGRpbmcgcXVvdGVzIHdoZW4gbmVjZXNzYXJ5LlxyXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBzdHJpbmcsIGJvb2xlYW4sIG51bWJlciBvciBhcnJheSB0byBtYWtlIFlBTUwtc2FmZVxyXG4gICAgICogQHJldHVybnMgVGhlIHNhZmVseSBxdW90ZWQgc3RyaW5nIHdoZW4gbmVlZGVkLCBvciB0aGUgb3JpZ2luYWwgc3RyaW5nIGlmIHNhZmVcclxuICAgICAqL1xyXG4gICAgdG9ZYW1sU2FmZVN0cmluZyhpbnB1dDogc3RyaW5nfG51bWJlcnxib29sZWFufHN0cmluZ1tdKTogc3RyaW5nfG51bWJlcnxzdHJpbmdbXSB7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgIGlucHV0LmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICBpbnB1dFtpbmRleF0gPSB0aGlzLnRvWWFtbFNhZmVTdHJpbmcoaXRlbSkudG9TdHJpbmcoKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIHJldHVybiBpbnB1dDtcclxuICAgICAgfVxyXG4gICAgICBzd2l0Y2ggKHR5cGVvZiBpbnB1dCkge1xyXG4gICAgICAgIGNhc2UgJ251bWJlcic6IHJldHVybiBpbnB1dDtcclxuICAgICAgICBjYXNlICdib29sZWFuJzogcmV0dXJuIGlucHV0ID8gJ3RydWUnIDogJ2ZhbHNlJztcclxuICAgICAgICBjYXNlICdzdHJpbmcnOlxyXG4gICAgICAgICAgLy8gVHJpbSB3aGl0ZXNwYWNlIGZpcnN0XHJcbiAgICAgICAgICBjb25zdCB0cmltbWVkID0gaW5wdXQudHJpbSgpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBFbXB0eSBzdHJpbmdzIG5lZWQgcXVvdGVzXHJcbiAgICAgICAgICBpZiAodHJpbW1lZCA9PT0gJycpIHJldHVybiAnXCJcIic7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIENoZWNrIGZvciBzcGVjaWFsIGNoYXJhY3RlcnMvcGF0dGVybnMgdGhhdCByZXF1aXJlIHF1b3RpbmdcclxuICAgICAgICAgIGNvbnN0IG5lZWRzUXVvdGVzID0gL1s6e31cXFtcXF0sJiojP3w8Pj0hJUBgXCInXFxcXF18XlstP1xcbl18W1xcc1xcbl18Xlt5WW5OXXxeWzAtOV18XlsrLV18Xih0cnVlfGZhbHNlfHllc3xub3xvbnxvZmYpJC9pLnRlc3QodHJpbW1lZCk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBzdHJpbmcgaXMgYWxyZWFkeSBwcm9wZXJseSBxdW90ZWRcclxuICAgICAgICAgIGNvbnN0IGlzQWxyZWFkeVF1b3RlZCA9ICh0cmltbWVkLnN0YXJ0c1dpdGgoJ1wiJykgJiYgdHJpbW1lZC5lbmRzV2l0aCgnXCInKSkgfHwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRyaW1tZWQuc3RhcnRzV2l0aChcIidcIikgJiYgdHJpbW1lZC5lbmRzV2l0aChcIidcIikpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAoIW5lZWRzUXVvdGVzICYmICFpc0FscmVhZHlRdW90ZWQpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gdHJpbW1lZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIHdlIG5lZWQgcXVvdGVzXHJcbiAgICAgICAgICAvLyBVc2UgZG91YmxlIHF1b3RlcyBhbmQgZXNjYXBlIGFueSBleGlzdGluZyBkb3VibGUgcXVvdGVzXHJcbiAgICAgICAgICBpZiAoIWlzQWxyZWFkeVF1b3RlZCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBgXCIke3RyaW1tZWQucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpfVwiYDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gSWYgYWxyZWFkeSBxdW90ZWQsIHJldHVybiBhcy1pc1xyXG4gICAgICAgICAgcmV0dXJuIHRyaW1tZWQ7XHJcbiAgICAgICAgZGVmYXVsdDogXHJcbiAgICAgICAgICBsb2dnZXIubG9nKEVSUk9SLGB0b1lhbWxTYWZlU3RyaW5nKCR7aW5wdXR9KSBpZiBvZiB0eXBlICcke3R5cGVvZiBpbnB1dH0nYCk7XHJcbiAgICAgICAgICByZXR1cm4gaW5wdXQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYW4gaW5wdXQgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MgaW50byBhIE1hcmtkb3duIExpbmsgZm9ybWF0LlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0gaW5wdXQgLSBUaGUgaW5wdXQgdG8gYmUgY29udmVydGVkLiBDYW4gYmUgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cclxuICAgICAqIEBwYXJhbSByZXBsYWNlU3BhY2VzIC0gT3B0aW9uYWwgcGFyYW1ldGVyIHRvIHNwZWNpZnkgYSByZXBsYWNlbWVudCBmb3Igc3BhY2VzIGluIHRoZSBwYXRoIG9yIHRpdGxlLlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICBJZiBwcm92aWRlZCwgc3BhY2VzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGlzIHZhbHVlLlxyXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgaW4gTWFya2Rvd24gTGluayBmb3JtYXQgaWYgdGhlIGlucHV0IGlzIGEgc2luZ2xlIHN0cmluZywgb3IgYSBjb25jYXRlbmF0ZWQgc3RyaW5nXHJcbiAgICAgKiAgICAgICAgICBvZiBNYXJrZG93biBMaW5rcyBpZiB0aGUgaW5wdXQgaXMgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cclxuICAgICAqIFxyXG4gICAgICogVGhlIE1hcmtkb3duIExpbmsgZm9ybWF0IGlzIGBbdGl0bGVdKHBhdGgpYCwgd2hlcmU6XHJcbiAgICAgKiAtIGBwYXRoYCBpcyB0aGUgZm9ybWF0dGVkIHBhdGggb2YgdGhlIGxpbmsuXHJcbiAgICAgKiAtIGB0aXRsZWAgaXMgdGhlIGZvcm1hdHRlZCB0aXRsZSBvZiB0aGUgbGluay5cclxuICAgICAqIFxyXG4gICAgICogSWYgdGhlIGlucHV0IGlzIGFuIGFycmF5LCBlYWNoIGVsZW1lbnQgaXMgY29udmVydGVkIHRvIGEgV2lraUxpbmsgYW5kIGpvaW5lZCB3aXRoIGEgY29tbWEuXHJcbiAgICAgKi9cclxuICAgIHRvTWFya2Rvd25MaW5rKGlucHV0OiBhbnksIHJlcGxhY2VTcGFjZXM/OiBzdHJpbmcpOiBzdHJpbmcgfCBzdHJpbmdbXSB7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgIHJldHVybiBpbnB1dC5tYXAoaXRlbSA9PiB0aGlzLnRvV2lraUxpbmsoaXRlbSkpLmpvaW4oJywgJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBjb25zdCB7IHBhdGgsIHRpdGxlLCBmaWxlTmFtZSB9ID0gdGhpcy5leHRyYWN0UGF0aFBhcnRzKGlucHV0KTtcclxuICAgICAgICBjb25zdCBmb3JtYXR0ZWRQYXRoID0gdGhpcy5yZXBsYWNlU3BhY2VzKGlucHV0LCByZXBsYWNlU3BhY2VzKTtcclxuICAgICAgICBjb25zdCBmb3JtYXR0ZWRUaXRsZSA9IHRoaXMucmVwbGFjZVNwYWNlcyh0aXRsZSwgcmVwbGFjZVNwYWNlcyk7XHJcbiAgICAgICAgcmV0dXJuIGBbWyR7Zm9ybWF0dGVkUGF0aH18JHtmb3JtYXR0ZWRUaXRsZX1dXWA7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGlucHV0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBhbiBpbnB1dCBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncyBpbnRvIGEgV2lraUxpbmsgZm9ybWF0IHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0gaW5wdXQgLSBUaGUgaW5wdXQgdG8gYmUgY29udmVydGVkLiBDYW4gYmUgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cclxuICAgICAqIEBwYXJhbSByZXBsYWNlU3BhY2VzIC0gT3B0aW9uYWwgcGFyYW1ldGVyIHRvIHNwZWNpZnkgYSByZXBsYWNlbWVudCBmb3Igc3BhY2VzIGluIHRoZSBwYXRoIG9yIHRpdGxlLlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICBJZiBwcm92aWRlZCwgc3BhY2VzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGlzIHZhbHVlLlxyXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgaW4gV2lraUxpbmsgZm9ybWF0IGlmIHRoZSBpbnB1dCBpcyBhIHNpbmdsZSBzdHJpbmcsIG9yIGEgY29uY2F0ZW5hdGVkIHN0cmluZ1xyXG4gICAgICogICAgICAgICAgb2YgV2lraUxpbmtzIGlmIHRoZSBpbnB1dCBpcyBhbiBhcnJheSBvZiBzdHJpbmdzLlxyXG4gICAgICogXHJcbiAgICAgKiBUaGUgV2lraUxpbmsgZm9ybWF0IGlzIGBbW2ZpbGVOYW1lXV1gLCB3aGVyZTpcclxuICAgICAqIC0gYGZpbGVOYW1lYCBpcyB0aGUgZm9ybWF0dGVkIHVuaXF1ZSBmaWxlTmFtZSBvZiB0aGUgbGluay5cclxuICAgICAqIFxyXG4gICAgICogSWYgdGhlIGlucHV0IGlzIGFuIGFycmF5LCBlYWNoIGVsZW1lbnQgaXMgY29udmVydGVkIHRvIGEgV2lraUxpbmsgYW5kIGpvaW5lZCB3aXRoIGEgY29tbWEuXHJcbiAgICAgKi9cclxuICAgIHRvV2lraUxpbmsoaW5wdXQ6IGFueSwgcmVwbGFjZVNwYWNlcyA9ICcgJyk6IHN0cmluZyB8IHN0cmluZ1tdIHtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0LmZsYXRNYXAoaXRlbSA9PiB0aGlzLnRvV2lraUxpbmsoaXRlbSkpO1xyXG4gICAgICAgIC8vcmV0dXJuIGlucHV0Lm1hcChpdGVtID0+IHRoaXMudG9XaWtpTGluayhpdGVtKSkuam9pbignLCAnKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGNvbnN0IHsgcGF0aCwgdGl0bGUgfSA9IHRoaXMuZXh0cmFjdExpbmtQYXJ0cyhpbnB1dCk7XHJcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkVGl0bGUgPSB0aGlzLnJlcGxhY2VTcGFjZXModGhpcy5yZW1vdmVBbGxFeHRlbnNpb25zKHRpdGxlKSwgcmVwbGFjZVNwYWNlcyk7XHJcbiAgICAgICAgcmV0dXJuIGBbWyR7Zm9ybWF0dGVkVGl0bGV9XV1gO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBpbnB1dDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVwbGFjZXMgYWxsIHdoaXRlc3BhY2UgY2hhcmFjdGVycyBpbiB0aGUgZ2l2ZW4gdGV4dCB3aXRoIGEgc3BlY2lmaWVkIHJlcGxhY2VtZW50IHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGV4dCAtIFRoZSBpbnB1dCBzdHJpbmcgaW4gd2hpY2ggc3BhY2VzIHdpbGwgYmUgcmVwbGFjZWQuXHJcbiAgICAgKiBAcGFyYW0gcmVwbGFjZUJ5IC0gT3B0aW9uYWwuIFRoZSBzdHJpbmcgdG8gcmVwbGFjZSBzcGFjZXMgd2l0aC4gSWYgbm90IHByb3ZpZGVkLCB1c2VzIHRoZSB2YWx1ZSBmcm9tIGB0aGlzLnNldHRpbmdzLnNwYWNlUmVwbGFjZW1lbnRgIG9yIGRlZmF1bHRzIHRvICdfJy5cclxuICAgICAqIEByZXR1cm5zIFRoZSBtb2RpZmllZCBzdHJpbmcgd2l0aCBzcGFjZXMgcmVwbGFjZWQgYnkgdGhlIHNwZWNpZmllZCByZXBsYWNlbWVudCBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIHJlcGxhY2VTcGFjZXModGV4dDpzdHJpbmcsIHJlcGxhY2VCeTpzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQpOnN0cmluZyB7XHJcbiAgICAgIGxldCByZXBsYWNlU3RyaW5nID0gJ18nO1xyXG4gICAgICBpZiAoIXJlcGxhY2VCeSAmJiB0aGlzLnNldHRpbmdzKSB7XHJcbiAgICAgICAgcmVwbGFjZVN0cmluZyA9IHRoaXMuc2V0dGluZ3Muc3BhY2VSZXBsYWNlbWVudCB8fCAnXyc7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKHJlcGxhY2VCeSkgcmVwbGFjZVN0cmluZyA9IHJlcGxhY2VCeTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9cXHMrL2csIHJlcGxhY2VTdHJpbmcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBBTEwgZmlsZSBleHRlbnNpb24ocykgZnJvbSBhIGdpdmVuIGZpbGUgbmFtZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZmlsZU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZmlsZSwgaW5jbHVkaW5nIGl0cyBleHRlbnNpb24uXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZmlsZSBuYW1lIHdpdGhvdXQgaXRzIGV4dGVuc2lvbi5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlQWxsRXh0ZW5zaW9ucyhmaWxlTmFtZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gZmlsZU5hbWUuc3BsaXQoJy4nKVswXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgbGFzdCBmaWxlIGV4dGVuc2lvbihzKSBmcm9tIGEgZ2l2ZW4gZmlsZSBuYW1lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmaWxlTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmaWxlLCBpbmNsdWRpbmcgaXRzIGV4dGVuc2lvbi5cclxuICAgICAqIEByZXR1cm5zIFRoZSBmaWxlIG5hbWUgd2l0aG91dCBpdHMgZXh0ZW5zaW9uLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVFeHRlbnNpb25zKGZpbGVOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGZpbGVOYW1lLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgcmVzdWx0LnBvcCgpOyAvLyByZW1vdmUgdGhlIGxhc3QgcGFydFxyXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSByZXR1cm4gZmlsZU5hbWU7IC8vIG5vIGV4dGVuc2lvblxyXG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbignLicpIHx8IGZpbGVOYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYSBnaXZlbiBzdHJpbmcgdG8gY2FtZWxDYXNlIGZvcm1hdC5cclxuICAgICAqXHJcbiAgICAgKiBTcGxpdHMgdGhlIGlucHV0IHRleHQgYnkgc3BhY2VzLCBsb3dlcmNhc2VzIHRoZSBmaXJzdCB3b3JkLFxyXG4gICAgICogYW5kIGNhcGl0YWxpemVzIHRoZSBmaXJzdCBsZXR0ZXIgb2YgZWFjaCBzdWJzZXF1ZW50IHdvcmQsXHJcbiAgICAgKiB0aGVuIGpvaW5zIHRoZW0gdG9nZXRoZXIgd2l0aG91dCBzcGFjZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRleHQgLSBUaGUgaW5wdXQgc3RyaW5nIHRvIGJlIGNvbnZlcnRlZC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBjYW1lbENhc2UgZm9ybWF0dGVkIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgZm9ybWF0VXBwZXJDYW1lbENhc2UodGV4dDpzdHJpbmcpOnN0cmluZyB7XHJcbiAgICAgIGxldCB0ZXh0UGFydHMgPSB0ZXh0LnNwbGl0KCcgJyk7XHJcbiAgICAgIGxldCBjb252ZXJ0ZWRUZXh0UGFydHM6c3RyaW5nW10gPSBbXTtcclxuICAgICAgdGV4dFBhcnRzLmZvckVhY2goKHRleHQsaW5kZXgpID0+IHtcclxuICAgICAgICBsZXQgbmV3VGV4dFBhcnQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgbmV3VGV4dFBhcnQgPSBuZXdUZXh0UGFydC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5ld1RleHRQYXJ0LnNsaWNlKDEpO1xyXG4gICAgICAgIGNvbnZlcnRlZFRleHRQYXJ0cy5wdXNoKG5ld1RleHRQYXJ0KTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBjb252ZXJ0ZWRUZXh0UGFydHMuam9pbignJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQgdGhlIHBhdGggdG8gYSBmaWxlIGZyb20gYSBzdHJpbmcgY29udGFpbmluZyB0aGUgZnVsbCBwYXJoL25hbWUgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBzdHJpbmdcclxuICAgICAqIEBwYXJhbSBzZXBhcmF0b3Igc3RyaW5nIGRlZmF1bHRzIHRvICcvJ1xyXG4gICAgICogQHJldHVybnMgc3RyaW5nXHJcbiAgICAgKi9cclxuICAgIGdldEZvbGRlckZyb21QYXRoIChwYXRoOnN0cmluZ3xudWxsfHVuZGVmaW5lZCwgc2VwYXJhdG9yID0gJy8nKSB7XHJcbiAgICAgICAgaWYgKHBhdGggPT09IG51bGwpIHJldHVybiBudWxsO1xyXG4gICAgICAgIGlmIChwYXRoID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFBhdGhQYXJ0cyA9IHBhdGguc3BsaXQoJy8nKTtcclxuICAgICAgICBjdXJyZW50UGF0aFBhcnRzLnBvcCgpOyAvLyByZW1vdmUgRmlsZSBuYW1lO1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50UGF0aFBhcnRzLmpvaW4oc2VwYXJhdG9yKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiByZW1vdmVzIGR1cGxpY2F0ZSBzdHJpbmdzIGluIGFuIGFycmF5IGFuZCBkZWxldGVzIGVtcHR5IHN0cmluZ3NcclxuICAgICAqIEBwYXJhbSBzdHJpbmdBcnJheSBcclxuICAgICAqIEByZXR1cm5zIFxyXG4gICAgICovXHJcbiAgICByZW1vdmVEdXBsaWNhdGVTdHJpbmdzKHN0cmluZ0FycmF5OiBzdHJpbmdbXSk6IHN0cmluZ1tdIHtcclxuICAgICAgaWYgKCFzdHJpbmdBcnJheSkgcmV0dXJuIFtdO1xyXG4gICAgICBjb25zdCB1bmlxdWVTdHJpbmdzU2V0ID0gbmV3IFNldDxzdHJpbmc+KHN0cmluZ0FycmF5KTtcclxuICAgICAgdW5pcXVlU3RyaW5nc1NldC5kZWxldGUoJycpOyAvLyByZW1vdmUgZW1wdHkgc3RyaW5nc1xyXG4gICAgICByZXR1cm4gWy4uLnVuaXF1ZVN0cmluZ3NTZXRdO1xyXG4gICAgfVxyXG4gIH1cclxuLyoqXHJcbiAqIGdldCB0aGUgcGF0aCB0byBhIGZpbGUgZnJvbSBhIHN0cmluZyBjb250YWluaW5nIHRoZSBmdWxsIHBhcmgvbmFtZSBzdHJpbmdcclxuICogQHBhcmFtIHBhdGggc3RyaW5nXHJcbiAqIEBwYXJhbSBzZXBhcmF0b3Igc3RyaW5nIGRlZmF1bHRzIHRvICcvJ1xyXG4gKiBAcmV0dXJucyBzdHJpbmdcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRGb2xkZXJGcm9tUGF0aCAocGF0aDpzdHJpbmd8bnVsbHx1bmRlZmluZWQsIHNlcGFyYXRvciA9ICcvJykge1xyXG4gICAgaWYgKHBhdGggPT09IG51bGwpIHJldHVybiBudWxsO1xyXG4gICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IGN1cnJlbnRQYXRoUGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XHJcbiAgICBjdXJyZW50UGF0aFBhcnRzLnBvcCgpOyAvLyByZW1vdmUgRmlsZSBuYW1lO1xyXG4gICAgcmV0dXJuIGN1cnJlbnRQYXRoUGFydHMuam9pbihzZXBhcmF0b3IpO1xyXG59XHJcbiAgICAiLCAiaW1wb3J0IHsgTW9kYWwsIEFwcCwgU2V0dGluZyB9IGZyb20gJ29ic2lkaWFuJztcclxuXHJcbi8qKlxyXG4gKiBkaXNwbGF5IGFuIEFsZXJ0IE1vZGFsXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQWxlcnRNb2RhbCBleHRlbmRzIE1vZGFsIHtcclxuICAgIHByaXZhdGUgdGl0bGU6IHN0cmluZztcclxuICAgIHByaXZhdGUgZGVzY3JpcHRpb246IHN0cmluZztcclxuICAgIHByaXZhdGUgcmVzb2x2ZVByb21pc2UhOiAodmFsdWU6IHtwcm9jZWVkOmJvb2xlYW4sIGRhdGE6YW55fSkgPT4gdm9pZDtcclxuICAgIHByaXZhdGUgcHJvbWlzZTogUHJvbWlzZTx7cHJvY2VlZDpib29sZWFuLCBkYXRhOmFueX0+O1xyXG4gICAgcHJpdmF0ZSBidG4xVGV4dDogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBidG4yVGV4dDogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBjaGVja2JveEVsITogSFRNTElucHV0RWxlbWVudDtcclxuICAgIHByaXZhdGUgYXNrQWdhaW5MYWJlbDogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG4gIFxyXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHRpdGxlOiBzdHJpbmcsIGRlc2NyaXB0aW9uOiBzdHJpbmcsIGJ0bjE6IHN0cmluZywgYnRuMjpzdHJpbmcsIGFza0FnYWluTGFiZWw/OiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcclxuICAgICAgc3VwZXIoYXBwKTtcclxuICAgICAgdGhpcy50aXRsZSA9IHRpdGxlO1xyXG4gICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XHJcbiAgICAgIHRoaXMuYnRuMVRleHQgPSBidG4xO1xyXG4gICAgICB0aGlzLmJ0bjJUZXh0ID0gYnRuMjtcclxuICAgICAgdGhpcy5hc2tBZ2FpbkxhYmVsID0gYXNrQWdhaW5MYWJlbDtcclxuICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICB0aGlzLnJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgXHJcbiAgICBvbk9wZW4oKSB7XHJcbiAgICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xyXG4gIFxyXG4gICAgICBjb250ZW50RWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiB0aGlzLnRpdGxlIH0pO1xyXG4gICAgICBjb250ZW50RWwuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6IHRoaXMuZGVzY3JpcHRpb24gfSk7XHJcbiAgXHJcbiAgICAgIGNvbnN0IHNldHRpbmdzID0gbmV3IFNldHRpbmcoY29udGVudEVsKTtcclxuICAgICAgaWYgKHRoaXMuYXNrQWdhaW5MYWJlbCkge1xyXG4gICAgICAgIGNvbnN0IGl0ZW1JbmZvRGl2ID0gc2V0dGluZ3Muc2V0dGluZ0VsLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3NldHRpbmctaXRlbS1pbmZvJylbMF07XHJcbiAgICAgICAgaWYgKGl0ZW1JbmZvRGl2KSB7XHJcbiAgICAgICAgICB0aGlzLmNoZWNrYm94RWwgPSBpdGVtSW5mb0Rpdi5jcmVhdGVFbCgnaW5wdXQnLCB7IHR5cGU6ICdjaGVja2JveCcgfSk7XHJcbiAgICAgICAgICBjb25zdCBsYWJlbCA9IGl0ZW1JbmZvRGl2LmNyZWF0ZUVsKCdsYWJlbCcsIHsgdGV4dDogdGhpcy5hc2tBZ2FpbkxhYmVsIH0pO1xyXG4gICAgICAgICAgbGFiZWwuc3R5bGUubWFyZ2luTGVmdCA9ICc4cHgnO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBzZXR0aW5ncy5hZGRCdXR0b24oKGJ0bikgPT4ge1xyXG4gICAgICAgICAgYnRuLnNldEJ1dHRvblRleHQodGhpcy5idG4xVGV4dClcclxuICAgICAgICAgICAgLnNldEN0YSgpXHJcbiAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlUHJvbWlzZSh7cHJvY2VlZDp0cnVlLCBkYXRhOnthc2tDb25maXJtYXRpb246IHRoaXMuY2hlY2tib3hFbD8uY2hlY2tlZH19KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgc2V0dGluZ3MuYWRkQnV0dG9uKChidG4pID0+IHtcclxuICAgICAgICAgIGJ0bi5zZXRCdXR0b25UZXh0KHRoaXMuYnRuMlRleHQpXHJcbiAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlUHJvbWlzZSh7cHJvY2VlZDpmYWxzZSwgZGF0YTp7YXNrQ29uZmlybWF0aW9uOiB0aGlzLmNoZWNrYm94RWw/LmNoZWNrZWR9fSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgb25DbG9zZSgpIHtcclxuICAgICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XHJcbiAgICAgIGNvbnRlbnRFbC5lbXB0eSgpO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgYXN5bmMgb3BlbkFuZEdldFZhbHVlKCk6IFByb21pc2U8e3Byb2NlZWQ6Ym9vbGVhbiwgZGF0YTphbnl9PiB7XHJcbiAgICAgIHRoaXMub3BlbigpO1xyXG4gICAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xyXG4gICAgfVxyXG4gIH0iLCAiaW1wb3J0IHsgQXBwLCBQbHVnaW4sIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7IHBhcnNlSlNDb2RlLCBTY3JpcHRpbmdUb29scyB9IGZyb20gXCIuLi90b29sc1wiO1xyXG5pbXBvcnQgeyBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCBPYnNpZGlhblByb3BlcnR5VHlwZXMgfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuaW1wb3J0IHsgRVJST1IsIGxvZ2dlciwgV0FSTklORyB9IGZyb20gXCIuLi9Mb2dcIjtcclxuXHJcbmV4cG9ydCB0eXBlIEZyb250bWF0dGVyQXV0b21hdGVSdWxlVHlwZXMgPSAnYnVpbGRJbicgfCAnYnVpbGRJbi5pbnB1dFByb3BlcnR5JyB8ICdhdXRvY29tcGxldGUubW9kYWwnIHwgJ2F1dG9tYXRpb24nIHwgJ3NjcmlwdCcgfCAnZm9ybWF0dGVyJyB8ICdsaW5rRm9ybWF0dGVyJyA7XHJcbi8qKlxyXG4gKiBUaGUgYFJ1bGVDb25maWdFbGVtZW50c2AgaW50ZXJmYWNlIGRlZmluZXMgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgYSBydWxlLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBpbnRlcmZhY2UgUnVsZUNvbmZpZ0VsZW1lbnRzXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFJ1bGVDb25maWdFbGVtZW50cyB7XHJcbiAgICBba2V5OiBzdHJpbmddOiBib29sZWFuOyAvLyBBbGxvdyBzdHJpbmcga2V5cyB3aXRoIGJvb2xlYW4gdmFsdWVzXHJcbiAgICByZW1vdmVDb250ZW50OiBib29sZWFuO1xyXG4gICAgcnVsZUFjdGl2ZTogYm9vbGVhbjtcclxuICAgIG1vZGlmeU9ubHk6IGJvb2xlYW47XHJcbiAgICBpbnB1dFByb3BlcnR5OiBib29sZWFuO1xyXG4gICAgYWRkUHJlZml4OiBib29sZWFuO1xyXG4gICAgc3BhY2VSZXBsYWNlbWVudDogYm9vbGVhbjtcclxuICAgIHNwZWNpYWxDaGFyYWN0ZXJSZXBsYWNlbWVudDogYm9vbGVhbjtcclxuICAgIGNvbnZlcnRUb0xvd2VyQ2FzZTogYm9vbGVhbjtcclxuICAgIHJlc3VsdEFzTGluazogYm9vbGVhbjtcclxuICAgIGFkZENvbnRlbnQ6IGJvb2xlYW47XHJcbiAgICBleGNsdWRlRm9sZGVyczogYm9vbGVhbjtcclxuICAgIGluY2x1ZGVGb2xkZXJzOiBib29sZWFuO1xyXG4gICAgc2NyaXB0OiBib29sZWFuO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgUnVsZVByb3RvdHlwZSB7XHJcbiAgICBydWxlc0NvbmZpZ0RpdjogSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcbiAgICBzY3JpcHRpbmdUb29sczogU2NyaXB0aW5nVG9vbHM7XHJcbiAgICBpZCE6IHN0cmluZztcclxuICAgIG5hbWUhOiBzdHJpbmc7XHJcbiAgICBkZXNjcmlwdGlvbiE6IHN0cmluZztcclxuICAgIHJ1bGVUeXBlOiBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVR5cGVzID0gJ2J1aWxkSW4nO1xyXG4gICAgaXNMaXZlUnVsZTogYm9vbGVhbiA9IGZhbHNlOyAvLyBJZiB0cnVlLCB0aGUgcnVsZSBpcyBhIGxpdmUgcnVsZSBhbmQgd2lsbCBiZSBleGVjdXRlZCBvbiBmaWxlIGNoYW5nZVxyXG4gICAgdHlwZTogc3RyaW5nW10gPSBbJ3RleHQnXTsgLy8gVHlwZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGJ5IHRoaXMgcnVsZVxyXG4gICAgY29uZmlnRWxlbWVudHM6IFJ1bGVDb25maWdFbGVtZW50cyB8IG9iamVjdCA9IHt9OyAvLyBFbGVtZW50cyB0aGF0IGFyZSB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUgcnVsZVxyXG4gICAgc291cmNlOiBzdHJpbmcgPSAnZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBsZXQgcmVzdWx0ID0gXFwnXFwnXFxuICByZXR1cm4gcmVzdWx0O1xcbn0nO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFwcD86IEFwcCB8IHVuZGVmaW5lZCwgcGx1Z2luPzogYW55fCB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aGlzLnNjcmlwdGluZ1Rvb2xzID0gbmV3IFNjcmlwdGluZ1Rvb2xzKGFwcCwgcGx1Z2luKTtcclxuICAgIH07XHJcblxyXG4gICAgZ2V0U291cmNlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ4IChhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogYW55LCB0b29sczogU2NyaXB0aW5nVG9vbHMsIGlucHV0PzphbnkpIHsgLy8gRGVmYXVsdCBmdW5jdGlvbiBzaWduYXR1cmVcclxuICAgICAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCB8fCBpbnB1dCA9PT0gbnVsbCkgaW5wdXQgPSB0b29scy5nZXRDdXJyZW50Q29udGVudCgpOyAvLyBHZXQgdGhlIGN1cnJlbnQgY29udGVudCBvZiBwcm9wZXJ0eVxyXG4gICAgICAgIHJldHVybiBpbnB1dDsgLy8gUmV0dXJuIHRoZSBpbnB1dCB1bmFsdGVyZWRcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25maWd1cmVzIHRoZSBzZXR0aW5ncyB0YWIgZm9yIGEgc3BlY2lmaWMgcnVsZSBpbiB0aGUgcGx1Z2luLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25FTCAtIFRoZSBIVE1MIGVsZW1lbnQgd2hlcmUgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB3aWxsIGJlIHJlbmRlcmVkLlxyXG4gICAgICogQHBhcmFtIHJ1bGUgLSBUaGUgc2V0dGluZ3Mgb2JqZWN0IGZvciB0aGUgZnJvbnRtYXR0ZXIgYXV0b21hdGlvbiBydWxlLlxyXG4gICAgICogQHBhcmFtIHRoYXQgLSBUaGUgY29udGV4dCBvciByZWZlcmVuY2UgdG8gdGhlIGNhbGxpbmcgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHByZXZpZXdDb21wb25lbnQgLSBUaGUgY29tcG9uZW50IHVzZWQgdG8gcmVuZGVyIGEgcHJldmlldyBvZiB0aGUgcnVsZSdzIGVmZmVjdC5cclxuICAgICAqL1xyXG4gICAgY29uZmlnVGFiIChvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6RnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDphbnksIHByZXZpZXdDb21wb25lbnQ6IGFueSkge1xyXG4gICAgICAgIG9wdGlvbkVMLmVtcHR5KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGRlZmF1bHRDb25maWdFbGVtZW50cyhtb2RpZmllcnM6IFJ1bGVDb25maWdFbGVtZW50cyB8IGFueSk6IFJ1bGVDb25maWdFbGVtZW50cyB7XHJcbiAgICAgICAgY29uc3QgY29uZmlnRWxlbWVudHM6IFJ1bGVDb25maWdFbGVtZW50cyA9IHtcclxuICAgICAgICAgICAgcmVtb3ZlQ29udGVudDogdHJ1ZSxcclxuICAgICAgICAgICAgcnVsZUFjdGl2ZTogdHJ1ZSxcclxuICAgICAgICAgICAgbW9kaWZ5T25seTogdHJ1ZSxcclxuICAgICAgICAgICAgaW5wdXRQcm9wZXJ0eTogZmFsc2UsXHJcbiAgICAgICAgICAgIGFkZFByZWZpeDogdHJ1ZSxcclxuICAgICAgICAgICAgc3BhY2VSZXBsYWNlbWVudDogdHJ1ZSxcclxuICAgICAgICAgICAgc3BlY2lhbENoYXJhY3RlclJlcGxhY2VtZW50OiB0cnVlLFxyXG4gICAgICAgICAgICBjb252ZXJ0VG9Mb3dlckNhc2U6IHRydWUsXHJcbiAgICAgICAgICAgIHJlc3VsdEFzTGluazogdHJ1ZSxcclxuICAgICAgICAgICAgYWRkQ29udGVudDogdHJ1ZSxcclxuICAgICAgICAgICAgZXhjbHVkZUZvbGRlcnM6IHRydWUsXHJcbiAgICAgICAgICAgIGluY2x1ZGVGb2xkZXJzOiB0cnVlLFxyXG4gICAgICAgICAgICBzY3JpcHQ6IHRydWUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnRWxlbWVudHMsIG1vZGlmaWVycyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBhIHNwZWNpZmljIHJ1bGUgb3B0aW9uIGlzIGVuYWJsZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbiAtIFRoZSBuYW1lIG9mIHRoZSBydWxlIG9wdGlvbiB0byBjaGVjay5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBpZiB0aGUgb3B0aW9uIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgdXNlUnVsZU9wdGlvbihvcHRpb246c3RyaW5nKTpib29sZWFuIHtcclxuICAgICAgICBpZiAoKHRoaXMuY29uZmlnRWxlbWVudHMgYXMgUnVsZUNvbmZpZ0VsZW1lbnRzKVtvcHRpb25dID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKHRoaXMuY29uZmlnRWxlbWVudHMgYXMgUnVsZUNvbmZpZ0VsZW1lbnRzKVtvcHRpb25dIHx8IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgdGhlIHJ1bGUgaGFzIGFueSBjb25maWd1cmF0aW9uIG9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IC0gUmV0dXJucyB0cnVlIGlmIHRoZSBydWxlIGhhcyBvcHRpb25zLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIGhhc093bkNvbmZpZ1RhYigpOiBib29sZWFuIHtcclxuICAgICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuY29uZmlnVGFiICE9PSBSdWxlUHJvdG90eXBlLnByb3RvdHlwZS5jb25maWdUYWI7XHJcbiAgICB9ICAgXHJcbiAgICAvKipcclxuICAgICAqIEV4ZWN1dGVzIHRoZSBgZnhgIGZ1bmN0aW9uIGJhc2VkIG9uIHRoZSBgcnVsZVR5cGVgLlxyXG4gICAgICogSGFuZGxlcyBkaWZmZXJlbnQgZnVuY3Rpb24gc2lnbmF0dXJlcyBkeW5hbWljYWxseS5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtBcHB9IGFwcCAtIFRoZSBPYnNpZGlhbiBhcHAgaW5zdGFuY2UuXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gZmlsZSAtIFRoZSBmaWxlIHRvIHBhc3MgdG8gdGhlIHJ1bGUncyBgZnhgIGZ1bmN0aW9uLlxyXG4gICAgICogQHBhcmFtIHtTY3JpcHRpbmdUb29sc30gdG9vbHMgLSBUaGUgc2NyaXB0aW5nIHRvb2xzIHRvIHBhc3MgdG8gdGhlIHJ1bGUncyBgZnhgIGZ1bmN0aW9uLlxyXG4gICAgICogQHBhcmFtIHthbnl9IFtpbnB1dF0gLSBPcHRpb25hbCBpbnB1dCBmb3IgcnVsZXMgdGhhdCByZXF1aXJlIGl0IChlLmcuLCBgYnVpbGRJbi5pbnB1dFByb3BlcnR5YCkuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSByZXN1bHQgb2YgdGhlIGBmeGAgZnVuY3Rpb24uXHJcbiAgICAqL1xyXG4gICAgZXhlY3V0ZShhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogYW55LCB0b29sczogU2NyaXB0aW5nVG9vbHMsIGlucHV0PzogYW55KTogc3RyaW5nIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMucnVsZVR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnZm9ybWF0dGVyJzpcclxuICAgICAgICAgICAgY2FzZSAnbGlua0Zvcm1hdHRlcic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5meChhcHAsIGZpbGUsIHRvb2xzLCBpbnB1dCk7IC8vIGBmb3JtYXR0ZXJgIHJ1bGVzIGV4cGVjdCAoaW5wdXQsIHRvb2xzKVxyXG5cclxuICAgICAgICAgICAgY2FzZSAnYnVpbGRJbi5pbnB1dFByb3BlcnR5JzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZ4KGFwcCwgZmlsZSwgdG9vbHMsIGlucHV0KTsgLy8gYGJ1aWxkSW4uaW5wdXRQcm9wZXJ0eWAgcnVsZXMgZXhwZWN0IChhcHAsIGZpbGUsIHRvb2xzLCBpbnB1dClcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ2F1dG9jb21wbGV0ZS5tb2RhbCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ2F1dG9tYXRpb24nOlxyXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGFzeW5jIGZ1bmN0aW9ucyBieSByZXNvbHZpbmcgdGhlIFByb21pc2Ugc3luY2hyb25vdXNseVxyXG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5meChhcHAsIGZpbGUsIHRvb2xzKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChyZXM6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycjogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coRVJST1IsYEVycm9yIGV4ZWN1dGluZyBhc3luYyBhdXRvbWF0aW9uIHJ1bGU6ICR7ZXJyfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsgLy8gUmV0dXJuIHRoZSByZXNvbHZlZCByZXN1bHQgYXMgYSBzdHJpbmdcclxuXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5meChhcHAsIGZpbGUsIHRvb2xzKTsgLy8gRGVmYXVsdCBydWxlcyBleHBlY3QgKGFwcCwgZmlsZSwgdG9vbHMpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgYFJ1bGVzYCBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgbWFuYWdpbmcgYW5kIG9yZ2FuaXppbmcgYSBjb2xsZWN0aW9uIG9mIHJ1bGVzLlxyXG4gKiBJdCBwcm92aWRlcyBtZXRob2RzIHRvIHJlZ2lzdGVyIG5ldyBydWxlcyBhbmQgcmV0cmlldmUgcnVsZXMgYmFzZWQgb24gdGhlaXIgdHlwZS5cclxuICpcclxuICogQHJlbWFya3NcclxuICogVGhpcyBjbGFzcyBpcyBkZXNpZ25lZCB0byB3b3JrIHdpdGhpbiB0aGUgY29udGV4dCBvZiBhbiBPYnNpZGlhbiBwbHVnaW4gYW5kIHJlbGllcyBvblxyXG4gKiB0aGUgYEFwcGAgYW5kIGBwbHVnaW5gIGluc3RhbmNlcyBmb3IgaXRzIGZ1bmN0aW9uYWxpdHkuIFJ1bGVzIGFyZSBzdG9yZWQgYXMgYW4gYXJyYXlcclxuICogb2YgYFJ1bGVQcm90b3R5cGVgIG9iamVjdHMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY29uc3QgcnVsZXNNYW5hZ2VyID0gbmV3IFJ1bGVzKGFwcCwgcGx1Z2luKTtcclxuICogcnVsZXNNYW5hZ2VyLnJlZ2lzdGVyUnVsZSh7XHJcbiAqICAgaWQ6IFwiZXhhbXBsZS1ydWxlXCIsXHJcbiAqICAgbmFtZTogXCJFeGFtcGxlIFJ1bGVcIixcclxuICogICBydWxlVHlwZTogRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVUeXBlcy5Tb21lVHlwZSxcclxuICogfSk7XHJcbiAqIGNvbnN0IGZpbHRlcmVkUnVsZXMgPSBydWxlc01hbmFnZXIuZ2V0UnVsZXNCeVR5cGUoRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVUeXBlcy5Tb21lVHlwZSk7XHJcbiAqIGNvbnNvbGUubG9nKGZpbHRlcmVkUnVsZXMpO1xyXG4gKiBgYGBcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVzIHtcclxuICAgIGFwcDogQXBwIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG4gICAgcGx1Z2luOiBhbnkgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcbiAgICBydWxlczogUnVsZVByb3RvdHlwZVtdO1xyXG4gICAgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFwcD86IEFwcCB8IHVuZGVmaW5lZCwgcGx1Z2luPzogYW55KSB7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICAgICAgdGhpcy50b29scyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnJ1bGVzID0gW107XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGluaXQgKGFwcDogQXBwLCBwbHVnaW46IGFueSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzKSB7XHJcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICAgICAgdGhpcy50b29scyA9IHRvb2xzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJzIGEgbmV3IHJ1bGUgYnkgYWRkaW5nIGl0IHRvIHRoZSBsaXN0IG9mIGV4aXN0aW5nIHJ1bGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBydWxlIC0gVGhlIHJ1bGUgcHJvdG90eXBlIHRvIGJlIHJlZ2lzdGVyZWQuIFRoaXMgc2hvdWxkIGNvbmZvcm0gdG8gdGhlIGBSdWxlUHJvdG90eXBlYCBpbnRlcmZhY2UuXHJcbiAgICAgKi9cclxuICAgIHJlZ2lzdGVyUnVsZShydWxlOiBSdWxlUHJvdG90eXBlKSB7XHJcbiAgICAgICAgdGhpcy5ydWxlcy5wdXNoKHJ1bGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBydWxlcyBmaWx0ZXJlZCBieSB0aGUgc3BlY2lmaWVkIHJ1bGUgdHlwZSBhbmQgcHJvcGVydHkgdHlwZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcnVsZVR5cGUgLSBUaGUgdHlwZSBvZiBydWxlIHRvIGZpbHRlciBieS5cclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eVR5cGUgLSBUaGUgcHJvcGVydHkgdHlwZSB0byBmaWx0ZXIgYnkgd2l0aGluIHRoZSBydWxlJ3MgdHlwZSBhcnJheS5cclxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyB0aGUgYGlkYCBhbmQgYG5hbWVgIG9mIGVhY2ggbWF0Y2hpbmcgcnVsZSwgc29ydGVkIGFscGhhYmV0aWNhbGx5IGJ5IG5hbWUuXHJcbiAgICAgKi9cclxuICAgIGdldFJ1bGVzQnlUeXBlKHJ1bGVUeXBlOiBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVR5cGVzLCBwcm9wZXJ0eVR5cGU/OiBPYnNpZGlhblByb3BlcnR5VHlwZXMpOiBBcnJheTx7aWQ6IHN0cmluZywgbmFtZTogc3RyaW5nfT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJ1bGVzXHJcbiAgICAgICAgICAgIC5maWx0ZXIocnVsZSA9PiBydWxlLnJ1bGVUeXBlID09PSBydWxlVHlwZSAmJiAoIXByb3BlcnR5VHlwZSB8fCBydWxlLnR5cGUuaW5jbHVkZXMocHJvcGVydHlUeXBlKSkpIC8vIEZpbHRlciBydWxlcyBieSBydWxlVHlwZSBhbmQgcHJvcGVydHlUeXBlXHJcbiAgICAgICAgICAgIC5tYXAocnVsZSA9PiAoeyBpZDogcnVsZS5pZCwgbmFtZTogcnVsZS5uYW1lIH0pKSAvLyBNYXAgdG8ge2lkLCBuYW1lfVxyXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKSk7IC8vIFNvcnQgYWxwaGFiZXRpY2FsbHkgYnkgbmFtZVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIGEgcnVsZSBvYmplY3QgYnkgaXRzIHVuaXF1ZSBpZGVudGlmaWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgcnVsZSB0byByZXRyaWV2ZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBydWxlIG9iamVjdCBtYXRjaGluZyB0aGUgcHJvdmlkZWQgSUQsIG9yIGB1bmRlZmluZWRgIGlmIG5vIG1hdGNoaW5nIHJ1bGUgaXMgZm91bmQuXHJcbiAgICAgKiBAdGhyb3dzIExvZ3MgYSB3YXJuaW5nIHRvIHRoZSBjb25zb2xlIGlmIHRoZSBydWxlIHdpdGggdGhlIHNwZWNpZmllZCBJRCBpcyBub3QgZm91bmQuXHJcbiAgICAgKi9cclxuICAgIGdldFJ1bGVCeUlkKGlkOiBzdHJpbmcpOiBSdWxlUHJvdG90eXBlIHwgdW5kZWZpbmVkIHtcclxuICAgICAgICBjb25zdCBydWxlT2JqZWN0ID0gdGhpcy5ydWxlcy5maW5kKHJ1bGUgPT4gcnVsZS5pZCA9PT0gaWQpO1xyXG4gICAgICAgIGlmICghcnVsZU9iamVjdCkge1xyXG4gICAgICAgICAgICBsb2dnZXIubG9nKFdBUk5JTkcsYFJ1bGUgd2l0aCBpZCBcIiR7aWR9XCIgbm90IGZvdW5kLmApO1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcnVsZU9iamVjdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSBzb3VyY2UgY29kZSBvZiBhIHJ1bGUgYnkgaXRzIHVuaXF1ZSBpZGVudGlmaWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgcnVsZSBmb3Igd2hpY2ggdG8gcmV0cmlldmUgdGhlIHNvdXJjZSBjb2RlLlxyXG4gICAgICogQHJldHVybnMgVGhlIHNvdXJjZSBjb2RlIG9mIHRoZSBydWxlLCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgcnVsZSBpcyBub3QgZm91bmQuXHJcbiAgICAgKi9cclxuICAgIGdldFNvdXJjZShpZDogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuICAgICAgICBjb25zdCBydWxlT2JqZWN0ID0gdGhpcy5nZXRSdWxlQnlJZChpZCk7XHJcbiAgICAgICAgaWYgKCFydWxlT2JqZWN0KSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5sb2coV0FSTklORyxgU291cmNlIGZvciBydWxlIHdpdGggaWQgXCIke2lkfVwiIG5vdCBmb3VuZC5gKTtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJ1bGVPYmplY3QuZ2V0U291cmNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeGVjdXRlcyB0aGUgYGZ4YCBmdW5jdGlvbiBvZiBhIHJ1bGUgbWF0Y2hpbmcgdGhlIGdpdmVuIGBpZGAgYW5kIHJldHVybnMgaXRzIHJlc3VsdC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBydWxlIHRvIGV4ZWN1dGUuXHJcbiAgICAgKiBAcGFyYW0ge0FwcH0gYXBwIC0gVGhlIE9ic2lkaWFuIGFwcCBpbnN0YW5jZS5cclxuICAgICAqIEBwYXJhbSB7YW55fSBmaWxlIC0gVGhlIGZpbGUgdG8gcGFzcyB0byB0aGUgcnVsZSdzIGBmeGAgZnVuY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0ge1NjcmlwdGluZ1Rvb2xzfSB0b29scyAtIFRoZSBzY3JpcHRpbmcgdG9vbHMgdG8gcGFzcyB0byB0aGUgcnVsZSdzIGBmeGAgZnVuY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gW2lucHV0XSAtIE9wdGlvbmFsIGlucHV0IGZvciBydWxlcyB0aGF0IHJlcXVpcmUgaXQuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgbnVsbH0gLSBUaGUgcmVzdWx0IG9mIHRoZSBgZnhgIGZ1bmN0aW9uLCBvciBgbnVsbGAgaWYgdGhlIHJ1bGUgaXMgbm90IGZvdW5kLlxyXG4gICAgKi9cclxuICAgIGV4ZWN1dGVSdWxlQnlJZChpZDogc3RyaW5nLCBydWxlU2V0dGluZ3M6IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBhbnksIHRvb2xzOiBTY3JpcHRpbmdUb29scywgaW5wdXQ/OiBhbnkpOiBzdHJpbmcgfCBudWxsIHtcclxuICAgICAgICBjb25zdCBydWxlID0gdGhpcy5ydWxlcy5maW5kKHJ1bGUgPT4gcnVsZS5pZCA9PT0gaWQpO1xyXG4gICAgICAgIGlmICghcnVsZSkge1xyXG4gICAgICAgICAgICBsb2dnZXIubG9nKFdBUk5JTkcsYFJ1bGUgd2l0aCBpZCBcIiR7aWR9XCIgbm90IGZvdW5kLmApO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZVJ1bGUocnVsZVNldHRpbmdzLCBydWxlLCBhcHAsIGZpbGUsIHRvb2xzLCBpbnB1dCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4ZWN1dGVzIHRoZSBgZnhgIGZ1bmN0aW9uIG9mIGEgZ2l2ZW4gcnVsZSBhbmQgcmV0dXJucyBpdHMgcmVzdWx0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBydWxlIC0gVGhlIHJ1bGUgdG8gZXhlY3V0ZS5cclxuICAgICAqIEBwYXJhbSBhcHAgLSBUaGUgT2JzaWRpYW4gYXBwIGluc3RhbmNlLlxyXG4gICAgICogQHBhcmFtIGZpbGUgLSBUaGUgZmlsZSB0byBwYXNzIHRvIHRoZSBydWxlJ3MgYGZ4YCBmdW5jdGlvbi5cclxuICAgICAqIEBwYXJhbSB0b29scyAtIFRoZSBzY3JpcHRpbmcgdG9vbHMgdG8gcGFzcyB0byB0aGUgcnVsZSdzIGBmeGAgZnVuY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gaW5wdXQgLSBPcHRpb25hbCBpbnB1dCBmb3IgcnVsZXMgdGhhdCByZXF1aXJlIGl0LlxyXG4gICAgICogQHJldHVybnMge3N0cmluZyB8IG51bGx9IC0gVGhlIHJlc3VsdCBvZiB0aGUgYGZ4YCBmdW5jdGlvbiwgb3IgYG51bGxgIGlmIHRoZSBydWxlIGlzIG5vdCBmb3VuZC5cclxuICAgICAqL1xyXG4gICAgZXhlY3V0ZVJ1bGUocnVsZVNldHRpbmdzOiBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCBydWxlOiBSdWxlUHJvdG90eXBlLCBhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogYW55LCB0b29sczogU2NyaXB0aW5nVG9vbHMsIGlucHV0PzogYW55KTogc3RyaW5nIHwgbnVsbCB7XHJcbiAgICAgICAgc3dpdGNoIChydWxlLnJ1bGVUeXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2Zvcm1hdHRlcic6XHJcbiAgICAgICAgICAgIGNhc2UgJ2xpbmtGb3JtYXR0ZXInOlxyXG4gICAgICAgICAgICBjYXNlICdidWlsZEluLmlucHV0UHJvcGVydHknOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGUuZXhlY3V0ZShhcHAsIGZpbGUsIHRvb2xzLCBpbnB1dCk7XHJcbiAgICAgICAgICAgIGNhc2UgJ2F1dG9tYXRpb24nOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGUuZXhlY3V0ZShhcHAsIGZpbGUsIHRvb2xzKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGlmIChydWxlU2V0dGluZ3MudXNlQ3VzdG9tQ29kZSAmJiBydWxlU2V0dGluZ3MuYnVpbGRJbkNvZGUgJiYgcnVsZVNldHRpbmdzLmJ1aWxkSW5Db2RlICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBydWxlIGhhcyBjdXN0b20gY29kZSwgZXhlY3V0ZSBpdFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBwYXJzZUpTQ29kZShydWxlU2V0dGluZ3MuYnVpbGRJbkNvZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29kZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZShhcHAsIGZpbGUsIHRvb2xzKTsgLy8gUGFzcyBpbnB1dCBpZiBhdmFpbGFibGVcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKEVSUk9SLGBJbnZhbGlkIGN1c3RvbSBjb2RlIGZvciBydWxlIFwiJHtydWxlU2V0dGluZ3MuY29udGVudH1cIjogJHtydWxlU2V0dGluZ3MuYnVpbGRJbkNvZGV9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgSW52YWxpZCBjdXN0b20gY29kZSBmb3IgcnVsZSBcIiR7cnVsZVNldHRpbmdzLmlkfVwiYDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBydWxlLmV4ZWN1dGUoYXBwLCBmaWxlLCB0b29scywgaW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhcHBseUZvcm1hdE9wdGlvbnModmFsdWU6YW55LCBydWxlOkZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIGFjdGl2ZUZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMgKTphbnkge1xyXG5cclxuICAgICAgICBpZiAocnVsZS50eXBlID09PSAnbnVtYmVyJyB8fCBydWxlLnR5cGUgPT09ICdjaGVja2JveCcgfHwgcnVsZS50eXBlID09PSAnZGF0ZScgfHwgcnVsZS50eXBlID09PSAnZGF0ZXRpbWUnKSByZXR1cm4gdmFsdWU7IC8vIGxlYXZlIGRhdGUgYW5kIGRhdGVUaW1lIHVudG91Y2hlZFxyXG5cclxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xyXG4gICAgICAgICAgY2FzZSAnYm9vbGVhbic6XHJcbiAgICAgICAgICBjYXNlICdudW1iZXInOlxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICBjYXNlICdzdHJpbmcnOlxyXG4gICAgICAgICAgICAvL2lmIChydWxlLnNwYWNlUmVwbGFjZW1lbnQgJiYgcnVsZS5zcGFjZVJlcGxhY2VtZW50ICE9PSAnJykgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXHMrL2csIHJ1bGUuc3BhY2VSZXBsYWNlbWVudCk7XHJcbiAgICAgICAgICAgIC8vaWYgKHJ1bGUuc3BlY2lhbENoYXJSZXBsYWNlbWVudCAmJiBydWxlLnNwZWNpYWxDaGFyUmVwbGFjZW1lbnQgIT09JycpIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW15hLXpBLVowLTlcXC1fXFwvXHUwMEU0XHUwMEY2XHUwMEZDXHUwMERGXHUwMEM0XHUwMEQ2XHUwMERDXHUwMEUxXHUwMEU5XHUwMEVEXHUwMEYzXHUwMEZBXHUwMEZEXHUwMEMxXHUwMEM5XHUwMENEXHUwMEQzXHUwMERBXHUwMEREXHUwMEUwXHUwMEU4XHUwMEVDXHUwMEYyXHUwMEY5XHUwMEMwXHUwMEM4XHUwMENDXHUwMEQyXHUwMEQ5XHUwMEUyXHUwMEVBXHUwMEVFXHUwMEY0XHUwMEZCXHUwMEMyXHUwMENBXHUwMENFXHUwMEQ0XHUwMERCXHUwMEUzXHUwMEYxXHUwMEY1XHUwMEMzXHUwMEQxXHUwMEQ1XS9nLCBydWxlLnNwZWNpYWxDaGFyUmVwbGFjZW1lbnQpO1xyXG4gICAgICAgICAgICBpZiAocnVsZS5mb3JtYXR0ZXJzICYmIHJ1bGUuZm9ybWF0dGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgcnVsZS5mb3JtYXR0ZXJzLmZvckVhY2goZm9ybWF0dGVySWQgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmV4ZWN1dGVSdWxlQnlJZChmb3JtYXR0ZXJJZCwgcnVsZSwgdGhpcy5hcHAsIGFjdGl2ZUZpbGUsIHRvb2xzLCB2YWx1ZSk7IC8vIGV4ZWN1dGUgdGhlIGZvcm1hdHRlciBydWxlXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJ1bGUubGlua0Zvcm1hdHRlciAmJiBydWxlLmxpbmtGb3JtYXR0ZXIgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmV4ZWN1dGVSdWxlQnlJZChydWxlLmxpbmtGb3JtYXR0ZXIsIHJ1bGUsIHRoaXMuYXBwLCBhY3RpdmVGaWxlLCB0b29scywgdmFsdWUpOyAvLyBleGVjdXRlIHRoZSBsaW5rIGZvcm1hdHRlciBydWxlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9pZiAocnVsZS5wcmVmaXggJiYgcnVsZS5wcmVmaXggIT09ICcnKSB2YWx1ZSA9IHJ1bGUucHJlZml4ICsgdmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVxyXG4gICAgICAgICAgY2FzZSAnb2JqZWN0JzpcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCh2YWx1ZSA9PiB0aGlzLmFwcGx5Rm9ybWF0T3B0aW9ucyh2YWx1ZSwgcnVsZSwgYWN0aXZlRmlsZSwgdG9vbHMpKTsgLy8gcGFzcyBhY3RpdmVGaWxlIGFuZCB0b29sc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgbWVyZ2VSZXN1bHQocmVzdWx0OiBhbnksIG9sZFJlc3VsdDogYW55LCByZXR1cm5SZXN1bHQ6IGFueSwgcnVsZTogRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyk6IGFueSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnRvb2xzKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignVG9vbHMgYXJlIG5vdCBhdmFpbGFibGUgZm9yIG1lcmdpbmcgcmVzdWx0cy4nKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsgLy8gaWYgdG9vbHMgYXJlIG5vdCBhdmFpbGFibGUsIHJldHVybiB0aGUgcmVzdWx0IGFzIGlzXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAocnVsZS5hZGRDb250ZW50KSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ292ZXJ3cml0ZSc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm5SZXN1bHQgPSByZXN1bHQ7IC8vIHVwZGF0ZSBvciBhZGQgdGhlIG5ldyB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XHJcbiAgICAgICAgICAgICAgICBpZiAocnVsZS50eXBlID09PSAnbXVsdGl0ZXh0JyB8fCBydWxlLnR5cGUgPT09ICd0YWdzJyB8fCBydWxlLnR5cGUgPT09ICdhbGlhc2VzJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KSByZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHJlc3VsdCA9IFtyZXN1bHRdOyAvLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSBcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmV0dXJuUmVzdWx0KSkgcmV0dXJuUmVzdWx0ID0gW3JldHVyblJlc3VsdF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9sZFJlc3VsdCkpIG9sZFJlc3VsdCA9IFtvbGRSZXN1bHRdO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWx0ZXJlZCA9IHJldHVyblJlc3VsdC5maWx0ZXIoKHZhbHVlOmFueSkgPT4gIW9sZFJlc3VsdC5pbmNsdWRlcyh2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuUmVzdWx0ID0gdGhpcy50b29scy5yZW1vdmVEdXBsaWNhdGVTdHJpbmdzKGZpbHRlcmVkLmNvbmNhdChyZXN1bHQpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXR1cm5SZXN1bHQpIHJldHVyblJlc3VsdCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblJlc3VsdCA9IHJldHVyblJlc3VsdC5yZXBsYWNlQWxsKHJldHVyblJlc3VsdCxvbGRSZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblJlc3VsdCA9IHJldHVyblJlc3VsdCArIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdzdGFydCc6XHJcbiAgICAgICAgICAgICAgICBpZiAocnVsZS50eXBlID09PSAnbXVsdGl0ZXh0JyB8fCBydWxlLnR5cGUgPT09ICd0YWdzJyB8fCBydWxlLnR5cGUgPT09ICdhbGlhc2VzJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KSByZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHJlc3VsdCA9IFtyZXN1bHRdOyAvLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSBcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmV0dXJuUmVzdWx0KSkgcmV0dXJuUmVzdWx0ID0gW3JldHVyblJlc3VsdF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9sZFJlc3VsdCkpIG9sZFJlc3VsdCA9IFtvbGRSZXN1bHRdO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWx0ZXJlZCA9IHJldHVyblJlc3VsdC5maWx0ZXIoKHZhbHVlOmFueSkgPT4gIW9sZFJlc3VsdC5pbmNsdWRlcyh2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuUmVzdWx0ID0gdGhpcy50b29scy5yZW1vdmVEdXBsaWNhdGVTdHJpbmdzKHJlc3VsdC5jb25jYXQoZmlsdGVyZWQpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXR1cm5SZXN1bHQpIHJldHVyblJlc3VsdCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblJlc3VsdCA9IHJldHVyblJlc3VsdC5yZXBsYWNlQWxsKHJldHVyblJlc3VsdCxvbGRSZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblJlc3VsdCA9IHJlc3VsdCArIHJldHVyblJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0dXJuUmVzdWx0O1xyXG4gICAgfTtcclxuICAgICAgICAgICAgXHJcbiAgICAvKipcclxuICAgICAqIEJ1aWxkcyB0aGUgY29uZmlndXJhdGlvbiB0YWIgZm9yIGEgc3BlY2lmaWMgcnVsZSBieSBpdHMgSUQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBydWxlIGZvciB3aGljaCB0aGUgY29uZmlndXJhdGlvbiB0YWIgaXMgYmVpbmcgYnVpbHQuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uRUwgLSBUaGUgSFRNTCBlbGVtZW50IHdoZXJlIHRoZSBjb25maWd1cmF0aW9uIHRhYiB3aWxsIGJlIHJlbmRlcmVkLlxyXG4gICAgICogQHBhcmFtIHJ1bGUgLSBUaGUgZGVmaW5pdGlvbiBvZiB0aGUgcnVsZSwgY29udGFpbmluZyBpdHMgcHJvcGVydGllcyBhbmQgc2V0dGluZ3MuXHJcbiAgICAgKiBAcGFyYW0gdGhhdCAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGNvbnRleHQgb3Igb2JqZWN0LCB0eXBpY2FsbHkgdXNlZCBmb3IgbWFpbnRhaW5pbmcgc2NvcGUuXHJcbiAgICAgKiBAcGFyYW0gcHJldmlld0NvbXBvbmVudCAtIEEgY29tcG9uZW50IHVzZWQgdG8gcmVuZGVyIGEgcHJldmlldyBvZiB0aGUgcnVsZSdzIGVmZmVjdCBvciBjb25maWd1cmF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKiBJZiBhIHJ1bGUgd2l0aCB0aGUgc3BlY2lmaWVkIElEIGlzIGZvdW5kLCBpdHMgYGNvbmZpZ1RhYmAgbWV0aG9kIGlzIGludm9rZWQgdG8gYnVpbGQgdGhlIGNvbmZpZ3VyYXRpb24gdGFiLlxyXG4gICAgICogSWYgbm8gcnVsZSBpcyBmb3VuZCwgYSB3YXJuaW5nIGlzIGxvZ2dlZCB0byB0aGUgY29uc29sZS5cclxuICAgICAqL1xyXG4gICAgYnVpbGRDb25maWdUYWIoaWQ6IHN0cmluZywgb3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOiBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCB0aGF0OiBhbnksIHByZXZpZXdDb21wb25lbnQ6IGFueSkge1xyXG4gICAgICAgIGNvbnN0IHJ1bGVJbnN0YW5jZSA9IHRoaXMucnVsZXMuZmluZChydWxlID0+IHJ1bGUuaWQgPT09IGlkKTtcclxuICAgICAgICBpZiAocnVsZUluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHJ1bGVJbnN0YW5jZS5jb25maWdUYWIob3B0aW9uRUwsIHJ1bGUsIHRoYXQsIHByZXZpZXdDb21wb25lbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgUnVsZSB3aXRoIGlkIFwiJHtpZH1cIiBub3QgZm91bmQgZm9yIGNvbmZpZyB0YWIuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgcnVsZXNNYW5hZ2VyID0gbmV3IFJ1bGVzKCk7IiwgImltcG9ydCB7IERpcmVjdG9yeURpc3BsYXlNb2RlLCBEaXJlY3RvcnlTZWxlY3Rpb25Nb2RlIH0gZnJvbSAnLi9kaXJlY3RvcnlTZWxlY3Rpb25Nb2RhbCc7XHJcbmltcG9ydCB7IFRyZWVIaWVyYXJjaHlEYXRhIH0gZnJvbSAnLi91aVRyZWVIaWVyYXJjaHlTb3J0YWJsZVNldHRpbmdzJztcclxuaW1wb3J0IHsgV0FSTklORyB9IGZyb20gJy4vTG9nJztcclxuXHJcbmV4cG9ydCBjb25zdCB2ZXJzaW9uU3RyaW5nID0gXCIwLjAuMjVcIjtcclxuXHJcbmV4cG9ydCB0eXBlIE9ic2lkaWFuUHJvcGVydHlUeXBlcyA9IFwiYWxpYXNlc1wifFwiY2hlY2tib3hcInxcImRhdGVcInxcImRhdGV0aW1lXCJ8XCJtdWx0aXRleHRcInxcIm51bWJlclwifFwidGFnc1wifFwidGV4dFwiO1xyXG5leHBvcnQgdHlwZSBGcm9udG1hdHRlckF1dG9tYXRlRXZlbnRzID0gJ2NyZWF0ZScgfCAncmVuYW1lJyB8ICdhY3RpdmUtbGVhZi1jaGFuZ2UnIHwgJ21ldGFkYXRhLWNoYW5nZWQnIHwgJ2RlbGV0ZScgfCAnbW9kaWZ5JyB8ICdwcmV2aWV3JyB8ICdhbGwnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBGaWx0ZXJGaWxlc0FuZEZvbGRlcnMge1xyXG4gICAgc2VsZWN0ZWRGb2xkZXJzOiBzdHJpbmdbXSxcclxuICAgIHNlbGVjdGVkRmlsZXM6IHN0cmluZ1tdLFxyXG4gICAgbW9kZTogRGlyZWN0b3J5U2VsZWN0aW9uTW9kZSxcclxuICAgIGRpc3BsYXk6IERpcmVjdG9yeURpc3BsYXlNb2RlXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX0ZJTFRFUl9GSUxFU19BTkRfRk9MREVSUzogRmlsdGVyRmlsZXNBbmRGb2xkZXJzID0ge1xyXG4gICAgc2VsZWN0ZWRGb2xkZXJzOiBbXSxcclxuICAgIHNlbGVjdGVkRmlsZXM6IFtdLFxyXG4gICAgbW9kZTogJ2V4Y2x1ZGUnLFxyXG4gICAgZGlzcGxheTogJ2ZvbGRlcnMnLFxyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgRnJvbnRtYXR0ZXJBdXRvbWF0ZVNldHRpbmdzIHtcclxuICAgIHRhZ1ByZWZpeDogc3RyaW5nO1xyXG4gICAgZXhjbHVkZVJvb3RGb2xkZXI6IGJvb2xlYW47XHJcbiAgICB0YWdzUHJvcGVydHlOYW1lOiBzdHJpbmc7XHJcbiAgICBzcGFjZVJlcGxhY2VtZW50OiBzdHJpbmc7XHJcbiAgICBzcGVjaWFsQ2hhclJlcGxhY2VtZW50OiBzdHJpbmc7XHJcbiAgICBsb3dlcmNhc2VUYWdzOiBib29sZWFuO1xyXG4gICAga25vd25Qcm9wZXJ0aWVzOiBQcm9wZXJ0eVR5cGVJbmZvW107XHJcbiAgICBydWxlczogRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5nc1tdO1xyXG4gICAgdXNlVGV4dEFyZWE6IGJvb2xlYW47XHJcbiAgICBleGNsdWRlOiBGaWx0ZXJGaWxlc0FuZEZvbGRlcnM7XHJcbiAgICBpbmNsdWRlOiBGaWx0ZXJGaWxlc0FuZEZvbGRlcnM7XHJcbiAgICBjb25maWd1cmVkUHJvcGVydGllczogQXJyYXk8eyBuYW1lOiBzdHJpbmc7IHZhbHVlOiBhbnkgfT47XHJcbiAgICBkZWJ1Z0xldmVsOiBudW1iZXI7XHJcbiAgICBkZWxheUNyZWF0ZUV2ZW50OiBudW1iZXI7IC8vIG9wdGlvbmFsIGRlbGF5IGZvciBjcmVhdGUgZXZlbnRzXHJcbiAgICBmb2xkZXJDb25maWc6IFRyZWVIaWVyYXJjaHlEYXRhO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgREVGQVVMVF9GUk9OVE1BVFRFUl9BVVRPTUFURV9TRVRUSU5HUzogRnJvbnRtYXR0ZXJBdXRvbWF0ZVNldHRpbmdzID0ge1xyXG4gICAgdGFnUHJlZml4OiAnJyxcclxuICAgIGV4Y2x1ZGVSb290Rm9sZGVyOiBmYWxzZSxcclxuICAgIHRhZ3NQcm9wZXJ0eU5hbWU6ICd0YWdzJyxcclxuICAgIHNwYWNlUmVwbGFjZW1lbnQ6ICcnLFxyXG4gICAgc3BlY2lhbENoYXJSZXBsYWNlbWVudDogJycsXHJcbiAgICBsb3dlcmNhc2VUYWdzOiBmYWxzZSxcclxuICAgIGtub3duUHJvcGVydGllczogW10sXHJcbiAgICBydWxlczogW10sXHJcbiAgICB1c2VUZXh0QXJlYTogZmFsc2UsXHJcbiAgICBleGNsdWRlOiB7XHJcbiAgICAgICAgc2VsZWN0ZWRGb2xkZXJzOiBbXSxcclxuICAgICAgICBzZWxlY3RlZEZpbGVzOiBbXSxcclxuICAgICAgICBtb2RlOiAnZXhjbHVkZScsXHJcbiAgICAgICAgZGlzcGxheTogJ2ZvbGRlcnMnLFxyXG4gICAgfSxcclxuICAgIGluY2x1ZGU6IHtcclxuICAgICAgICBzZWxlY3RlZEZvbGRlcnM6IFtdLFxyXG4gICAgICAgIHNlbGVjdGVkRmlsZXM6IFtdLFxyXG4gICAgICAgIG1vZGU6ICdpbmNsdWRlJyxcclxuICAgICAgICBkaXNwbGF5OiAnZm9sZGVycycsXHJcbiAgICB9LFxyXG4gICAgY29uZmlndXJlZFByb3BlcnRpZXM6IFtdLFxyXG4gICAgZGVidWdMZXZlbDogV0FSTklORyxcclxuICAgIGRlbGF5Q3JlYXRlRXZlbnQ6IDAsIC8vIGRlZmF1bHQgdG8gbm8gZGVsYXlcclxuICAgIGZvbGRlckNvbmZpZzoge2ZvbGRlcnM6IFtdLCByb3dzOiBbXX0sXHJcbn07XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3Mge1xyXG4gICAgaWQ6IHN0cmluZztcclxuICAgIGFjdGl2ZTogYm9vbGVhbjtcclxuICAgIGFkZENvbnRlbnQ6ICdvdmVyd3JpdGUnIHwgJ3N0YXJ0JyB8ICdlbmQnO1xyXG4gICAgYXNMaW5rOiBib29sZWFuOyAvL2RlcHJlY2F0ZWRcclxuICAgIHByb3BlcnR5OiBzdHJpbmc7XHJcbiAgICB2YWx1ZTogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbjtcclxuICAgIGN1c3RvbVByb3BlcnR5OiBzdHJpbmc7XHJcbiAgICB0eXBlOiBPYnNpZGlhblByb3BlcnR5VHlwZXM7XHJcbiAgICB0eXBlUHJvcGVydHk6IFByb3BlcnR5VHlwZUluZm8gfCB1bmRlZmluZWQ7XHJcbiAgICBjb250ZW50OiBzdHJpbmc7XHJcbiAgICBidWlsZEluQ29kZTogc3RyaW5nO1xyXG4gICAganNDb2RlOiBzdHJpbmc7XHJcbiAgICBzaG93Q29udGVudDogYm9vbGVhbjtcclxuICAgIGV4Y2x1ZGU6IEZpbHRlckZpbGVzQW5kRm9sZGVycztcclxuICAgIGluY2x1ZGU6IEZpbHRlckZpbGVzQW5kRm9sZGVycztcclxuICAgIHByZWZpeDogc3RyaW5nO1xyXG4gICAgc3BhY2VSZXBsYWNlbWVudDogc3RyaW5nO1xyXG4gICAgc3BlY2lhbENoYXJSZXBsYWNlbWVudDogc3RyaW5nO1xyXG4gICAgbG93ZXJjYXNlVGFnczogYm9vbGVhbjsgLy9kZXByZWNhdGVkXHJcbiAgICBmb3JtYXR0ZXI6IHN0cmluZzsgLy9kZXByZWNhdGVkXHJcbiAgICBmb3JtYXR0ZXJzOiBzdHJpbmdbXTsgLy9hZGRlZFxyXG4gICAgbGlua0Zvcm1hdHRlcjogc3RyaW5nOyAvL2FkZGVkXHJcbiAgICBpbnB1dFByb3BlcnR5OiBzdHJpbmc7XHJcbiAgICBvbmx5TW9kaWZ5OiBib29sZWFuO1xyXG4gICAgdXNlQ3VzdG9tQ29kZTogYm9vbGVhbjtcclxuICAgIG9wdGlvbkNvbmZpZz86e307XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX1JVTEVfREVGSU5JVElPTiA6IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MgPSB7XHJcbiAgICBpZDogJycsXHJcbiAgICBhY3RpdmUgOiB0cnVlLFxyXG4gICAgYXNMaW5rOiBmYWxzZSwgLy9kZXByZWNhdGVkXHJcbiAgICBhZGRDb250ZW50OiAnb3ZlcndyaXRlJyxcclxuICAgIHByb3BlcnR5IDogJycsXHJcbiAgICB2YWx1ZTogJycsXHJcbiAgICBjdXN0b21Qcm9wZXJ0eSA6ICcnLFxyXG4gICAgdHlwZTogJ3RleHQnLFxyXG4gICAgdHlwZVByb3BlcnR5OiB7bmFtZTonJyx0eXBlOid0ZXh0Jywgc291cmNlOidyZWdpc3RlcmVkJ30sXHJcbiAgICBjb250ZW50OiAnJyxcclxuICAgIGJ1aWxkSW5Db2RlOiAnJyxcclxuICAgIGpzQ29kZTogJycsXHJcbiAgICBzaG93Q29udGVudDogZmFsc2UsXHJcbiAgICBleGNsdWRlOiB7XHJcbiAgICAgICAgc2VsZWN0ZWRGb2xkZXJzOiBbXSxcclxuICAgICAgICBzZWxlY3RlZEZpbGVzOiBbXSxcclxuICAgICAgICBtb2RlOiAnZXhjbHVkZScsXHJcbiAgICAgICAgZGlzcGxheTogJ2ZvbGRlcnMnLFxyXG4gICAgfSxcclxuICAgIGluY2x1ZGU6IHtcclxuICAgICAgICBzZWxlY3RlZEZvbGRlcnM6IFtdLFxyXG4gICAgICAgIHNlbGVjdGVkRmlsZXM6IFtdLFxyXG4gICAgICAgIG1vZGU6ICdpbmNsdWRlJyxcclxuICAgICAgICBkaXNwbGF5OiAnZm9sZGVycycsXHJcbiAgICB9LFxyXG4gICAgcHJlZml4OiAnJyxcclxuICAgIHNwYWNlUmVwbGFjZW1lbnQ6ICcnLFxyXG4gICAgc3BlY2lhbENoYXJSZXBsYWNlbWVudDogJycsXHJcbiAgICBsb3dlcmNhc2VUYWdzOiBmYWxzZSwgLy9kZXByZWNhdGVkXHJcbiAgICBmb3JtYXR0ZXI6ICd0b09yaWdpbmFsJywgLy9kZXByZWNhdGVkXHJcbiAgICBmb3JtYXR0ZXJzOiBbJ3RvT3JpZ2luYWwnXSxcclxuICAgIGxpbmtGb3JtYXR0ZXI6ICd0b09yaWdpbmFsTGluaycsXHJcbiAgICBpbnB1dFByb3BlcnR5OiAnJyxcclxuICAgIG9ubHlNb2RpZnk6IHRydWUsXHJcbiAgICB1c2VDdXN0b21Db2RlOiBmYWxzZSxcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgUHJvcGVydHlJbmZvID0ge1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgdHlwZTogT2JzaWRpYW5Qcm9wZXJ0eVR5cGVzO1xyXG4gICAgY291bnQ/OiBudW1iZXI7XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBQcm9wZXJ0eVR5cGVJbmZvID0ge1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgICAgIHR5cGU6IE9ic2lkaWFuUHJvcGVydHlUeXBlcztcclxuICAgIGNvdW50PzogbnVtYmVyO1xyXG4gICAgaXNBcnJheT86IGJvb2xlYW47XHJcbiAgICB2YWx1ZXM/OiBzdHJpbmdbXTtcclxuICAgIHNvdXJjZTogJ3JlZ2lzdGVyZWQnIHwgJ2luZmVycmVkJztcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIFByb3BlcnR5VHlwZSA9IHtcclxuICAgIHR5cGU6IHN0cmluZztcclxuICAgIGljb246IHN0cmluZztcclxuICAgIGpzVHlwZTogc3RyaW5nO1xyXG59OyIsICJpbXBvcnQgZXhwIGZyb20gJ2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IEFwcCwgTW9kYWwsIFNldHRpbmcsIFRBYnN0cmFjdEZpbGUsIFRGaWxlLCBURm9sZGVyLCBWYXVsdCwgc2V0SWNvbiB9IGZyb20gJ29ic2lkaWFuJzsgLy8gQWRkZWQgc2V0SWNvblxyXG5cclxuLy8gRGVmaW5lIHRoZSBzdHJ1Y3R1cmUgZm9yIHRyZWUgbm9kZXNcclxuaW50ZXJmYWNlIFRyZWVOb2RlIHtcclxuICAgIHBhdGg6IHN0cmluZztcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIHR5cGU6IHN0cmluZzsgLy8gJ2ZvbGRlcicgfCAnZmlsZSc7XHJcbiAgICBjaGlsZHJlbj86IFRyZWVOb2RlW107XHJcbiAgICBlbGVtZW50OiBIVE1MRWxlbWVudDsgLy8gUmVmZXJlbmNlIHRvIHRoZSBsaXN0IGl0ZW0gZWxlbWVudCAobGkpXHJcbiAgICBjaGVja2JveDogSFRNTElucHV0RWxlbWVudDtcclxuICAgIGxhYmVsOiBIVE1MTGFiZWxFbGVtZW50O1xyXG4gICAgY29udGFpbmVyOiBIVE1MRWxlbWVudDsgLy8gUmVmZXJlbmNlIHRvIHRoZSBjb250YWluZXIgZGl2IGhvbGRpbmcgY2hlY2tib3ggYW5kIGxhYmVsXHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIERpcmVjdG9yeVNlbGVjdGlvbk1vZGUgPSAnaW5jbHVkZScgfCAnZXhjbHVkZSc7IC8vIERlZmluZSBzZWxlY3Rpb24gbW9kZXNcclxuZXhwb3J0IHR5cGUgRGlyZWN0b3J5RGlzcGxheU1vZGUgPSAnZm9sZGVycycgfCAnZmlsZXMnIHwgJ2ZvbGRlcicgfCAnZmlsZSc7IC8vIERlZmluZSBkaXNwbGF5IG1vZGVzXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGlyZWN0b3J5U2VsZWN0aW9uT3B0aW9ucyB7XHJcbiAgICB0aXRsZT86IHN0cmluZzsgLy8gVGl0bGUgb2YgdGhlIG1vZGFsXHJcbiAgICBzZWxlY3Rpb25Nb2RlOiBEaXJlY3RvcnlTZWxlY3Rpb25Nb2RlOyAvLyAnaW5jbHVkZScgb3IgJ2V4Y2x1ZGUnXHJcbiAgICBkaXNwbGF5TW9kZTogRGlyZWN0b3J5RGlzcGxheU1vZGU7IC8vICdmb2xkZXJzJyBvciAnZmlsZXMnXHJcbiAgICBvcHRpb25TZWxlY3Rpb25Nb2RlOiBib29sZWFuOyAvLyBTaG93IGluY2x1ZGUvZXhjbHVkZSBvcHRpb25cclxuICAgIG9wdGlvblNob3dGaWxlczogYm9vbGVhbjsgLy8gU2hvdyBmaWxlcyBvcHRpb25cclxufVxyXG4vLyBEZWZpbmUgdGhlIHJlc3VsdCBzdHJ1Y3R1cmUgcmV0dXJuZWQgYnkgdGhlIG1vZGFsXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGlyZWN0b3J5U2VsZWN0aW9uUmVzdWx0IHtcclxuICAgIGZvbGRlcnM6IHN0cmluZ1tdO1xyXG4gICAgZmlsZXM6IHN0cmluZ1tdO1xyXG4gICAgbW9kZTogRGlyZWN0b3J5U2VsZWN0aW9uTW9kZTtcclxuICAgIGRpc3BsYXk6IERpcmVjdG9yeURpc3BsYXlNb2RlO1xyXG59XHJcblxyXG4vKipcclxuICogT2JzaWRpYW4gTW9kYWwgZm9yIHNlbGVjdGluZyBkaXJlY3RvcmllcyBhbmQgZmlsZXMgZnJvbSB0aGUgdmF1bHQgc3RydWN0dXJlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIERpcmVjdG9yeVNlbGVjdGlvbk1vZGFsIGV4dGVuZHMgTW9kYWwge1xyXG4gICAgLy8gSW5pdGlhbCBzdGF0ZSBwYXNzZWQgdG8gdGhlIG1vZGFsIChzdG9yZWQgZm9yIHJlc2V0IGZ1bmN0aW9uYWxpdHkpXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IGluaXRpYWxGb2xkZXJzU25hcHNob3Q6IFJlYWRvbmx5U2V0PHN0cmluZz47XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IGluaXRpYWxGaWxlc1NuYXBzaG90OiBSZWFkb25seVNldDxzdHJpbmc+O1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBpbml0aWFsTW9kZVNuYXBzaG90OiBEaXJlY3RvcnlTZWxlY3Rpb25Nb2RlO1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBpbml0aWFsRGlzcGxheVNuYXBzaG90OiBEaXJlY3RvcnlEaXNwbGF5TW9kZTtcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgb3B0aW9uczogRGlyZWN0b3J5U2VsZWN0aW9uT3B0aW9uczsgLy8gT3B0aW9ucyBmb3IgdGhlIG1vZGFsXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IG9rQ2FsbGJhY2s6IChyZXN1bHQ6IERpcmVjdG9yeVNlbGVjdGlvblJlc3VsdCB8IG51bGwpID0+IHZvaWQ7XHJcblxyXG4gICAgLy8gQ3VycmVudCBzdGF0ZSBiZWluZyBtb2RpZmllZCB3aXRoaW4gdGhlIG1vZGFsXHJcbiAgICBwcml2YXRlIGN1cnJlbnRGb2xkZXJzITogU2V0PHN0cmluZz47XHJcbiAgICBwcml2YXRlIGN1cnJlbnRGaWxlcyE6IFNldDxzdHJpbmc+O1xyXG4gICAgcHJpdmF0ZSBjdXJyZW50TW9kZSE6IERpcmVjdG9yeVNlbGVjdGlvbk1vZGU7XHJcbiAgICBwcml2YXRlIGN1cnJlbnREaXNwbGF5ITogRGlyZWN0b3J5RGlzcGxheU1vZGU7XHJcbiAgICBwcml2YXRlIGluY2x1ZGVFeGNsdWRlU2VsZWN0YWJsZSE6IGJvb2xlYW47XHJcbiAgICBwcml2YXRlIHNob3dGaWxlczogYm9vbGVhbiA9IGZhbHNlOyAvLyBTdGF0ZSBmb3Igc2hvd2luZyBmaWxlcyBpbiB0aGUgdHJlZVxyXG5cclxuICAgIC8vIFVJIEVsZW1lbnRzXHJcbiAgICBwcml2YXRlIHRyZWVSb290RWxlbWVudCE6IEhUTUxFbGVtZW50OyAvLyBDb250YWluZXIgZm9yIHRoZSB0cmVlIHZpZXdcclxuICAgIHByaXZhdGUgdHJlZU5vZGVzOiBNYXA8c3RyaW5nLCBUcmVlTm9kZT4gPSBuZXcgTWFwKCk7IC8vIE1hcCBwYXRoIHRvIG5vZGUgaW5mbyBmb3IgcXVpY2sgYWNjZXNzXHJcbiAgICBwcml2YXRlIG1vZGVEcm9wZG93bjogU2V0dGluZyB8IG51bGwgPSBudWxsOyAvLyBSZWZlcmVuY2UgdG8gdXBkYXRlIGRyb3Bkb3duIG9uIHJlc2V0XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoZSBEaXJlY3RvcnlTZWxlY3Rpb25Nb2RhbC5cclxuICAgICAqIEBwYXJhbSBhcHAgLSBUaGUgT2JzaWRpYW4gQXBwIGluc3RhbmNlLlxyXG4gICAgICogQHBhcmFtIGluaXRpYWxGb2xkZXJzIC0gQXJyYXkgb2YgaW5pdGlhbGx5IHNlbGVjdGVkIGZvbGRlciBwYXRocy5cclxuICAgICAqIEBwYXJhbSBpbml0aWFsRmlsZXMgLSBBcnJheSBvZiBpbml0aWFsbHkgc2VsZWN0ZWQgZmlsZSBwYXRocy5cclxuICAgICAqIEBwYXJhbSBpbml0aWFsTW9kZSAtIFRoZSBpbml0aWFsIHNlbGVjdGlvbiBtb2RlICgnaW5jbHVkZScgb3IgJ2V4Y2x1ZGUnKS5cclxuICAgICAqIEBwYXJhbSBva0NhbGxiYWNrIC0gRnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBcIk9LXCIuIFJlY2VpdmVzIHRoZSBzZWxlY3Rpb24gcmVzdWx0LlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBhcHA6IEFwcCxcclxuICAgICAgICBpbml0aWFsRm9sZGVyczogc3RyaW5nW10sXHJcbiAgICAgICAgaW5pdGlhbEZpbGVzOiBzdHJpbmdbXSxcclxuICAgICAgICBpbml0aWFsT3B0aW9uczogRGlyZWN0b3J5U2VsZWN0aW9uT3B0aW9ucyxcclxuICAgICAgICBva0NhbGxiYWNrOiAocmVzdWx0OiBEaXJlY3RvcnlTZWxlY3Rpb25SZXN1bHQgfCBudWxsKSA9PiB2b2lkXHJcbiAgICApIHtcclxuICAgICAgICBzdXBlcihhcHApO1xyXG4gICAgICAgIC8vIFN0b3JlIGluaXRpYWwgc3RhdGUgZm9yIHJlc2V0XHJcbiAgICAgICAgdGhpcy5pbml0aWFsRm9sZGVyc1NuYXBzaG90ID0gbmV3IFNldChpbml0aWFsRm9sZGVycyk7XHJcbiAgICAgICAgdGhpcy5pbml0aWFsRmlsZXNTbmFwc2hvdCA9IG5ldyBTZXQoaW5pdGlhbEZpbGVzKTtcclxuICAgICAgICB0aGlzLmluaXRpYWxNb2RlU25hcHNob3QgPSBpbml0aWFsT3B0aW9ucy5zZWxlY3Rpb25Nb2RlO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbERpc3BsYXlTbmFwc2hvdCA9IGluaXRpYWxPcHRpb25zLmRpc3BsYXlNb2RlO1xyXG4gICAgICAgIHRoaXMuc2hvd0ZpbGVzID0gaW5pdGlhbE9wdGlvbnMuZGlzcGxheU1vZGU9PT0nZmlsZXMnIHx8IGluaXRpYWxPcHRpb25zLmRpc3BsYXlNb2RlPT09J2ZpbGUnfHwgaW5pdGlhbEZpbGVzLmxlbmd0aD4wO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGluaXRpYWxPcHRpb25zO1xyXG4gICAgICAgIHRoaXMub2tDYWxsYmFjayA9IG9rQ2FsbGJhY2s7XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgY3VycmVudCBzdGF0ZSBmcm9tIGluaXRpYWwgc3RhdGUgZm9yIGVkaXRpbmdcclxuICAgICAgICB0aGlzLnJlc2V0U2VsZWN0aW9uVG9Jbml0aWFsKCk7IC8vIFVzZSBhIG1ldGhvZCBmb3IgaW5pdGlhbGl6YXRpb24gYW5kIHJlc2V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHN0YXRlIHRvIHRoZSBpbml0aWFsIHN0YXRlIHByb3ZpZGVkIGF0IGNvbnN0cnVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZXNldFNlbGVjdGlvblRvSW5pdGlhbCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRGb2xkZXJzID0gbmV3IFNldCh0aGlzLmluaXRpYWxGb2xkZXJzU25hcHNob3QpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudEZpbGVzID0gbmV3IFNldCh0aGlzLmluaXRpYWxGaWxlc1NuYXBzaG90KTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRNb2RlID0gdGhpcy5pbml0aWFsTW9kZVNuYXBzaG90O1xyXG4gICAgICAgIC8vIE5vdGU6IHNob3dGaWxlcyBpcyBub3QgcmVzZXQgYnkgdGhpcyBhY3Rpb24sIHVzZXIgY2FuIHRvZ2dsZSBpdCBpbmRlcGVuZGVudGx5XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHN0YXRlIHRvIGVtcHR5LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlc2V0U2VsZWN0aW9uVG9FbXB0eSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRGb2xkZXJzID0gbmV3IFNldChbXSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RmlsZXMgPSBuZXcgU2V0KFtdKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRNb2RlID0gdGhpcy5pbml0aWFsTW9kZVNuYXBzaG90O1xyXG4gICAgICAgIC8vIE5vdGU6IHNob3dGaWxlcyBpcyBub3QgcmVzZXQgYnkgdGhpcyBhY3Rpb24sIHVzZXIgY2FuIHRvZ2dsZSBpdCBpbmRlcGVuZGVudGx5XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgbW9kYWwgaXMgb3BlbmVkLiBCdWlsZHMgdGhlIFVJLlxyXG4gICAgICovXHJcbiAgICBvbk9wZW4oKSB7XHJcbiAgICAgICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XHJcbiAgICAgICAgY29udGVudEVsLmVtcHR5KCk7IC8vIENsZWFyIHByZXZpb3VzIGNvbnRlbnRcclxuICAgICAgICBjb250ZW50RWwuYWRkQ2xhc3MoJ2RpcmVjdG9yeS1zZWxlY3Rpb24tbW9kYWwnKTsgXHJcblxyXG4gICAgICAgIC8vIC0tLSBNb2RhbCBUaXRsZSAtLS1cclxuICAgICAgICBpZiAodGhpcy5pbmNsdWRlRXhjbHVkZVNlbGVjdGFibGUpIHtcclxuICAgICAgICAgICAgY29udGVudEVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogdGhpcy5vcHRpb25zLnRpdGxlIHx8ICdJbmNsdWRlIG9yIEV4Y2x1ZGUgRm9sZGVycyBhbmQgRmlsZXMnIH0pOyBcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb250ZW50RWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiB0aGlzLm9wdGlvbnMudGl0bGUgfHwgYCR7dGhpcy5jdXJyZW50TW9kZSA9PT0gJ2V4Y2x1ZGUnID8gJ0V4Y2x1ZGUnIDogJ0luY2x1ZGUnfSBGb2xkZXJzIGFuZCBGaWxlc2AgfSk7IFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gLS0tIFNldHRpbmdzIENvbnRyb2xzIC0tLVxyXG4gICAgICAgIGNvbnN0IGNvbnRyb2xzRWwgPSBjb250ZW50RWwuY3JlYXRlRGl2KHsgY2xzOiAnbW9kYWwtY29udHJvbHMnIH0pO1xyXG4gICAgICAgIHRoaXMuY3JlYXRlTW9kZVNldHRpbmcoY29udHJvbHNFbCk7IC8vIENyZWF0ZSBtb2RlIGRyb3Bkb3duXHJcbiAgICAgICAgdGhpcy5jcmVhdGVTaG93RmlsZXNTZXR0aW5nKGNvbnRyb2xzRWwpOyAvLyBDcmVhdGUgZmlsZSB0b2dnbGVcclxuXHJcbiAgICAgICAgLy8gLS0tIFRyZWUgQ29udGFpbmVyIC0tLVxyXG4gICAgICAgIHRoaXMudHJlZVJvb3RFbGVtZW50ID0gY29udGVudEVsLmNyZWF0ZURpdih7IGNsczogJ3RyZWUtdmlldy1jb250YWluZXInIH0pO1xyXG4gICAgICAgIHRoaXMudHJlZVJvb3RFbGVtZW50LnN0eWxlLm1heEhlaWdodCA9ICc2MDBweCc7XHJcbiAgICAgICAgdGhpcy50cmVlUm9vdEVsZW1lbnQuc3R5bGUub3ZlcmZsb3dZID0gJ2F1dG8nO1xyXG4gICAgICAgIHRoaXMudHJlZVJvb3RFbGVtZW50LnN0eWxlLmJvcmRlciA9ICcxcHggc29saWQgdmFyKC0tYmFja2dyb3VuZC1tb2RpZmllci1ib3JkZXIpJztcclxuICAgICAgICB0aGlzLnRyZWVSb290RWxlbWVudC5zdHlsZS5wYWRkaW5nID0gJzEwcHgnO1xyXG4gICAgICAgIHRoaXMudHJlZVJvb3RFbGVtZW50LnN0eWxlLm1hcmdpblRvcCA9ICcxMHB4JztcclxuICAgICAgICB0aGlzLnRyZWVSb290RWxlbWVudC5zdHlsZS5tYXJnaW5Cb3R0b20gPSAnMTBweCc7XHJcblxyXG4gICAgICAgIC8vIC0tLSBCdWlsZCBhbmQgUmVuZGVyIFRyZWUgLS0tXHJcbiAgICAgICAgaWYgKCF0aGlzLnRyZWVOb2Rlcy5zaXplKSB7IC8vIEVuc3VyZSB0aGUgdHJlZSBpcyBvbmx5IHJlbmRlcmVkIG9uY2VcclxuICAgICAgICAgICAgdGhpcy5idWlsZEFuZFJlbmRlclRyZWUoKTsgLy8gSW5pdGlhbCByZW5kZXJpbmcgYmFzZWQgb24gY3VycmVudCBzdGF0ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gLS0tIEFjdGlvbiBCdXR0b25zIC0tLVxyXG4gICAgICAgIHRoaXMuY3JlYXRlQWN0aW9uQnV0dG9ucyhjb250ZW50RWwpOyAvLyBDcmVhdGUgT0sgYW5kIFJlc2V0IGJ1dHRvbnNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIGRyb3Bkb3duIHNldHRpbmcgZm9yIGNob29zaW5nIHRoZSBzZWxlY3Rpb24gbW9kZS5cclxuICAgICAqIEBwYXJhbSBjb250YWluZXJFbCAtIFRoZSBIVE1MIGVsZW1lbnQgdG8gYXBwZW5kIHRoZSBzZXR0aW5nIHRvLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNyZWF0ZU1vZGVTZXR0aW5nKGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVFeGNsdWRlU2VsZWN0YWJsZSkge1xyXG4gICAgICAgICAgICB0aGlzLm1vZGVEcm9wZG93biA9IG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKSAvLyBTdG9yZSByZWZlcmVuY2VcclxuICAgICAgICAgICAgICAgIC5zZXROYW1lKCdTZWxlY3Rpb24gTW9kZScpIC8vIFNldHRpbmcgTmFtZSBpbiBHZXJtYW5cclxuICAgICAgICAgICAgICAgIC5zZXREZXNjKCdDaG9vc2UgaWYgdGhlIHNlbGVjdGVkIGZpbGVzIGFuZCBmb2xkZXJzIHNob3VsZCBiZSBleGNsdWRlZCBvciBpbmNsdWRlZC4nKSBcclxuICAgICAgICAgICAgICAgIC5hZGREcm9wZG93bihkcm9wZG93biA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHJvcGRvd25cclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZE9wdGlvbignZXhjbHVkZScsICdleGNsdWRlJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZE9wdGlvbignaW5jbHVkZScsICdpbmNsdWRlJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMuY3VycmVudE1vZGUpIC8vIFNldCBpbml0aWFsIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZSh2YWx1ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNb2RlID0gdmFsdWUgYXMgJ2luY2x1ZGUnIHwgJ2V4Y2x1ZGUnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUcmVlQXBwZWFyYW5jZSgpOyAvLyBVcGRhdGUgdHJlZSB2aXN1YWxzIGJhc2VkIG9uIG5ldyBtb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgbW9kZSBkcm9wZG93biBVSSBlbGVtZW50IHRvIHJlZmxlY3QgdGhlIGN1cnJlbnRNb2RlIHN0YXRlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHVwZGF0ZU1vZGVEcm9wZG93bigpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBkcm9wZG93bkNvbXBvbmVudCA9IHRoaXMubW9kZURyb3Bkb3duPy5jb21wb25lbnRzWzBdIGFzIGFueTsgLy8gQWNjZXNzIGRyb3Bkb3duIGNvbXBvbmVudFxyXG4gICAgICAgIGlmIChkcm9wZG93bkNvbXBvbmVudCAmJiB0eXBlb2YgZHJvcGRvd25Db21wb25lbnQuc2V0VmFsdWUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgIGRyb3Bkb3duQ29tcG9uZW50LnNldFZhbHVlKHRoaXMuY3VycmVudE1vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSB0b2dnbGUgc2V0dGluZyBmb3Igc2hvd2luZy9oaWRpbmcgZmlsZXMgaW4gdGhlIHRyZWUuXHJcbiAgICAgKiBAcGFyYW0gY29udGFpbmVyRWwgLSBUaGUgSFRNTCBlbGVtZW50IHRvIGFwcGVuZCB0aGUgc2V0dGluZyB0by5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjcmVhdGVTaG93RmlsZXNTZXR0aW5nKGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMub3B0aW9uU2hvd0ZpbGVzKSB7XHJcbiAgICAgICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAgICAgLnNldE5hbWUoJ1Nob3cgRmlsZXMnKVxyXG4gICAgICAgICAgICAgICAgLnNldERlc2MoJ1Nob3cgRmlsZXMgd2l0aGluIHRoZSBkaXJlY3RvcnkgdHJlZS4nKVxyXG4gICAgICAgICAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5zaG93RmlsZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZSh2YWx1ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dGaWxlcyA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZEFuZFJlbmRlclRyZWUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSBcIk9LXCIgYW5kIFwiUmVzZXRcIiBidXR0b25zLlxyXG4gICAgICogQHBhcmFtIGNvbnRhaW5lckVsIC0gVGhlIEhUTUwgZWxlbWVudCB0byBhcHBlbmQgdGhlIGJ1dHRvbnMgdG8uXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY3JlYXRlQWN0aW9uQnV0dG9ucyhjb250YWluZXJFbDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBidXR0b25zRWwgPSBjb250YWluZXJFbC5jcmVhdGVEaXYoeyBjbHM6ICdtb2RhbC1idXR0b25zJyB9KTtcclxuICAgICAgICBidXR0b25zRWwuc3R5bGUubWFyZ2luVG9wID0gJzE1cHgnO1xyXG4gICAgICAgIGJ1dHRvbnNFbC5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnOyAvLyBVc2UgZmxleCBmb3IgYWxpZ25tZW50XHJcbiAgICAgICAgYnV0dG9uc0VsLnN0eWxlLmp1c3RpZnlDb250ZW50ID0gJ2ZsZXgtZW5kJzsgLy8gQWxpZ24gYnV0dG9ucyB0byB0aGUgcmlnaHRcclxuICAgICAgICBidXR0b25zRWwuc3R5bGUuZ2FwID0gJzEwcHgnOyAvLyBTcGFjZSBiZXR3ZWVuIGJ1dHRvbnNcclxuXHJcbiAgICAgICAgLy8gUmVzZXQgQnV0dG9uIChVbmRvIFx1MjFBQVx1RkUwRilcclxuICAgICAgICBjb25zdCByZXNldEJ1dHRvbiA9IGJ1dHRvbnNFbC5jcmVhdGVFbCgnYnV0dG9uJyk7XHJcbiAgICAgICAgLy8gVXNlIE9ic2lkaWFuJ3Mgc2V0SWNvbiBmb3IgY29uc2lzdGVuY3ksIG9yIHVzZSB0ZXh0XHJcbiAgICAgICAgc2V0SWNvbihyZXNldEJ1dHRvbiwgJ3Jlc2V0Jyk7IC8vIFVzZSBhIHN1aXRhYmxlIGljb24gbGlrZSAncmVzZXQnIG9yICd1bmRvJ1xyXG4gICAgICAgIHJlc2V0QnV0dG9uLmFyaWFMYWJlbCA9ICdSZXNldCBzZWxlY3Rpb24nOyAvLyBBY2Nlc3NpYmlsaXR5XHJcbiAgICAgICAgcmVzZXRCdXR0b24ub25jbGljayA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZXNldFNlbGVjdGlvblRvSW5pdGlhbCgpOyAvLyBSZXNldCBpbnRlcm5hbCBzdGF0ZVxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1vZGVEcm9wZG93bigpOyAvLyBVcGRhdGUgZHJvcGRvd24gVUlcclxuICAgICAgICAgICAgdGhpcy5idWlsZEFuZFJlbmRlclRyZWUoKTsgLy8gUmUtcmVuZGVyIHRyZWUgd2l0aCByZXNldCBzdGF0ZVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIENsZWFyIEJ1dHRvbiAoQ2xlYXIgXHVEODNEXHVERUFFKVxyXG4gICAgICAgIGNvbnN0IGVtcHR5QnV0dG9uID0gYnV0dG9uc0VsLmNyZWF0ZUVsKCdidXR0b24nKTtcclxuICAgICAgICAvLyBVc2UgT2JzaWRpYW4ncyBzZXRJY29uIGZvciBjb25zaXN0ZW5jeSwgb3IgdXNlIHRleHRcclxuICAgICAgICBzZXRJY29uKGVtcHR5QnV0dG9uLCAnZXJhc2VyJyk7IC8vIFVzZSBhIHN1aXRhYmxlIGljb24gbGlrZSAncmVzZXQnIG9yICd1bmRvJ1xyXG4gICAgICAgIGVtcHR5QnV0dG9uLmFyaWFMYWJlbCA9ICdDbGVhciBzZWxlY3Rpb24nOyAvLyBBY2Nlc3NpYmlsaXR5XHJcbiAgICAgICAgZW1wdHlCdXR0b24ub25jbGljayA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZXNldFNlbGVjdGlvblRvRW1wdHkoKTsgLy8gQ2xlYXIgc3RhdGVcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVNb2RlRHJvcGRvd24oKTsgLy8gVXBkYXRlIGRyb3Bkb3duIFVJXHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRBbmRSZW5kZXJUcmVlKCk7IC8vIFJlLXJlbmRlciB0cmVlIHdpdGggcmVzZXQgc3RhdGVcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBjYW5jZWwgQnV0dG9uXHJcbiAgICAgICAgY29uc3QgY2FuY2VsQnV0dG9uID0gYnV0dG9uc0VsLmNyZWF0ZUVsKCdidXR0b24nLCB7IHRleHQ6ICdDYW5jZWwnIH0pO1xyXG4gICAgICAgIGNhbmNlbEJ1dHRvbi5hcmlhTGFiZWwgPSAnY2xvc2UgYW5kIGRpc2NhcmQgY2hhbmdlcyc7IC8vIEFjY2Vzc2liaWxpdHlcclxuICAgICAgICBjYW5jZWxCdXR0b24ub25jbGljayA9ICgpID0+IHtcclxuICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZyhERUJVRyxcIkNhbmNlbCBDbGlja2VkIC0gUmV0dXJuaW5nXCIpOyAvLyBEZWJ1ZyBsb2dcclxuICAgICAgICAgICAgdGhpcy5va0NhbGxiYWNrKCBudWxsICk7IC8vIFBhc3MgdGhlIGZpbmFsIHNlbGVjdGlvbiBiYWNrXHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBPSyBCdXR0b25cclxuICAgICAgICBjb25zdCBva0J1dHRvbiA9IGJ1dHRvbnNFbC5jcmVhdGVFbCgnYnV0dG9uJywgeyB0ZXh0OiAnT0snLCBjbHM6ICdtb2QtY3RhJyB9KTtcclxuICAgICAgICBva0J1dHRvbi5hcmlhTGFiZWwgPSAnY2xvc2UgYW5kIHNhdmUgY2hhbmdlcyc7IC8vIEFjY2Vzc2liaWxpdHlcclxuICAgICAgICBva0J1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnVpbGRzIHRoZSBsb2dpY2FsIHRyZWUgc3RydWN0dXJlIGRhdGEgZnJvbSB0aGUgdmF1bHQncyBmaWxlcyBhbmQgZm9sZGVycy5cclxuICAgICAqIEByZXR1cm5zIFRoZSByb290IG5vZGUgb2YgdGhlIHRyZWUgc3RydWN0dXJlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGJ1aWxkVHJlZURhdGEoKTogVHJlZU5vZGUge1xyXG4gICAgICAgIC8vIENyZWF0ZSBhIHZpcnR1YWwgcm9vdCBub2RlIHJlcHJlc2VudGluZyB0aGUgdmF1bHRcclxuICAgICAgICBjb25zdCB2YXVsdFJvb3ROb2RlOiBUcmVlTm9kZSA9IHtcclxuICAgICAgICAgICAgcGF0aDogJy8nLCAvLyBSb290IGZvbGRlciBwYXRoXHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMuYXBwLnZhdWx0LmdldE5hbWUoKSB8fCAnVmF1bHQnLCAvLyBVc2UgdmF1bHQgbmFtZSBvciBkZWZhdWx0XHJcbiAgICAgICAgICAgIHR5cGU6ICdmb2xkZXInLFxyXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXHJcbiAgICAgICAgICAgIC8vIFBsYWNlaG9sZGVyIGVsZW1lbnRzLCB3aWxsIGJlIGFzc2lnbmVkIGR1cmluZyByZW5kZXJpbmdcclxuICAgICAgICAgICAgZWxlbWVudDogbnVsbCEsXHJcbiAgICAgICAgICAgIGNoZWNrYm94OiBudWxsISxcclxuICAgICAgICAgICAgbGFiZWw6IG51bGwhLFxyXG4gICAgICAgICAgICBjb250YWluZXI6IG51bGwhLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IGZvbGRlck5vZGVzID0gbmV3IE1hcDxzdHJpbmcsIFRyZWVOb2RlPigpO1xyXG4gICAgICAgIGZvbGRlck5vZGVzLnNldCgnLycsIHZhdWx0Um9vdE5vZGUpOyAvLyBBZGQgcm9vdCB0byB0aGUgbWFwXHJcblxyXG4gICAgICAgIC8vIFVzZSBnZXRGaWxlcygpIHRvIHJldHJpZXZlIGFsbCBURmlsZSBvYmplY3RzIChNYXJrZG93biwgaW1hZ2VzLCBwZGYsIGV0Yy4pXHJcbiAgICAgICAgY29uc3QgYWxsRmlsZXMgPSB0aGlzLmFwcC52YXVsdC5nZXRGaWxlcygpO1xyXG5cclxuICAgICAgICAvLyAtLS0gU3RlcCAxOiBDcmVhdGUgYWxsIGZvbGRlciBub2RlcyBiYXNlZCBvbiBmaWxlIHBhcmVudCBwYXRocyAtLS1cclxuICAgICAgICBhbGxGaWxlcy5mb3JFYWNoKGZpbGUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJlbnRGb2xkZXIgPSBmaWxlLnBhcmVudDtcclxuICAgICAgICAgICAgaWYgKCFwYXJlbnRGb2xkZXIpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50UGF0aCA9ICcnO1xyXG4gICAgICAgICAgICBjb25zdCBwYXRoUGFydHMgPSBwYXJlbnRGb2xkZXIucGF0aC5zcGxpdCgnLycpLmZpbHRlcihwID0+IHAubGVuZ3RoID4gMCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgcGFyZW50Tm9kZSA9IHZhdWx0Um9vdE5vZGU7IC8vIFN0YXJ0IGZyb20gdmF1bHQgcm9vdFxyXG4gICAgICAgICAgICBwYXRoUGFydHMuZm9yRWFjaChwYXJ0ID0+IHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQYXRoID0gY3VycmVudFBhdGggPT09ICcvJyA/IHBhcnQgOiBgJHtjdXJyZW50UGF0aH0vJHtwYXJ0fWA7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZvbGRlck5vZGVzLmhhcyhjdXJyZW50UGF0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdGb2xkZXJOb2RlOiBUcmVlTm9kZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogY3VycmVudFBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHBhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmb2xkZXInLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG51bGwhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja2JveDogbnVsbCEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBudWxsISxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiBudWxsISxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvbGRlck5vZGVzLnNldChjdXJyZW50UGF0aCwgbmV3Rm9sZGVyTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnROb2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuY2hpbGRyZW4gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5jaGlsZHJlbiEucHVzaChuZXdGb2xkZXJOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlID0gbmV3Rm9sZGVyTm9kZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZSA9IGZvbGRlck5vZGVzLmdldChjdXJyZW50UGF0aCkhO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gLS0tIFN0ZXAgMjogQWRkIGZpbGUgbm9kZXMgaWYgJ3Nob3dGaWxlcycgaXMgZW5hYmxlZCAtLS1cclxuICAgICAgICBpZiAodGhpcy5zaG93RmlsZXMpIHtcclxuICAgICAgICAgICAgYWxsRmlsZXMuZm9yRWFjaChmaWxlID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudEZvbGRlciA9IGZpbGUucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudFBhdGggPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudEZvbGRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFBhdGggPSBcIi9cIiArIChwYXJlbnRGb2xkZXIucGF0aD09PSAnLycgPyAnJyA6IHBhcmVudEZvbGRlci5wYXRoKTsgLy8gRW5zdXJlIHRoZSBwYXRoIHN0YXJ0cyB3aXRoIGEgc2xhc2hcclxuICAgICAgICAgICAgICAgIH0gLy8gRW5zdXJlIHRoZSBwYXRoIHN0YXJ0cyB3aXRoIGEgc2xhc2hcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gZm9sZGVyTm9kZXMuZ2V0KHBhcmVudFBhdGgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVOb2RlOiBUcmVlTm9kZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBmaWxlLnBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZmlsZS5uYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmaWxlJyxcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBudWxsISxcclxuICAgICAgICAgICAgICAgICAgICBjaGVja2JveDogbnVsbCEsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IG51bGwhLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogbnVsbCEsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnROb2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuY2hpbGRyZW4gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5jaGlsZHJlbiEucHVzaChmaWxlTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gLS0tIFN0ZXAgMzogU29ydCBjaGlsZHJlbiBhbHBoYWJldGljYWxseSAoZm9sZGVycyBmaXJzdCwgdGhlbiBmaWxlcykgLS0tXHJcbiAgICAgICAgY29uc3Qgc29ydE5vZGVzID0gKGE6IFRyZWVOb2RlLCBiOiBUcmVlTm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoYS50eXBlID09PSAnZm9sZGVyJyAmJiBiLnR5cGUgPT09ICdmaWxlJykgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICBpZiAoYS50eXBlID09PSAnZmlsZScgJiYgYi50eXBlID09PSAnZm9sZGVyJykgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIHJldHVybiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGZvbGRlck5vZGVzLmZvckVhY2gobm9kZSA9PiBub2RlLmNoaWxkcmVuPy5zb3J0KHNvcnROb2RlcykpO1xyXG5cclxuICAgICAgICByZXR1cm4gdmF1bHRSb290Tm9kZTsgLy8gUmV0dXJuIHRoZSBwb3B1bGF0ZWQgcm9vdCBub2RlXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyB0aGUgZW50aXJlIHRyZWUgc3RydWN0dXJlIGluIHRoZSBET00gYmFzZWQgb24gdGhlIHRyZWUgZGF0YS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZW5kZXJUcmVlKCkge1xyXG4gICAgICAgICB0aGlzLnRyZWVSb290RWxlbWVudC5lbXB0eSgpOyAvLyBDbGVhciBleGlzdGluZyBET00gZWxlbWVudHNcclxuICAgICAgICAgdGhpcy50cmVlTm9kZXMuY2xlYXIoKTsgLy8gQ2xlYXIgdGhlIG5vZGUgbWFwXHJcblxyXG4gICAgICAgICBjb25zdCB0cmVlRGF0YSA9IHRoaXMuYnVpbGRUcmVlRGF0YSgpOyAvLyBHZXQgdGhlIHN0cnVjdHVyZWQgZGF0YVxyXG5cclxuICAgICAgICAgLy8gQ3JlYXRlIHRoZSB0b3AtbGV2ZWwgbGlzdCBmb3IgdGhlIHZhdWx0IGNvbnRlbnRzXHJcbiAgICAgICAgIGNvbnN0IHJvb3RVbCA9IHRoaXMudHJlZVJvb3RFbGVtZW50LmNyZWF0ZUVsKCd1bCcpO1xyXG4gICAgICAgICByb290VWwuYWRkQ2xhc3MoJ3RyZWUtcm9vdC11bCcpO1xyXG4gICAgICAgICByb290VWwuc3R5bGUubGlzdFN0eWxlID0gJ25vbmUnO1xyXG4gICAgICAgICByb290VWwuc3R5bGUucGFkZGluZ0xlZnQgPSAnMCc7IC8vIFJlbW92ZSBkZWZhdWx0IGxpc3QgaW5kZW50YXRpb25cclxuXHJcbiAgICAgICAgIC8vIFJlbmRlciB0aGUgcm9vdCBmb2xkZXIgaXRzZWxmXHJcbiAgICAgICAgIC8vdGhpcy5yZW5kZXJUcmVlTm9kZSh0cmVlRGF0YSwgcm9vdFVsLCAwLCB0aGlzLmN1cnJlbnRNb2RlID09PSAnaW5jbHVkZScgPyB0aGlzLmN1cnJlbnRGb2xkZXJzIDogdGhpcy5jdXJyZW50RmlsZXMpO1xyXG4gICAgICAgICB0aGlzLnJlbmRlclRyZWVOb2RlKHRyZWVEYXRhLCByb290VWwsIDAsIHRoaXMuY3VycmVudEZvbGRlcnMsIHRoaXMuY3VycmVudEZpbGVzKTsgLy9UT0RPOiBleHBhbmQgdGhpcyB0byBpbmNsdWRlIGZpbGVzIGFzIHdlbGxcclxuXHJcbiAgICAgICAgIC8vIFJlbmRlciBjaGlsZHJlbiBvZiB0aGUgcm9vdCBmb2xkZXJcclxuICAgICAgICAgdHJlZURhdGEuY2hpbGRyZW4/LmZvckVhY2goY2hpbGROb2RlID0+IHtcclxuICAgICAgICAgICAgIC8vdGhpcy5yZW5kZXJUcmVlTm9kZShjaGlsZE5vZGUsIHJvb3RVbCwgMSwgdGhpcy5jdXJyZW50TW9kZSA9PT0gJ2luY2x1ZGUnID8gdGhpcy5jdXJyZW50Rm9sZGVycyA6IHRoaXMuY3VycmVudEZpbGVzKTsgLy8gU3RhcnQgcmVuZGVyaW5nIGF0IGxldmVsIDFcclxuICAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWN1cnNpdmVseSByZW5kZXJzIGEgc2luZ2xlIHRyZWUgbm9kZSBhbmQgaXRzIGNoaWxkcmVuIGluIHRoZSBET00uXHJcbiAgICAgKiBAcGFyYW0gbm9kZSAtIFRoZSBUcmVlTm9kZSBkYXRhIHRvIHJlbmRlci5cclxuICAgICAqIEBwYXJhbSBwYXJlbnRFbGVtZW50IC0gVGhlIEhUTUwgYHVsYCBlbGVtZW50IHRvIGFwcGVuZCB0aGlzIG5vZGUncyBgbGlgIHRvLlxyXG4gICAgICogQHBhcmFtIGxldmVsIC0gVGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVuZGVyVHJlZU5vZGUobm9kZTogVHJlZU5vZGUsIHBhcmVudEVsZW1lbnQ6IEhUTUxFbGVtZW50LCBsZXZlbDogbnVtYmVyLCBzZWxlY3RlZFBhdGhzOiBTZXQ8c3RyaW5nPiwgc2VsZWN0ZWRmaWxlczogU2V0PHN0cmluZz4pIHtcclxuICAgICAgICBjb25zdCBsaSA9IHBhcmVudEVsZW1lbnQuY3JlYXRlRWwoJ2xpJyk7XHJcbiAgICAgICAgbGkuc3R5bGUubWFyZ2luTGVmdCA9IGAke2xldmVsICogMjB9cHhgOyAvLyBBcHBseSBpbmRlbnRhdGlvbiBiYXNlZCBvbiBsZXZlbFxyXG4gICAgICAgIGxpLmFkZENsYXNzKGB0cmVlLW5vZGUtJHtub2RlLnR5cGV9YCk7IC8vIEFkZCBjbGFzcyBmb3IgdHlwZSAoZm9sZGVyL2ZpbGUpXHJcblxyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGxpLmNyZWF0ZURpdih7IGNsczogJ3RyZWUtbm9kZS1jb250YWluZXInIH0pO1xyXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xyXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5hbGlnbkl0ZW1zID0gJ2NlbnRlcic7XHJcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLnBhZGRpbmcgPSAnMnB4IDAnOyAvLyBBZGQgc29tZSB2ZXJ0aWNhbCBwYWRkaW5nXHJcblxyXG4gICAgICAgIC8vIC0tLSBUb2dnbGUgQnV0dG9uIGZvciBGb2xkZXJzIC0tLVxyXG4gICAgICAgIGxldCB0b2dnbGVCdXR0b246IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgbGV0IGlzQ29sbGFwc2VkID0gdHJ1ZTsgLy8gRGVmYXVsdCBzdGF0ZSBpcyBjb2xsYXBzZWRcclxuXHJcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2ZvbGRlcicpIHtcclxuICAgICAgICAgICAgdG9nZ2xlQnV0dG9uID0gY29udGFpbmVyLmNyZWF0ZVNwYW4oeyBjbHM6ICd0cmVlLXRvZ2dsZS1idXR0b24nIH0pO1xyXG4gICAgICAgICAgICB0b2dnbGVCdXR0b24udGV4dENvbnRlbnQgPSAnXHUyNUI2JzsgLy8gUmlnaHQtcG9pbnRpbmcgdHJpYW5nbGVcclxuICAgICAgICAgICAgdG9nZ2xlQnV0dG9uLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcclxuICAgICAgICAgICAgdG9nZ2xlQnV0dG9uLnN0eWxlLm1hcmdpblJpZ2h0ID0gJzVweCc7XHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGZvbGRlciBvciBhbnkgb2YgaXRzIGNoaWxkcmVuIGFyZSBzZWxlY3RlZFxyXG4gICAgICAgICAgICBjb25zdCBzaG91bGRFeHBhbmQgPSB0aGlzLnNob3VsZEV4cGFuZEZvbGRlcihub2RlLCBzZWxlY3RlZFBhdGhzLCBzZWxlY3RlZGZpbGVzKTtcclxuICAgICAgICAgICAgaWYgKHNob3VsZEV4cGFuZCkge1xyXG4gICAgICAgICAgICAgICAgaXNDb2xsYXBzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdG9nZ2xlQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpc0NvbGxhcHNlZCA9ICFpc0NvbGxhcHNlZDtcclxuICAgICAgICAgICAgICAgIGlmICh0b2dnbGVCdXR0b24pIHRvZ2dsZUJ1dHRvbi50ZXh0Q29udGVudCA9IGlzQ29sbGFwc2VkID8gJ1x1MjVCNicgOiAnXHUyNUJDJzsgLy8gVXBkYXRlIHRyaWFuZ2xlIGRpcmVjdGlvblxyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuVWwpIGNoaWxkcmVuVWwuc3R5bGUuZGlzcGxheSA9IGlzQ29sbGFwc2VkID8gJ25vbmUnIDogJ2Jsb2NrJzsgLy8gU2hvdy9oaWRlIGNoaWxkcmVuXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAtLS0gQ2hlY2tib3ggLS0tXHJcbiAgICAgICAgY29uc3QgY2hlY2tib3ggPSBjb250YWluZXIuY3JlYXRlRWwoJ2lucHV0JywgeyB0eXBlOiAnY2hlY2tib3gnIH0pO1xyXG4gICAgICAgIGNoZWNrYm94LmlkID0gYHRyZWUtY2ItJHtub2RlLnBhdGgucmVwbGFjZSgvW15hLXpBLVowLTldL2csICctJyl9YDsgLy8gQ3JlYXRlIGEgc2FmZSBJRFxyXG4gICAgICAgIGNoZWNrYm94LmRhdGFzZXQucGF0aCA9IG5vZGUucGF0aDsgLy8gU3RvcmUgcGF0aCBpbiBkYXRhIGF0dHJpYnV0ZVxyXG4gICAgICAgIGNoZWNrYm94LmRhdGFzZXQudHlwZSA9IG5vZGUudHlwZTsgLy8gU3RvcmUgdHlwZVxyXG5cclxuICAgICAgICAvLyAtLS0gTGFiZWwgLS0tXHJcbiAgICAgICAgY29uc3QgbGFiZWwgPSBjb250YWluZXIuY3JlYXRlRWwoJ2xhYmVsJyk7XHJcbiAgICAgICAgbGFiZWwudGV4dENvbnRlbnQgPSBgJHtub2RlLnR5cGUgPT09ICdmb2xkZXInID8gJ1x1RDgzRFx1RENDMScgOiAnXHVEODNEXHVEQ0M0J30gJHtub2RlLm5hbWV9YDtcclxuICAgICAgICAvLyBsYWJlbC50ZXh0Q29udGVudCA9IG5vZGUubmFtZTtcclxuICAgICAgICBsYWJlbC5odG1sRm9yID0gY2hlY2tib3guaWQ7IC8vIExpbmsgbGFiZWwgdG8gY2hlY2tib3hcclxuICAgICAgICBsYWJlbC5zdHlsZS5tYXJnaW5MZWZ0ID0gJzVweCc7XHJcbiAgICAgICAgbGFiZWwuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xyXG4gICAgICAgIGxhYmVsLnRpdGxlID0gbm9kZS5wYXRoOyAvLyBTaG93IGZ1bGwgcGF0aCBvbiBob3ZlclxyXG5cclxuICAgICAgICAvLyAtLS0gU3RvcmUgcmVmZXJlbmNlcyBpbiB0aGUgbm9kZSBvYmplY3QgYW5kIG1hcCAtLS1cclxuICAgICAgICBub2RlLmVsZW1lbnQgPSBsaTtcclxuICAgICAgICBub2RlLmNoZWNrYm94ID0gY2hlY2tib3g7XHJcbiAgICAgICAgbm9kZS5sYWJlbCA9IGxhYmVsO1xyXG4gICAgICAgIG5vZGUuY29udGFpbmVyID0gY29udGFpbmVyOyAvLyBTdG9yZSBjb250YWluZXIgcmVmZXJlbmNlXHJcbiAgICAgICAgdGhpcy50cmVlTm9kZXMuc2V0KG5vZGUucGF0aCwgbm9kZSk7XHJcblxyXG4gICAgICAgIC8vIC0tLSBTZXQgaW5pdGlhbCBjaGVja2VkIHN0YXRlIGJhc2VkIG9uIGN1cnJlbnQgc2VsZWN0aW9uIC0tLVxyXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdmb2xkZXInKSB7XHJcbiAgICAgICAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSB0aGlzLmN1cnJlbnRGb2xkZXJzLmhhcyhub2RlLnBhdGgpO1xyXG4gICAgICAgIH0gZWxzZSB7IC8vIGZpbGVcclxuICAgICAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9IHRoaXMuY3VycmVudEZpbGVzLmhhcyhub2RlLnBhdGgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gLS0tIEFkZCBldmVudCBsaXN0ZW5lciBmb3IgY2hlY2tib3ggY2hhbmdlcyAtLS1cclxuICAgICAgICBjaGVja2JveC5vbmNoYW5nZSA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICAgICAgY29uc3QgcGF0aCA9IHRhcmdldC5kYXRhc2V0LnBhdGghO1xyXG4gICAgICAgICAgICBjb25zdCB0eXBlID0gdGFyZ2V0LmRhdGFzZXQudHlwZSBhcyAnZm9sZGVyJyB8ICdmaWxlJztcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgY3VycmVudCBzZWxlY3Rpb24gc2V0c1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0LmNoZWNrZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnZm9sZGVyJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXNwbGF5TW9kZSA9PT0gJ2ZvbGRlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Rm9sZGVycy5jbGVhcigpOyAvLyBDbGVhciBwcmV2aW91cyBzZWxlY3Rpb24gaWYgb25seSBvbmUgZm9sZGVyIGNhbiBiZSBzZWxlY3RlZFxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Rm9sZGVycy5hZGQocGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzcGxheU1vZGUgPT09ICdmaWxlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRGaWxlcy5jbGVhcigpOyAvLyBDbGVhciBwcmV2aW91cyBzZWxlY3Rpb24gaWYgb25seSBvbmUgZmlsZSBjYW4gYmUgc2VsZWN0ZWRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RmlsZXMuYWRkKHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdmb2xkZXInKSB0aGlzLmN1cnJlbnRGb2xkZXJzLmRlbGV0ZShwYXRoKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgdGhpcy5jdXJyZW50RmlsZXMuZGVsZXRlKHBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgdmlzdWFsIHN0YXRlIG9mIHRoZSBlbnRpcmUgdHJlZSBhZnRlciBhIGNoYW5nZVxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRyZWVBcHBlYXJhbmNlKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gLS0tIFJlbmRlciBjaGlsZHJlbiByZWN1cnNpdmVseSBpZiBpdCdzIGEgZm9sZGVyIC0tLVxyXG4gICAgICAgIGxldCBjaGlsZHJlblVsOiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsO1xyXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdmb2xkZXInICYmIG5vZGUuY2hpbGRyZW4gJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuVWwgPSBsaS5jcmVhdGVFbCgndWwnKTtcclxuICAgICAgICAgICAgY2hpbGRyZW5VbC5zdHlsZS5saXN0U3R5bGUgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuVWwuc3R5bGUucGFkZGluZ0xlZnQgPSAnMCc7IC8vIFJlc2V0IHBhZGRpbmcgZm9yIG5lc3RlZCBsaXN0XHJcbiAgICAgICAgICAgIGNoaWxkcmVuVWwuc3R5bGUubWFyZ2luTGVmdCA9ICcwJzsgLy8gUHJldmVudCBkb3VibGUgaW5kZW50YXRpb24gZnJvbSBkZWZhdWx0IFVMIHN0eWxlc1xyXG4gICAgICAgICAgICBjaGlsZHJlblVsLnN0eWxlLmRpc3BsYXkgPSBpc0NvbGxhcHNlZCA/ICdub25lJyA6ICdibG9jayc7IC8vIFNob3cvaGlkZSBjaGlsZHJlbiBiYXNlZCBvbiBpbml0aWFsIHN0YXRlXHJcblxyXG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gdGhpcy5yZW5kZXJUcmVlTm9kZShjaGlsZCwgY2hpbGRyZW5VbCEsIGxldmVsICsgMSwgc2VsZWN0ZWRQYXRocywgc2VsZWN0ZWRmaWxlcykpOyAvLyBJbmNyZWFzZSBsZXZlbCBmb3IgY2hpbGRyZW5cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGVscGVyIG1ldGhvZCB0byBkZXRlcm1pbmUgaWYgYSBmb2xkZXIgc2hvdWxkIGJlIGV4cGFuZGVkXHJcbiAgICBwcml2YXRlIHNob3VsZEV4cGFuZEZvbGRlcihub2RlOiBUcmVlTm9kZSwgc2VsZWN0ZWRQYXRoczogU2V0PHN0cmluZz4sIHNlbGVjdGVkRmlsZXM6IFNldDxzdHJpbmc+KTogYm9vbGVhbiB7XHJcbiAgICAgICAgaWYgKHNlbGVjdGVkUGF0aHMuaGFzKG5vZGUucGF0aCkgfHwgc2VsZWN0ZWRGaWxlcy5oYXMobm9kZS5wYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gVGhlIGZvbGRlciBpdHNlbGYgaXMgc2VsZWN0ZWRcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkRXhwYW5kRm9sZGVyKGNoaWxkLCBzZWxlY3RlZFBhdGhzLCBzZWxlY3RlZEZpbGVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBBIGNoaWxkIGlzIHNlbGVjdGVkXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gTmVpdGhlciB0aGUgZm9sZGVyIG5vciBpdHMgY2hpbGRyZW4gYXJlIHNlbGVjdGVkXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgdmlzdWFsIGFwcGVhcmFuY2UgKGVuYWJsZWQvZGlzYWJsZWQvc3R5bGluZykgb2YgYWxsIG5vZGVzXHJcbiAgICAgKiBpbiB0aGUgdHJlZSBiYXNlZCBvbiB0aGUgY3VycmVudCBtb2RlIGFuZCBzZWxlY3Rpb25zLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHVwZGF0ZVRyZWVBcHBlYXJhbmNlKCkge1xyXG4gICAgICAgIHRoaXMudHJlZU5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcclxuICAgICAgICAgICAgbGV0IGlzRGlzYWJsZWQgPSBmYWxzZTsgLy8gU2hvdWxkIHRoZSBub2RlIGFwcGVhciBkaXNhYmxlZCAoZ3JleWVkIG91dCk/XHJcbiAgICAgICAgICAgIGxldCBpc0VmZmVjdGl2ZWx5SW5jbHVkZWQgPSBmYWxzZTsgLy8gSXMgdGhlIG5vZGUgcGFydCBvZiB0aGUgJ2FjdGl2ZScgc2V0IGluIGluY2x1ZGUgbW9kZT9cclxuICAgICAgICAgICAgbGV0IGlzRWZmZWN0aXZlbHlFeGNsdWRlZCA9IGZhbHNlOyAvLyBJcyB0aGUgbm9kZSBwYXJ0IG9mIHRoZSAnaW5hY3RpdmUnIHNldCBpbiBleGNsdWRlIG1vZGU/XHJcblxyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgYW4gYW5jZXN0b3IgRk9MREVSIG9mIHRoaXMgbm9kZSBpcyBzZWxlY3RlZFxyXG4gICAgICAgICAgICBsZXQgYW5jZXN0b3JGb2xkZXJTZWxlY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudFBhdGggPSBub2RlLnBhdGg7XHJcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50UGF0aCAhPT0gJy8nKSB7XHJcbiAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IGN1cnJlbnRQYXRoLnN1YnN0cmluZygwLCBjdXJyZW50UGF0aC5sYXN0SW5kZXhPZignLycpKSB8fCAnLyc7XHJcbiAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudEZvbGRlcnMuaGFzKHBhcmVudFBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIGFuY2VzdG9yRm9sZGVyU2VsZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFBhdGggPT09IGN1cnJlbnRQYXRoKSBicmVhazsgLy8gU2FmZXR5IGJyZWFrIGF0IHJvb3RcclxuICAgICAgICAgICAgICAgICBjdXJyZW50UGF0aCA9IHBhcmVudFBhdGg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBub2RlIGl0c2VsZiBpcyBzZWxlY3RlZFxyXG4gICAgICAgICAgICBjb25zdCBub2RlU2VsZWN0ZWQgPSBub2RlLnR5cGUgPT09ICdmb2xkZXInXHJcbiAgICAgICAgICAgICAgICA/IHRoaXMuY3VycmVudEZvbGRlcnMuaGFzKG5vZGUucGF0aClcclxuICAgICAgICAgICAgICAgIDogdGhpcy5jdXJyZW50RmlsZXMuaGFzKG5vZGUucGF0aCk7XHJcblxyXG4gICAgICAgICAgICAvLyAtLS0gQXBwbHkgTG9naWMgQmFzZWQgb24gTW9kZSAtLS1cclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudE1vZGUgPT09ICdleGNsdWRlJykge1xyXG4gICAgICAgICAgICAgICAgLy8gRVhDTFVERSBNb2RlOiBBIG5vZGUgaXMgY29uc2lkZXJlZCBleGNsdWRlZCBpZiBpdCBPUiBhbiBhbmNlc3RvciBGT0xERVIgaXMgc2VsZWN0ZWQuXHJcbiAgICAgICAgICAgICAgICAvLyBWaXN1YWxseSBkaXNhYmxlIChncmV5IG91dCkgbm9kZXMgdGhhdCBhcmUgZXhjbHVkZWQuXHJcbiAgICAgICAgICAgICAgICBpc0VmZmVjdGl2ZWx5RXhjbHVkZWQgPSBub2RlU2VsZWN0ZWQgfHwgYW5jZXN0b3JGb2xkZXJTZWxlY3RlZDtcclxuICAgICAgICAgICAgICAgIGlzRGlzYWJsZWQgPSBpc0VmZmVjdGl2ZWx5RXhjbHVkZWQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIElOQ0xVREUgTW9kZVxyXG4gICAgICAgICAgICAgICAgLy8gSU5DTFVERSBNb2RlOiBBIG5vZGUgaXMgY29uc2lkZXJlZCBpbmNsdWRlZCBpZiBpdCBPUiBhbiBhbmNlc3RvciBGT0xERVIgaXMgc2VsZWN0ZWQuXHJcbiAgICAgICAgICAgICAgICAvLyBWaXN1YWxseSBkaXNhYmxlIChncmV5IG91dCkgbm9kZXMgdGhhdCBhcmUgTk9UIGluY2x1ZGVkLlxyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2ZvbGRlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICBpc0VmZmVjdGl2ZWx5SW5jbHVkZWQgPSBub2RlU2VsZWN0ZWQgfHwgYW5jZXN0b3JGb2xkZXJTZWxlY3RlZDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIGZpbGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBGaWxlIGluY2x1ZGVkIGlmIHNlbGVjdGVkIE9SIHBhcmVudCBwYXRoIGlzIGluY2x1ZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IG5vZGUucGF0aC5zdWJzdHJpbmcoMCwgbm9kZS5wYXRoLmxhc3RJbmRleE9mKCcvJykpIHx8ICcvJztcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRFZmZlY3RpdmVseUluY2x1ZGVkID0gdGhpcy5pc1BhdGhFZmZlY3RpdmVseUluY2x1ZGVkKHBhcmVudFBhdGgpOyAvLyBDaGVjayBwYXJlbnQgZm9sZGVyIHN0YXR1c1xyXG4gICAgICAgICAgICAgICAgICAgIGlzRWZmZWN0aXZlbHlJbmNsdWRlZCA9IG5vZGVTZWxlY3RlZCB8fCBwYXJlbnRFZmZlY3RpdmVseUluY2x1ZGVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaXNEaXNhYmxlZCA9ICFpc0VmZmVjdGl2ZWx5SW5jbHVkZWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIC0tLSBBcHBseSBWaXN1YWwgU3R5bGVzIC0tLVxyXG4gICAgICAgICAgICAvLyBDaGVja2JveCBpdHNlbGYgc2hvdWxkIGFsd2F5cyBiZSBjbGlja2FibGUgdG8gY2hhbmdlIHNlbGVjdGlvbiBzdGF0ZVxyXG4gICAgICAgICAgICBub2RlLmNoZWNrYm94LmRpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIG5vZGUuY2hlY2tib3guY2hlY2tlZCA9IG5vZGVTZWxlY3RlZDtcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGx5IHN0eWxpbmcgdG8gdGhlIGNvbnRhaW5lciAobGFiZWwsIGljb24pIGJhc2VkIG9uIGRpc2FibGVkIHN0YXRlXHJcbiAgICAgICAgICAgIGlmIChpc0Rpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLmVsZW1lbnQuYWRkQ2xhc3MoJ2lzLWRpc2FibGVkJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLmVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2lzLWRpc2FibGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIC0tLSBGSVggZm9yIEludmFsaWRDaGFyYWN0ZXJFcnJvciAtLS1cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGNsYXNzZXMgaW5kaXZpZHVhbGx5XHJcbiAgICAgICAgICAgIG5vZGUuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdpcy1pbmNsdWRlZCcsICdpcy1leGNsdWRlZCcpO1xyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHNwZWNpZmljIGNsYXNzZXMgZm9yIHN0eWxpbmcgaW5jbHVkZWQvZXhjbHVkZWQgc3RhdGVzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRNb2RlID09PSAnaW5jbHVkZScgJiYgaXNFZmZlY3RpdmVseUluY2x1ZGVkKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLmVsZW1lbnQuYWRkQ2xhc3MoJ2lzLWluY2x1ZGVkJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50TW9kZSA9PT0gJ2V4Y2x1ZGUnICYmIGlzRWZmZWN0aXZlbHlFeGNsdWRlZCkge1xyXG4gICAgICAgICAgICAgICAgIC8vIEFwcGx5IGV4Y2x1ZGVkIGNsYXNzIGV2ZW4gaWYgaXQncyBqdXN0IHZpc3VhbGx5IGRpc2FibGVkXHJcbiAgICAgICAgICAgICAgICAgLy8gVGhpcyBhbGxvd3Mgc3BlY2lmaWMgc3R5bGluZyBmb3IgZXhjbHVkZWQgaXRlbXMgYmV5b25kIGp1c3QgZ3JleWVkIG91dFxyXG4gICAgICAgICAgICAgICAgbm9kZS5lbGVtZW50LmFkZENsYXNzKCdpcy1leGNsdWRlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGlmIGEgZ2l2ZW4gcGF0aCBpcyBlZmZlY3RpdmVseSBpbmNsdWRlZFxyXG4gICAgICogaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVuZGVyICdpbmNsdWRlJyBtb2RlLlxyXG4gICAgICogQSBwYXRoIGlzIGluY2x1ZGVkIGlmIGl0IChmaWxlIG9yIGZvbGRlcikgaXMgc2VsZWN0ZWQsIG9yIGlmIGFueSBvZiBpdHMgYW5jZXN0b3IgRk9MREVSUyBhcmUgc2VsZWN0ZWQuXHJcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBmb2xkZXIgb3IgZmlsZSBwYXRoIHRvIGNoZWNrLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgcGF0aCBzaG91bGQgYmUgY29uc2lkZXJlZCBpbmNsdWRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGlzUGF0aEVmZmVjdGl2ZWx5SW5jbHVkZWQocGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgLy8gVGhpcyBjaGVjayBpcyBwcmltYXJpbHkgZm9yICdpbmNsdWRlJyBtb2RlIGxvZ2ljLlxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRNb2RlICE9PSAnaW5jbHVkZScpIHtcclxuICAgICAgICAgICAgIC8vIEluICdleGNsdWRlJyBtb2RlLCBjb25jZXB0dWFsbHkgZXZlcnl0aGluZyBpcyBpbmNsdWRlZCB1bmxlc3MgZXhjbHVkZWQuXHJcbiAgICAgICAgICAgICAvLyBGb3IgaW50ZXJuYWwgY2hlY2tzLCB3ZSBtaWdodCBuZWVkIHRoZSBpbnZlcnNlIG9mIGV4Y2x1c2lvbi5cclxuICAgICAgICAgICAgIHJldHVybiAhdGhpcy5pc1BhdGhFZmZlY3RpdmVseUV4Y2x1ZGVkKHBhdGgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHBhdGggaXRzZWxmIGlzIHNlbGVjdGVkIChhcHBsaWVzIHRvIGJvdGggZmlsZXMgYW5kIGZvbGRlcnMpXHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEZpbGVzLmhhcyhwYXRoKSB8fCB0aGlzLmN1cnJlbnRGb2xkZXJzLmhhcyhwYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIGFueSBhbmNlc3RvciBGT0xERVIgaXMgc2VsZWN0ZWRcclxuICAgICAgICBsZXQgY3VycmVudCA9IHBhdGg7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09ICcvJykge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJlbnRQYXRoID0gY3VycmVudC5zdWJzdHJpbmcoMCwgY3VycmVudC5sYXN0SW5kZXhPZignLycpKSB8fCAnLyc7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRGb2xkZXJzLmhhcyhwYXJlbnRQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIEFuIGFuY2VzdG9yIGZvbGRlciBpcyBzZWxlY3RlZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnRQYXRoID09PSBjdXJyZW50KSBicmVhazsgLy8gUmVhY2hlZCByb290IG9yIGVycm9yXHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBwYXJlbnRQYXRoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBOZWl0aGVyIHRoZSBwYXRoIG5vciBhbnkgYW5jZXN0b3IgZm9sZGVyIGlzIHNlbGVjdGVkXHJcbiAgICB9XHJcblxyXG4gICAgIC8qKlxyXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiBhIGdpdmVuIHBhdGggaXMgZWZmZWN0aXZlbHkgZXhjbHVkZWRcclxuICAgICAqIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1bmRlciAnZXhjbHVkZScgbW9kZS5cclxuICAgICAqIEEgcGF0aCBpcyBleGNsdWRlZCBpZiBpdCAoZmlsZSBvciBmb2xkZXIpIGlzIHNlbGVjdGVkLCBvciBpZiBhbnkgb2YgaXRzIGFuY2VzdG9yIEZPTERFUlMgYXJlIHNlbGVjdGVkLlxyXG4gICAgICogQHBhcmFtIHBhdGggLSBUaGUgZm9sZGVyIG9yIGZpbGUgcGF0aCB0byBjaGVjay5cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHBhdGggc2hvdWxkIGJlIGNvbnNpZGVyZWQgZXhjbHVkZWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBpc1BhdGhFZmZlY3RpdmVseUV4Y2x1ZGVkKHBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgICAgICAvLyBUaGlzIGNoZWNrIGlzIHByaW1hcmlseSBmb3IgJ2V4Y2x1ZGUnIG1vZGUgbG9naWMuXHJcbiAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRNb2RlICE9PSAnZXhjbHVkZScpIHtcclxuICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgfVxyXG5cclxuICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHBhdGggaXRzZWxmIGlzIHNlbGVjdGVkXHJcbiAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRGaWxlcy5oYXMocGF0aCkgfHwgdGhpcy5jdXJyZW50Rm9sZGVycy5oYXMocGF0aCkpIHtcclxuICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICB9XHJcblxyXG4gICAgICAgICAvLyBDaGVjayBpZiBhbnkgYW5jZXN0b3IgRk9MREVSIGlzIHNlbGVjdGVkXHJcbiAgICAgICAgIGxldCBjdXJyZW50ID0gcGF0aDtcclxuICAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09ICcvJykge1xyXG4gICAgICAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IGN1cnJlbnQuc3Vic3RyaW5nKDAsIGN1cnJlbnQubGFzdEluZGV4T2YoJy8nKSkgfHwgJy8nO1xyXG4gICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudEZvbGRlcnMuaGFzKHBhcmVudFBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIEFuIGFuY2VzdG9yIGZvbGRlciBpcyBzZWxlY3RlZFxyXG4gICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgaWYgKHBhcmVudFBhdGggPT09IGN1cnJlbnQpIGJyZWFrOyAvLyBSZWFjaGVkIHJvb3Qgb3IgZXJyb3JcclxuICAgICAgICAgICAgIGN1cnJlbnQgPSBwYXJlbnRQYXRoO1xyXG4gICAgICAgICB9XHJcblxyXG4gICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5laXRoZXIgdGhlIHBhdGggbm9yIGFueSBhbmNlc3RvciBmb2xkZXIgaXMgc2VsZWN0ZWQgZm9yIGV4Y2x1c2lvblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbWJpbmVzIGJ1aWxkaW5nIHRoZSB0cmVlIGRhdGEsIHJlbmRlcmluZyB0aGUgRE9NLCBhbmQgYXBwbHlpbmcgaW5pdGlhbCBhcHBlYXJhbmNlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGJ1aWxkQW5kUmVuZGVyVHJlZSgpIHtcclxuICAgICAgICAvLyBsb2dnZXIubG9nKERFQlVHLCdCdWlsZGluZyBhbmQgcmVuZGVyaW5nIHRyZWUuLi4nKTtcclxuICAgICAgICB0aGlzLnJlbmRlclRyZWUoKTsgLy8gQnVpbGQgZGF0YSBhbmQgcmVuZGVyIERPTSBlbGVtZW50c1xyXG4gICAgICAgIHRoaXMudXBkYXRlVHJlZUFwcGVhcmFuY2UoKTsgLy8gQXBwbHkgc3R5bGVzIGJhc2VkIG9uIGN1cnJlbnQgbW9kZS9zZWxlY3Rpb25cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgbW9kYWwgaXMgY2xvc2VkLiBDbGVhbnMgdXAgcmVzb3VyY2VzLlxyXG4gICAgICovXHJcbiAgICBvbkNsb3NlKCkge1xyXG4gICAgICAgIC8vIEdhdGhlciB0aGUgZmluYWwgc3RhdGUgT05MWSB3aGVuIE9LIGlzIGNsaWNrZWRcclxuICAgICAgICBjb25zdCByZXN1bHQ6IERpcmVjdG9yeVNlbGVjdGlvblJlc3VsdCA9IHtcclxuICAgICAgICAgICAgZm9sZGVyczogQXJyYXkuZnJvbSh0aGlzLmN1cnJlbnRGb2xkZXJzKSxcclxuICAgICAgICAgICAgZmlsZXM6IEFycmF5LmZyb20odGhpcy5jdXJyZW50RmlsZXMpLFxyXG4gICAgICAgICAgICBtb2RlOiB0aGlzLmN1cnJlbnRNb2RlLFxyXG4gICAgICAgICAgICBkaXNwbGF5OiB0aGlzLmN1cnJlbnREaXNwbGF5LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gbG9nZ2VyLmxvZyhERUJVRyxcIk9LIENsaWNrZWQgLSBSZXR1cm5pbmcgUmVzdWx0OlwiLCByZXN1bHQpOyAvLyBEZWJ1ZyBsb2dcclxuICAgICAgICB0aGlzLm9rQ2FsbGJhY2socmVzdWx0KTsgLy8gUGFzcyB0aGUgZmluYWwgc2VsZWN0aW9uIGJhY2tcclxuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcclxuICAgICAgICBjb250ZW50RWwuZW1wdHkoKTsgLy8gQ2xlYXIgdGhlIG1vZGFsJ3MgY29udGVudFxyXG4gICAgICAgIHRoaXMudHJlZU5vZGVzLmNsZWFyKCk7IC8vIENsZWFyIHRoZSBub2RlIG1hcCB0byBmcmVlIG1lbW9yeVxyXG4gICAgICAgIHRoaXMubW9kZURyb3Bkb3duID0gbnVsbDsgLy8gQ2xlYXIgcmVmZXJlbmNlXHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZWFzaWx5IG9wZW4gdGhlIERpcmVjdG9yeSBTZWxlY3Rpb24gTW9kYWwuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcHAgLSBUaGUgT2JzaWRpYW4gQXBwIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gaW5pdGlhbEZvbGRlcnMgLSBBcnJheSBvZiBpbml0aWFsbHkgc2VsZWN0ZWQgZm9sZGVyIHBhdGhzLlxyXG4gKiBAcGFyYW0gaW5pdGlhbEZpbGVzIC0gQXJyYXkgb2YgaW5pdGlhbGx5IHNlbGVjdGVkIGZpbGUgcGF0aHMuXHJcbiAqIEBwYXJhbSBpbml0aWFsTW9kZSAtIFRoZSBpbml0aWFsIHNlbGVjdGlvbiBtb2RlICgnaW5jbHVkZScgb3IgJ2V4Y2x1ZGUnKS5cclxuICogQHBhcmFtIG9rQ2FsbGJhY2sgLSBGdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHVzZXIgY2xpY2tzIFwiT0tcIi4gUmVjZWl2ZXMgdGhlIHNlbGVjdGlvbiByZXN1bHQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gb3BlbkRpcmVjdG9yeVNlbGVjdGlvbk1vZGFsKFxyXG4gICAgYXBwOiBBcHAsXHJcbiAgICBpbml0aWFsRm9sZGVyczogc3RyaW5nW10sXHJcbiAgICBpbml0aWFsRmlsZXM6IHN0cmluZ1tdLFxyXG4gICAgb3B0aW9uczogRGlyZWN0b3J5U2VsZWN0aW9uT3B0aW9ucyxcclxuICAgIG9rQ2FsbGJhY2s6IChyZXN1bHQ6IERpcmVjdG9yeVNlbGVjdGlvblJlc3VsdCB8IG51bGwpID0+IHZvaWRcclxuKTogdm9pZCB7XHJcbiAgICAvLyBDcmVhdGUgYW5kIG9wZW4gdGhlIG1vZGFsIGluc3RhbmNlXHJcbiAgICBuZXcgRGlyZWN0b3J5U2VsZWN0aW9uTW9kYWwoXHJcbiAgICAgICAgYXBwLFxyXG4gICAgICAgIGluaXRpYWxGb2xkZXJzLFxyXG4gICAgICAgIGluaXRpYWxGaWxlcyxcclxuICAgICAgICBvcHRpb25zLFxyXG4gICAgICAgIG9rQ2FsbGJhY2tcclxuICAgICkub3BlbigpO1xyXG59XHJcblxyXG4vKlxyXG4vLyAtLS0gRXhhbXBsZSBVc2FnZSBpbiB5b3VyIFBsdWdpbidzIFNldHRpbmdzIFRhYiAtLS1cclxuLy8gKFBsYWNlIHRoaXMgaW4geW91ciBzZXR0aW5ncyB0YWIgZmlsZSwgZS5nLiwgc2V0dGluZ3MudHMpXHJcblxyXG5pbXBvcnQgeyBBcHAsIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcgfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCB7IG9wZW5EaXJlY3RvcnlTZWxlY3Rpb25Nb2RhbCwgRGlyZWN0b3J5U2VsZWN0aW9uUmVzdWx0IH0gZnJvbSAnLi9EaXJlY3RvcnlTZWxlY3Rpb25Nb2RhbCc7IC8vIEFkanVzdCBwYXRoIGFzIG5lZWRlZFxyXG5pbXBvcnQgWW91clBsdWdpbiBmcm9tICcuL21haW4nOyAvLyBBZGp1c3QgcGF0aCB0byB5b3VyIG1haW4gcGx1Z2luIGZpbGVcclxuXHJcbi8vIC0tLSBFeGFtcGxlIFBsdWdpbiBTZXR0aW5ncyBJbnRlcmZhY2UgKGluIHlvdXIgbWFpbi50cyBvciBzZXR0aW5ncyBmaWxlKSAtLS1cclxuZXhwb3J0IGludGVyZmFjZSBZb3VyUGx1Z2luU2V0dGluZ3Mge1xyXG4gICAgc2VsZWN0ZWRGb2xkZXJzOiBzdHJpbmdbXTtcclxuICAgIHNlbGVjdGVkRmlsZXM6IHN0cmluZ1tdO1xyXG4gICAgc2VsZWN0aW9uTW9kZTogJ2luY2x1ZGUnIHwgJ2V4Y2x1ZGUnO1xyXG4gICAgLy8gLi4uIG90aGVyIHNldHRpbmdzIGZvciB5b3VyIHBsdWdpblxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgREVGQVVMVF9TRVRUSU5HUzogWW91clBsdWdpblNldHRpbmdzID0ge1xyXG4gICAgc2VsZWN0ZWRGb2xkZXJzOiBbXSxcclxuICAgIHNlbGVjdGVkRmlsZXM6IFtdLFxyXG4gICAgc2VsZWN0aW9uTW9kZTogJ2V4Y2x1ZGUnLCAvLyBEZWZhdWx0IG1vZGUgaXMgb2Z0ZW4gJ2V4Y2x1ZGUnXHJcbiAgICAvLyAuLi4gb3RoZXIgZGVmYXVsdCBzZXR0aW5nc1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFlvdXJQbHVnaW5TZXR0aW5nc1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xyXG4gICAgcGx1Z2luOiBZb3VyUGx1Z2luO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IFlvdXJQbHVnaW4pIHtcclxuICAgICAgICBzdXBlcihhcHAsIHBsdWdpbik7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICB9XHJcblxyXG4gICAgZGlzcGxheSgpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XHJcblxyXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ0VpbnN0ZWxsdW5nZW4gZlx1MDBGQ3IgTWVpbiBQbHVnaW4nIH0pOyAvLyBTZXR0aW5ncyBUaXRsZSBpbiBHZXJtYW5cclxuXHJcbiAgICAgICAgLy8gLS0tIEJ1dHRvbiB0byBPcGVuIHRoZSBNb2RhbCAtLS1cclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ1ZlcnplaWNobmlzc2UvRGF0ZWllbiBrb25maWd1cmllcmVuJykgLy8gU2V0dGluZyBOYW1lIGluIEdlcm1hblxyXG4gICAgICAgICAgICAuc2V0RGVzYygnS2xpY2tlIGF1ZiBkZW4gQnV0dG9uLCB1bSBkaWUgQXVzd2FobCB6dSBiZWFyYmVpdGVuLicpIC8vIFNldHRpbmcgRGVzY3JpcHRpb24gaW4gR2VybWFuXHJcbiAgICAgICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IHtcclxuICAgICAgICAgICAgICAgIGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdBdXN3YWhsIFx1MDBGNmZmbmVuJykgLy8gQnV0dG9uIFRleHQgaW4gR2VybWFuXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldEN0YSgpIC8vIE1ha2VzIHRoZSBidXR0b24gbW9yZSBwcm9taW5lbnRcclxuICAgICAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHJpZXZlIGN1cnJlbnQgc2V0dGluZ3MgdG8gcHJlLXBvcHVsYXRlIHRoZSBtb2RhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Rm9sZGVycyA9IHRoaXMucGx1Z2luLnNldHRpbmdzLnNlbGVjdGVkRm9sZGVycyB8fCBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEZpbGVzID0gdGhpcy5wbHVnaW4uc2V0dGluZ3Muc2VsZWN0ZWRGaWxlcyB8fCBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudE1vZGUgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zZWxlY3Rpb25Nb2RlIHx8ICdleGNsdWRlJzsgLy8gVXNlIGRlZmF1bHQgaWYgbm90IHNldFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlbiB0aGUgbW9kYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbkRpcmVjdG9yeVNlbGVjdGlvbk1vZGFsKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rm9sZGVycyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaWxlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNb2RlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgb2tDYWxsYmFjayBmdW5jdGlvbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZXN1bHQ6IERpcmVjdG9yeVNlbGVjdGlvblJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coREVCVUcsJ0F1c3dhaGwgYmVzdFx1MDBFNHRpZ3Q6JywgcmVzdWx0KTsgLy8gTG9nIHJlc3VsdCBpbiBHZXJtYW4gY29uc29sZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtLS0gSU1QT1JUQU5UOiBTYXZlIHRoZSByZXN1bHRzIGJhY2sgdG8geW91ciBwbHVnaW4gc2V0dGluZ3MgLS0tXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Muc2VsZWN0ZWRGb2xkZXJzID0gcmVzdWx0LmZvbGRlcnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Muc2VsZWN0ZWRGaWxlcyA9IHJlc3VsdC5maWxlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zZWxlY3Rpb25Nb2RlID0gcmVzdWx0Lm1vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7IC8vIFBlcnNpc3QgdGhlIGNoYW5nZXNcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW9uYWxseSwgcmUtcmVuZGVyIHRoZSBzZXR0aW5ncyB0YWIgdG8gc2hvdyB0aGUgdXBkYXRlZCBzZWxlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTsgLy8gUmUtcmVuZGVyIHNldHRpbmdzIHRhYlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgIC8vIC0tLSBEaXNwbGF5IEN1cnJlbnQgU2VsZWN0aW9uIChSZWFkLW9ubHkpIC0tLVxyXG4gICAgICAgICBjb25zdCBzZWxlY3Rpb25JbmZvRWwgPSBjb250YWluZXJFbC5jcmVhdGVEaXYoeyBjbHM6ICdzZXR0aW5ncy1zZWxlY3Rpb24taW5mbycgfSk7XHJcbiAgICAgICAgIHNlbGVjdGlvbkluZm9FbC5jcmVhdGVFbCgnaDQnLCB7IHRleHQ6ICdBa3R1ZWxsZSBBdXN3YWhsOicgfSk7IC8vIFNlY3Rpb24gVGl0bGUgaW4gR2VybWFuXHJcbiAgICAgICAgIGNvbnN0IG1vZGVUZXh0ID0gYE1vZHVzOiAke3RoaXMucGx1Z2luLnNldHRpbmdzLnNlbGVjdGlvbk1vZGUgfHwgJ05pY2h0IGZlc3RnZWxlZ3QnfWA7IC8vIFRleHQgaW4gR2VybWFuXHJcbiAgICAgICAgIC8vIFRydW5jYXRlIGxvbmcgbGlzdHMgZm9yIGRpc3BsYXkgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgIGNvbnN0IGZvbGRlclRleHQgPSBgQXVzZ2V3XHUwMEU0aGx0ZSBPcmRuZXI6ICR7KHRoaXMucGx1Z2luLnNldHRpbmdzLnNlbGVjdGVkRm9sZGVycz8ubGVuZ3RoIHx8IDApfSBTdFx1MDBGQ2NrYDsgLy8gVGV4dCBpbiBHZXJtYW5cclxuICAgICAgICAgY29uc3QgZmlsZVRleHQgPSBgQXVzZ2V3XHUwMEU0aGx0ZSBEYXRlaWVuOiAkeyh0aGlzLnBsdWdpbi5zZXR0aW5ncy5zZWxlY3RlZEZpbGVzPy5sZW5ndGggfHwgMCl9IFN0XHUwMEZDY2tgOyAvLyBUZXh0IGluIEdlcm1hblxyXG5cclxuICAgICAgICAgc2VsZWN0aW9uSW5mb0VsLmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiBtb2RlVGV4dCB9KTtcclxuICAgICAgICAgc2VsZWN0aW9uSW5mb0VsLmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiBmb2xkZXJUZXh0IH0pO1xyXG4gICAgICAgICBzZWxlY3Rpb25JbmZvRWwuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6IGZpbGVUZXh0IH0pO1xyXG4gICAgICAgICAvLyBZb3UgY291bGQgYWRkIGEgc21hbGwgYnV0dG9uL2xpbmsgaGVyZSB0byB2aWV3IHRoZSBmdWxsIGxpc3QgaWYgaXQncyBsb25nXHJcbiAgICB9XHJcbn1cclxuKi9cclxuIiwgImltcG9ydCB7IEFwcCwgUGx1Z2luLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nLCBEcm9wZG93bkNvbXBvbmVudCwgVGV4dENvbXBvbmVudCwgQnV0dG9uQ29tcG9uZW50LCBUb2dnbGVDb21wb25lbnQsIHNldEljb24sIGFwaVZlcnNpb24sIFRGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQgeyBvcGVuRGlyZWN0b3J5U2VsZWN0aW9uTW9kYWwsIERpcmVjdG9yeVNlbGVjdGlvblJlc3VsdCB9IGZyb20gJy4vZGlyZWN0b3J5U2VsZWN0aW9uTW9kYWwnO1xyXG5pbXBvcnQgeyB2ZXJzaW9uU3RyaW5nLCBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCBERUZBVUxUX1JVTEVfREVGSU5JVElPTiwgUHJvcGVydHlUeXBlSW5mbywgT2JzaWRpYW5Qcm9wZXJ0eVR5cGVzLCBERUZBVUxUX0ZJTFRFUl9GSUxFU19BTkRfRk9MREVSUywgUHJvcGVydHlJbmZvfSBmcm9tICcuL3R5cGVzJztcclxuaW1wb3J0IHsgY2hlY2tJZkZpbGVBbGxvd2VkLCBleGVjdXRlUnVsZU9iamVjdCB9IGZyb20gJy4vcnVsZXMnO1xyXG5pbXBvcnQgeyBBbGVydE1vZGFsIH0gZnJvbSAnLi9hbGVydEJveCc7XHJcbmltcG9ydCB7IHJhbmRvbVVVSUQgfSBmcm9tICdjcnlwdG8nO1xyXG5pbXBvcnQgeyBjb2RlRWRpdG9yTW9kYWwsIGNvZGVFZGl0b3JNb2RhbFJlc3VsdCwgb3BlbkNvZGVFZGl0b3JNb2RhbCB9IGZyb20gJy4vZWRpdG9yTW9kYWwnO1xyXG5pbXBvcnQgeyBjb3B5RmlsZVN5bmMgfSBmcm9tICdmcyc7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSAnLi90b29scyc7XHJcbmltcG9ydCB7IHVwZGF0ZVByb3BlcnR5SWNvbiB9IGZyb20gJy4vdWlFbGVtZW50cyc7XHJcbmltcG9ydCB7IHJ1bGVzTWFuYWdlciB9IGZyb20gJy4vcnVsZXMvcnVsZXMnO1xyXG5pbXBvcnQgeyBERUJVRywgbG9nZ2VyLCBXQVJOSU5HIH0gZnJvbSAnLi9Mb2cnO1xyXG5pbXBvcnQgeyBNdWx0aVByb3BlcnR5U2V0dGluZyB9IGZyb20gJy4vdWlNdWx0aVByb3BlcnR5U2V0dGluZyc7XHJcbmltcG9ydCB7IFRyZWVIaWVyYXJjaHlEYXRhLCBUcmVlSGllcmFyY2h5U29ydGFibGVTZXR0aW5ncywgUk9PVF9GT0xERVIsIFRyZWVIaWVyYXJjaHlSb3cgfSBmcm9tICcuL3VpVHJlZUhpZXJhcmNoeVNvcnRhYmxlU2V0dGluZ3MnO1xyXG5pbXBvcnQgeyBmZXRjaE1hcmtkb3duRnJvbUdpdEh1YiwgTWFya2Rvd25IZWxwTW9kYWwgfSBmcm9tICcuL3VpTWFya2Rvd25IZWxwTW9kYWwnO1xyXG5cclxuZXhwb3J0IGNsYXNzIFJ1bGVzVGFibGUgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcclxuICAgIHBsdWdpbjogYW55O1xyXG4gICAga25vd25Qcm9wZXJ0aWVzOiBSZWNvcmQ8c3RyaW5nLCBQcm9wZXJ0eUluZm8+ID0ge307IFxyXG4gICAgY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudDtcclxuICAgIHByb3BlcnRpZXNMaXN0RWwhOiBIVE1MRGl2RWxlbWVudDtcclxuICAgIHNldHRpbmdzOiBUcmVlSGllcmFyY2h5RGF0YTtcclxuICAgIHRvb2xzOiBTY3JpcHRpbmdUb29scztcclxuICAgIGFjdGl2ZUZpbGU6IFRGaWxlIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogYW55LCBjb250YWluZXI6IEhUTUxEaXZFbGVtZW50LCBzZXR0aW5nczogVHJlZUhpZXJhcmNoeURhdGEpIHtcclxuICAgICAgICBzdXBlcihhcHAsIHBsdWdpbik7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xyXG4gICAgICAgIHRoaXMudG9vbHMgPSBuZXcgU2NyaXB0aW5nVG9vbHMoYXBwLCBwbHVnaW4pO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIEhlbHBlciB0byByZW5kZXIgb25lIHJ1bGVcclxuXHJcbiAgICByZW5kZXJQcm9wZXJ0eVJvdyhjb250YWluZXJFbDogSFRNTEVsZW1lbnQsIHJ1bGU6IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MgKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy9jb25zdCBhY3RpdmVGaWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcclxuXHJcbiAgICAgICAgY29uc3Qgcm93RWwgPSBjb250YWluZXJFbC5jcmVhdGVEaXYoeyBjbHM6ICdwcm9wZXJ0eS1zZXR0aW5nLXJvdyBzZXR0aW5nLWl0ZW0nIH0pO1xyXG4gICAgICAgIHJvd0VsLnN0eWxlLndpZHRoID0gJzEwMCUnOyAvLyBtYWtlIHN1cmUgdGhlIHJvdyB0YWtlcyBmdWxsIHdpZHRoXHJcbiAgICAgICAgcm93RWwuaWQgPSBydWxlLmlkO1xyXG4gICAgICAgIGNvbnN0IGNvbnRyb2xFbCA9IHJvd0VsLmNyZWF0ZURpdih7IGNsczogJ3NldHRpbmctaXRlbS1jb250cm9sJyB9KTsgXHJcbiAgICAgICAgY29udHJvbEVsLnN0eWxlLndpZHRoID0gJzEwMCUnO1xyXG4gICAgICAgIGNvbnRyb2xFbC5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xyXG4gICAgICAgIGNvbnRyb2xFbC5zdHlsZS5nYXAgPSAnMHB4JztcclxuICAgICAgICBjb25zdCBsZWZ0Q29udGFpbmVyID0gY29udHJvbEVsLmNyZWF0ZURpdih7IGNsczogJ3Byb3BlcnR5LWxlZnQtY29udGFpbmVyJyB9KTtcclxuICAgICAgICBjb25zdCBpY29uRWwgPSBsZWZ0Q29udGFpbmVyLmNyZWF0ZVNwYW4oeyBjbHM6ICdwcm9wZXJ0eS1pY29uIHNldHRpbmctaXRlbS1pY29uJyB9KTsgXHJcbiAgICAgICAgc2V0SWNvbihpY29uRWwsICdoYXNoJyk7IC8vIFN0YW5kYXJkLUljb25cclxuXHJcblxyXG4gICAgICAgIGNvbnN0IHNlYXJjaENvbnRhaW5lciA9IGxlZnRDb250YWluZXIuY3JlYXRlRGl2KHsgY2xzOiAncHJvcGVydHktc2VhcmNoLWNvbnRhaW5lcicgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IG5hbWVJbnB1dCA9IG5ldyBUZXh0Q29tcG9uZW50KHNlYXJjaENvbnRhaW5lcilcclxuICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdTZWxlY3QgcHJvcGVydHkuLi4nKVxyXG4gICAgICAgICAgICAuc2V0VmFsdWUocnVsZS5wcm9wZXJ0eSB8fCAnJylcclxuICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJTZWFyY2hSZXN1bHRzKHNlYXJjaENvbnRhaW5lciwgdmFsdWUsIHJ1bGUpO1xyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICBuYW1lSW5wdXQuaW5wdXRFbC5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7IC8vIG1ha2UgaXQgaW52aXNpYmxlXHJcbiAgICAgICAgbmFtZUlucHV0LmlucHV0RWwuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU2VhcmNoUmVzdWx0cyhzZWFyY2hDb250YWluZXIsIG5hbWVJbnB1dC5nZXRWYWx1ZSgpLCBydWxlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBuYW1lSW5wdXQuaW5wdXRFbC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTZWFyY2hSZXN1bHRzKHNlYXJjaENvbnRhaW5lciwgbmFtZUlucHV0LmdldFZhbHVlKCksIHJ1bGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG5hbWVJbnB1dC5pbnB1dEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldCBhcyBOb2RlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0c0VsID0gc2VhcmNoQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5wcm9wZXJ0eS1zZWFyY2gtcmVzdWx0cycpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHRzRWwgfHwgIXJlc3VsdHNFbC5jb250YWlucyhyZWxhdGVkVGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJTZWFyY2hSZXN1bHRzKHNlYXJjaENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIDEwMCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRQcm9wZXJ0eUluZm8gPSB0aGlzLmtub3duUHJvcGVydGllc1tydWxlLnByb3BlcnR5XTtcclxuICAgICAgICBpZiAoY3VycmVudFByb3BlcnR5SW5mbykge1xyXG4gICAgICAgICAgICB1cGRhdGVQcm9wZXJ0eUljb24oaWNvbkVsLCBjdXJyZW50UHJvcGVydHlJbmZvLnR5cGUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocnVsZS5wcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICBzZXRJY29uKGljb25FbCwgJ2FsZXJ0LWNpcmNsZScpOyBcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IG1pZGRsZUNvbnRhaW5lciA9IGNvbnRyb2xFbC5jcmVhdGVEaXYoeyBjbHM6ICdwcm9wZXJ0eS1taWRkbGUtY29udGFpbmVyJyB9KTtcclxuICAgICAgICBjb25zdCB2YWx1ZUNvbnRhaW5lciA9IG1pZGRsZUNvbnRhaW5lci5jcmVhdGVEaXYoeyBjbHM6ICdGTUEtcHJvcGVydHktdmFsdWUtY29udGFpbmVyJyB9KTtcclxuICAgICAgICBpZiAodGhpcy5hY3RpdmVGaWxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLmZpbGVNYW5hZ2VyLnByb2Nlc3NGcm9udE1hdHRlcih0aGlzLmFjdGl2ZUZpbGUsIGFzeW5jIChmcm9udG1hdHRlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcnVsZS52YWx1ZSA9IGF3YWl0IGV4ZWN1dGVSdWxlT2JqZWN0KCdwcmV2aWV3Jyx0aGlzLmFwcCwgdGhpcywgdGhpcy5wbHVnaW4uc2V0dGluZ3MsIHRoaXMuYWN0aXZlRmlsZSwgJycsIHJ1bGUsIGZyb250bWF0dGVyKTsgLy9UT0RPOiBpbXBsZW1lbnQgdXNpbmcgb25seSB1cGRhdGVQZXJ2aWV3XHJcbiAgICAgICAgICAgIH0seydtdGltZSc6dGhpcy5hY3RpdmVGaWxlLnN0YXQubXRpbWV9KTsgLy8gZG8gbm90IGNoYW5nZSB0aGUgbW9kaWZ5IHRpbWUuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHByZXZpZXdDb21wb25lbnQgPSB0aGlzLnJlbmRlclZhbHVlSW5wdXQodmFsdWVDb250YWluZXIsIGN1cnJlbnRQcm9wZXJ0eUluZm8sIHJ1bGUudmFsdWUsIHJ1bGUpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlUHJldmlldyhydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJvcGVydHlEZXZEcm9wZG93biA9ICBuZXcgRHJvcGRvd25Db21wb25lbnQobWlkZGxlQ29udGFpbmVyKTtcclxuICAgICAgICBwcm9wZXJ0eURldkRyb3Bkb3duLnNlbGVjdEVsLnN0eWxlLm1pbldpZHRoID0gJzM1JSdcclxuICAgICAgICBwcm9wZXJ0eURldkRyb3Bkb3duLnNlbGVjdEVsLnN0eWxlLm1heFdpZHRoID0gJzUwJSc7XHJcbiAgICAgICAgcHJvcGVydHlEZXZEcm9wZG93bi5hZGRPcHRpb24oXCJcIiwgXCJTZWxlY3QgYSBjb250ZW50XCIpO1xyXG5cclxuICAgICAgICAvLyBhZGQgcnVsZSBmdW5jdGlvbnMgdG8gZHJvcGRvd25cclxuICAgICAgICBydWxlc01hbmFnZXIuZ2V0UnVsZXNCeVR5cGUoJ2J1aWxkSW4nLCBydWxlLnR5cGUpLmZvckVhY2gocnVsZSA9PiB7XHJcbiAgICAgICAgICAgIHByb3BlcnR5RGV2RHJvcGRvd24uYWRkT3B0aW9uKHJ1bGUuaWQsIHJ1bGUubmFtZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIHByb3BlcnR5RGV2RHJvcGRvd24uYWRkT3B0aW9uKFwic2NyaXB0XCIsIFwiSmF2YVNjcmlwdCBmdW5jdGlvbiAoYWR2YW5jZWQpXCIpO1xyXG4gICAgICAgIHByb3BlcnR5RGV2RHJvcGRvd24uc2V0VmFsdWUocnVsZS5jb250ZW50KTtcclxuICAgICAgICBwcm9wZXJ0eURldkRyb3Bkb3duLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBydWxlRnVuY3Rpb24gPSBydWxlc01hbmFnZXIuZ2V0UnVsZUJ5SWQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChydWxlRnVuY3Rpb24/LnJ1bGVUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2NyaXB0JzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdidWlsZEluLmlucHV0UHJvcGVydHknOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2J1aWxkSW4nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3J1bGUuYnVpbGRJbkNvZGUgPSBydWxlc01hbmFnZXIuZ2V0U291cmNlKHZhbHVlKSB8fCBydWxlc01hbmFnZXIuZ2V0U291cmNlKCdkZWZhdWx0JykgfHwgJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvbGRPcmlnaW5hbENvZGUgPSBydWxlc01hbmFnZXIuZ2V0U291cmNlKHZhbHVlKSB8fCBydWxlc01hbmFnZXIuZ2V0U291cmNlKCdkZWZhdWx0JykgfHwgJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocnVsZS5idWlsZEluQ29kZSAhPT0gJycpICYmIChydWxlLmJ1aWxkSW5Db2RlICE9PSBvbGRPcmlnaW5hbENvZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRQcm9jZWVkID0gYXdhaXQgbmV3IEFsZXJ0TW9kYWwoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnT3ZlcndyaXRlIGV4aXN0aW5nIGNvZGU/JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0kgc2VlcyBsaWtlIHlvdSBoYXZlIGN1c3RvbSBjb2RlIGZvciB0aGlzIHJ1bGUhIFNob3VsZCB0aGlzIGJlIG92ZXJ3cml0dGVuIGJ5IGRlZmF1bHQgY29kZSBmb3IgdGhpcyBwYXJhbWV0ZXI/JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1llcycsICdObydcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLm9wZW5BbmRHZXRWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkUHJvY2VlZC5wcm9jZWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5idWlsZEluQ29kZSA9IHJ1bGVzTWFuYWdlci5nZXRTb3VyY2UodmFsdWUpIHx8IHJ1bGVzTWFuYWdlci5nZXRTb3VyY2UoJ2RlZmF1bHQnKSB8fCAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLnVzZUN1c3RvbUNvZGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5idWlsZEluQ29kZTsgLy8ga2VlcCB0aGUgZXhpc3RpbmcgY29kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLmJ1aWxkSW5Db2RlID0gcnVsZXNNYW5hZ2VyLmdldFNvdXJjZSh2YWx1ZSkgfHwgcnVsZXNNYW5hZ2VyLmdldFNvdXJjZSgnZGVmYXVsdCcpIHx8ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS51c2VDdXN0b21Db2RlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXV0b21hdGlvbic6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXV0b2NvbXBsZXRlLm1vZGFsJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcnVsZS5pc0xpdmVSdWxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJ1bGUuY29udGVudCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgLy9ydWxlT3B0aW9uc0Rpdi5zdHlsZS5kaXNwbGF5ID0gYCR7KHJ1bGUuY29udGVudCA9PT0gJ3NjcmlwdCcpID8gJ2ZsZXgnIDogJ25vbmUnfWA7XHJcbiAgICAgICAgICAgICAgICAvL3Nob3dKc0Z1bmN0aW9uQnV0dG9uKHJ1bGUuY29udGVudCk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUHJldmlldyhydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUHJvcGVydHlPcHRpb25zKG9wdGlvbkVMLCBydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGxlZnRDb250YWluZXJFbCA9IGNvbnRyb2xFbC5jcmVhdGVEaXYoeyBjbHM6ICdGTUEtcHJvcGVydHktcmlnaHQtY29udGFpbmVyJyB9KTtcclxuICAgICAgICBuZXcgQnV0dG9uQ29tcG9uZW50KGxlZnRDb250YWluZXJFbClcclxuICAgICAgICAuc2V0SWNvbignZ2VhcicpXHJcbiAgICAgICAgLnNldFRvb2x0aXAoJ29wZW4gc2V0dGluZ3MnKVxyXG4gICAgICAgIC5zZXRDbGFzcygncHJvcGVydHktaWNvbi1idXR0b24nKVxyXG4gICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgbGV0IHNldHRpbmdzQ29udGFpbmVycyA9IGNvbnRhaW5lckVsLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3Byb3BlcnR5LW9wdGlvbnMtY29udGFpbmVyJyk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGNvbnRhaW5lciBvZiBzZXR0aW5nc0NvbnRhaW5lcnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb250YWluZXIuZ2V0QXR0cmlidXRlKCdpZCcpICE9PSBydWxlLmlkKSBjb250YWluZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsJ2Rpc3BsYXk6IG5vbmU7Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJQcm9wZXJ0eU9wdGlvbnMob3B0aW9uRUwsIHJ1bGUsIHByZXZpZXdDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBvcHRpb25FTC5zdHlsZS5kaXNwbGF5ID0gb3B0aW9uRUwuc3R5bGUuZGlzcGxheSA9PT0gJ2Jsb2NrJyA/ICdub25lJyA6ICdibG9jayc7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLypcclxuICAgICAgICAvLyAtLS0gcmlnaHQgcGFydDogZXJhc2UgcnVsZSAtLS1cclxuICAgICAgICBjb25zdCBkZWxldGVCdXR0b25Db250YWluZXIgPSBjb250cm9sRWwuY3JlYXRlRGl2KHsgY2xzOiAncHJvcGVydHktZGVsZXRlLWJ1dHRvbi1jb250YWluZXInIH0pO1xyXG4gICAgICAgIG5ldyBCdXR0b25Db21wb25lbnQoZGVsZXRlQnV0dG9uQ29udGFpbmVyKVxyXG4gICAgICAgICAgICAuc2V0SWNvbigndHJhc2gtMicpXHJcbiAgICAgICAgICAgIC5zZXRUb29sdGlwKCdyZW1vdmUgdGhpcyBydWxlJylcclxuICAgICAgICAgICAgLnNldENsYXNzKCdtb2Qtc3VidGxlJylcclxuICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3NbdGhpcy5zZXR0aW5nc1BhcmFtZXRlcl0uc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5KCk7IC8vIFJlLXJlbmRlciB0aGUgc2V0dGluZ3MgdGFiXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIGRlbGV0ZUJ1dHRvbkNvbnRhaW5lci5zdHlsZS5tYXJnaW5MZWZ0ID0gJ2F1dG8nOyBcclxuICAgICAgICAqL1xyXG4gICAgICAgIGNvbnRyb2xFbC5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xyXG4gICAgICAgIGNvbnRyb2xFbC5zdHlsZS5hbGlnbkl0ZW1zID0gJ2NlbnRlcic7XHJcbiAgICAgICAgY29udHJvbEVsLnN0eWxlLmp1c3RpZnlDb250ZW50ID0gJ3NwYWNlLWJldHdlZW4nO1xyXG4gICAgICAgIGNvbnRyb2xFbC5zdHlsZS53aWR0aCA9ICcxMDAlJztcclxuXHJcbiAgICAgICAgbGVmdENvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xyXG4gICAgICAgIGxlZnRDb250YWluZXIuc3R5bGUuYWxpZ25JdGVtcyA9ICdjZW50ZXInO1xyXG4gICAgICAgIGxlZnRDb250YWluZXIuc3R5bGUubWluV2lkdGggPSAnMTAwcHgnOyBcclxuICAgICAgICBpY29uRWwuc3R5bGUubWFyZ2luUmlnaHQgPSAnOHB4JztcclxuXHJcbiAgICAgICAgc2VhcmNoQ29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJzsgXHJcbiAgICAgICAgLy9zZWFyY2hDb250YWluZXIuc3R5bGUuZmxleEdyb3cgPSAnMSc7XHJcblxyXG4gICAgICAgIC8vdmFsdWVDb250YWluZXIuc3R5bGUuZmxleEdyb3cgPSAnNCc7IFxyXG5cclxuXHJcbiAgICAgICAgbGV0IG9wdGlvbkVMOiBIVE1MRGl2RWxlbWVudDtcclxuICAgICAgICBpZiAoY29udGFpbmVyRWwucGFyZW50RWxlbWVudCkge1xyXG4gICAgICAgICAgICBvcHRpb25FTCA9IGNvbnRhaW5lckVsLnBhcmVudEVsZW1lbnQuY3JlYXRlRGl2KHsgY2xzOiAncHJvcGVydHktb3B0aW9ucy1jb250YWluZXInIH0pO1xyXG4gICAgICAgICAgICBvcHRpb25FTC5pZCA9IHJ1bGUuaWQ7XHJcbiAgICAgICAgICAgIG9wdGlvbkVMLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZmFsbGJhY2s6IGNyZWF0ZSBpbiBjb250YWluZXJFbCBpZiBwYXJlbnRFbGVtZW50IGlzIG51bGxcclxuICAgICAgICAgICAgb3B0aW9uRUwgPSBjb250YWluZXJFbC5jcmVhdGVEaXYoeyBjbHM6ICdwcm9wZXJ0eS1vcHRpb25zLWNvbnRhaW5lcicgfSk7XHJcbiAgICAgICAgICAgIG9wdGlvbkVMLmlkID0gcnVsZS5pZDtcclxuICAgICAgICAgICAgb3B0aW9uRUwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyUHJvcGVydHlPcHRpb25zKG9wdGlvbkVMOiBIVE1MRGl2RWxlbWVudCwgcnVsZTogRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgcHJldmlld0NvbXBvbmVudDogSFRNTERpdkVsZW1lbnQgfCBUZXh0Q29tcG9uZW50IHwgdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaWYgKCEocHJldmlld0NvbXBvbmVudCBpbnN0YW5jZW9mIFRleHRDb21wb25lbnQpKSByZXR1cm47XHJcbiAgICAgICAgb3B0aW9uRUwuZW1wdHkoKTsgLy8gY2xlYXIgcHJldmlvdXMgb3B0aW9uc1xyXG4gICAgICAgIC8vY29uc3QgcnVsZUZuID0gZ2V0UnVsZUZ1bmN0aW9uQnlJZChydWxlLmNvbnRlbnQpO1xyXG4gICAgICAgIGNvbnN0IHJ1bGVGbiA9IHJ1bGVzTWFuYWdlci5nZXRSdWxlQnlJZChydWxlLmNvbnRlbnQpO1xyXG4gICAgICAgIGlmICghcnVsZUZuKSByZXR1cm47XHJcbiAgICAgICAgaWYgKHJ1bGVGbi51c2VSdWxlT3B0aW9uKCdyZW1vdmVDb250ZW50JykpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVtb3ZlQ29udGVudEJ1dHRvbiA9IG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgICAgICAgICAgLnNldE5hbWUoJ1JlbW92ZSBjb250ZW50JylcclxuICAgICAgICAgICAgICAgIC5zZXREZXNjKGBCZWZvcmUgbWFraW5nIGNoYW5nZXMgeW91IG1pZ2h0IGNvbnNpZGVyIHRvIHJlbW92ZSBjb250ZW50IGdlbmVyYXRlZCBieSB0aGlzIHJ1bGVgKVxyXG4gICAgICAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0V2FybmluZygpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdSZW1vdmUgQ29udGVudCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRDdGEoKSAvLyBNYWtlcyB0aGUgYnV0dG9uIG1vcmUgcHJvbWluZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb3VudCA9IHRoaXMucGx1Z2luLnJlbW92ZUZyb250bWF0dGVyUGFyYW1zRnJvbUFsbEZpbGVzKHJ1bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLnJlbW92ZUN0YSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLnNldERpc2FibGVkKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ29udGVudEJ1dHRvbi5zZXREZXNjKGBSZW1vdmVkIHRoaXMgcnVsZSBmcm9tICR7Y291bnQuZmlsZXN9IGZpbGVzLmApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChydWxlRm4udXNlUnVsZU9wdGlvbigncnVsZUFjdGl2ZScpKSB7XHJcbiAgICAgICAgICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgICAgICAgICAgLnNldE5hbWUoJ1J1bGUgYWN0aXZlJylcclxuICAgICAgICAgICAgICAgIC5zZXREZXNjKCdJZiBlbmFibGVkLCB0aGUgcnVsZSB3aWxsIGJlIGV4ZWN1dGVkJylcclxuICAgICAgICAgICAgICAgIC5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShydWxlLmFjdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuYWN0aXZlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocnVsZUZuLnVzZVJ1bGVPcHRpb24oJ21vZGlmeU9ubHknKSkge1xyXG4gICAgICAgICAgICBuZXcgU2V0dGluZyhvcHRpb25FTClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ01vZGlmeSBvbmx5JylcclxuICAgICAgICAgICAgLnNldERlc2MoJ09ubHkgbW9kaWZ5IGV4aXN0aW5nIHByb3BlcnRpZXMnKVxyXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShydWxlLm9ubHlNb2RpZnkpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5vbmx5TW9kaWZ5ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQcmV2aWV3KHJ1bGUsIHByZXZpZXdDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocnVsZS50eXBlID09PSAndGV4dCcgfHwgcnVsZS50eXBlID09PSAnbXVsdGl0ZXh0JyB8fCBydWxlLnR5cGUgPT09ICd0YWdzJyB8fCBydWxlLnR5cGUgPT09ICdhbGlhc2VzJykge1xyXG4gICAgICAgICAgICBsZXQgZm9ybWF0UnVsZSA9IHJ1bGVzTWFuYWdlci5nZXRSdWxlQnlJZChydWxlLmZvcm1hdHRlcik7XHJcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlclJ1bGVzID0gcnVsZXNNYW5hZ2VyLmdldFJ1bGVzQnlUeXBlKCdmb3JtYXR0ZXInKSB8fCBbXTtcclxuICAgICAgICAgICAgbGV0IGZvcm1hdE9wdGlvbnNCdXR0b246IGFueTtcclxuICAgICAgICAgICAgaWYgKHJ1bGVGbi51c2VSdWxlT3B0aW9uKCdjb252ZXJ0VG9Mb3dlckNhc2UnKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbXVsdGlQcm9wID0gbmV3IE11bHRpUHJvcGVydHlTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXROYW1lKFwiRm9ybWF0IG91dHB1dFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXREZXNjKFwiRm9ybWF0IG91dHB1dCB1c2luZyBzZWxlY3RlZCBvcHRpb25zLlwiKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRPcHRpb25zKGZvcm1hdHRlclJ1bGVzKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShydWxlLmZvcm1hdHRlcnMgfHwgWyd0b09yaWdpbmFsJ10pXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKChmb3JtYXR0ZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5mb3JtYXR0ZXJzID0gZm9ybWF0dGVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXRSdWxlID0gcnVsZXNNYW5hZ2VyLmdldFJ1bGVCeUlkKHJ1bGUuZm9ybWF0dGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQcmV2aWV3KHJ1bGUsIHByZXZpZXdDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgbXVsdGlQcm9wLmFkZEV4dHJhQnV0dG9uKChzZXR0aW5nLCBpZHgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZy5hZGRFeHRyYUJ1dHRvbihidG4gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnRuLnNldEljb24oJ2dlYXInKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoJ09wdGlvbnMnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNldERpc2FibGVkKCFydWxlc01hbmFnZXIuZ2V0UnVsZUJ5SWQocnVsZT8uZm9ybWF0dGVycz8uW2lkeF0gPz8gXCJ0b09yaWdpbmFsXCIpPy5oYXNPd25Db25maWdUYWIoKSB8fCBmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0ZXJPcHRpb25EaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydGVyT3B0aW9uRGl2LmVtcHR5KCk7IC8vIGNsZWFyIHByZXZpb3VzIG9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXRSdWxlID0gcnVsZXNNYW5hZ2VyLmdldFJ1bGVCeUlkKHJ1bGU/LmZvcm1hdHRlcnM/LltpZHhdID8/IFwidG9PcmlnaW5hbFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXRSdWxlPy5jb25maWdUYWIoY29udmVydGVyT3B0aW9uRGl2LCBydWxlLCB0aGlzLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlQcm9wLnN0eWxlRGlzYWJsZWQoYnRuLCAhcnVsZXNNYW5hZ2VyLmdldFJ1bGVCeUlkKHJ1bGU/LmZvcm1hdHRlcnM/LltpZHhdID8/IFwidG9PcmlnaW5hbFwiKT8uaGFzT3duQ29uZmlnVGFiKCkgfHwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgY29udmVydGVyT3B0aW9uRGl2ID0gb3B0aW9uRUwuY3JlYXRlRGl2KHsgY2xzOiAncHJvcGVydHktY29udmVydGVyLW9wdGlvbicgfSk7XHJcbiAgICAgICAgICAgIGNvbnZlcnRlck9wdGlvbkRpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICBjb252ZXJ0ZXJPcHRpb25EaXYuc3R5bGUubWFyZ2luTGVmdCA9ICcyMHB4JztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChydWxlRm4udXNlUnVsZU9wdGlvbigncmVzdWx0QXNMaW5rJykpIHtcclxuICAgICAgICAgICAgICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXROYW1lKCdSZXN1bHQgYXMgTGluaycpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldERlc2MoJ0Zvcm1hdCBSZXN1bHQgYXMgTGluaycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmFkZERyb3Bkb3duKGRyb3Bkb3duID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXNNYW5hZ2VyLmdldFJ1bGVzQnlUeXBlKCdsaW5rRm9ybWF0dGVyJykuZm9yRWFjaChydWxlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyb3Bkb3duLmFkZE9wdGlvbihydWxlLmlkLCBydWxlLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHJvcGRvd24uc2V0VmFsdWUocnVsZS5saW5rRm9ybWF0dGVyIHx8ICd0b09yaWdpbmFsTGluaycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyb3Bkb3duLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5saW5rRm9ybWF0dGVyID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUHJldmlldyhydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocnVsZS50eXBlID09PSAndGV4dCcgfHwgcnVsZS50eXBlID09PSAnbXVsdGl0ZXh0JyB8fCBydWxlLnR5cGUgPT09ICd0YWdzJyB8fCBydWxlLnR5cGUgPT09ICdhbGlhc2VzJykge1xyXG4gICAgICAgICAgICBpZiAocnVsZUZuLnVzZVJ1bGVPcHRpb24oJ2FkZENvbnRlbnQnKSkge1xyXG4gICAgICAgICAgICAgICAgbmV3IFNldHRpbmcob3B0aW9uRUwpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldE5hbWUoJ0FkZCBjb250ZW50JylcclxuICAgICAgICAgICAgICAgICAgICAuc2V0RGVzYygnc2VsZWN0IGhvdyB0aGUgY29udGVudCBzaG91bGQgYmUgc3RvcmVkJylcclxuICAgICAgICAgICAgICAgICAgICAuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4gZHJvcGRvd25cclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZE9wdGlvbihcIm92ZXJ3cml0ZVwiLCBcInJlcGxhY2UgY29udGVudFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9uKFwic3RhcnRcIiwgXCJwbGFjZSBvbiBzdGFydFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9uKFwiZW5kXCIsIFwicGxhY2Ugb24gZW5kXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShydWxlLmFkZENvbnRlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLmFkZENvbnRlbnQgPSB2YWx1ZSA9PT0gJ292ZXJ3cml0ZScgPyAnb3ZlcndyaXRlJyA6IHZhbHVlID09PSAnc3RhcnQnID8gJ3N0YXJ0JyA6ICdlbmQnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUHJldmlldyhydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChydWxlRm4udXNlUnVsZU9wdGlvbignZXhjbHVkZUZvbGRlcnMnKSkge1xyXG4gICAgICAgICAgICBjb25zdCBleGNsdWRlRUwgPSBuZXcgU2V0dGluZyhvcHRpb25FTClcclxuICAgICAgICAgICAgICAgIC5zZXROYW1lKCdFeGNsdWRlIEZpbGVzIGFuZCBGb2xkZXJzIGZyb20gdGhpcyBydWxlJylcclxuICAgICAgICAgICAgICAgIC5zZXREZXNjKGBDdXJyZW50bHkgJHtydWxlLmV4Y2x1ZGU/LnNlbGVjdGVkRm9sZGVycy5sZW5ndGggfHwgMH0gZm9sZGVycyBhbmQgJHtydWxlLmV4Y2x1ZGU/LnNlbGVjdGVkRmlsZXMubGVuZ3RoIHx8IDB9IGZpbGVzIHdpbGwgYmUgJHtydWxlLmV4Y2x1ZGU/Lm1vZGUgfHwgJ2V4Y2x1ZGUnfWQuYClcclxuICAgICAgICAgICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBidXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldEljb24oJ2ZvbGRlci14JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoJ0V4Y2x1ZGUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0Q3RhKCkgLy8gTWFrZXMgdGhlIGJ1dHRvbiBtb3JlIHByb21pbmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuRGlyZWN0b3J5U2VsZWN0aW9uTW9kYWwoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5leGNsdWRlPy5zZWxlY3RlZEZvbGRlcnMgfHwgW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5leGNsdWRlPy5zZWxlY3RlZEZpbGVzIHx8IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbk1vZGU6ICdleGNsdWRlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU1vZGU6IHJ1bGUuZXhjbHVkZT8uZGlzcGxheSB8fCAnZm9sZGVycycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvblNlbGVjdGlvbk1vZGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25TaG93RmlsZXM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVzdWx0OiBEaXJlY3RvcnlTZWxlY3Rpb25SZXN1bHQgfCBudWxsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcnVsZS5leGNsdWRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLmV4Y2x1ZGU9T2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9GSUxURVJfRklMRVNfQU5EX0ZPTERFUlMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlIDogJ2V4Y2x1ZGUnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5leGNsdWRlLnNlbGVjdGVkRm9sZGVycyA9IHJlc3VsdC5mb2xkZXJzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLmV4Y2x1ZGUuc2VsZWN0ZWRGaWxlcyA9IHJlc3VsdC5maWxlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5leGNsdWRlLm1vZGUgPSAnZXhjbHVkZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuZXhjbHVkZS5kaXNwbGF5ID0gcmVzdWx0LmRpc3BsYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKERFQlVHLHJ1bGUuZXhjbHVkZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRmlsdGVySW5kaWNhdG9yKHRoaXMuYWN0aXZlRmlsZSwgdGhpcy5wcm9wZXJ0aWVzTGlzdEVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhjbHVkZUVMLnNldERlc2MoYEN1cnJlbnRseSAke3J1bGUuZXhjbHVkZT8uc2VsZWN0ZWRGb2xkZXJzLmxlbmd0aCB8fCAwfSBmb2xkZXJzIGFuZCAke3J1bGUuZXhjbHVkZT8uc2VsZWN0ZWRGaWxlcy5sZW5ndGggfHwgMH0gZmlsZXMgd2lsbCBiZSAke3J1bGUuZXhjbHVkZT8ubW9kZSB8fCAnZXhjbHVkZSd9ZC5gKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7ICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChydWxlRm4udXNlUnVsZU9wdGlvbignaW5jbHVkZUZvbGRlcnMnKSkge1xyXG4gICAgICAgICAgICBjb25zdCBpbmNsdWRlRUwgPSBuZXcgU2V0dGluZyhvcHRpb25FTClcclxuICAgICAgICAgICAgICAgIC5zZXROYW1lKCdJbmNsdWRlIEZpbGVzIGFuZCBGb2xkZXJzIGZvciB0aGlzIHJ1bGUgJylcclxuICAgICAgICAgICAgICAgIC5zZXREZXNjKGBDdXJyZW50bHkgJHtydWxlLmluY2x1ZGU/LnNlbGVjdGVkRm9sZGVycy5sZW5ndGggfHwgMH0gZm9sZGVycyBhbmQgJHtydWxlLmluY2x1ZGU/LnNlbGVjdGVkRmlsZXMubGVuZ3RoIHx8IDB9IGZpbGVzIHdpbGwgYmUgJHtydWxlLmluY2x1ZGU/Lm1vZGUgfHwgJ2luY2x1ZGUnfWQgZXZlbiBpZiB0aGV5IGFyZSBleGNsdWRlZCBnbG9iYWxseS5gKVxyXG4gICAgICAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4ge2J1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRJY29uKCdmb2xkZXItY2hlY2snKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdJbmNsdWRlJylcclxuICAgICAgICAgICAgICAgICAgICAuc2V0Q3RhKCkgLy8gTWFrZXMgdGhlIGJ1dHRvbiBtb3JlIHByb21pbmVudFxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbkRpcmVjdG9yeVNlbGVjdGlvbk1vZGFsKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLmluY2x1ZGU/LnNlbGVjdGVkRm9sZGVycyB8fCBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuaW5jbHVkZT8uc2VsZWN0ZWRGaWxlcyB8fCBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uTW9kZTogJ2luY2x1ZGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlNb2RlOiBydWxlLmluY2x1ZGU/LmRpc3BsYXkgfHwgJ2ZvbGRlcnMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvblNlbGVjdGlvbk1vZGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvblNob3dGaWxlczogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVzdWx0OiBEaXJlY3RvcnlTZWxlY3Rpb25SZXN1bHQgfCBudWxsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJ1bGUuaW5jbHVkZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLmluY2x1ZGUgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0ZJTFRFUl9GSUxFU19BTkRfRk9MREVSUywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA6ICdpbmNsdWRlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLmluY2x1ZGUuc2VsZWN0ZWRGb2xkZXJzID0gcmVzdWx0LmZvbGRlcnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5pbmNsdWRlLnNlbGVjdGVkRmlsZXMgPSByZXN1bHQuZmlsZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5pbmNsdWRlLm1vZGUgPSAnaW5jbHVkZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5pbmNsdWRlLmRpc3BsYXkgPSByZXN1bHQuZGlzcGxheTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKERFQlVHLHJ1bGUuaW5jbHVkZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVGaWx0ZXJJbmRpY2F0b3IodGhpcy5hY3RpdmVGaWxlLCB0aGlzLnByb3BlcnRpZXNMaXN0RWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGVFTC5zZXREZXNjKGBDdXJyZW50bHkgJHtydWxlLmluY2x1ZGU/LnNlbGVjdGVkRm9sZGVycy5sZW5ndGggfHwgMH0gZm9sZGVycyBhbmQgJHtydWxlLmluY2x1ZGU/LnNlbGVjdGVkRmlsZXMubGVuZ3RoIHx8IDB9IGZpbGVzIHdpbGwgYmUgJHtydWxlLmluY2x1ZGU/Lm1vZGUgfHwgJ2luY2x1ZGUnfWQuYClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7IFxyXG4gICAgICAgIH0gICAgICBcclxuICAgICAgICBpZiAocnVsZUZuLnVzZVJ1bGVPcHRpb24oJ3NjcmlwdCcpKSB7XHJcbiAgICAgICAgICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgICAgICAgICAgLnNldE5hbWUoJ1NjcmlwdCcpXHJcbiAgICAgICAgICAgICAgICAuc2V0RGVzYygnZWRpdCB0aGUgc2NyaXB0IGZvciBvd24gbW9kaWZpY2F0aW9ucycpXHJcbiAgICAgICAgICAgICAgICAuYWRkQnV0dG9uKGJ1dHRvbiA9PiB7IGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdKUyBFZGl0b3InKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIERFQlVHLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYE9wZW5pbmcgY29kZSBlZGl0b3IgZm9yIHJ1bGUgJHtydWxlLmlkfSB3aXRoIGNvbnRlbnQgJHtydWxlLmNvbnRlbnR9LCBmaWxlOiAke3RoaXMuYWN0aXZlRmlsZT8ucGF0aH1gLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVGaWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVGaWxlID8gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUodGhpcy5hY3RpdmVGaWxlKSB8fCB7fSA6IHt9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5Db2RlRWRpdG9yTW9kYWwoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5idWlsZEluQ29kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUudHlwZVByb3BlcnR5Py50eXBlIHx8ICd0ZXh0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlRmlsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlRmlsZSA/IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKHRoaXMuYWN0aXZlRmlsZSk/LmZyb250bWF0dGVyIHx8IHt9IDoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVzdWx0OiBjb2RlRWRpdG9yTW9kYWxSZXN1bHQgfCBudWxsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLmJ1aWxkSW5Db2RlID0gcmVzdWx0LmNvZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS51c2VDdXN0b21Db2RlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b24uc2V0Q3RhKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQcmV2aWV3KHJ1bGUsIHByZXZpZXdDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChydWxlLnVzZUN1c3RvbUNvZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLnNldEN0YSgpOyAvLyBNYWtlcyB0aGUgYnV0dG9uIG1vcmUgcHJvbWluZW50XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLnJlbW92ZUN0YSgpOyAvLyBNYWtlcyB0aGUgYnV0dG9uIGxlc3MgcHJvbWluZW50XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhZGQgY3VzdG9tIGNvbmZpZ1xyXG4gICAgICAgIGxldCBydWxlT3B0aW9uRGl2ID0gb3B0aW9uRUwuY3JlYXRlRGl2KHsgY2xzOiAncHJvcGVydHktcnVsZS1vcHRpb24nIH0pO1xyXG4gICAgICAgIHJ1bGVPcHRpb25EaXYuc3R5bGUubWFyZ2luTGVmdCA9ICcyMHB4JztcclxuICAgICAgICBydWxlc01hbmFnZXIuYnVpbGRDb25maWdUYWIocnVsZS5jb250ZW50LCBydWxlT3B0aW9uRGl2LCBydWxlLCB0aGlzLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnVwZGF0ZVByZXZpZXcocnVsZSwgcHJldmlld0NvbXBvbmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9uIGZvciBhIHNwZWNpZmljIHJ1bGUgYW5kIHByb3BlcnR5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBydWxlSWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHJ1bGUuXHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydHlJZCAtIFRoZSBzcGVjaWZpYyBwcm9wZXJ0eSBmb3Igd2hpY2ggdGhlIGNvbmZpZ3VyYXRpb24gaXMgYmVpbmcgcmV0cmlldmVkLlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvbmZpZ3VyYXRpb24gdmFsdWUgZm9yIHRoZSBzcGVjaWZpZWQgcHJvcGVydHksIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXHJcbiAgICAgKi9cclxuICAgIGdldE9wdGlvbkNvbmZpZyhydWxlSWQ6c3RyaW5nLHByb3BlcnR5SWQ6c3RyaW5nKXtcclxuICAgICAgICBjb25zdCBydWxlID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MucnVsZXMuZmluZCgocnVsZTogRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncykgPT4gcnVsZS5pZCA9PT0gcnVsZUlkKTtcclxuICAgICAgICBpZiAocnVsZSkge1xyXG4gICAgICAgICAgICBjb25zdCBvcHRpb25Db25maWcgPSBydWxlLm9wdGlvbnNDb25maWdbcnVsZUlkXVxyXG4gICAgICAgICAgICBpZiAob3B0aW9uQ29uZmlnW3Byb3BlcnR5SWRdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uQ29uZmlnW3Byb3BlcnR5SWRdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbiBmb3IgYSBzcGVjaWZpYyBydWxlIGFuZCBwcm9wZXJ0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcnVsZUlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBydWxlLlxyXG4gICAgICogQHBhcmFtIHByb3BlcnR5SWQgLSBUaGUgc3BlY2lmaWMgcHJvcGVydHkgZm9yIHdoaWNoIHRoZSBjb25maWd1cmF0aW9uIGlzIGJlaW5nIHNldC5cclxuICAgICAqIEBwYXJhbSBjb25maWcgLSBUaGUgY29uZmlndXJhdGlvbiB2YWx1ZSB0byBiZSBzZXQuXHJcbiAgICAgKi9cclxuICAgIHNldE9wdGlvbkNvbmZpZyhydWxlSWQ6c3RyaW5nLHByb3BlcnR5SWQ6c3RyaW5nLGNvbmZpZzphbnkpe1xyXG4gICAgICAgIGNvbnN0IHJ1bGUgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5ydWxlcy5maW5kKChydWxlOiBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzKSA9PiBydWxlLmlkID09PSBydWxlSWQpO1xyXG4gICAgICAgIGlmIChydWxlKSB7XHJcbiAgICAgICAgICAgIGlmICghcnVsZS5vcHRpb25zQ29uZmlnKSBydWxlLm9wdGlvbnNDb25maWcgPSB7fVxyXG4gICAgICAgICAgICBpZiAoIXJ1bGUub3B0aW9uc0NvbmZpZ1tydWxlSWRdKSBydWxlLm9wdGlvbnNDb25maWdbcnVsZUlkXSA9IHt9O1xyXG5cclxuICAgICAgICAgICAgcnVsZS5vcHRpb25zQ29uZmlnW3J1bGVJZF1bcHJvcGVydHlJZF0gPSBjb25maWc7XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBoYXNPcHRpb25Db25maWcocnVsZUlkOnN0cmluZyk6Ym9vbGVhbntcclxuICAgICAgICBjb25zdCBydWxlID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MucnVsZXMuZmluZCgocnVsZTogRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncykgPT4gcnVsZS5pZCA9PT0gcnVsZUlkKTtcclxuICAgICAgICBpZiAocnVsZSkge1xyXG4gICAgICAgICAgICBpZiAoIXJ1bGUub3B0aW9uc0NvbmZpZykgcnVsZS5vcHRpb25zQ29uZmlnID0ge31cclxuICAgICAgICAgICAgaWYgKCFydWxlLm9wdGlvbnNDb25maWdbcnVsZUlkXSkgcnVsZS5vcHRpb25zQ29uZmlnW3J1bGVJZF0gPSB7fTtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHJ1bGUub3B0aW9uc0NvbmZpZ1tydWxlSWRdKS5sZW5ndGggPiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0T3B0aW9uQ29uZmlnRGVmYXVsdHMocnVsZUlkOnN0cmluZywgZGVmYXVsdHM6YW55KXtcclxuICAgICAgICBjb25zdCBydWxlID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MucnVsZXMuZmluZCgocnVsZTogRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncykgPT4gcnVsZS5pZCA9PT0gcnVsZUlkKTtcclxuICAgICAgICBpZiAocnVsZSkge1xyXG4gICAgICAgICAgICBpZiAoIXJ1bGUub3B0aW9uc0NvbmZpZykgcnVsZS5vcHRpb25zQ29uZmlnID0ge31cclxuICAgICAgICAgICAgcnVsZS5vcHRpb25zQ29uZmlnW3J1bGVJZF0gPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgcnVsZS5vcHRpb25zQ29uZmlnW3J1bGVJZF0gfHwge30pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcnVsZS5vcHRpb25zQ29uZmlnW3J1bGVJZF07XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyU2VhcmNoUmVzdWx0cyhzZWFyY2hDb250YWluZXJFbDogSFRNTEVsZW1lbnQsIHNlYXJjaFRlcm06IHN0cmluZywgcGF5bG9hZDogYW55KSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5jbGVhclNlYXJjaFJlc3VsdHMoc2VhcmNoQ29udGFpbmVyRWwpO1xyXG5cclxuICAgICAgICBjb25zdCBmaWx0ZXJlZFByb3BlcnRpZXMgPSBPYmplY3QuZW50cmllcyh0aGlzLmtub3duUHJvcGVydGllcylcclxuICAgICAgICAgICAgLmZpbHRlcigoW25hbWVdKSA9PiBuYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoc2VhcmNoVGVybS50b0xvd2VyQ2FzZSgpKSk7XHJcblxyXG4gICAgICAgIGlmIChmaWx0ZXJlZFByb3BlcnRpZXMubGVuZ3RoID09PSAwICYmIHNlYXJjaFRlcm0pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmlsdGVyZWRQcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMCAmJiAhc2VhcmNoVGVybSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCByZXN1bHRzRWwgPSBzZWFyY2hDb250YWluZXJFbC5jcmVhdGVEaXYoeyBjbHM6ICdwcm9wZXJ0eS1zZWFyY2gtcmVzdWx0cyBtZW51JyB9KTtcclxuICAgICAgICByZXN1bHRzRWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgIHJlc3VsdHNFbC5zdHlsZS50b3AgPSAnMTAwJSc7XHJcbiAgICAgICAgcmVzdWx0c0VsLnN0eWxlLmxlZnQgPSAnMCc7XHJcbiAgICAgICAgcmVzdWx0c0VsLnN0eWxlLndpZHRoID0gJ2NhbGMoMTAwJSArIDEwMHB4KSc7XHJcbiAgICAgICAgcmVzdWx0c0VsLnN0eWxlLnpJbmRleCA9ICcxMCc7XHJcbiAgICAgICAgcmVzdWx0c0VsLnN0eWxlLm1heEhlaWdodCA9ICcyMDBweCc7XHJcbiAgICAgICAgcmVzdWx0c0VsLnN0eWxlLm92ZXJmbG93WSA9ICdhdXRvJztcclxuXHJcbiAgICAgICAgbGV0IGFjdGl2ZUluZGV4ID0gLTE7XHJcblxyXG4gICAgICAgIGNvbnN0IHVwZGF0ZUFjdGl2ZUl0ZW0gPSAobmV3SW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IHJlc3VsdHNFbC5xdWVyeVNlbGVjdG9yQWxsKCcubWVudS1pdGVtJyk7XHJcbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IG5ld0luZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5hZGRDbGFzcygncHJvcGVydHktc2VhcmNoLWlzLWFjdGl2ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc2Nyb2xsSW50b1ZpZXcoeyBibG9jazogJ25lYXJlc3QnIH0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLnJlbW92ZUNsYXNzKCdwcm9wZXJ0eS1zZWFyY2gtaXMtYWN0aXZlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBhY3RpdmVJbmRleCA9IG5ld0luZGV4O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IHNlbGVjdEFjdGl2ZUl0ZW0gPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChhY3RpdmVJbmRleCA+PSAwICYmIGFjdGl2ZUluZGV4IDwgZmlsdGVyZWRQcm9wZXJ0aWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgW25hbWUsIGluZm9dID0gZmlsdGVyZWRQcm9wZXJ0aWVzW2FjdGl2ZUluZGV4XTtcclxuICAgICAgICAgICAgICAgIHBheWxvYWQucHJvcGVydHkgPSBuYW1lO1xyXG4gICAgICAgICAgICAgICAgcGF5bG9hZC50eXBlID0gaW5mby50eXBlO1xyXG4gICAgICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IHVuZGVmaW5lZDsgLy8gUmVzZXQgdmFsdWVcclxuICAgICAgICAgICAgICAgIC8vdGhpcy5wbHVnaW4uc2V0dGluZ3NbdGhpcy5zZXR0aW5nc1BhcmFtZXRlcl1bcm93SW5kZXhdLnByb3BlcnR5ID0gbmFtZTtcclxuICAgICAgICAgICAgICAgIC8vdGhpcy5wbHVnaW4uc2V0dGluZ3NbdGhpcy5zZXR0aW5nc1BhcmFtZXRlcl1bcm93SW5kZXhdLnR5cGUgPSBpbmZvLnR5cGU7XHJcbiAgICAgICAgICAgICAgICAvL3RoaXMucGx1Z2luLnNldHRpbmdzW3RoaXMuc2V0dGluZ3NQYXJhbWV0ZXJdW3Jvd0luZGV4XS52YWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclNlYXJjaFJlc3VsdHMoc2VhcmNoQ29udGFpbmVyRWwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5KCk7IC8vIFJlLXJlbmRlclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZmlsdGVyZWRQcm9wZXJ0aWVzLmZvckVhY2goKFtuYW1lLCBpbmZvXSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaXRlbUVsID0gcmVzdWx0c0VsLmNyZWF0ZURpdih7IGNsczogJ21lbnUtaXRlbScgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1JY29uID0gaXRlbUVsLmNyZWF0ZVNwYW4oeyBjbHM6ICdtZW51LWl0ZW0taWNvbicgfSk7XHJcbiAgICAgICAgICAgIHVwZGF0ZVByb3BlcnR5SWNvbihpdGVtSWNvbiwgaW5mby50eXBlKTtcclxuICAgICAgICAgICAgaXRlbUVsLmNyZWF0ZVNwYW4oeyB0ZXh0OiBuYW1lIH0pO1xyXG5cclxuICAgICAgICAgICAgaXRlbUVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGFzeW5jIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBhY3RpdmVJbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgc2VsZWN0QWN0aXZlSXRlbSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc2VhcmNoQ29udGFpbmVyRWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGFzeW5jIChlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gcmVzdWx0c0VsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5tZW51LWl0ZW0nKTtcclxuICAgICAgICAgICAgaWYgKGUua2V5ID09PSAnQXJyb3dEb3duJykge1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlQWN0aXZlSXRlbSgoYWN0aXZlSW5kZXggKyAxKSAlIGl0ZW1zLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5rZXkgPT09ICdBcnJvd1VwJykge1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlQWN0aXZlSXRlbSgoYWN0aXZlSW5kZXggLSAxICsgaXRlbXMubGVuZ3RoKSAlIGl0ZW1zLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5rZXkgPT09ICdFbnRlcicpIHtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHNlbGVjdEFjdGl2ZUl0ZW0oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyU2VhcmNoUmVzdWx0cyhzZWFyY2hDb250YWluZXJFbDogSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICBjb25zdCByZXN1bHRzRWwgPSBzZWFyY2hDb250YWluZXJFbC5xdWVyeVNlbGVjdG9yKCcucHJvcGVydHktc2VhcmNoLXJlc3VsdHMnKTtcclxuICAgICAgICBpZiAocmVzdWx0c0VsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHNFbC5yZW1vdmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyVmFsdWVJbnB1dChjb250YWluZXJFbDogSFRNTEVsZW1lbnQsIHByb3BlcnR5SW5mbzogUHJvcGVydHlJbmZvIHwgdW5kZWZpbmVkLCBjdXJyZW50VmFsdWU6IGFueSwgcGF5bG9hZDogYW55KSB7XHJcbiAgICAgICAgbGV0IHJldHVybkNvbXBvbmVudDogYW55O1xyXG5cclxuICAgICAgICBpZiAoIXByb3BlcnR5SW5mbykge1xyXG4gICAgICAgICAgICAgY29udGFpbmVyRWwuc2V0VGV4dCgnJyk7XHJcbiAgICAgICAgICAgICBjb250YWluZXJFbC5hZGRDbGFzcygndGV4dC1tdXRlZCcpO1xyXG4gICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgdHlwZSA9IHByb3BlcnR5SW5mby50eXBlO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgICAgICAgICAgIHJldHVybkNvbXBvbmVudCA9IG5ldyBUZXh0Q29tcG9uZW50KGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignTnVtZXJpYyBWYWx1ZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKGN1cnJlbnRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIGN1cnJlbnRWYWx1ZSAhPT0gbnVsbCA/IFN0cmluZyhjdXJyZW50VmFsdWUpIDogJycpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBudW1WYWx1ZSA9IHZhbHVlID09PSAnJyA/IHVuZGVmaW5lZCA6IHBhcnNlRmxvYXQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gaXNOYU4obnVtVmFsdWUgYXMgbnVtYmVyKSA/IHVuZGVmaW5lZCA6IG51bVZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMucGx1Z2luLnNldHRpbmdzW3RoaXMuc2V0dGluZ3NQYXJhbWV0ZXJdW2luZGV4XS52YWx1ZSA9IGlzTmFOKG51bVZhbHVlIGFzIG51bWJlcikgPyB1bmRlZmluZWQgOiBudW1WYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5Db21wb25lbnQuaW5wdXRFbC50eXBlID0gJ251bWJlcic7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50ID0gY29udGFpbmVyRWwuY3JlYXRlRGl2KHsgY2xzOiAnRk1BLXRyaS1zdGF0ZS1jaGVja2JveCcgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5Db21wb25lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgJ0NoZWNrYm94IGNoYW5nZSBzdGF0ZScpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdjaGVja2JveCcpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZUNoZWNrYm94VmlzdWFsID0gKHN0YXRlOiBib29sZWFuIHwgdW5kZWZpbmVkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGljb25OYW1lOiBzdHJpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFyaWFTdGF0ZTogJ3RydWUnIHwgJ2ZhbHNlJyB8ICdtaXhlZCc7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb25OYW1lID0gJ2NoZWNrLXNxdWFyZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyaWFTdGF0ZSA9ICd0cnVlJztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uTmFtZSA9ICdzcXVhcmUnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmlhU3RhdGUgPSAnZmFsc2UnO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIHVuZGVmaW5lZCBvciBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb25OYW1lID0gJ21pbnVzLXNxdWFyZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyaWFTdGF0ZSA9ICdtaXhlZCc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHNldEljb24ocmV0dXJuQ29tcG9uZW50LCBpY29uTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1jaGVja2VkJywgYXJpYVN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5Db21wb25lbnQuZGF0YXNldC5zdGF0ZSA9IFN0cmluZyhzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIHVwZGF0ZUNoZWNrYm94VmlzdWFsKGN1cnJlbnRWYWx1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50U3RhdGUgPSByZXR1cm5Db21wb25lbnQuZGF0YXNldC5zdGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dFN0YXRlOiBib29sZWFuIHwgdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFN0YXRlID09PSAnZmFsc2UnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50U3RhdGUgPT09ICd0cnVlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUgPSB1bmRlZmluZWQ7IFxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUgPSBmYWxzZTsgXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQudmFsdWUgPSBuZXh0U3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy90aGlzLnBsdWdpbi5zZXR0aW5nc1t0aGlzLnNldHRpbmdzUGFyYW1ldGVyXVtpbmRleF0udmFsdWUgPSBuZXh0U3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNoZWNrYm94VmlzdWFsKG5leHRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcclxuICAgICAgICAgICAgICAgIHJldHVybkNvbXBvbmVudCA9IG5ldyBUZXh0Q29tcG9uZW50KGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignWVlZWS1NTS1ERCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKGN1cnJlbnRWYWx1ZSB8fCAnJylcclxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQudmFsdWUgPSB2YWx1ZSB8fCB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcy5wbHVnaW4uc2V0dGluZ3NbdGhpcy5zZXR0aW5nc1BhcmFtZXRlcl1baW5kZXhdLnZhbHVlID0gdmFsdWUgfHwgdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkNvbXBvbmVudC5pbnB1dEVsLnR5cGUgPSAnZGF0ZSc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50ID0gbmV3IFRleHRDb21wb25lbnQoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdZWVlZLU1NLUREVEhIOm1tJylcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUoY3VycmVudFZhbHVlIHx8ICcnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IHZhbHVlIHx8IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzLnBsdWdpbi5zZXR0aW5nc1t0aGlzLnNldHRpbmdzUGFyYW1ldGVyXVtpbmRleF0udmFsdWUgPSB2YWx1ZSB8fCB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50LmlucHV0RWwudHlwZSA9ICdkYXRldGltZS1sb2NhbCc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnYWxpYXNlcyc6XHJcbiAgICAgICAgICAgIGNhc2UgJ3RhZ3MnOlxyXG4gICAgICAgICAgICBjYXNlICdtdWx0aXRleHQnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50ID0gbmV3IFRleHRDb21wb25lbnQoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCd2YWx1ZXMgKGRpdmlkZWQgYnkgY29tbWEpJylcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUoQXJyYXkuaXNBcnJheShjdXJyZW50VmFsdWUpID8gY3VycmVudFZhbHVlLmpvaW4oJywgJykgOiAoY3VycmVudFZhbHVlIHx8ICcnKSlcclxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5VmFsdWUgPSB2YWx1ZS5zcGxpdCgnLCcpLm1hcChzID0+IHMudHJpbSgpKS5maWx0ZXIocyA9PiBzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IGFycmF5VmFsdWUubGVuZ3RoID4gMCA/IGFycmF5VmFsdWUgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcy5wbHVnaW4uc2V0dGluZ3NbdGhpcy5zZXR0aW5nc1BhcmFtZXRlcl1baW5kZXhdLnZhbHVlID0gYXJyYXlWYWx1ZS5sZW5ndGggPiAwID8gYXJyYXlWYWx1ZSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAndGV4dCc6XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm5Db21wb25lbnQgPSBuZXcgVGV4dENvbXBvbmVudChjb250YWluZXJFbClcclxuICAgICAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ3ZhbHVlJylcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUoY3VycmVudFZhbHVlIHx8ICcnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IHZhbHVlIHx8IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzLnBsdWdpbi5zZXR0aW5nc1t0aGlzLnNldHRpbmdzUGFyYW1ldGVyXVtpbmRleF0udmFsdWUgPSB2YWx1ZSB8fCB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGUgIT09ICdjaGVja2JveCcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybkNvbXBvbmVudC5pbnB1dEVsLmFkZENsYXNzKCdGTUEtcHJvcGVydHktdmFsdWUtaW5wdXQnKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybkNvbXBvbmVudC5hZGRDbGFzcygnRk1BLXByb3BlcnR5LXZhbHVlLWlucHV0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJldHVybkNvbXBvbmVudDtcclxuICAgXHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgdXBkYXRlUHJldmlldyhydWxlOiBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCBwcmV2aWV3Q29tcG9uZW50OiBhbnkpIHtcclxuICAgICAgICBpZiAodGhpcy5hY3RpdmVGaWxlKSB7XHJcbiAgICAgICAgICAgIGxldCBydWxlUmVzdWx0OmFueTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHAuZmlsZU1hbmFnZXIucHJvY2Vzc0Zyb250TWF0dGVyKHRoaXMuYWN0aXZlRmlsZSwgYXN5bmMgKGZyb250bWF0dGVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBydWxlUmVzdWx0ID0gYXdhaXQgZXhlY3V0ZVJ1bGUoJ3ByZXZpZXcnLHRoaXMuYXBwLCB0aGlzLnBsdWdpbi5zZXR0aW5ncywgdGhpcy5hY3RpdmVGaWxlLCAnJywgcnVsZSwgZnJvbnRtYXR0ZXIpO1xyXG4gICAgICAgICAgICAgICAgcnVsZVJlc3VsdCA9IGF3YWl0IGV4ZWN1dGVSdWxlT2JqZWN0KCdwcmV2aWV3Jyx0aGlzLmFwcCwgdGhpcywgdGhpcy5wbHVnaW4uc2V0dGluZ3MsIHRoaXMuYWN0aXZlRmlsZSwgJycsIHJ1bGUsIGZyb250bWF0dGVyKTtcclxuICAgICAgICAgICAgfSx7J210aW1lJzp0aGlzLmFjdGl2ZUZpbGUuc3RhdC5tdGltZX0pOyAgXHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBydWxlUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJ1bGVSZXN1bHQpKSBwcmV2aWV3Q29tcG9uZW50LmlucHV0RWwudmFsdWUgPSBydWxlUmVzdWx0LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aWV3Q29tcG9uZW50Py5pbnB1dEVsKSBwcmV2aWV3Q29tcG9uZW50LmlucHV0RWwudmFsdWUgPSBydWxlUmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjb21wb25lbnRFbC5zZXRUb29sdGlwKGNvbXBvbmVudEVsLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGFzeW5jIGRpc3BsYXkoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyRWwgPSB0aGlzLmNvbnRhaW5lcjtcclxuICAgICAgICBjb250YWluZXJFbC5lbXB0eSgpO1xyXG5cclxuICAgICAgICB0aGlzLmtub3duUHJvcGVydGllcyA9IGF3YWl0IHRoaXMudG9vbHMuZmV0Y2hLbm93blByb3BlcnRpZXModGhpcy5hcHApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMucHJvcGVydGllc0xpc3RFbCA9IGNvbnRhaW5lckVsOyAvLy5jcmVhdGVEaXYoJ3Byb3BlcnRpZXMtbGlzdCcpO1xyXG5cclxuICAgICAgICAvL3RoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlckNvbmZpZy5yb3dzID0gW107XHJcbiAgICAgICAgY29uc3QgZm9sZGVyTGlzdCA9IG5ldyBUcmVlSGllcmFyY2h5U29ydGFibGVTZXR0aW5ncyhcclxuICAgICAgICAgICAgY29udGFpbmVyRWwsXHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlckNvbmZpZyxcclxuICAgICAgICAgICAgKHJvdywgcm93RWwpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFJlbmRlciByb3cgY29udGVudCBoZXJlXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclByb3BlcnR5Um93KHJvd0VsLCByb3cucGF5bG9hZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAuc2V0VGl0bGUoJ1J1bGVzJylcclxuICAgICAgICAgICAgLnNldERlc2NyaXB0aW9uKCdhZGQgcnVsZXMgdG8gc2VsZWN0ZWQgZnJvbnRtYXR0ZXIgcHJvcGVydGllcycpXHJcbiAgICAgICAgICAgIC5vbkNoYW5nZSgoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9sZGVyQ29uZmlnID0gZGF0YTtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRmlsdGVySW5kaWNhdG9yKHRoaXMuYWN0aXZlRmlsZSwgdGhpcy5wcm9wZXJ0aWVzTGlzdEVsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub25SZW5kZXJlZCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUZpbHRlckluZGljYXRvcih0aGlzLmFjdGl2ZUZpbGUsIHRoaXMucHJvcGVydGllc0xpc3RFbCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vblJvd0NyZWF0ZWQoYXN5bmMgKHJvdykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdE5hbWUgPSAnJzsgLy9PYmplY3Qua2V5cyh0aGlzLmtub3duUHJvcGVydGllcylbMF0gfHwgJyc7XHJcbiAgICAgICAgICAgICAgICByb3cucGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfUlVMRV9ERUZJTklUSU9OLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHJhbmRvbVVVSUQoKS50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uRGVsZXRlQnQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkUHJvY2VlZCA9IGF3YWl0IG5ldyBBbGVydE1vZGFsKFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLFxyXG4gICAgICAgICAgICAgICAgICAgICdFcmFzZSBhbGwgUnVsZXM/JyxcclxuICAgICAgICAgICAgICAgICAgICAnRG8geW91IHJlYWxseSBsaWtlIHRvIGVyYXNlIEFMTCBydWxlcz8nLFxyXG4gICAgICAgICAgICAgICAgICAgICdZZXMnLCAnTm8nXHJcbiAgICAgICAgICAgICAgICApLm9wZW5BbmRHZXRWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkUHJvY2VlZC5wcm9jZWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uZm9sZGVyQ29uZmlnLnJvd3MgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmFkZEV4dHJhQnV0dG9uVG9IZWFkZXIoKGVsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBlbC5hZGRFeHRyYUJ1dHRvbihidG4gPT4gYnRuXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldEljb24oXCJjaXJjbGUtaGVscFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1hcmtkb3duID0gXCJDb3VsZCBub3QgbG9hZCBoZWxwIGZyb20gR2l0SHViLlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2Rvd24gPSBhd2FpdCBmZXRjaE1hcmtkb3duRnJvbUdpdEh1YihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9DaHJpc3RpYW4tTWUvb2JzaWRpYW4tZnJvbnQtbWF0dGVyLWF1dG9tYXRlL21haW4vZG9jL1JFQURNRS5tZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgTWFya2Rvd25IZWxwTW9kYWwodGhpcy5hcHAsIG1hcmtkb3duLCBcIm1vZHVsZXMubWRcIikub3BlbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBpZiAodGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9sZGVyQ29uZmlnLnJvd3MubGVuZ3RoID09PSAwICYmIHRoaXMucGx1Z2luLnNldHRpbmdzLnJ1bGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIHJ1bGVzIGJ1dCBubyBmb2xkZXIgY29uZmlnLCBjcmVhdGUgZGVmYXVsdCByb3dzXHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnJ1bGVzLmZvckVhY2goKHJ1bGU6IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleXdvcmRzIDogc3RyaW5nW10gPSBbXTtcclxuICAgICAgICAgICAgICAgIGtleXdvcmRzLnB1c2gocnVsZS5jb250ZW50KTtcclxuICAgICAgICAgICAgICAgIGZvbGRlckxpc3QuYWRkUm93KFJPT1RfRk9MREVSLCBbXSwgcnVsZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKlxyXG4gICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnJ1bGVzLmZvckVhY2goKHJ1bGU6IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIGluZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJQcm9wZXJ0eVJvdyh0aGlzLnByb3BlcnRpZXNMaXN0RWwsIHJ1bGUsIGluZGV4KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAqL1xyXG4gICAgICAgIGxldCBhY3RpdmVGaWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUZpbHRlckluZGljYXRvcihhY3RpdmVGaWxlLCB0aGlzLnByb3BlcnRpZXNMaXN0RWwpO1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgY29uc3QgYWRkQnRuQ29udGFpbmVyID0gY29udGFpbmVyRWwuY3JlYXRlRGl2KHsgY2xzOiAnc2V0dGluZy1pdGVtLWNvbnRyb2wnIH0pO1xyXG4gICAgICAgIGFkZEJ0bkNvbnRhaW5lci5zdHlsZS5qdXN0aWZ5Q29udGVudCA9ICdyaWdodCc7XHJcbiAgICAgICAgbmV3IEJ1dHRvbkNvbXBvbmVudChhZGRCdG5Db250YWluZXIpXHJcbiAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdBZGQgUHJvcGVydHknKVxyXG4gICAgICAgICAgICAuc2V0SWNvbigncGx1cy1jaXJjbGUnKVxyXG4gICAgICAgICAgICAuc2V0Q3RhKClcclxuICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdE5hbWUgPSAnJzsgLy9PYmplY3Qua2V5cyh0aGlzLmtub3duUHJvcGVydGllcylbMF0gfHwgJyc7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzLnBsdWdpbi5zZXR0aW5nc1t0aGlzLnNldHRpbmdzUGFyYW1ldGVyXS5wdXNoKHsgbmFtZTogZGVmYXVsdE5hbWUsIHZhbHVlOiB1bmRlZmluZWQgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5nc1t0aGlzLnNldHRpbmdzUGFyYW1ldGVyXS5wdXNoKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfUlVMRV9ERUZJTklUSU9OLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHJhbmRvbVVVSUQoKS50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmJ1dHRvbkVsLmNsYXNzTmFtZT0ncHJvcGVydHktcGx1cy1idXR0b24nO1xyXG4gICAgICAgICovXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB1cGRhdGVGaWx0ZXJJbmRpY2F0b3IoYWN0aXZlRmlsZTpURmlsZSB8IG51bGwsIHByb3BlcnRpZXNMaXN0RWw6IEhUTUxEaXZFbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKGFjdGl2ZUZpbGUpIHsgLy9UT0RPOiBmaXggZm9yIG5ldyBzb3J0YWJsZSBUYWJsZVxyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJDb25maWcucm93cy5mb3JFYWNoKChyb3c6IFRyZWVIaWVyYXJjaHlSb3csIGluZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSByb3cucGF5bG9hZCBhcyBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHlSb3dFbGVtZW50cyA9IHByb3BlcnRpZXNMaXN0RWwuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgncHJvcGVydHktc2V0dGluZy1yb3cnKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5Um93RWwgPSBBcnJheS5mcm9tKHByb3BlcnR5Um93RWxlbWVudHMpLmZpbHRlcihlbCA9PiBlbC5pZCA9PT0gcnVsZS5pZClbMF0gYXMgSFRNTERpdkVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXByb3BlcnR5Um93RWwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIFNraXAgaWYgbm8gcm93IGZvdW5kIGZvciB0aGlzIHJ1bGVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5TGVmdERpdiA9IHByb3BlcnR5Um93RWwucXVlcnlTZWxlY3RvcignLnByb3BlcnR5LWxlZnQtY29udGFpbmVyJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tJZkZpbGVBbGxvd2VkKGFjdGl2ZUZpbGUsIHRoaXMucGx1Z2luLnNldHRpbmdzLCBydWxlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5TGVmdERpdj8uYWRkQ2xhc3MoJ3Byb3BlcnR5LWxlZnQtY29udGFpbmVyLWFsbG93ZWQnKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlMZWZ0RGl2Py5yZW1vdmVDbGFzcygncHJvcGVydHktbGVmdC1jb250YWluZXItYWxsb3dlZCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwgImltcG9ydCB7IEFwcCwgcmVuZGVyUmVzdWx0cywgU2VhcmNoQ29tcG9uZW50LCBTZXR0aW5nLCBURmlsZSwgVEZvbGRlciB9IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IHsgZ2V0Rm9sZGVyRnJvbVBhdGgsIHBhcnNlSlNDb2RlLCBTY3JpcHRpbmdUb29scyB9IGZyb20gJy4vdG9vbHMnO1xyXG5pbXBvcnQgeyBPYnNpZGlhblByb3BlcnR5VHlwZXMsIEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIEZyb250bWF0dGVyQXV0b21hdGVTZXR0aW5ncywgRnJvbnRtYXR0ZXJBdXRvbWF0ZUV2ZW50cyB9IGZyb20gJy4vdHlwZXMnO1xyXG5pbXBvcnQgeyBBdXRvY29tcGxldGVNb2RhbCwgYXV0b2NvbXBsZXRlTW9kYWxSZXN1bHQsIG9wZW5BdXRvY29tcGxldGVNb2RhbCB9IGZyb20gJy4vYXV0b2NvbXBsZXRlTW9kYWwnO1xyXG5pbXBvcnQgeyBjb2RlRWRpdG9yTW9kYWxSZXN1bHQgfSBmcm9tICcuL2VkaXRvck1vZGFsJztcclxuaW1wb3J0IHsgRm9sZGVyU3VnZ2VzdCB9IGZyb20gXCIuL3N1Z2dlc3RlcnMvRm9sZGVyU3VnZ2VzdGVyXCI7XHJcbmltcG9ydCB7IEZpbGVTdWdnZXN0IH0gZnJvbSBcIi4vc3VnZ2VzdGVycy9GaWxlU3VnZ2VzdGVyXCI7XHJcbmltcG9ydCB7IERpcmVjdG9yeVNlbGVjdGlvblJlc3VsdCwgb3BlbkRpcmVjdG9yeVNlbGVjdGlvbk1vZGFsIH0gZnJvbSAnLi9kaXJlY3RvcnlTZWxlY3Rpb25Nb2RhbCc7XHJcbmltcG9ydCB7IEFsZXJ0TW9kYWwgfSBmcm9tICcuL2FsZXJ0Qm94JztcclxuaW1wb3J0IHsgcnVsZXNNYW5hZ2VyIH0gZnJvbSAnLi9ydWxlcy9ydWxlcyc7XHJcbmltcG9ydCB7IERFQlVHLCBFUlJPUiwgbG9nZ2VyLCBUUkFDRSB9IGZyb20gJy4vTG9nJztcclxuXHJcbmV4cG9ydCB0eXBlIEZyb250bWF0dGVyQXV0b21hdGVSdWxlVHlwZXMgPSAnYnVpbGRJbicgfCAnYnVpbGRJbi5pbnB1dFByb3BlcnR5JyB8ICdhdXRvY29tcGxldGUubW9kYWwnIHwgJ2F1dG9tYXRpb24nIHwgJ3NjcmlwdCc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENvbmZpZ0VsZW1lbnRzIHtcclxuICAgIFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfCB1bmRlZmluZWQ7XHJcbiAgICByZW1vdmVDb250ZW50OiBib29sZWFuO1xyXG4gICAgcnVsZUFjdGl2ZTogYm9vbGVhbjtcclxuICAgIG1vZGlmeU9ubHk6IGJvb2xlYW47XHJcbiAgICBpbnB1dFByb3BlcnR5OiBib29sZWFuO1xyXG4gICAgYWRkUHJlZml4OiBib29sZWFuO1xyXG4gICAgc3BhY2VSZXBsYWNlbWVudDogYm9vbGVhbjtcclxuICAgIHNwZWNpYWxDaGFyYWN0ZXJSZXBsYWNlbWVudDogYm9vbGVhbjtcclxuICAgIGNvbnZlcnRUb0xvd2VyQ2FzZTogYm9vbGVhbjtcclxuICAgIHJlc3VsdEFzTGluazogYm9vbGVhbjtcclxuICAgIGFkZENvbnRlbnQ6IGJvb2xlYW47XHJcbiAgICBleGNsdWRlRm9sZGVyczogYm9vbGVhbjtcclxuICAgIGluY2x1ZGVGb2xkZXJzOiBib29sZWFuO1xyXG4gICAgc2NyaXB0OiBib29sZWFuO1xyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgUnVsZUZ1bmN0aW9uIHtcclxuICAgIGlkOnN0cmluZztcclxuICAgIHJ1bGVUeXBlOiBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVR5cGVzO1xyXG4gICAgZGVzY3JpcHRpb246c3RyaW5nO1xyXG4gICAgdG9vbHRpcD86IHN0cmluZztcclxuICAgIGlucHV0UHJvcGVydHk/OiBib29sZWFuO1xyXG4gICAgaXNMaXZlUnVsZT86IGJvb2xlYW47XHJcbiAgICBzb3VyY2U6c3RyaW5nO1xyXG4gICAgdHlwZTpPYnNpZGlhblByb3BlcnR5VHlwZXNbXTtcclxuICAgIGZ4OkZ1bmN0aW9uO1xyXG4gICAgY29uZmlnRWxlbWVudHM6IENvbmZpZ0VsZW1lbnRzO1xyXG4gICAgY29uZmlnVGFiPzogKG9wdGlvbkVsOiBIVE1MRWxlbWVudCwgcnVsZTpGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCB0aGF0OmFueSwgcHJldmlld0NvbXBvbmVudDphbnkpID0+IHZvaWQ7IC8vIGZ1bmN0aW9uIHRvIHJlbmRlciB0aGUgY29uZmlnIHRhYiBmb3IgdGhlIHJ1bGVcclxufVxyXG4vKlxyXG5leHBvcnQgY29uc3QgcnVsZUZ1bmN0aW9uczpSdWxlRnVuY3Rpb25bXT1bXTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRSdWxlRnVuY3Rpb25CeUlkIChpZCA6IHN0cmluZyk6UnVsZUZ1bmN0aW9uIHwgdW5kZWZpbmVkIHtcclxuICAgIGNvbnN0IHJ1bGVGdW5jdGlvbiA9IHJ1bGVGdW5jdGlvbnMuZmluZChydWxlID0+IHJ1bGUuaWQgPT09IGlkKTtcclxuICAgIGlmICghcnVsZUZ1bmN0aW9uKSB7XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhFUlJPUixgUnVsZSBmdW5jdGlvbiAke2lkfSBub3QgZm91bmQhYCk7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHJldHVybiBydWxlRnVuY3Rpb247XHJcbn1cclxuKi9cclxuZnVuY3Rpb24gYXBwbHlGb3JtYXRPcHRpb25zKHRoaXM6IGFueSwgdmFsdWU6YW55LCBydWxlOkZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MpOmFueSB7XHJcbiAgaWYgKHJ1bGUudHlwZSA9PT0gJ2RhdGUnIHx8IHJ1bGUudHlwZSA9PT0gJ2RhdGV0aW1lJykgcmV0dXJuIHZhbHVlOyAvLyBsZWF2ZSBkYXRlIGFuZCBkYXRlVGltZSB1bnRvdWNoZWRcclxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xyXG4gICAgY2FzZSAnYm9vbGVhbic6XHJcbiAgICBjYXNlICdudW1iZXInOlxyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICBjYXNlICdzdHJpbmcnOlxyXG4gICAgICBpZiAocnVsZS5zcGFjZVJlcGxhY2VtZW50ICYmIHJ1bGUuc3BhY2VSZXBsYWNlbWVudCAhPT0gJycpIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxzKy9nLCBydWxlLnNwYWNlUmVwbGFjZW1lbnQpO1xyXG4gICAgICBpZiAocnVsZS5zcGVjaWFsQ2hhclJlcGxhY2VtZW50ICYmIHJ1bGUuc3BlY2lhbENoYXJSZXBsYWNlbWVudCAhPT0nJykgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXmEtekEtWjAtOVxcLV9cXC9cdTAwRTRcdTAwRjZcdTAwRkNcdTAwREZcdTAwQzRcdTAwRDZcdTAwRENcdTAwRTFcdTAwRTlcdTAwRURcdTAwRjNcdTAwRkFcdTAwRkRcdTAwQzFcdTAwQzlcdTAwQ0RcdTAwRDNcdTAwREFcdTAwRERcdTAwRTBcdTAwRThcdTAwRUNcdTAwRjJcdTAwRjlcdTAwQzBcdTAwQzhcdTAwQ0NcdTAwRDJcdTAwRDlcdTAwRTJcdTAwRUFcdTAwRUVcdTAwRjRcdTAwRkJcdTAwQzJcdTAwQ0FcdTAwQ0VcdTAwRDRcdTAwREJcdTAwRTNcdTAwRjFcdTAwRjVcdTAwQzNcdTAwRDFcdTAwRDVdL2csIHJ1bGUuc3BlY2lhbENoYXJSZXBsYWNlbWVudCk7XHJcbiAgICAgIGlmIChydWxlLmZvcm1hdHRlciAmJiBydWxlLmZvcm1hdHRlciAhPT0gJycpIHtcclxuICAgICAgICB2YWx1ZSA9IHJ1bGVzTWFuYWdlci5leGVjdXRlUnVsZUJ5SWQocnVsZS5mb3JtYXR0ZXIsIHRoaXMuYXBwLCB0aGlzLmFjdGl2ZUZpbGUsIHRoaXMudG9vbHMsIHZhbHVlKTsgLy8gZXhlY3V0ZSB0aGUgZm9ybWF0dGVyIHJ1bGVcclxuICAgICAgfVxyXG4gICAgICBpZiAocnVsZS5saW5rRm9ybWF0dGVyICYmIHJ1bGUubGlua0Zvcm1hdHRlciAhPT0gJycpIHtcclxuICAgICAgICB2YWx1ZSA9IHJ1bGVzTWFuYWdlci5leGVjdXRlUnVsZUJ5SWQocnVsZS5saW5rRm9ybWF0dGVyLCB0aGlzLmFwcCwgdGhpcy5hY3RpdmVGaWxlLCB0aGlzLnRvb2xzLCB2YWx1ZSk7IC8vIGV4ZWN1dGUgdGhlIGxpbmsgZm9ybWF0dGVyIHJ1bGVcclxuICAgICAgfVxyXG4gICAgICBpZiAocnVsZS5wcmVmaXggJiYgcnVsZS5wcmVmaXggIT09ICcnKSB2YWx1ZSA9IHJ1bGUucHJlZml4ICsgdmFsdWU7XHJcbiAgICAgIHJldHVybiB2YWx1ZVxyXG4gICAgY2FzZSAnb2JqZWN0JzpcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCh2YWx1ZSA9PiBhcHBseUZvcm1hdE9wdGlvbnModmFsdWUsIHJ1bGUpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgfVxyXG4gIHJldHVyblxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRSdWxlUmVzdWx0KHJ1bGVGeDogRnVuY3Rpb24sIGFwcDogQXBwLCBydWxlOiBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCBydWxlRnVuY3Rpb246IFJ1bGVGdW5jdGlvbiwgY3VycmVudEZpbGU6IFRGaWxlLCB0b29sczpTY3JpcHRpbmdUb29scywgZnJvbnRNYXR0ZXI6YW55KTpQcm9taXNlPGFueT4ge1xyXG4gIGxldCByZXN1bHQ6YW55ID0gdW5kZWZpbmVkO1xyXG4gIC8vbG9nZ2VyLmxvZyhERUJVRywnZ2V0UnVsZVJlc3VsdCcsIHJ1bGVGeCwgcnVsZUZ1bmN0aW9uLCBjdXJyZW50RmlsZSwgdG9vbHMsIGZyb250TWF0dGVyKTtcclxuICBzd2l0Y2ggKHJ1bGVGdW5jdGlvbi5ydWxlVHlwZSkge1xyXG4gICAgY2FzZSAnc2NyaXB0JzpcclxuICAgIGNhc2UgJ2J1aWxkSW4nOlxyXG4gICAgICByZXN1bHQgPSBhcHBseUZvcm1hdE9wdGlvbnMocnVsZUZ4KGFwcCwgY3VycmVudEZpbGUsIHRvb2xzKSwgcnVsZSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnYnVpbGRJbi5pbnB1dFByb3BlcnR5JzpcclxuICAgICAgcmVzdWx0ID0gYXBwbHlGb3JtYXRPcHRpb25zKHJ1bGVGeChhcHAsIGN1cnJlbnRGaWxlLCB0b29scywgZnJvbnRNYXR0ZXJbcnVsZS5pbnB1dFByb3BlcnR5XSksIHJ1bGUpO1xyXG4gICAgICBicmVha1xyXG4gICAgY2FzZSAnYXV0b2NvbXBsZXRlLm1vZGFsJzpcclxuICAgICAgcnVsZUZ4KGFwcCwgY3VycmVudEZpbGUsIHRvb2xzKTtcclxuICAgICAgLy9sb2dnZXIubG9nKERFQlVHLCdhdXRvY29tcGxldGUgbW9kYWwnLCBydWxlRngsIHJ1bGVGdW5jdGlvbiwgY3VycmVudEZpbGUsIHRvb2xzKTtcclxuICAgICAgcmVzdWx0ID0gbnVsbDtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICdhdXRvbWF0aW9uJzpcclxuICAgICAgLy9sb2dnZXIubG9nKERFQlVHLCdhdXRvbWF0aW9uJywgcnVsZUZ1bmN0aW9uLCBjdXJyZW50RmlsZSwgdG9vbHMpO1xyXG4gICAgICByZXN1bHQgPSBhcHBseUZvcm1hdE9wdGlvbnMocnVsZUZ4KGFwcCwgY3VycmVudEZpbGUsIHRvb2xzKSwgcnVsZSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZXhlY3V0ZVJ1bGVPYmplY3QgKFxyXG4gIGV2ZW50OiBGcm9udG1hdHRlckF1dG9tYXRlRXZlbnRzLFxyXG4gIGFwcDogQXBwLFxyXG4gIHBsdWdpbjogYW55LFxyXG4gIHNldHRpbmdzOiBGcm9udG1hdHRlckF1dG9tYXRlU2V0dGluZ3MsIFxyXG4gIGN1cnJlbnRGaWxlOiBURmlsZSB8IHVuZGVmaW5lZCB8IG51bGwsIFxyXG4gIGN1cnJlbnRDb250ZW50OiBhbnksIFxyXG4gIHJ1bGU6RnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgXHJcbiAgZnJvbnRNYXR0ZXI6IGFueSwgXHJcbiAgb2xkTG9jYXRpb25SZXN1bHRzPzp7cnVsZUlkOiBzdHJpbmcsIHJlc3VsdDogYW55fVtdKTphbnkge1xyXG5cclxuICBpZiAoIXJ1bGUpIHJldHVybiBjdXJyZW50Q29udGVudDtcclxuICBpZiAoIXJ1bGUuYWN0aXZlKSByZXR1cm4gY3VycmVudENvbnRlbnQ7XHJcbiAgaWYgKCFjdXJyZW50RmlsZSkgcmV0dXJuIGN1cnJlbnRDb250ZW50O1xyXG4gIGlmICghY2hlY2tJZkZpbGVBbGxvd2VkKGN1cnJlbnRGaWxlLCBzZXR0aW5ncywgcnVsZSkpIHJldHVybiBjdXJyZW50Q29udGVudDtcclxuICBjb25zdCB0b29scyA9IG5ldyBTY3JpcHRpbmdUb29scyhhcHAsIHBsdWdpbiwgc2V0dGluZ3MsIHJ1bGUsIGZyb250TWF0dGVyKTtcclxuICBsZXQgcmVzdWx0ID0gY3VycmVudENvbnRlbnQ7XHJcbiAgbGV0IG9sZFJlc3VsdDphbnkgPSB1bmRlZmluZWQ7XHJcbiAgdG9vbHMuc2V0Q3VycmVudENvbnRlbnQoZnJvbnRNYXR0ZXJbcnVsZS5wcm9wZXJ0eV0pXHJcbiAgdG9vbHMuc2V0UnVsZShydWxlKTtcclxuICB0b29scy5zZXRGcm9udG1hdHRlcihmcm9udE1hdHRlcik7XHJcbiAgdG9vbHMuc2V0QWN0aXZlRmlsZShjdXJyZW50RmlsZSk7XHJcbiAgY29uc3QgcnVsZU9iamVjdCA9IHJ1bGVzTWFuYWdlci5nZXRSdWxlQnlJZChydWxlLmNvbnRlbnQpO1xyXG4gIGlmICghcnVsZU9iamVjdCkgcmV0dXJuIGN1cnJlbnRDb250ZW50O1xyXG5cclxuICByZXN1bHQgPSBydWxlc01hbmFnZXIuZXhlY3V0ZVJ1bGUocnVsZSwgcnVsZU9iamVjdCwgYXBwLCBjdXJyZW50RmlsZSwgdG9vbHMsIGZyb250TWF0dGVyKTsgLy8gZXhlY3V0ZSB0aGUgZm9ybWF0dGVyIHJ1bGVcclxuICByZXN1bHQgPSBydWxlc01hbmFnZXIuYXBwbHlGb3JtYXRPcHRpb25zKHJlc3VsdCwgcnVsZSwgY3VycmVudEZpbGUsIHRvb2xzKTsgLy8gYXBwbHkgZm9ybWF0IG9wdGlvbnNcclxuICBpZiAob2xkTG9jYXRpb25SZXN1bHRzICYmIG9sZExvY2F0aW9uUmVzdWx0cy5sZW5ndGggPiAwICYmIHJ1bGUuYWRkQ29udGVudCAhPT0gJ292ZXJ3cml0ZScpIHtcclxuICAgIG9sZFJlc3VsdCA9IG9sZExvY2F0aW9uUmVzdWx0cy5maW5kKHJlcyA9PiByZXMucnVsZUlkID09PSBydWxlLmlkKT8ucmVzdWx0O1xyXG4gICAgaWYgKCFvbGRSZXN1bHQpIHtcclxuICAgICAgbG9nZ2VyLmxvZyhFUlJPUixgZXhlY3V0ZVJ1bGVPYmplY3Q6IE9sZCByZXN1bHQgZm9yIHJ1bGUgJHtydWxlLnByb3BlcnR5fXwke3J1bGUuY29udGVudH0gbm90IGZvdW5kIWAsIG9sZExvY2F0aW9uUmVzdWx0cyk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7IC8vIHJldHVybiB0aGUgY3VycmVudCByZXN1bHQgaWYgbm8gb2xkIHJlc3VsdCBpcyBmb3VuZFxyXG4gICAgfVxyXG4gICAgb2xkUmVzdWx0ID0gcnVsZXNNYW5hZ2VyLmFwcGx5Rm9ybWF0T3B0aW9ucyhvbGRSZXN1bHQsIHJ1bGUsIGN1cnJlbnRGaWxlLCB0b29scyk7IC8vIGFwcGx5IGZvcm1hdCBvcHRpb25zIG9uIHRoZSBvbGQgZmlsZSBsb2NhdGlvblxyXG4gICAgbG9nZ2VyLmxvZyhERUJVRyxgZXhlY3V0ZVJ1bGVPYmplY3Q6IE1lcmdpbmcgcmVzdWx0IGZvciBydWxlICR7cnVsZS5wcm9wZXJ0eX18JHtydWxlLmNvbnRlbnR9IHdpdGggb2xkIHJlc3VsdGAsIG9sZFJlc3VsdCwgcmVzdWx0KTtcclxuICAgIHJlc3VsdCA9IHJ1bGVzTWFuYWdlci5tZXJnZVJlc3VsdChyZXN1bHQsIG9sZFJlc3VsdCwgY3VycmVudENvbnRlbnQsIHJ1bGUpOyAvLyBtZXJnZSB0aGUgcmVzdWx0IHdpdGggdGhlIGN1cnJlbnQgY29udGVudC4gUmVtb3ZlIG9sZCByZXN1bHQgaWYgbmVjZXNzYXJ5XHJcbiAgfSBlbHNlIHtcclxuICAgIHJlc3VsdCA9IHJ1bGVzTWFuYWdlci5tZXJnZVJlc3VsdChyZXN1bHQsIHJlc3VsdCwgY3VycmVudENvbnRlbnQsIHJ1bGUpOyAvLyBtZXJnZSB0aGUgcmVzdWx0IHdpdGggdGhlIGN1cnJlbnQgY29udGVudC4gUmVtb3ZlIG9sZCByZXN1bHQgaWYgbmVjZXNzYXJ5XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLypcclxuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGVSdWxlT2xkIChldmVudDogRnJvbnRtYXR0ZXJBdXRvbWF0ZUV2ZW50cywgYXBwLCBzZXR0aW5ncywgY3VycmVudEZpbGU6IFRGaWxlIHwgbnVsbCwgcmV0dXJuUmVzdWx0OiBhbnksIHJ1bGU6RnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgZnJvbnRNYXR0ZXIsIG9sZFBhdGg/OnN0cmluZykge1xyXG4gIC8vbG9nZ2VyLmxvZyhERUJVRyxgRXZlbnQ6ICR7ZXZlbnR9IGZvciBydWxlICR7cnVsZS5wcm9wZXJ0eX18JHtydWxlLmNvbnRlbnR9YCwgcnVsZSk7XHJcbiAgaWYgKCFydWxlLmFjdGl2ZSB8fCAhY3VycmVudEZpbGUpIHJldHVybiByZXR1cm5SZXN1bHQ7XHJcbiAgY29uc3QgdG9vbHMgPSBuZXcgU2NyaXB0aW5nVG9vbHMoYXBwLCB0aGlzLCBzZXR0aW5ncywgcnVsZSwgZnJvbnRNYXR0ZXIsIGN1cnJlbnRGaWxlKTtcclxuICBsZXQgZnhSZXN1bHQgPSByZXR1cm5SZXN1bHQ7XHJcbiAgbGV0IG9sZFJlc3VsdDphbnk7XHJcbiAgbGV0IG9sZEZpbGU6VEZpbGUgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcbiAgaWYgKG9sZFBhdGgpIHtcclxuICAgIGxldCBvbGRGaWxlUGFydHMgPSBvbGRQYXRoLnNwbGl0KCcvJyk7XHJcbiAgICBvbGRGaWxlID0ge1xyXG4gICAgICBwYXRoOiBvbGRQYXRoLFxyXG4gICAgICBleHRlbnNpb246IG9sZEZpbGVQYXJ0c1tvbGRGaWxlUGFydHMubGVuZ3RoLTFdLnNwbGl0KCcuJylbMV0sXHJcbiAgICAgIG5hbWU6IG9sZEZpbGVQYXJ0c1tvbGRGaWxlUGFydHMubGVuZ3RoLTFdLnNwbGl0KCcuJylbMF0sXHJcbiAgICAgIHN0YXQ6IGN1cnJlbnRGaWxlLnN0YXQsXHJcbiAgICAgIGJhc2VuYW1lOiBjdXJyZW50RmlsZS5iYXNlbmFtZSxcclxuICAgICAgdmF1bHQ6IGN1cnJlbnRGaWxlLnZhdWx0LFxyXG4gICAgICBwYXJlbnQ6IGN1cnJlbnRGaWxlLnBhcmVudFxyXG4gICAgfVxyXG4gIH1cclxuICB0cnkge1xyXG4gICAgY29uc3QgZnVuY3Rpb25JbmRleCA9IHJ1bGVGdW5jdGlvbnMuZmluZEluZGV4KGZ4ID0+IGZ4LmlkID09PSBydWxlLmNvbnRlbnQpO1xyXG4gICAgaWYgKGZ1bmN0aW9uSW5kZXg9PT0tMSl7XHJcbiAgICAgIGxvZ2dlci5sb2coRVJST1IsYFJ1bGUgZnVuY3Rpb24gJHtydWxlLmNvbnRlbnR9IG5vdCBmb3VuZCFgKTtcclxuICAgICAgcmV0dXJuIHJldHVyblJlc3VsdDsgLy8gcmV0dXJuIHRoZSBvcmlnaW5hbCB2YWx1ZSBpZiB0aGUgZnVuY3Rpb24gaXMgbm90IGZvdW5kXHJcbiAgICB9XHJcbiAgICBjb25zdCBydWxlRnVuY3Rpb25Db25maWcgPSBydWxlRnVuY3Rpb25zW2Z1bmN0aW9uSW5kZXhdO1xyXG4gICAgdG9vbHMuc2V0Q3VycmVudENvbnRlbnQoZnJvbnRNYXR0ZXJbcnVsZS5wcm9wZXJ0eV0pXHJcbiAgICB0b29scy5zZXRSdWxlKHJ1bGUpO1xyXG4gICAgdG9vbHMuc2V0RnJvbnRtYXR0ZXIoZnJvbnRNYXR0ZXIpO1xyXG4gICAgc3dpdGNoIChydWxlRnVuY3Rpb25Db25maWcucnVsZVR5cGUpIHtcclxuICAgICAgY2FzZSAnc2NyaXB0JzogXHJcbiAgICAgICAgY29uc3QgY3VzdG9tUnVsZUZ1bmN0aW9uID0gcGFyc2VKU0NvZGUocnVsZS5qc0NvZGUpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY3VzdG9tUnVsZUZ1bmN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICBsb2dnZXIubG9nKEVSUk9SLGBDb3VsZCBub3QgcGFyc2UgY3VzdG9tIGZ1bmN0aW9uIGZvciAke3J1bGUuY29udGVudH0hYCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ4UmVzdWx0ID0gYXBwbHlGb3JtYXRPcHRpb25zKGN1c3RvbVJ1bGVGdW5jdGlvbihhcHAsIGN1cnJlbnRGaWxlLCB0b29scyksIHJ1bGUpO1xyXG4gICAgICAgIGlmIChvbGRGaWxlKSB7XHJcbiAgICAgICAgICBvbGRSZXN1bHQgPSBhcHBseUZvcm1hdE9wdGlvbnMoY3VzdG9tUnVsZUZ1bmN0aW9uKGFwcCwgb2xkRmlsZSwgdG9vbHMpLCBydWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2J1aWxkSW4uaW5wdXRQcm9wZXJ0eSc6XHJcbiAgICAgIGNhc2UgJ2J1aWxkSW4nOiAgXHJcbiAgICAgICAgY29uc3QgcnVsZUZ1bmN0aW9uID0gcnVsZS51c2VDdXN0b21Db2RlID8gcGFyc2VKU0NvZGUocnVsZS5idWlsZEluQ29kZSkgOiBydWxlRnVuY3Rpb25Db25maWcuZng7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBydWxlRnVuY3Rpb24gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIGxvZ2dlci5sb2coRVJST1IsYENvdWxkIG5vdCBwYXJzZSBjdXN0b20gZnVuY3Rpb24gZm9yICR7cnVsZS5jb250ZW50fSFgKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmeFJlc3VsdCA9IGdldFJ1bGVSZXN1bHQocnVsZUZ1bmN0aW9uLCBhcHAsIHJ1bGUsIHJ1bGVGdW5jdGlvbkNvbmZpZywgY3VycmVudEZpbGUsIHRvb2xzLCBmcm9udE1hdHRlcik7XHJcbiAgICAgICAgaWYgKG9sZEZpbGUpIHtcclxuICAgICAgICAgICAgb2xkUmVzdWx0ID0gZ2V0UnVsZVJlc3VsdChydWxlRnVuY3Rpb24sIGFwcCwgcnVsZSwgcnVsZUZ1bmN0aW9uQ29uZmlnLCBvbGRGaWxlLCB0b29scywgZnJvbnRNYXR0ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsb2dnZXIubG9nKERFQlVHLGAgIGV4ZWN1dGVSdWxlOiAke3J1bGUuY29udGVudH0gJHtydWxlLnByb3BlcnR5fSBbJHtydWxlLnR5cGV9XT0gJyR7ZnhSZXN1bHR9J2ApXHJcblxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdhdXRvY29tcGxldGUubW9kYWwnOlxyXG4gICAgICAgIGZ4UmVzdWx0ID0gZ2V0UnVsZVJlc3VsdChydWxlRnVuY3Rpb25Db25maWcuZngsIGFwcCwgcnVsZSwgcnVsZUZ1bmN0aW9uQ29uZmlnLCBjdXJyZW50RmlsZSwgdG9vbHMsIGZyb250TWF0dGVyKTtcclxuICAgICAgICBicmVhazsgLy8gaGFuZGxlZCBpbiB0aGUgYXV0b2NvbXBsZXRlIG1vZGFsXHJcbiAgICAgIGNhc2UgJ2F1dG9tYXRpb24nOlxyXG4gICAgICAgIC8vIGZ4UmVzdWx0ID0gZ2V0UnVsZVJlc3VsdChydWxlRnVuY3Rpb25Db25maWcuZngsIGFwcCwgcnVsZSwgcnVsZUZ1bmN0aW9uQ29uZmlnLCBjdXJyZW50RmlsZSwgdG9vbHMsIGZyb250TWF0dGVyKTtcclxuICAgICAgICBmeFJlc3VsdCA9IHJ1bGVzTWFuYWdlci5leGVjdXRlUnVsZUJ5SWQocnVsZS5jb250ZW50LCBhcHAsIGN1cnJlbnRGaWxlLCB0b29scywgZnJvbnRNYXR0ZXIpOyAvLyBleGVjdXRlIHRoZSBmb3JtYXR0ZXIgcnVsZVxyXG5cclxuICAgICAgICBicmVhazsgLy8gaGFuZGxlZCBpbiB0aGUgYXV0b21hdGlvbiBtb2RhbFxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGxvZ2dlci5sb2coRVJST1IsYEVycm9yIGV4ZWN1dGluZyBydWxlICR7cnVsZS5wcm9wZXJ0eX18JHtydWxlLmNvbnRlbnR9IGZvciBmaWxlICR7Y3VycmVudEZpbGUucGF0aH06ICR7ZXJyb3J9YCk7XHJcbiAgICByZXR1cm4gcmV0dXJuUmVzdWx0OyAvLyByZXR1cm4gdGhlIG9yaWdpbmFsIHZhbHVlIGlmIHRoZXJlIGlzIGFuIGVycm9yXHJcbiAgfVxyXG5cclxuICBpZiAocnVsZS50eXBlID09PSAnbnVtYmVyJyB8fCBydWxlLnR5cGUgPT09ICdjaGVja2JveCcgfHwgcnVsZS50eXBlID09PSAnZGF0ZScgfHwgcnVsZS50eXBlID09PSAnZGF0ZXRpbWUnKSB7XHJcbiAgICAgIHJldHVybiBmeFJlc3VsdDtcclxuICB9XHJcbiAgc3dpdGNoIChydWxlLmFkZENvbnRlbnQpIHtcclxuICAgICAgY2FzZSAnb3ZlcndyaXRlJzpcclxuICAgICAgICAgIHJldHVyblJlc3VsdCA9IGZ4UmVzdWx0OyAvLyB1cGRhdGUgb3IgYWRkIHRoZSBuZXcgdmFsdWVcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdlbmQnOlxyXG4gICAgICAgICAgaWYgKHJ1bGUudHlwZSA9PT0gJ211bHRpdGV4dCcgfHwgcnVsZS50eXBlID09PSAndGFncycgfHwgcnVsZS50eXBlID09PSAnYWxpYXNlcycpIHtcclxuICAgICAgICAgICAgICBpZiAoIWZ4UmVzdWx0KSBmeFJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZnhSZXN1bHQgPT09ICdzdHJpbmcnKSBmeFJlc3VsdCA9IFtmeFJlc3VsdF07IC8vIGNvbnZlcnQgc3RyaW5nIHRvIGFycmF5IFxyXG4gICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXR1cm5SZXN1bHQpKSByZXR1cm5SZXN1bHQgPSBbcmV0dXJuUmVzdWx0XTtcclxuICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2xkUmVzdWx0KSkgb2xkUmVzdWx0ID0gW29sZFJlc3VsdF07XHJcbiAgICAgICAgICAgICAgbGV0IGZpbHRlcmVkID0gcmV0dXJuUmVzdWx0LmZpbHRlcigodmFsdWUpID0+ICFvbGRSZXN1bHQuaW5jbHVkZXModmFsdWUpKVxyXG4gICAgICAgICAgICAgIHJldHVyblJlc3VsdCA9IHRvb2xzLnJlbW92ZUR1cGxpY2F0ZVN0cmluZ3MoZmlsdGVyZWQuY29uY2F0KGZ4UmVzdWx0KSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGlmICghcmV0dXJuUmVzdWx0KSByZXR1cm5SZXN1bHQgPSAnJztcclxuICAgICAgICAgICAgICByZXR1cm5SZXN1bHQgPSByZXR1cm5SZXN1bHQucmVwbGFjZUFsbChyZXR1cm5SZXN1bHQsb2xkUmVzdWx0KTtcclxuICAgICAgICAgICAgICByZXR1cm5SZXN1bHQgPSByZXR1cm5SZXN1bHQgKyBmeFJlc3VsdDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdzdGFydCc6XHJcbiAgICAgICAgICBpZiAocnVsZS50eXBlID09PSAnbXVsdGl0ZXh0JyB8fCBydWxlLnR5cGUgPT09ICd0YWdzJyB8fCBydWxlLnR5cGUgPT09ICdhbGlhc2VzJykge1xyXG4gICAgICAgICAgICAgIGlmICghZnhSZXN1bHQpIGZ4UmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmeFJlc3VsdCA9PT0gJ3N0cmluZycpIGZ4UmVzdWx0ID0gW2Z4UmVzdWx0XTsgLy8gY29udmVydCBzdHJpbmcgdG8gYXJyYXkgXHJcbiAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJldHVyblJlc3VsdCkpIHJldHVyblJlc3VsdCA9IFtyZXR1cm5SZXN1bHRdO1xyXG4gICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvbGRSZXN1bHQpKSBvbGRSZXN1bHQgPSBbb2xkUmVzdWx0XTtcclxuICAgICAgICAgICAgICBsZXQgZmlsdGVyZWQgPSByZXR1cm5SZXN1bHQuZmlsdGVyKCh2YWx1ZSkgPT4gIW9sZFJlc3VsdC5pbmNsdWRlcyh2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgcmV0dXJuUmVzdWx0ID0gdG9vbHMucmVtb3ZlRHVwbGljYXRlU3RyaW5ncyhmeFJlc3VsdC5jb25jYXQoZmlsdGVyZWQpKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaWYgKCFyZXR1cm5SZXN1bHQpIHJldHVyblJlc3VsdCA9ICcnO1xyXG4gICAgICAgICAgICAgIHJldHVyblJlc3VsdCA9IHJldHVyblJlc3VsdC5yZXBsYWNlQWxsKHJldHVyblJlc3VsdCxvbGRSZXN1bHQpO1xyXG4gICAgICAgICAgICAgIHJldHVyblJlc3VsdCA9IGZ4UmVzdWx0ICsgcmV0dXJuUmVzdWx0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgfVxyXG4gIHJldHVybiByZXR1cm5SZXN1bHQ7XHJcblxyXG59XHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVSdWxlT2JqZWN0IChhcHA6IEFwcCwgc2V0dGluZ3M6IGFueSwgY3VycmVudEZpbGU6IFRGaWxlLCByZXR1cm5SZXN1bHQ6IGFueSwgcnVsZTpGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCBmcm9udE1hdHRlcjogYW55KSB7XHJcbn1cclxuLypcclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVJ1bGUgKGFwcCwgc2V0dGluZ3MsIGN1cnJlbnRGaWxlOiBURmlsZSwgcmV0dXJuUmVzdWx0OiBhbnksIHJ1bGU6RnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgZnJvbnRNYXR0ZXIpIHtcclxuICBjb25zdCB0b29scyA9IG5ldyBTY3JpcHRpbmdUb29scyhhcHAsIHNldHRpbmdzLCBmcm9udE1hdHRlcik7XHJcbiAgbGV0IGZ4UmVzdWx0OmFueTtcclxuICBpZiAocnVsZS5jb250ZW50ID09PSAnc2NyaXB0Jykge1xyXG4gICAgICBjb25zdCBydWxlRnVuY3Rpb24gPSBwYXJzZUpTQ29kZShydWxlLmpzQ29kZSk7XHJcbiAgICAgIGlmICh0eXBlb2YgcnVsZUZ1bmN0aW9uICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XHJcbiAgICAgIGZ4UmVzdWx0ID0gcnVsZUZ1bmN0aW9uKGFwcCwgY3VycmVudEZpbGUsIHRvb2xzKTtcclxuICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBmdW5jdGlvbkluZGV4ID0gcnVsZUZ1bmN0aW9ucy5maW5kSW5kZXgoZnggPT4gZnguaWQgPT09IHJ1bGUuY29udGVudCk7XHJcbiAgICAgIGlmIChmdW5jdGlvbkluZGV4IT09LTEpe1xyXG4gICAgICAgICAgY29uc3QgcnVsZUZ1bmN0aW9uID0gcnVsZS51c2VDdXN0b21Db2RlID8gcGFyc2VKU0NvZGUocnVsZS5idWlsZEluQ29kZSkgOiBydWxlRnVuY3Rpb25zW2Z1bmN0aW9uSW5kZXhdLmZ4O1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBydWxlRnVuY3Rpb24gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmxvZyhFUlJPUixgQ291bGQgbm90IHBhcnNlIGN1c3RvbSBmdW5jdGlvbiBmb3IgJHtydWxlLmNvbnRlbnR9IWApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAocnVsZUZ1bmN0aW9uc1tmdW5jdGlvbkluZGV4XS5pbnB1dFByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgIGZ4UmVzdWx0ID0gYXBwbHlGb3JtYXRPcHRpb25zKHJ1bGVGdW5jdGlvbihhcHAsIGN1cnJlbnRGaWxlLCB0b29scywgZnJvbnRNYXR0ZXJbcnVsZS5pbnB1dFByb3BlcnR5XSksIHJ1bGUpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZnhSZXN1bHQgPSBhcHBseUZvcm1hdE9wdGlvbnMocnVsZUZ1bmN0aW9uKGFwcCwgY3VycmVudEZpbGUsIHRvb2xzKSwgcnVsZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICB9XHJcbiAgc3dpdGNoIChydWxlLmFkZENvbnRlbnQpIHtcclxuICAgICAgY2FzZSAnb3ZlcndyaXRlJzpcclxuICAgICAgICAgIHJldHVyblJlc3VsdCA9IGZ4UmVzdWx0OyAvLyB1cGRhdGUgb3IgYWRkIHRoZSBuZXcgdmFsdWVcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdlbmQnOlxyXG4gICAgICAgICAgaWYgKHJ1bGUudHlwZSA9PT0gJ211bHRpdGV4dCcgfHwgcnVsZS50eXBlID09PSAndGFncycgfHwgcnVsZS50eXBlID09PSAnYWxpYXNlcycpIHtcclxuICAgICAgICAgICAgICBpZiAoIWZ4UmVzdWx0KSBmeFJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZnhSZXN1bHQgPT09ICdzdHJpbmcnKSBmeFJlc3VsdCA9IFtmeFJlc3VsdF07IC8vIGNvbnZlcnQgc3RyaW5nIHRvIGFycmF5IFxyXG4gICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXR1cm5SZXN1bHQpKSByZXR1cm5SZXN1bHQgPSBbcmV0dXJuUmVzdWx0XTtcclxuICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZnhSZXN1bHQpKSBmeFJlc3VsdCA9IFtmeFJlc3VsdF07XHJcbiAgICAgICAgICAgICAgbGV0IGZpbHRlcmVkID0gcmV0dXJuUmVzdWx0LmZpbHRlcigodmFsdWUpID0+ICFmeFJlc3VsdC5pbmNsdWRlcyh2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgcmV0dXJuUmVzdWx0ID0gdG9vbHMucmVtb3ZlRHVwbGljYXRlU3RyaW5ncyhmaWx0ZXJlZCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGlmICghcmV0dXJuUmVzdWx0KSByZXR1cm5SZXN1bHQgPSAnJztcclxuICAgICAgICAgICAgICByZXR1cm5SZXN1bHQgPSByZXR1cm5SZXN1bHQucmVwbGFjZUFsbChyZXR1cm5SZXN1bHQsZnhSZXN1bHQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3N0YXJ0JzpcclxuICAgICAgICAgIGlmIChydWxlLnR5cGUgPT09ICdtdWx0aXRleHQnIHx8IHJ1bGUudHlwZSA9PT0gJ3RhZ3MnIHx8IHJ1bGUudHlwZSA9PT0gJ2FsaWFzZXMnKSB7XHJcbiAgICAgICAgICAgICAgaWYgKCFmeFJlc3VsdCkgZnhSZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGZ4UmVzdWx0ID09PSAnc3RyaW5nJykgZnhSZXN1bHQgPSBbZnhSZXN1bHRdOyAvLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSBcclxuICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmV0dXJuUmVzdWx0KSkgcmV0dXJuUmVzdWx0ID0gW3JldHVyblJlc3VsdF07XHJcbiAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZ4UmVzdWx0KSkgZnhSZXN1bHQgPSBbZnhSZXN1bHRdO1xyXG4gICAgICAgICAgICAgIGxldCBmaWx0ZXJlZCA9IHJldHVyblJlc3VsdC5maWx0ZXIoKHZhbHVlKSA9PiAhZnhSZXN1bHQuaW5jbHVkZXModmFsdWUpKVxyXG4gICAgICAgICAgICAgIHJldHVyblJlc3VsdCA9IHRvb2xzLnJlbW92ZUR1cGxpY2F0ZVN0cmluZ3MoZmlsdGVyZWQpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpZiAoIXJldHVyblJlc3VsdCkgcmV0dXJuUmVzdWx0ID0gJyc7XHJcbiAgICAgICAgICAgICAgcmV0dXJuUmVzdWx0ID0gcmV0dXJuUmVzdWx0LnJlcGxhY2VBbGwocmV0dXJuUmVzdWx0LGZ4UmVzdWx0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gIH1cclxuICByZXR1cm4gcmV0dXJuUmVzdWx0O1xyXG5cclxufVxyXG4qL1xyXG4vKipcclxuICogRmlsdGVycyBhIGdpdmVuIGZpbGUgYW5kIHJldHVybnMgdHJ1ZSBpZiBpdCBpcyBpbmNsdWRlZCBpbiBhIGZvbGRlciBvciBmaWxlIGxpc3RcclxuICogQHBhcmFtIGZpbGUgXHJcbiAqIEBwYXJhbSBmaWx0ZXJNb2RlICdleGNsdWRlJ3wnaW5jbHVkZSdcclxuICogQHBhcmFtIHR5cGUgJ2ZvbGRlcnMnfCdmaWxlcydcclxuICogQHJldHVybnMgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyRmlsZShmaWxlOiBURmlsZSwgZmlsZUxpc3Q6IGFueSwgZmlsdGVyTW9kZTogc3RyaW5nLCB0eXBlOnN0cmluZyk6Ym9vbGVhbiB7XHJcbiAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XHJcbiAgICBjb25zdCBmaWx0ZXJBcnJheSA9ICh0eXBlPT09J2ZvbGRlcnMnKSA/IGZpbGVMaXN0W2ZpbHRlck1vZGVdLnNlbGVjdGVkRm9sZGVycyA6IGZpbGVMaXN0W2ZpbHRlck1vZGVdLnNlbGVjdGVkRmlsZXM7XHJcbiAgICBpZiAoZmlsdGVyQXJyYXkubGVuZ3RoID09PSAwKSByZXR1cm4gKGZpbHRlck1vZGUgPT09ICdpbmNsdWRlJyk/IGZhbHNlIDogdHJ1ZTtcclxuICAgIGNvbnN0IGZpbGVQYXRoID0gZmlsZS5wYXRoO1xyXG4gICAgY29uc3QgZmlsZUZvbGRlciA9IGdldEZvbGRlckZyb21QYXRoKGZpbGUucGF0aCk7IC8vIHRoaXMudG9vbHMuYWRkTGVhZGluZ1NsYXNoKGdldEZvbGRlckZyb21QYXRoKGZpbGUucGF0aCkpO1xyXG4gICAgY29uc3QgZmlsZU5hbWUgPSBmaWxlLmJhc2VuYW1lICsgJy4nICsgZmlsZS5leHRlbnNpb247XHJcbiAgICBcclxuICAgIGlmICh0eXBlID09PSAnZmlsZXMnKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gZmlsdGVyQXJyYXkuaW5jbHVkZXMoZmlsZVBhdGgpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGUgPT09ICdmb2xkZXJzJykge1xyXG4gICAgICAgIGZvciAobGV0IHBhdGggb2YgZmlsdGVyQXJyYXkpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gZmlsZUZvbGRlcj8uc3RhcnRzV2l0aChwYXRoLnNsaWNlKDEpKSB8fCBmYWxzZTsgLy8gcmVtb3ZlIHJvb3QgJy8nXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHRydWUpIHJldHVybiAoZmlsdGVyTW9kZSA9PT0gJ2V4Y2x1ZGUnKT8gIXJlc3VsdCA6IHJlc3VsdDtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIHJldHVybiAoZmlsdGVyTW9kZSA9PT0gJ2V4Y2x1ZGUnKT8gIXJlc3VsdCA6IHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrSWZGaWxlQWxsb3dlZChmaWxlOiBURmlsZSwgc2V0dGluZ3M/OkZyb250bWF0dGVyQXV0b21hdGVTZXR0aW5ncywgcnVsZT86RnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyk6Ym9vbGVhbiB7XHJcbiAgICAgIGxldCByZXN1bHQgPSB0cnVlO1xyXG4gICAgICBpZiAoIWZpbGUpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKHNldHRpbmdzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIC8vbG9nZ2VyLmxvZyhERUJVRyxgY2hlY2sgZmlsZSAke2ZpbGUucGF0aH0gYWdhaW5zdCBzZXR0aW5nc2AsIHNldHRpbmdzLmluY2x1ZGUsIHNldHRpbmdzLmV4Y2x1ZGUpO1xyXG4gICAgICAgICAgaWYgKHNldHRpbmdzLmV4Y2x1ZGUuc2VsZWN0ZWRGaWxlcy5sZW5ndGg+MCkgeyAvLyB0aGVyZSBhcmUgZmlsZXMgaW4gdGhlIGV4Y2x1ZGUgZmlsZXMgbGlzdC5cclxuICAgICAgICAgICAgICByZXN1bHQgPSBmaWx0ZXJGaWxlKGZpbGUsIHNldHRpbmdzLCAnZXhjbHVkZScsICdmaWxlcycpOyAgICBcclxuICAgICAgICAgIH0gICAgICAgIFxyXG4gICAgICAgICAgaWYgKHJlc3VsdCAmJiBzZXR0aW5ncy5leGNsdWRlLnNlbGVjdGVkRm9sZGVycy5sZW5ndGg+MCkgeyAvLyB0aGVyZSBhcmUgZm9sZGVycyBpbiB0aGUgZXhjbHVkZSBmb2xkZXJzIGxpc3QuXHJcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZmlsdGVyRmlsZShmaWxlLCBzZXR0aW5ncywgJ2V4Y2x1ZGUnLCAnZm9sZGVycycpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCFyZXN1bHQgJiYgc2V0dGluZ3MuaW5jbHVkZS5zZWxlY3RlZEZpbGVzLmxlbmd0aD4wKSB7IC8vIHRoZXJlIGFyZSBmaWxlcyBpbiB0aGUgaW5jbHVkZSBmaWxlcyBsaXN0XHJcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZmlsdGVyRmlsZShmaWxlLCBzZXR0aW5ncywgJ2luY2x1ZGUnLCAnZmlsZXMnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICghcmVzdWx0ICYmIHNldHRpbmdzLmluY2x1ZGUuc2VsZWN0ZWRGb2xkZXJzLmxlbmd0aD4wKSB7IC8vIHRoZXJlIGFyZSBmb2xkZXJzIGluIHRoZSBpbmNsdWRlIGZvbGRlcnMgbGlzdFxyXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZpbHRlckZpbGUoZmlsZSwgc2V0dGluZ3MsICdpbmNsdWRlJywgJ2ZvbGRlcnMnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIGlmIChyZXN1bHQgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7IC8vIGlmIHRoZSBmaWxlIGlzIGV4Y2x1ZGVkLCByZXR1cm4gZmFsc2VcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZyhFUlJPUixgRXJyb3IgZmlsdGVyaW5nIGZpbGUgJHtmaWxlLnBhdGh9IGdsb2JhbGx5OiAke2Vycm9yfWApO1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBkZWZhdWx0IHRvIGZhbHNlIGlmIHRoZXJlIGlzIGFuIGVycm9yXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmKHJ1bGUpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgLy9sb2dnZXIubG9nKERFQlVHLGBjaGVjayBmaWxlICR7ZmlsZS5wYXRofSBhZ2FpbnN0IHJ1bGVgLCBydWxlLmluY2x1ZGUsIHJ1bGUuZXhjbHVkZSk7XHJcbiAgICAgICAgICBpZiAocmVzdWx0ICYmIHJ1bGUuZXhjbHVkZS5zZWxlY3RlZEZpbGVzLmxlbmd0aD4wKSB7IC8vIHRoZXJlIGFyZSBmaWxlcyBpbiB0aGUgZXhjbHVkZSBmaWxlcyBsaXN0LlxyXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZpbHRlckZpbGUoZmlsZSwgcnVsZSwgJ2V4Y2x1ZGUnLCAnZmlsZXMnKTtcclxuICAgICAgICAgIH0gICAgICAgIFxyXG4gICAgICAgICAgaWYgKHJlc3VsdCAmJiBydWxlLmV4Y2x1ZGUuc2VsZWN0ZWRGb2xkZXJzLmxlbmd0aD4wKSB7IC8vIHRoZXJlIGFyZSBmb2xkZXJzIGluIHRoZSBpbmNsdWRlIGZvbGRlcnMgbGlzdC5cclxuICAgICAgICAgICAgICByZXN1bHQgPSBmaWx0ZXJGaWxlKGZpbGUsIHJ1bGUsICdleGNsdWRlJywgJ2ZvbGRlcnMnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICghcmVzdWx0ICYmIHJ1bGUuaW5jbHVkZS5zZWxlY3RlZEZpbGVzLmxlbmd0aD4wKSB7IC8vIGZpbGUgaXMgZXhjbHVkZWQgYnV0IHRoZXJlIGFyZSBmaWxlcyBpbiB0aGUgaW5jbHVkZSBmaWxlcyBsaXN0XHJcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZmlsdGVyRmlsZShmaWxlLCBydWxlLCAnaW5jbHVkZScsICdmaWxlcycpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCFyZXN1bHQgJiYgcnVsZS5pbmNsdWRlLnNlbGVjdGVkRm9sZGVycy5sZW5ndGg+MCkgeyAvLyBmaWxlIGlzIGV4Y2x1ZGVkIGJ1dCB0aGVyZSBhcmUgZm9sZGVycyBpbiB0aGUgaW5jbHVkZSBmb2xkZXJzIGxpc3RcclxuICAgICAgICAgICAgICByZXN1bHQgPSBmaWx0ZXJGaWxlKGZpbGUsIHJ1bGUsICdpbmNsdWRlJywgJ2ZvbGRlcnMnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZyhFUlJPUixgRXJyb3IgZmlsdGVyaW5nIGZpbGUgJHtmaWxlLnBhdGh9IGJ5IHJ1bGUgJHtydWxlLnByb3BlcnR5fXwke3J1bGUuY29udGVudH06ICR7ZXJyb3J9YCk7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGRlZmF1bHQgdG8gZmFsc2UgaWYgdGhlcmUgaXMgYW4gZXJyb3JcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVmYXVsdENvbmZpZ0VsZW1lbnRzKG1vZGlmaWVyczpDb25maWdFbGVtZW50cyB8IGFueSk6Q29uZmlnRWxlbWVudHMge1xyXG4gIGNvbnN0IGNvbmZpZ0VsZW1lbnRzOiBDb25maWdFbGVtZW50cyA9IHtcclxuICAgIHJlbW92ZUNvbnRlbnQ6IHRydWUsXHJcbiAgICBydWxlQWN0aXZlOiB0cnVlLFxyXG4gICAgbW9kaWZ5T25seTogdHJ1ZSxcclxuICAgIGlucHV0UHJvcGVydHk6IGZhbHNlLFxyXG4gICAgYWRkUHJlZml4OiB0cnVlLFxyXG4gICAgc3BhY2VSZXBsYWNlbWVudDogdHJ1ZSxcclxuICAgIHNwZWNpYWxDaGFyYWN0ZXJSZXBsYWNlbWVudDogdHJ1ZSxcclxuICAgIGNvbnZlcnRUb0xvd2VyQ2FzZTogdHJ1ZSxcclxuICAgIHJlc3VsdEFzTGluazogdHJ1ZSxcclxuICAgIGFkZENvbnRlbnQ6IHRydWUsXHJcbiAgICBleGNsdWRlRm9sZGVyczogdHJ1ZSxcclxuICAgIGluY2x1ZGVGb2xkZXJzOiB0cnVlLCBcclxuICAgIHNjcmlwdDogdHJ1ZSxcclxuICB9XHJcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZ0VsZW1lbnRzLCBtb2RpZmllcnMpO1xyXG59XHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgc3BlY2lmaWMgb3B0aW9uIGlzIGVuYWJsZWQgZm9yIGEgZ2l2ZW4gcnVsZSBmdW5jdGlvbi5cclxuICpcclxuICogQHBhcmFtIHJ1bGVGbiAtIFRoZSBydWxlIGZ1bmN0aW9uIG9iamVjdCwgd2hpY2ggbWF5IGJlIHVuZGVmaW5lZC4gSWYgZGVmaW5lZCwgaXQgc2hvdWxkIGNvbnRhaW4gYSBgY29uZmlnRWxlbWVudHNgIHByb3BlcnR5LlxyXG4gKiBAcGFyYW0gb3B0aW9uIC0gVGhlIG5hbWUgb2YgdGhlIG9wdGlvbiB0byBjaGVjayB3aXRoaW4gdGhlIGBjb25maWdFbGVtZW50c2Agb2YgdGhlIHJ1bGUgZnVuY3Rpb24uXHJcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgb3B0aW9uIGlzIHVuZGVmaW5lZCBpbiB0aGUgYGNvbmZpZ0VsZW1lbnRzYCBvciBpZiB0aGUgb3B0aW9uIGlzIGV4cGxpY2l0bHkgc2V0IHRvIGB0cnVlYC5cclxuICogICAgICAgICAgUmV0dXJucyBgZmFsc2VgIGlmIHRoZSBvcHRpb24gaXMgZXhwbGljaXRseSBzZXQgdG8gYGZhbHNlYC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VSdWxlT3B0aW9uKHJ1bGVGbiA6IFJ1bGVGdW5jdGlvbiB8IHVuZGVmaW5lZCwgb3B0aW9uIDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgaWYgKHJ1bGVGbj8uY29uZmlnRWxlbWVudHNbb3B0aW9uXSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdHJ1ZTtcclxuICByZXR1cm4gcnVsZUZuLmNvbmZpZ0VsZW1lbnRzW29wdGlvbl07XHJcbn1cclxuLyoqXHJcbnJ1bGVGdW5jdGlvbnMucHVzaCh7XHJcbiAgICBpZDonZGVmYXVsdCcsXHJcbiAgICBydWxlVHlwZTogJ2J1aWxkSW4nLFxyXG4gICAgZGVzY3JpcHRpb246ICdQYXNzIHBhcmFtZXRlcicsXHJcbiAgICBzb3VyY2U6IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBsZXQgcmVzdWx0ID0gJyc7XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIixcclxuICAgIHR5cGU6IFsndGV4dCddLFxyXG4gICAgY29uZmlnRWxlbWVudHM6IGRlZmF1bHRDb25maWdFbGVtZW50cyh7fSksXHJcbiAgICBmeDogZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHM6U2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH1cclxufSk7XHJcbiovXHJcbi8qXHJcbnJ1bGVGdW5jdGlvbnMucHVzaCh7XHJcbiAgaWQ6J2NvbnN0YW50JyxcclxuICBydWxlVHlwZTogJ2J1aWxkSW4nLFxyXG4gIGRlc2NyaXB0aW9uOiAnQ29uc3RhbnQgdmFsdWUnLFxyXG4gIHNvdXJjZTogXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIC8vIGFjcXVpcmUgZmlsZSBwYXRoXFxuICBjb25zdCBwYXRoID0gZmlsZS5wYXRoO1xcbiAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XFxuICBsZXQgcmVzdWx0ID0gJyc7XFxuICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xcbiAgICBwYXJ0cy5wb3AoKTsgLy8gcmVtb3ZlIGZpbGUgbmFtZVxcbiAgICByZXN1bHQgPSByZXN1bHQgKyBwYXJ0cy5qb2luKCcvJyk7XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIixcclxuICB0eXBlOiBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywnbXVsdGl0ZXh0J10sXHJcbiAgY29uZmlnRWxlbWVudHM6IGRlZmF1bHRDb25maWdFbGVtZW50cyh7XHJcbiAgICBhZGRQcmVmaXg6IGZhbHNlLFxyXG4gICAgc3BhY2VSZXBsYWNlbWVudDogZmFsc2UsXHJcbiAgICBzcGVjaWFsQ2hhcmFjdGVyUmVwbGFjZW1lbnQ6IGZhbHNlLFxyXG4gICAgY29udmVydFRvTG93ZXJDYXNlOiBmYWxzZSxcclxuICAgIHJlc3VsdEFzTGluazogZmFsc2UsfSksXHJcbiAgZng6ZnVuY3Rpb24gKGFwcDogQXBwLCBmaWxlOlRGaWxlLCB0b29sczpTY3JpcHRpbmdUb29scyl7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRvb2xzLmdldE9wdGlvbkNvbmZpZyh0b29scy5nZXRSdWxlKCk/LmlkLCdjb25zdGFudFZhbHVlJyk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfSxcclxuICBjb25maWdUYWI6IGZ1bmN0aW9uIChvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6Rm9sZGVyVGFnUnVsZURlZmluaXRpb24sIHRoYXQ6YW55LCBwcmV2aWV3Q29tcG9uZW50OiBhbnkpIHtcclxuXHJcbiAgICB0aGF0LnNldE9wdGlvbkNvbmZpZ0RlZmF1bHRzKHJ1bGUuaWQsIHtcclxuICAgICAgY29uc3RhbnRWYWx1ZTogJycsXHJcbiAgICB9KVxyXG5cclxuICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgLnNldE5hbWUoJ0NvbnN0YW50IHZhbHVlJylcclxuICAgIC5zZXREZXNjKCdFbnRlciBhIGNvbnN0YW50IHZhbHVlIHRvIGJlIHVzZWQgaW4gdGhlIHJ1bGUnKVxyXG4gICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgLnNldFZhbHVlKHRoYXQuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQgLCdjb25zdGFudFZhbHVlJykgfHwgJycpXHJcbiAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWcocnVsZS5pZCwnY29uc3RhbnRWYWx1ZScsIHZhbHVlKTtcclxuICAgICAgICAgIHRoYXQudXBkYXRlUHJldmlldyhydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgICB9KSk7XHJcbiAgfVxyXG59KTtcclxuXHJcbnJ1bGVGdW5jdGlvbnMucHVzaCh7XHJcbiAgaWQ6J2Z1bGxQYXRoJyxcclxuICBydWxlVHlwZTogJ2J1aWxkSW4nLFxyXG4gIGRlc2NyaXB0aW9uOiAnRnVsbCBwYXRoLCBmaWxlbmFtZScsXHJcbiAgc291cmNlOiBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgLy8gYWNxdWlyZSBmaWxlIHBhdGhcXG4gIGNvbnN0IHBhdGggPSBmaWxlLnBhdGg7XFxuICBjb25zdCBwYXJ0cyA9IHBhdGguc3BsaXQoJy8nKTtcXG4gIGxldCByZXN1bHQgPSAnJztcXG4gIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XFxuICAgIHBhcnRzLnBvcCgpOyAvLyByZW1vdmUgZmlsZSBuYW1lXFxuICAgIHJlc3VsdCA9IHJlc3VsdCArIHBhcnRzLmpvaW4oJy8nKTtcXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxufVwiLFxyXG4gIHR5cGU6IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCdtdWx0aXRleHQnXSxcclxuICBjb25maWdFbGVtZW50czogZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KSxcclxuICBmeDpmdW5jdGlvbiAoYXBwOiBBcHAsIGZpbGU6VEZpbGUsIHRvb2xzOlNjcmlwdGluZ1Rvb2xzKXtcclxuICAgICAgbGV0IHBhcnRzID0gZmlsZS5wYXRoLnNwbGl0KCcvJyk7XHJcbiAgICAgIHBhcnRzLnBvcCgpO1xyXG4gICAgICBwYXJ0cy5wdXNoKGZpbGUuYmFzZW5hbWUpO1xyXG4gICAgICByZXR1cm4gcGFydHMuam9pbignLycpO1xyXG4gIH1cclxufSk7XHJcblxyXG5ydWxlRnVuY3Rpb25zLnB1c2goe1xyXG4gICAgaWQ6J2Z1bGxQYXRoRXh0JyxcclxuICAgIHJ1bGVUeXBlOiAnYnVpbGRJbicsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0Z1bGwgcGF0aCwgZmlsZW5hbWUgYW5kIEV4dGVuc2lvbicsXHJcbiAgICBzb3VyY2U6IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICAvLyBhY3F1aXJlIGZpbGUgcGF0aFxcbiAgY29uc3QgcmVzdWx0ID0gZmlsZS5wYXRoO1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59XCIsXHJcbiAgICB0eXBlOiBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJ10sXHJcbiAgICBjb25maWdFbGVtZW50czogZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KSxcclxuICAgIGZ4OiBmdW5jdGlvbiAoYXBwOiBBcHAsIGZpbGU6VEZpbGUsIHRvb2xzOlNjcmlwdGluZ1Rvb2xzKXtcclxuICAgICAgICAgICAgcmV0dXJuIGAke2ZpbGUucGF0aH1gO1xyXG4gICAgICAgIH1cclxufSk7XHJcblxyXG5ydWxlRnVuY3Rpb25zLnB1c2goe1xyXG4gICAgaWQ6J3BhdGgnLFxyXG4gICAgcnVsZVR5cGU6ICdidWlsZEluJyxcclxuICAgIGRlc2NyaXB0aW9uOiAnRnVsbCBQYXRoJyxcclxuICAgIHNvdXJjZTogXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIC8vIGFjcXVpcmUgZmlsZSBwYXRoXFxuICBjb25zdCBwYXRoID0gZmlsZS5wYXRoO1xcbiAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XFxuICBsZXQgcmVzdWx0ID0gJyc7XFxuICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xcbiAgICBwYXJ0cy5wb3AoKTsgLy8gcmVtb3ZlIGZpbGUgbmFtZVxcbiAgICByZXN1bHQgPSByZXN1bHQgKyBwYXJ0cy5qb2luKCcvJyk7XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIixcclxuICAgIHR5cGU6IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnXSxcclxuICAgIGNvbmZpZ0VsZW1lbnRzOiBkZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pLFxyXG4gICAgZng6ZnVuY3Rpb24gKGFwcDogQXBwLCBmaWxlOlRGaWxlLCB0b29sczpTY3JpcHRpbmdUb29scyl7XHJcbiAgICAgICAgbGV0IHBhcnRzID0gZmlsZS5wYXRoLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgcGFydHMucG9wKCk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJy8nKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5ydWxlRnVuY3Rpb25zLnB1c2goe1xyXG4gICAgaWQ6J2xpbmtUb0ZpbGUnLFxyXG4gICAgcnVsZVR5cGU6ICdidWlsZEluJyxcclxuICAgIGRlc2NyaXB0aW9uOiAnTGluayB0byBmaWxlJyxcclxuICAgIHNvdXJjZTogXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIC8vIGFjcXVpcmUgZmlsZSBwYXRoXFxuICBjb25zdCBwYXRoID0gZmlsZS5wYXRoO1xcbiAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XFxuICBsZXQgcmVzdWx0ID0gJyc7XFxuICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xcbiAgICBwYXJ0cy5wb3AoKTsgLy8gcmVtb3ZlIGZpbGUgbmFtZVxcbiAgICByZXN1bHQgPSByZXN1bHQgKyBwYXJ0cy5qb2luKCcvJyk7XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIixcclxuICAgIHR5cGU6IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCdtdWx0aXRleHQnXSxcclxuICAgIGNvbmZpZ0VsZW1lbnRzOiBkZWZhdWx0Q29uZmlnRWxlbWVudHMoe3Jlc3VsdEFzTGluazogZmFsc2V9KSxcclxuICAgIGZ4OmZ1bmN0aW9uIChhcHA6IEFwcCwgZmlsZTpURmlsZSwgdG9vbHM6U2NyaXB0aW5nVG9vbHMpe1xyXG4gICAgICAgIGNvbnN0IHBhcnRzID0gZmlsZS5wYXRoLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgY29uc3QgcnVsZSA9IHRvb2xzLmdldFJ1bGUoKTtcclxuICAgICAgICBpZiAoIXJ1bGUpIHJldHVybiB0b29scy5nZXRDdXJyZW50Q29udGVudCgpO1xyXG4gICAgICAgIGNvbnN0IGFkZEV4dGVuc2lvbiA9IHRvb2xzLmdldE9wdGlvbkNvbmZpZyhydWxlLmlkLCdhZGRFeHRlbnNpb24nKSBcclxuICAgICAgICBwYXJ0cy5wb3AoKTtcclxuICAgICAgICBpZiAocGFydHNbcGFydHMubGVuZ3RoLTFdID09PSBmaWxlLmJhc2VuYW1lKSBwYXJ0cy5wb3AoKTtcclxuICAgICAgICBsZXQgZmlsZU5hbWUgPSBhZGRFeHRlbnNpb24/IGZpbGUuYmFzZW5hbWUgKyAnLicgKyBmaWxlLmV4dGVuc2lvbiA6IGZpbGUuYmFzZW5hbWU7IFxyXG4gICAgICAgIHJldHVybiBgW1ske3BhcnRzLmpvaW4oJy8nKX0vJHtmaWxlTmFtZX18JHtmaWxlLmJhc2VuYW1lfV1dYDtcclxuICAgIH0sXHJcbiAgICBjb25maWdUYWI6IGZ1bmN0aW9uIChvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6RnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDphbnksIHByZXZpZXdDb21wb25lbnQ6IGFueSkge1xyXG5cclxuICAgICAgdGhhdC5zZXRPcHRpb25Db25maWdEZWZhdWx0cyhydWxlLmlkLCB7XHJcbiAgICAgICAgYWRkRXh0ZW5zaW9uOiB0cnVlXHJcbiAgICAgIH0pXHJcbiAgXHJcbiAgICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgIC5zZXROYW1lKCdJbmNsdWRlIGZpbGUgZXh0ZW5zaW9uJylcclxuICAgICAgICAuc2V0RGVzYygnQWRkIGZpbGUgZXh0ZW5zaW9uIHRvIHBhdGhuYW1lJylcclxuICAgICAgICAuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcclxuICAgICAgICAgICAgLnNldFZhbHVlKHRoYXQuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQgLCdhZGRFeHRlbnNpb24nKSB8fCBmYWxzZSlcclxuICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWcocnVsZS5pZCwnYWRkRXh0ZW5zaW9uJywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC51cGRhdGVQcmV2aWV3KHJ1bGUsIHByZXZpZXdDb21wb25lbnQpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICk7XHJcbiAgICB9ICBcclxufSk7XHJcblxyXG5ydWxlRnVuY3Rpb25zLnB1c2goe1xyXG4gICAgaWQ6J3BhdGhGb2xkZXJOb3RlcycsXHJcbiAgICBydWxlVHlwZTogJ2J1aWxkSW4nLFxyXG4gICAgZGVzY3JpcHRpb246ICdQYXRoIChmb2xkZXIgbm90ZXMpJyxcclxuICAgIHNvdXJjZTogXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIC8vIGFjcXVpcmUgZmlsZSBwYXRoXFxuICBjb25zdCBwYXRoID0gZmlsZS5wYXRoO1xcbiAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XFxuICBsZXQgcmVzdWx0ID0gJyc7XFxuICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xcbiAgICBwYXJ0cy5wb3AoKTsgLy8gcmVtb3ZlIGZpbGUgbmFtZVxcbiAgICByZXN1bHQgPSByZXN1bHQgKyBwYXJ0cy5qb2luKCcvJyk7XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIixcclxuICAgIHR5cGU6IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCdtdWx0aXRleHQnXSxcclxuICAgIGNvbmZpZ0VsZW1lbnRzOiBkZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pLFxyXG4gICAgZng6ZnVuY3Rpb24gKGFwcDogQXBwLCBmaWxlOlRGaWxlLCB0b29sczpTY3JpcHRpbmdUb29scyl7XHJcbiAgICAgICAgbGV0IHBhcnRzID0gZmlsZS5wYXRoLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgcGFydHMucG9wKCk7XHJcbiAgICAgICAgaWYgKHBhcnRzW3BhcnRzLmxlbmd0aC0xXSA9PT0gZmlsZS5iYXNlbmFtZSkgcGFydHMucG9wKCk7IC8vIHJlbW92ZSBwYXJlbnQgZm9sZGVyIGlmIHNhbWUgbmFtZSBhcyB0aGUgZmlsZVxyXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKCcvJyk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxucnVsZUZ1bmN0aW9ucy5wdXNoKHtcclxuICBpZDonZnVsbFBhdGhGb2xkZXJOb3RlcycsXHJcbiAgcnVsZVR5cGU6ICdidWlsZEluJyxcclxuICBkZXNjcmlwdGlvbjogJ0Z1bGwgUGF0aCAoY29tcGx5IHdpdGggXCJmb2xkZXIgbm90ZXNcIiknLFxyXG4gIHNvdXJjZTogXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIC8vIGFjcXVpcmUgZmlsZSBwYXRoXFxuICBjb25zdCBwYXRoID0gZmlsZS5wYXRoO1xcbiAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XFxuICBsZXQgcmVzdWx0ID0gJyc7XFxuICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xcbiAgICBwYXJ0cy5wb3AoKTsgLy8gcmVtb3ZlIGZpbGUgbmFtZVxcbiAgICByZXN1bHQgPSByZXN1bHQgKyBwYXJ0cy5qb2luKCcvJyk7XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIixcclxuICB0eXBlOiBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJ10sXHJcbiAgY29uZmlnRWxlbWVudHM6IGRlZmF1bHRDb25maWdFbGVtZW50cyh7fSksXHJcbiAgZng6ZnVuY3Rpb24gKGFwcDogQXBwLCBmaWxlOlRGaWxlLCB0b29sczpTY3JpcHRpbmdUb29scyl7XHJcbiAgICAgIGxldCBwYXJ0cyA9IGZpbGUucGF0aC5zcGxpdCgnLycpO1xyXG4gICAgICBwYXJ0cy5wb3AoKTsgLy8gcmVtb3ZlIGZpbGUgbmFtZVxyXG4gICAgICBpZiAocGFydHNbcGFydHMubGVuZ3RoLTFdID09PSBmaWxlLmJhc2VuYW1lKSBwYXJ0cy5wb3AoKTsgLy8gcmVtb3ZlIHBhcmVudCBmb2xkZXIgaWYgc2FtZSBuYW1lIGFzIHRoZSBmaWxlXHJcbiAgICAgIHBhcnRzLnB1c2goZmlsZS5iYXNlbmFtZSk7IC8vIGFkZCB0aGUgZmlsZSBuYW1lIGJhY2tcclxuICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJy8nKTtcclxuICB9XHJcbn0pO1xyXG5cclxucnVsZUZ1bmN0aW9ucy5wdXNoKHtcclxuICAgIGlkOidmdWxsUGF0aEV4dEZvbGRlck5vdGVzJyxcclxuICAgIHJ1bGVUeXBlOiAnYnVpbGRJbicsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0Z1bGwgUGF0aCB3aXRoIEV4dGVuc2lvbiAoY29tcGx5IHdpdGggXCJmb2xkZXIgbm90ZXNcIiknLFxyXG4gICAgc291cmNlOiBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgLy8gYWNxdWlyZSBmaWxlIHBhdGhcXG4gIGNvbnN0IHBhdGggPSBmaWxlLnBhdGg7XFxuICBjb25zdCBwYXJ0cyA9IHBhdGguc3BsaXQoJy8nKTtcXG4gIGxldCByZXN1bHQgPSAnJztcXG4gIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XFxuICAgIHBhcnRzLnBvcCgpOyAvLyByZW1vdmUgZmlsZSBuYW1lXFxuICAgIHJlc3VsdCA9IHJlc3VsdCArIHBhcnRzLmpvaW4oJy8nKTtcXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxufVwiLFxyXG4gICAgdHlwZTogWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcyddLFxyXG4gICAgY29uZmlnRWxlbWVudHM6IGRlZmF1bHRDb25maWdFbGVtZW50cyh7fSksXHJcbiAgICBmeDpmdW5jdGlvbiAoYXBwOiBBcHAsIGZpbGU6VEZpbGUsIHRvb2xzOlNjcmlwdGluZ1Rvb2xzKXtcclxuICAgICAgICBsZXQgcGFydHMgPSBmaWxlLnBhdGguc3BsaXQoJy8nKTtcclxuICAgICAgICBwYXJ0cy5wb3AoKTsgLy8gcmVtb3ZlIGZpbGUgbmFtZVxyXG4gICAgICAgIGlmIChwYXJ0c1twYXJ0cy5sZW5ndGgtMV0gPT09IGZpbGUuYmFzZW5hbWUpIHBhcnRzLnBvcCgpOyAvLyByZW1vdmUgcGFyZW50IGZvbGRlciBpZiBzYW1lIG5hbWUgYXMgdGhlIGZpbGVcclxuICAgICAgICBwYXJ0cy5wdXNoKGZpbGUubmFtZSk7IC8vIGFkZCB0aGUgZmlsZSBuYW1lIGJhY2tcclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbignLycpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbnJ1bGVGdW5jdGlvbnMucHVzaCh7XHJcbiAgICBpZDonaXNSb290JyxcclxuICAgIHJ1bGVUeXBlOiAnYnVpbGRJbicsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0ZpbGUgaW4gUm9vdCBmb2xkZXInLFxyXG4gICAgc291cmNlOiBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgbGV0IHBhcnRzID0gZmlsZS5wYXRoLnNwbGl0KCcvJyk7XFxuICByZXR1cm4gcGFydHMubGVuZ3RoID09PSAxO1xcbn1cIixcclxuICAgIHR5cGU6IFsnY2hlY2tib3gnXSxcclxuICAgIGNvbmZpZ0VsZW1lbnRzOiBkZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pLFxyXG4gICAgZng6ZnVuY3Rpb24gKGFwcDogQXBwLCBmaWxlOlRGaWxlLCB0b29sczpTY3JpcHRpbmdUb29scyl7XHJcbiAgICAgICAgbGV0IHBhcnRzID0gZmlsZS5wYXRoLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmxlbmd0aCA9PT0gMTtcclxuICAgIH1cclxufSk7XHJcblxyXG5ydWxlRnVuY3Rpb25zLnB1c2goe1xyXG4gICAgaWQ6J2ZvbGRlcicsXHJcbiAgICBydWxlVHlwZTogJ2J1aWxkSW4nLFxyXG4gICAgZGVzY3JpcHRpb246ICdQYXJlbnQgRm9sZGVyJyxcclxuICAgIHNvdXJjZTogXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIC8vIGFjcXVpcmUgZmlsZSBwYXRoXFxuICBjb25zdCBwYXRoID0gZmlsZS5wYXRoO1xcbiAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XFxuICBsZXQgcmVzdWx0ID0gJyc7XFxuICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xcbiAgICByZXN1bHQgPSBwYXJ0c1twYXJ0cy5sZW5ndGgtMl07XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIixcclxuICAgIHR5cGU6IFsndGV4dCcsICd0YWdzJ10sXHJcbiAgICBjb25maWdFbGVtZW50czogZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KSxcclxuICAgIGZ4OmZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzOlNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIC8vIGFjcXVpcmUgZmlsZSBwYXRoXHJcbiAgICAgICAgY29uc3QgcGF0aCA9IGZpbGUucGF0aDtcclxuICAgICAgICBjb25zdCBwYXJ0cyA9IHBhdGguc3BsaXQoJy8nKTtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XHJcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgIHJlc3VsdCA9IHBhcnRzW3BhcnRzLmxlbmd0aC0yXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG59KTtcclxuXHJcbnJ1bGVGdW5jdGlvbnMucHVzaCh7XHJcbiAgICBpZDonZm9sZGVyRm9sZGVyTm90ZXMnLFxyXG4gICAgcnVsZVR5cGU6ICdidWlsZEluJyxcclxuICAgIGRlc2NyaXB0aW9uOiAnUGFyZW50IEZvbGRlciAoY29tcGxpZXMgd2l0aCBcImZvbGRlciBub3Rlc1wiKScsXHJcbiAgICBzb3VyY2U6IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBjb25zdCBwYXJ0cyA9IGZpbGUucGF0aC5zcGxpdCgnLycpO1xcbiAgbGV0IGluZGV4ID0gcGFydHMubGVuZ3RoLTI7IC8vIGluZGV4IG9mIHBhcmVudCBmb2xkZXJcXG4gIGlmIChwYXJ0c1twYXJ0cy5sZW5ndGgtMl09PT1maWxlLmJhc2VuYW1lKSB7XFxuICAgICAgaW5kZXgtLTsgLy8gZm9sZGVyIG5vdGUgcGFyZW50IGlzIHRoZSBjaGlsZFxcbiAgfVxcbiAgaWYgKGluZGV4ID49IDApIHtcXG4gICAgcmV0dXJuIHBhcnRzW2luZGV4XTsgLy8gZmlsZSBpbiBmb2xkZXJcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiB0b29scy5hcHA/LnZhdWx0Py5nZXROYW1lKCkgfHwgJ1ZhdWx0JzsgLy8gZmlsZSBpbiByb290ID0gdmF1bHRcXG4gIH1cXG59XCIsXHJcbiAgICB0eXBlOiBbJ3RleHQnLCAndGFncyddLFxyXG4gICAgY29uZmlnRWxlbWVudHM6IGRlZmF1bHRDb25maWdFbGVtZW50cyh7fSksXHJcbiAgICBmeDpmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgICAgY29uc3QgcGFydHMgPSBmaWxlLnBhdGguc3BsaXQoJy8nKTtcclxuICAgICAgbGV0IGluZGV4ID0gcGFydHMubGVuZ3RoLTI7IC8vIGluZGV4IG9mIHBhcmVudCBmb2xkZXJcclxuICAgICAgaWYgKHBhcnRzW3BhcnRzLmxlbmd0aC0yXT09PWZpbGUuYmFzZW5hbWUpIHtcclxuICAgICAgICAgIGluZGV4LS07IC8vIGZvbGRlciBub3RlIHBhcmVudCBpcyB0aGUgY2hpbGRcclxuICAgICAgfVxyXG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xyXG4gICAgICAgIHJldHVybiBwYXJ0c1tpbmRleF07IC8vIGZpbGUgaW4gZm9sZGVyXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRvb2xzLmFwcD8udmF1bHQ/LmdldE5hbWUoKSB8fCAnVmF1bHQnOyAvLyBmaWxlIGluIHJvb3QgPSB2YXVsdFxyXG4gICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxucnVsZUZ1bmN0aW9ucy5wdXNoKHtcclxuICAgIGlkOidmb2xkZXJzJyxcclxuICAgIHJ1bGVUeXBlOiAnYnVpbGRJbicsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0FsbCBmb2xkZXJzIG9mIHRoZSBmaWxlIGFzIGEgbGlzdCcsXHJcbiAgICBzb3VyY2U6IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBjb25zdCBwYXRoID0gZmlsZS5wYXRoOyAvLyBhY3F1aXJlIGZpbGUgcGF0aFxcbiAgY29uc3QgcmVzdWx0ID0gcGF0aC5zcGxpdCgnLycpO1xcbiAgcmVzdWx0LnBvcCgpOyAvLyByZW1vdmUgZmlsZSBuYW1lXFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIixcclxuICAgIHR5cGU6IFsnbXVsdGl0ZXh0JywndGFncycsJ2FsaWFzZXMnXSxcclxuICAgIGNvbmZpZ0VsZW1lbnRzOiBkZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pLFxyXG4gICAgZng6ZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHM6U2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAgICAgLy8gYWNxdWlyZSBmaWxlIHBhdGhcclxuICAgICAgICBjb25zdCBwYXRoID0gZmlsZS5wYXRoO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhdGguc3BsaXQoJy8nKTtcclxuICAgICAgICByZXN1bHQucG9wKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG59KTtcclxuXHJcbnJ1bGVGdW5jdGlvbnMucHVzaCh7XHJcbiAgICBpZDoncm9vdEZvbGRlcicsXHJcbiAgICBydWxlVHlwZTogJ2J1aWxkSW4nLFxyXG4gICAgZGVzY3JpcHRpb246ICdSb290IGZvbGRlcicsXHJcbiAgICBzb3VyY2U6IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICAvLyBhY3F1aXJlIGZpbGUgcGF0aFxcbiAgY29uc3QgcGF0aCA9IGZpbGUucGF0aDtcXG4gIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLycpO1xcbiAgbGV0IHJlc3VsdCA9ICcnO1xcbiAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcXG4gICAgcmVzdWx0ID0gcGFydHNbMF07XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIixcclxuICAgIHR5cGU6IFsndGV4dCcsICdtdWx0aXRleHQnLCAndGFncycsICdhbGlhc2VzJ10sXHJcbiAgICBjb25maWdFbGVtZW50czogZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KSxcclxuICAgIGZ4OmZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzOlNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIC8vIGFjcXVpcmUgZmlsZSBwYXRoXHJcbiAgICAgICAgY29uc3QgcGF0aCA9IGZpbGUucGF0aDtcclxuICAgICAgICBjb25zdCBwYXJ0cyA9IHBhdGguc3BsaXQoJy8nKTtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XHJcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgIHJlc3VsdCA9IHBhcnRzWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9XHJcbn0pO1xyXG5cclxucnVsZUZ1bmN0aW9ucy5wdXNoKHtcclxuICAgIGlkOiduYW1lJyxcclxuICAgIHJ1bGVUeXBlOiAnYnVpbGRJbicsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0ZpbGUgbmFtZSB3aXRob3V0IGV4dGVuc2lvbicsXHJcbiAgICBzb3VyY2U6IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICAvLyBhY3F1aXJlIGZpbGUgbmFtZVxcbiAgY29uc3QgcmVzdWx0ID0gZmlsZS5uYW1lLnNwbGl0KCcuJyk7XFxuICByZXN1bHQucG9wKCk7IC8vIHJlbW92ZSBleHRlbnNpb25cXG4gIHJlc3VsdC5qb2luKCcuJyk7IC8vIHJlY29uc3RydWN0IHRoZSBmaWxlIG5hbWVcXG4gIHJldHVybiByZXN1bHQ7XFxufVwiLFxyXG4gICAgdHlwZTogWyd0ZXh0JywgJ211bHRpdGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnXSxcclxuICAgIGNvbmZpZ0VsZW1lbnRzOiBkZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pLFxyXG4gICAgZng6ZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHM6U2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAgICAgLy8gYWNxdWlyZSBmaWxlIG5hbWVcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBmaWxlLm5hbWUuc3BsaXQoJy4nKTtcclxuICAgICAgICByZXN1bHQucG9wKCk7IC8vIHJlbW92ZSBleHRlbnNpb25cclxuICAgICAgICByZXN1bHQuam9pbignLicpOyAvLyByZWNvbnN0cnVjdCB0aGUgZmlsZSBuYW1lXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG59KTtcclxuXHJcbnJ1bGVGdW5jdGlvbnMucHVzaCh7XHJcbiAgICBpZDonbmFtZUV4dCcsXHJcbiAgICBydWxlVHlwZTogJ2J1aWxkSW4nLFxyXG4gICAgZGVzY3JpcHRpb246ICdGaWxlIG5hbWUgd2l0aCBleHRlbnNpb24nLFxyXG4gICAgc291cmNlOiBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgLy8gYWNxdWlyZSBmaWxlIG5hbWVcXG4gIGNvbnN0IHJlc3VsdCA9IGZpbGUubmFtZTtcXG4gIHJldHVybiByZXN1bHQ7XFxufVwiLFxyXG4gICAgdHlwZTogWyd0ZXh0JywgJ211bHRpdGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnXSxcclxuICAgIGNvbmZpZ0VsZW1lbnRzOiBkZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pLFxyXG4gICAgZng6ZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHM6U2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAgICAgLy8gYWNxdWlyZSBmaWxlIG5hbWVcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBmaWxlLm5hbWU7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG59KTtcclxuXHJcbnJ1bGVGdW5jdGlvbnMucHVzaCh7XHJcbiAgICBpZDonZ2V0UHJvcGVydHknLFxyXG4gICAgcnVsZVR5cGU6ICdidWlsZEluLmlucHV0UHJvcGVydHknLFxyXG4gICAgZGVzY3JpcHRpb246ICdHZXQgYSBwcm9wZXJ0eScsXHJcbiAgICBpc0xpdmVSdWxlOiB0cnVlLFxyXG4gICAgaW5wdXRQcm9wZXJ0eTogdHJ1ZSxcclxuICAgIHNvdXJjZTogXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIGNvbnN0IHJlc3VsdCA9IGlucHV0O1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59XCIsXHJcbiAgICB0eXBlOiBbJ3RleHQnLCAnbXVsdGl0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcyddLFxyXG4gICAgY29uZmlnRWxlbWVudHM6IGRlZmF1bHRDb25maWdFbGVtZW50cyh7aW5wdXRQcm9wZXJ0eTp0cnVlfSksXHJcbiAgICBmeDpmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29sczpTY3JpcHRpbmdUb29scywgaW5wdXQ/KSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGlucHV0O1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH1cclxufSk7XHJcblxyXG5ydWxlRnVuY3Rpb25zLnB1c2goe1xyXG4gICAgaWQ6J2RhdGVUaW1lQ3JlYXRlZCcsXHJcbiAgICBydWxlVHlwZTogJ2J1aWxkSW4nLFxyXG4gICAgZGVzY3JpcHRpb246ICdEYXRlIChhbmQgVGltZSkgY3JlYXRlZCcsXHJcbiAgICBzb3VyY2U6IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBjb25zdCB0aW1lT2Zmc2V0ID0gbmV3IERhdGUoRGF0ZS5ub3coKSkuZ2V0VGltZXpvbmVPZmZzZXQoKSo2MDAwMDsgLy8gZ2V0IGxvY2FsIHRpbWUgb2Zmc2V0XFxuICBjb25zdCByZXN1bHQgPSBuZXcgRGF0ZShmaWxlLnN0YXQuY3RpbWUtdGltZU9mZnNldCk7XFxuICByZXR1cm4gcmVzdWx0LnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1onKVswXTsgLy8gcmVtb3ZlIFVUQyBzeW1ib2xcXG59XCIsXHJcbiAgICB0eXBlOiBbJ2RhdGUnLCAnZGF0ZXRpbWUnXSxcclxuICAgIGNvbmZpZ0VsZW1lbnRzOiBkZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pLFxyXG4gICAgZng6ZnVuY3Rpb24gKGFwcDogQXBwLCBmaWxlOlRGaWxlLCB0b29sczpTY3JpcHRpbmdUb29scykgeyBcclxuICAgICAgICBjb25zdCB0aW1lT2Zmc2V0ID0gbmV3IERhdGUoRGF0ZS5ub3coKSkuZ2V0VGltZXpvbmVPZmZzZXQoKSo2MDAwMDsgLy8gZ2V0IGxvY2FsIHRpbWUgb2Zmc2V0XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IERhdGUoZmlsZS5zdGF0LmN0aW1lLXRpbWVPZmZzZXQpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQudG9JU09TdHJpbmcoKS5zcGxpdCgnWicpWzBdOyAvLyByZW1vdmUgVVRDIHN5bWJvbFxyXG4gICAgICB9XHJcbn0pO1xyXG5cclxucnVsZUZ1bmN0aW9ucy5wdXNoKHtcclxuICAgIGlkOidkYXRlVGltZU1vZGlmaWVkJyxcclxuICAgIHJ1bGVUeXBlOiAnYnVpbGRJbicsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0RhdGUgKGFuZCBUaW1lKSBtb2RpZmllZCcsXHJcbiAgICBzb3VyY2U6IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBjb25zdCB0aW1lT2Zmc2V0ID0gbmV3IERhdGUoRGF0ZS5ub3coKSkuZ2V0VGltZXpvbmVPZmZzZXQoKSo2MDAwMDtcXG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBEYXRlKGZpbGUuc3RhdC5tdGltZS10aW1lT2Zmc2V0KTsgLy8gQXBwbHkgb2Zmc2V0IHRvIEdNVCBUaW1lc3RhbXBcXG4gIHJldHVybiByZXN1bHQudG9JU09TdHJpbmcoKS5zcGxpdCgnWicpWzBdOyAvLyByZW1vdmUgVVRDIHN5bWJvbFxcbn1cIixcclxuICAgIHR5cGU6IFsnZGF0ZScsICdkYXRldGltZSddLFxyXG4gICAgY29uZmlnRWxlbWVudHM6IGRlZmF1bHRDb25maWdFbGVtZW50cyh7fSksXHJcbiAgICBmeDpmdW5jdGlvbiAoYXBwOiBBcHAsIGZpbGU6VEZpbGUsIHRvb2xzOlNjcmlwdGluZ1Rvb2xzKSB7IFxyXG4gICAgICAgIGNvbnN0IHRpbWVPZmZzZXQgPSBuZXcgRGF0ZShEYXRlLm5vdygpKS5nZXRUaW1lem9uZU9mZnNldCgpKjYwMDAwO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBEYXRlKGZpbGUuc3RhdC5tdGltZS10aW1lT2Zmc2V0KTsgLy8gQXBwbHkgb2Zmc2V0IHRvIEdNVCBUaW1lc3RhbXBcclxuICAgICAgICByZXR1cm4gcmVzdWx0LnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1onKVswXTsgLy8gcmVtb3ZlIFVUQyBzeW1ib2xcclxuICAgICAgfVxyXG59KTtcclxuXHJcbnJ1bGVGdW5jdGlvbnMucHVzaCh7XHJcbiAgICBpZDonZmlsZVNpemVCeXRlcycsXHJcbiAgICBydWxlVHlwZTogJ2J1aWxkSW4nLFxyXG4gICAgZGVzY3JpcHRpb246ICdGaWxlIHNpemUgaW4gYnl0ZXMnLFxyXG4gICAgc291cmNlOiBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgLy8gYWNxdWlyZSBmaWxlIHNpemVcXG4gIGNvbnN0IHJlc3VsdCA9IGZpbGUuc3RhdC5zaXplO1xcbiAgcmV0dXJuIHJlc3VsdDsgLy8gcmV0dXJuIHlvdSByZXN1bHQuXFxufVwiLFxyXG4gICAgdHlwZTogWydudW1iZXInXSxcclxuICAgIGNvbmZpZ0VsZW1lbnRzOiBkZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pLFxyXG4gICAgZng6ZnVuY3Rpb24gKGFwcDogQXBwLCBmaWxlOlRGaWxlLCB0b29sczpTY3JpcHRpbmdUb29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgICAgICAvLyBhY3F1aXJlIGZpbGUgc2l6ZVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGZpbGUuc3RhdC5zaXplO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7IC8vIHJldHVybiB5b3UgcmVzdWx0LlxyXG4gICAgICB9XHJcbn0pO1xyXG5cclxucnVsZUZ1bmN0aW9ucy5wdXNoKHtcclxuICAgIGlkOidmaWxlU2l6ZVN0cmluZycsXHJcbiAgICBydWxlVHlwZTogJ2J1aWxkSW4nLFxyXG4gICAgZGVzY3JpcHRpb246ICdGaWxlIHNpemUgZm9ybWF0dGVkIGFzIHRleHQnLFxyXG4gICAgc291cmNlOiBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgLy8gYWNxdWlyZSBmaWxlIHNpemVcXG4gIGxldCBzaXplID1maWxlLnN0YXQuc2l6ZTtcXG4gIGNvbnN0IHByZWNpc2lvbiA9IDI7IC8vIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xcbiAgaWYgKHNpemUgPiAxMDI0KSB7XFxuICAgIHNpemUgPSBzaXplIC8gMTAyNDtcXG4gICAgaWYgKHNpemUgPiAxMDI0KSB7XFxuICAgICAgc2l6ZSA9IHNpemUgLyAxMDI0O1xcbiAgICAgIGlmIChzaXplID4gMTAyNCkge1xcbiAgICAgICAgc2l6ZSA9IHNpemUgLyAxMDI0O1xcbiAgICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUZsb2F0KHNpemUpLnRvRml4ZWQocHJlY2lzaW9uKSArICcgR0InO1xcbiAgICAgIH0gXFxuICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUZsb2F0KHNpemUpLnRvRml4ZWQocHJlY2lzaW9uKSArICcgTUInO1xcbiAgICB9XFxuICAgIHJldHVybiBOdW1iZXIucGFyc2VGbG9hdChzaXplKS50b0ZpeGVkKHByZWNpc2lvbikgKyAnIEtCJztcXG4gIH0gICBcXG4gIHJldHVybiBzaXplICsgJyBCeXRlcyc7IC8vIHJldHVybiB5b3UgcmVzdWx0Llxcbn1cIixcclxuICAgIHR5cGU6IFsndGV4dCddLFxyXG4gICAgY29uZmlnRWxlbWVudHM6IGRlZmF1bHRDb25maWdFbGVtZW50cyh7fSksXHJcbiAgICBmeDpmdW5jdGlvbiAoYXBwOiBBcHAsIGZpbGU6VEZpbGUsIHRvb2xzOlNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIC8vIGFjcXVpcmUgZmlsZSBzaXplXHJcbiAgICAgICAgbGV0IHNpemUgPWZpbGUuc3RhdC5zaXplO1xyXG4gICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IDI7IC8vIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xyXG4gICAgICAgIGlmIChzaXplID4gMTAyNCkge1xyXG4gICAgICAgICAgc2l6ZSA9IHNpemUgLyAxMDI0O1xyXG4gICAgICAgICAgaWYgKHNpemUgPiAxMDI0KSB7XHJcbiAgICAgICAgICAgIHNpemUgPSBzaXplIC8gMTAyNDtcclxuICAgICAgICAgICAgaWYgKHNpemUgPiAxMDI0KSB7XHJcbiAgICAgICAgICAgICAgc2l6ZSA9IHNpemUgLyAxMDI0O1xyXG4gICAgICAgICAgICAgIHJldHVybiBzaXplLnRvRml4ZWQocHJlY2lzaW9uKSArICcgR0InO1xyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICByZXR1cm4gc2l6ZS50b0ZpeGVkKHByZWNpc2lvbikgKyAnIE1CJztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBzaXplLnRvRml4ZWQocHJlY2lzaW9uKSArICcgS0InO1xyXG4gICAgICAgIH0gICBcclxuICAgICAgICByZXR1cm4gc2l6ZSArICcgQnl0ZXMnOyAvLyByZXR1cm4geW91IHJlc3VsdC5cclxuICAgICAgfVxyXG59KTtcclxuXHJcbnJ1bGVGdW5jdGlvbnMucHVzaCh7XHJcbiAgaWQ6ICdhdXRvY29tcGxldGUubW9kYWwnLFxyXG4gIHJ1bGVUeXBlOiAnYXV0b2NvbXBsZXRlLm1vZGFsJyxcclxuICBkZXNjcmlwdGlvbjogJ0F1dG9jb21wbGV0ZSBNb2RhbCAoYWR2YW5jZWQpJyxcclxuICBpc0xpdmVSdWxlOiB0cnVlLFxyXG4gIHNvdXJjZTogJycsXHJcbiAgdHlwZTogWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsJ211bHRpdGV4dCddLFxyXG4gIGNvbmZpZ0VsZW1lbnRzOiBkZWZhdWx0Q29uZmlnRWxlbWVudHMoe3JlbW92ZUNvbnRlbnQ6IGZhbHNlLCAgaW5wdXRQcm9wZXJ0eTogZmFsc2UsIGFkZFByZWZpeDogZmFsc2UsIHNwYWNlUmVwbGFjZW1lbnQ6IGZhbHNlLCBzcGVjaWFsQ2hhcmFjdGVyUmVwbGFjZW1lbnQ6IGZhbHNlLCBjb252ZXJ0VG9Mb3dlckNhc2U6IGZhbHNlLCByZXN1bHRBc0xpbms6IGZhbHNlLCBhZGRDb250ZW50OiBmYWxzZSwgc2NyaXB0OiBmYWxzZX0pLFxyXG4gIGZ4OiBhc3luYyBmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29sczpTY3JpcHRpbmdUb29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgIGxvZ2dlci5sb2coREVCVUcsYGF1dG9jb21wbGV0ZSBtb2RhbCwgd29yayBpbiBwcm9ncmVzcy4uLmApO1xyXG4gICAgY29uc3QgY3VycmVudENvbnRlbnQgPSB0b29scy5nZXRDdXJyZW50Q29udGVudCgpO1xyXG4gICAgY29uc3QgcnVsZSA9IHRvb2xzLmdldFJ1bGUoKTtcclxuICAgIGlmICghcnVsZSkgcmV0dXJuIGN1cnJlbnRDb250ZW50O1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRvb2xzLmdldE9wdGlvbkNvbmZpZyhydWxlLmlkKTtcclxuICAgIGlmICghcnVsZSkgcmV0dXJuIHRvb2xzLmdldEN1cnJlbnRDb250ZW50KCkgfHwgJ2F1dG9jb21wbGV0ZS5tb2RhbCc7IC8vIHJldHVybiBjdXJyZW50IGNvbnRlbnQgaWYgbm90IGltcGxlbWVudGVkIHlldFxyXG4gICAgY29uc3QgZnJvbnRtYXR0ZXIgPSB0b29scy5nZXRGcm9udG1hdHRlcigpO1xyXG4gICAgY29uc3QgaGFzQXV0b2NvbXBsZXRlUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKGZyb250bWF0dGVyKS5zb21lKGtleSA9PiBcclxuICAgICAga2V5LnN0YXJ0c1dpdGgocnVsZS5wcm9wZXJ0eSArIG9wdGlvbnMucHJvcGVydHlEZWxpbWl0ZXIpICYmXHJcbiAgICAgIChmcm9udG1hdHRlcltrZXldID09PSB1bmRlZmluZWQgfHxcclxuICAgICAgZnJvbnRtYXR0ZXJba2V5XSA9PT0gbnVsbCB8fFxyXG4gICAgICBmcm9udG1hdHRlcltrZXldID09PSAnJylcclxuICAgICk7XHJcbiAgICBpZiAoIWhhc0F1dG9jb21wbGV0ZVByb3BlcnRpZXMpIHJldHVybiB0b29scy5nZXRDdXJyZW50Q29udGVudCgpIHx8ICdhdXRvY29tcGxldGUubW9kYWwnOyAvLyByZXR1cm4gY3VycmVudCBjb250ZW50IGlmIG5vdCBpbXBsZW1lbnRlZCB5ZXRcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG9wZW5BdXRvY29tcGxldGVNb2RhbChcclxuICAgICAgICB0aGlzLmFwcCxcclxuICAgICAgICB0aGlzLnBsdWdpbixcclxuICAgICAgICBydWxlLFxyXG4gICAgICAgIG9wdGlvbnMsXHJcbiAgICAgICAgdG9vbHMuZ2V0QWN0aXZlRmlsZSgpLFxyXG4gICAgICAgIHRvb2xzLmdldEZyb250bWF0dGVyKClcclxuICAgICAgKTtcclxuICAgIGxvZ2dlci5sb2coREVCVUcsJ2F1dG9jb21wbGV0ZSBtb2RhbCByZXN1bHQnLCByZXN1bHQsIHRvb2xzLmdldEZyb250bWF0dGVyKCkpO1xyXG4gICAgaWYgKHJlc3VsdD8udmFsdWVzKSB7XHJcbiAgICAgIHRoaXMuYXBwLmZpbGVNYW5hZ2VyLnByb2Nlc3NGcm9udE1hdHRlcihmaWxlLCAoZnJvbnRtYXR0ZXIpID0+IHtcclxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyZXN1bHQudmFsdWVzKSkge1xyXG4gICAgICAgICAgZnJvbnRtYXR0ZXJba2V5XSA9IHZhbHVlOyAvLyBzZXQgdGhlIGZyb250bWF0dGVyIHZhbHVlXHJcbiAgICAgICAgfVxyXG4gICAgICB9LHsnbXRpbWUnOmZpbGUuc3RhdC5tdGltZX0pOyAvLyBkbyBub3QgY2hhbmdlIHRoZSBtb2RpZnkgdGltZS5cclxuICAgIH1cclxuICAgIHJldHVybiB0b29scy5nZXRDdXJyZW50Q29udGVudCgpIHx8ICdhdXRvY29tcGxldGUubW9kYWwnOyAvLyByZXR1cm4gY3VycmVudCBjb250ZW50IGlmIG5vdCBpbXBsZW1lbnRlZCB5ZXRcclxuICB9LFxyXG4gIGNvbmZpZ1RhYjogZnVuY3Rpb24gKG9wdGlvbkVMOiBIVE1MRWxlbWVudCwgcnVsZTpGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCB0aGF0OmFueSwgcHJldmlld0NvbXBvbmVudDogYW55KSB7XHJcblxyXG4gICAgdGhhdC5zZXRPcHRpb25Db25maWdEZWZhdWx0cyhydWxlLmlkLCB7XHJcbiAgICAgIHByb3BlcnR5RGVsaW1pdGVyOiAnLicsXHJcbiAgICB9KVxyXG5cclxuICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgLnNldE5hbWUoJ0RlbGltaXRlcicpXHJcbiAgICAuc2V0RGVzYygnQ2hhcmFjdGVyIHRvIGRldGVybWluZSB3aGljaCBwcm9wZXJ0eSBzaG91bGQgYXBwZWFyIGluIHRoZSBtb2RhbCcpXHJcbiAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuICAgICAgICAuc2V0VmFsdWUodGhhdC5nZXRPcHRpb25Db25maWcocnVsZS5pZCAsJ3Byb3BlcnR5RGVsaW1pdGVyJykgfHwgJy4nKVxyXG4gICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQsJ3Byb3BlcnR5RGVsaW1pdGVyJywgdmFsdWUpO1xyXG4gICAgICAgIH0pKTtcclxuICB9XHJcbn0pXHJcbiovXHJcbiIsICJcclxuaW1wb3J0IHsgQXBwLCBNb2RhbCwgU2V0dGluZywgVEFic3RyYWN0RmlsZSwgVEZpbGUsIFRGb2xkZXIsIFZhdWx0LCBzZXRJY29uLEJ1dHRvbkNvbXBvbmVudCwgVGV4dENvbXBvbmVudCwgQ29uc3RydWN0b3IgfSBmcm9tICdvYnNpZGlhbic7IC8vIEFkZGVkIHNldEljb25cclxuLy9pbXBvcnQgJ2NvZGVtaXJyb3IvbW9kZS9qYXZhc2NyaXB0L2phdmFzY3JpcHQnO1xyXG5pbXBvcnQgeyBPYnNpZGlhblByb3BlcnR5VHlwZXMgfSBmcm9tICcuL3R5cGVzJztcclxuaW1wb3J0IHsgcGFyc2VKU0NvZGUsIFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSAnLi90b29scyc7XHJcbmltcG9ydCB7IHVwZGF0ZVByb3BlcnR5SWNvbiB9IGZyb20gJy4vdWlFbGVtZW50cyc7XHJcbmltcG9ydCB7IERFQlVHLCBFUlJPUiwgbG9nZ2VyLCBUUkFDRSB9IGZyb20gJy4vTG9nJztcclxuLy9pbXBvcnQgeyBjaGRpciB9IGZyb20gJ25vZGU6cHJvY2Vzcyc7XHJcbi8vaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xyXG4vL2ltcG9ydCB7IEVkaXRvclN0YXRlIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xyXG5cclxuXHJcbi8vIERlZmluZSB0aGUgcmVzdWx0IHN0cnVjdHVyZSByZXR1cm5lZCBieSB0aGUgbW9kYWxcclxuZXhwb3J0IGludGVyZmFjZSBjb2RlRWRpdG9yTW9kYWxSZXN1bHQge1xyXG4gICAgY29kZTogc3RyaW5nO1xyXG4gICAgdHlwZTogT2JzaWRpYW5Qcm9wZXJ0eVR5cGVzO1xyXG4gICAgY2hlY2tlZDogYm9vbGVhbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIE9ic2lkaWFuIE1vZGFsIGZvciBzZWxlY3RpbmcgZGlyZWN0b3JpZXMgYW5kIGZpbGVzIGZyb20gdGhlIHZhdWx0IHN0cnVjdHVyZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBjb2RlRWRpdG9yTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XHJcbiAgICAvLyBJbml0aWFsIHN0YXRlIHBhc3NlZCB0byB0aGUgbW9kYWwgKHN0b3JlZCBmb3IgcmVzZXQgZnVuY3Rpb25hbGl0eSlcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgaW5pdGlhbENvZGU6IHN0cmluZztcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgb2tDYWxsYmFjazogKHJlc3VsdDogY29kZUVkaXRvck1vZGFsUmVzdWx0IHwgbnVsbCkgPT4gdm9pZDtcclxuICAgIHByaXZhdGUgc2NyaXB0aW5nVG9vbHM6IFNjcmlwdGluZ1Rvb2xzO1xyXG4gICAgcHJpdmF0ZSBwbHVnaW46IGFueTtcclxuXHJcbiAgICAvLyBDdXJyZW50IHN0YXRlIGJlaW5nIG1vZGlmaWVkIHdpdGhpbiB0aGUgbW9kYWxcclxuICAgIHByaXZhdGUgY3VycmVudENvZGU6IHN0cmluZztcclxuICAgIHByaXZhdGUgZXhwZWN0ZWRUeXBlOiBPYnNpZGlhblByb3BlcnR5VHlwZXM7XHJcbiAgICBwcml2YXRlIGN1cnJlbnRUeXBlOiBPYnNpZGlhblByb3BlcnR5VHlwZXM7XHJcbiAgICBwcml2YXRlIGNoZWNrZWRTdWNjZXNzZnVsbHkgOiBib29sZWFuO1xyXG4gICAgcHJpdmF0ZSB1c2VUZXh0QXJlYSA6IGJvb2xlYW47XHJcbiAgICBwcml2YXRlIGFjdGl2ZUZpbGU6IFRGaWxlIHwgVEZvbGRlciB8IG51bGxcclxuICAgIHByaXZhdGUgZnJvbnRtYXR0ZXI6IGFueTsgLy8gRnJvbnRtYXR0ZXIgZGF0YSBmb3IgdGhlIGFjdGl2ZSBmaWxlXHJcblxyXG4gICAgLy8gVUkgRWxlbWVudHNcclxuICAgIHByaXZhdGUgZWRpdG9yUm9vdEVsZW1lbnQhOiBIVE1MRWxlbWVudDtcclxuICAgIHByaXZhdGUgZnVuY3Rpb25UZXN0QnV0dG9uITogQnV0dG9uQ29tcG9uZW50O1xyXG4gICAgcHJpdmF0ZSBmdW5jdGlvblJlc3VsdFRleHRDb21wb25lbnQ6IFRleHRDb21wb25lbnQgfCB1bmRlZmluZWQ7XHJcbiAgICBwcml2YXRlIGNtRWRpdG9yITogQ29kZU1pcnJvci5FZGl0b3IgfCBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgRGlyZWN0b3J5U2VsZWN0aW9uTW9kYWwuXHJcbiAgICAgKiBAcGFyYW0gYXBwIC0gVGhlIE9ic2lkaWFuIEFwcCBpbnN0YW5jZS5cclxuICAgICAqIEBwYXJhbSBwbHVnaW4gLSBUaGUgcGx1Z2luIGluc3RhbmNlLlxyXG4gICAgICogQHBhcmFtIGluaXRpYWxDb2RlIC0gU3RyaW5nIHdpdGggdGhlIGluaXRpYWwgY29kZS5cclxuICAgICAqIEBwYXJhbSBleHBlY3RlZFR5cGUgLSBFeHBlY3RlZCByZXR1cm4gdHlwZS5cclxuICAgICAqIEBwYXJhbSBhY3RpdmVGaWxlIC0gVGhlIGN1cnJlbnRseSBhY3RpdmUgZmlsZSBvciBmb2xkZXIuXHJcbiAgICAgKiBAcGFyYW0gZnJvbnRtYXR0ZXIgLSBGcm9udG1hdHRlciBkYXRhIGZvciB0aGUgYWN0aXZlIGZpbGUuXHJcbiAgICAgKiBAcGFyYW0gb2tDYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgdXNlciBjbGlja3MgXCJPS1wiLiBSZWNlaXZlcyB0aGUgc2VsZWN0aW9uIHJlc3VsdC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgYXBwOiBBcHAsXHJcbiAgICAgICAgcGx1Z2luOiBhbnksXHJcbiAgICAgICAgaW5pdGlhbENvZGU6IHN0cmluZyxcclxuICAgICAgICBleHBlY3RlZFR5cGU6IE9ic2lkaWFuUHJvcGVydHlUeXBlcyxcclxuICAgICAgICBhY3RpdmVGaWxlOiBURmlsZSB8IFRGb2xkZXIgfCBudWxsLFxyXG4gICAgICAgIGZyb250bWF0dGVyOiBhbnksICAgXHJcbiAgICAgICAgb2tDYWxsYmFjazogKHJlc3VsdDogY29kZUVkaXRvck1vZGFsUmVzdWx0IHwgbnVsbCkgPT4gdm9pZFxyXG4gICAgKSB7XHJcbiAgICAgICAgc3VwZXIoYXBwKTtcclxuICAgICAgICAvLyBTdG9yZSBpbml0aWFsIHN0YXRlIGZvciByZXNldFxyXG4gICAgICAgIHRoaXMuaW5pdGlhbENvZGUgPSBpbml0aWFsQ29kZTtcclxuICAgICAgICB0aGlzLmV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZTtcclxuICAgICAgICB0aGlzLnVzZVRleHRBcmVhID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jaGVja2VkU3VjY2Vzc2Z1bGx5ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVGaWxlID0gYWN0aXZlRmlsZTtcclxuICAgICAgICB0aGlzLmZyb250bWF0dGVyID0gZnJvbnRtYXR0ZXI7IC8vIFN0b3JlIGZyb250bWF0dGVyIGRhdGFcclxuICAgICAgICB0aGlzLmN1cnJlbnRUeXBlID0gZXhwZWN0ZWRUeXBlOyAvLyBJbml0aWFsaXplIGN1cnJlbnQgdHlwZSB0byBleHBlY3RlZCB0eXBlXHJcbiAgICAgICAgdGhpcy5jdXJyZW50Q29kZSA9IGluaXRpYWxDb2RlOyAvLyBJbml0aWFsaXplIGN1cnJlbnQgY29kZSB0byBpbml0aWFsIGNvZGVcclxuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuICAgICAgICB0aGlzLnNjcmlwdGluZ1Rvb2xzID0gbmV3IFNjcmlwdGluZ1Rvb2xzKFxyXG4gICAgICAgICAgICBhcHAsXHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLFxyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncyxcclxuICAgICAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICB0aGlzLmZyb250bWF0dGVyLFxyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUZpbGUgaW5zdGFuY2VvZiBURmlsZSA/IHRoaXMuYWN0aXZlRmlsZSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5va0NhbGxiYWNrID0gb2tDYWxsYmFjaztcclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBjdXJyZW50IHN0YXRlIGZyb20gaW5pdGlhbCBzdGF0ZSBmb3IgZWRpdGluZ1xyXG4gICAgICAgIHRoaXMucmVzZXRTZWxlY3Rpb25Ub0luaXRpYWwoKTsgLy8gVXNlIGEgbWV0aG9kIGZvciBpbml0aWFsaXphdGlvbiBhbmQgcmVzZXRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGUgY3VycmVudCBzZWxlY3Rpb24gc3RhdGUgdG8gdGhlIGluaXRpYWwgc3RhdGUgcHJvdmlkZWQgYXQgY29uc3RydWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlc2V0U2VsZWN0aW9uVG9Jbml0aWFsKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuY3VycmVudENvZGUgPSB0aGlzLmluaXRpYWxDb2RlO1xyXG4gICAgICAgIHRoaXMuY21FZGl0b3I/LnNldFZhbHVlKHRoaXMuY3VycmVudENvZGUpOyAvLyBTZXQgdGhlIGluaXRpYWwgY29kZSBpbiB0aGUgZWRpdG9yXHJcbiAgICAgICAgaWYgKHRoaXMuZnVuY3Rpb25SZXN1bHRUZXh0Q29tcG9uZW50KSB0aGlzLmZ1bmN0aW9uUmVzdWx0VGV4dENvbXBvbmVudC5zZXRWYWx1ZSgnJyk7IC8vIENsZWFyIHRoZSByZXN1bHQgdGV4dCBjb21wb25lbnRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGUgY3VycmVudCBzZWxlY3Rpb24gc3RhdGUgdG8gZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVzZXRTZWxlY3Rpb25Ub0VtcHR5KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuY3VycmVudENvZGUgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgbGV0IHJlc3VsdCA9ICcnO1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59XCI7XHJcbiAgICAgICAgdGhpcy5jbUVkaXRvcj8uc2V0VmFsdWUodGhpcy5jdXJyZW50Q29kZSk7IC8vIFNldCB0aGUgaW5pdGlhbCBjb2RlIGluIHRoZSBlZGl0b3JcclxuICAgICAgICBpZiAodGhpcy5mdW5jdGlvblJlc3VsdFRleHRDb21wb25lbnQpIHRoaXMuZnVuY3Rpb25SZXN1bHRUZXh0Q29tcG9uZW50LnNldFZhbHVlKCcnKTsgLy8gQ2xlYXIgdGhlIHJlc3VsdCB0ZXh0IGNvbXBvbmVudCBcclxuICAgIH1cclxuXHJcbiAgICBsb2FkQ29kZU1pcnJvck1vZGUobW9kZTogc3RyaW5nKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIC8vIFZlcndlbmRlIHJlcXVpcmUgKGtcdTAwRjZubnRlIGluIHp1a1x1MDBGQ25mdGlnZW4gVmVyc2lvbmVuIHdlbmlnZXIgenV2ZXJsXHUwMEU0c3NpZyBzZWluKVxyXG4gICAgICAgICAgcmVxdWlyZShgb2JzaWRpYW4vbGliL2NvZGVtaXJyb3IvbW9kZS8ke21vZGV9LyR7bW9kZX0uanNgKTtcclxuICAgICAgICAgIGxvZ2dlci5sb2coREVCVUcsYENvZGVNaXJyb3IgbW9kZSAnJHttb2RlfScgbG9hZGVkIHN1Y2Nlc3NmdWxseSAodXNpbmcgcmVxdWlyZSkuYCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGxvZ2dlci5sb2coRVJST1IsYEZhaWxlZCB0byBsb2FkIENvZGVNaXJyb3IgbW9kZSAnJHttb2RlfScgKHVzaW5nIHJlcXVpcmUpOmAsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBtb2RhbCBpcyBvcGVuZWQuIEJ1aWxkcyB0aGUgVUkuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIG9uT3BlbigpIHtcclxuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcclxuICAgICAgICBpZiAoY29udGVudEVsLnBhcmVudEVsZW1lbnQpIGNvbnRlbnRFbC5wYXJlbnRFbGVtZW50LnN0eWxlLndpZHRoID0gJzkwMHB4JztcclxuICAgICAgICBjb250ZW50RWwuZW1wdHkoKTsgLy8gQ2xlYXIgcHJldmlvdXMgXHJcbiAgICAgICAgY29udGVudEVsLmFkZENsYXNzKCdjb2RlRWRpdG9yLW1vZGFsJyk7IFxyXG5cclxuICAgICAgICAvLyAtLS0gTW9kYWwgVGl0bGUgLS0tXHJcbiAgICAgICAgY29udGVudEVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ0phdmFTY3JpcHQgRWRpdG9yJyB9KTsgICAgXHJcbiAgICAgICAgY29udGVudEVsLmNyZWF0ZUVsKCdib2R5JywgeyB0ZXh0OiBgTWFrZSBzdXJlIHlvdXIgY29kZSByZXN1bHRzOiAke3RoaXMuZXhwZWN0ZWRUeXBlfWAgfSk7IFxyXG5cclxuICAgICAgICAvLyAtLS0gVHJlZSBDb250YWluZXIgLS0tXHJcbiAgICAgICAgdGhpcy5lZGl0b3JSb290RWxlbWVudCA9IGNvbnRlbnRFbC5jcmVhdGVEaXYoeyBjbHM6ICdjb2RlRWRpdG9yLWNvbnRhaW5lcicgfSk7XHJcbiAgICAgICAgLy8gQmFzaWMgc3R5bGluZyBmb3IgdGhlIHNjcm9sbGFibGUgdHJlZSBhcmVhXHJcbiAgICAgICAgLy8gdGhpcy5lZGl0b3JSb290RWxlbWVudC5zdHlsZS53aWR0aCA9ICc2MDBweCc7XHJcbiAgICAgICAgdGhpcy5lZGl0b3JSb290RWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnNjAwcHgnO1xyXG4gICAgICAgIHRoaXMuZWRpdG9yUm9vdEVsZW1lbnQuc3R5bGUub3ZlcmZsb3dZID0gJ2F1dG8nO1xyXG4gICAgICAgIC8vdGhpcy5lZGl0b3JSb290RWxlbWVudC5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkIHZhcigtLWJhY2tncm91bmQtbW9kaWZpZXItYm9yZGVyKSc7XHJcbiAgICAgICAgdGhpcy5lZGl0b3JSb290RWxlbWVudC5zdHlsZS5wYWRkaW5nID0gJzEwcHgnO1xyXG4gICAgICAgIHRoaXMuZWRpdG9yUm9vdEVsZW1lbnQuc3R5bGUubWFyZ2luVG9wID0gJzEwcHgnO1xyXG4gICAgICAgIHRoaXMuZWRpdG9yUm9vdEVsZW1lbnQuc3R5bGUubWFyZ2luQm90dG9tID0gJzEwcHgnO1xyXG5cclxuICAgICAgICB0aGlzLmNtRWRpdG9yID0gbnVsbDtcclxuXHJcbiAgICAgICAgY29uc3QgcnVsZU9wdGlvbnNEaXYgPSBjb250ZW50RWwuY3JlYXRlRGl2KHsgY2xzOiBcImNvZGVFZGl0b3Itb3B0aW9uc1wiIH0pO1xyXG5cclxuICAgICAgICBpZiAodGhpcy51c2VUZXh0QXJlYSkge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlT3B0aW9uc1NldHRpbmdzID0gbmV3IFNldHRpbmcodGhpcy5lZGl0b3JSb290RWxlbWVudClcclxuICAgICAgICAgICAgICAgIC5hZGRUZXh0QXJlYSh0ZXh0QXJlYSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFyZWEuc2V0UGxhY2Vob2xkZXIoJ2VuZGVyIHZhbGlkIEpTIENvZGUnKTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0QXJlYS5pbnB1dEVsLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBgaGVpZ2h0OjE5MHB4OyB3aWR0aDo4MCU7YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFyZWEub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZ1bmN0aW9uVGVzdEJ1dHRvbikgdGhpcy5mdW5jdGlvblRlc3RCdXR0b24uYnV0dG9uRWwuYWRkQ2xhc3MoJ21vZC13YXJuaW5nJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENvZGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICBsZXQgdmlldyA9IG5ldyBFZGl0b3JWaWV3KHtcclxuICAgICAgICAgICAgICAgIHN0YXRlOiBFZGl0b3JTdGF0ZS5jcmVhdGUoe1xyXG4gICAgICAgICAgICAgICAgICBkb2M6IHRoaXMuY3VycmVudENvZGUsICAvLyBvciBzb21lIHN0cmluZyBjb250ZW50c1xyXG4gICAgICAgICAgICAgICAgICBleHRlbnNpb25zOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgRWRpdG9yVmlldy5saW5lV3JhcHBpbmcsIC8vIEFkZCB5b3VyIGV4dGVudGlvbnMgaGVyZVxyXG4gICAgICAgICAgICAgICAgICAgIGphdmFzY3JpcHQoKSxcclxuICAgICAgICAgICAgICAgICAgICAvLyBzY2VuZUd1dHRlciwgLy8gb3IgbGVhdmUgZW1wdHkgZm9yIGJhc2ljIGVkaXRvclxyXG4gICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IHRoaXMuZWRpdG9yUm9vdEVsZW1lbnRcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBDb2RlTWlycm9yIDVcclxuICAgICAgICAgICAgLy8gQ29kZU1pcnJvci1CaWJsaW90aGVrIGFicnVmZW5cclxuICAgICAgICAgICAgY29uc3QgQ29kZU1pcnJvciA9ICh3aW5kb3cgYXMgYW55KS5Db2RlTWlycm9yO1xyXG4gICAgICAgICAgICAvLyBTaWNoZXJzdGVsbGVuLCBkYXNzIENvZGVNaXJyb3IgZ2VsYWRlbiBpc3RcclxuICAgICAgICAgICAgaWYgKENvZGVNaXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIC8vIEphdmFTY3JpcHQtTW9kdXMgbGFkZW4gKGZhbGxzIG5vY2ggbmljaHQgZ2VsYWRlbilcclxuICAgICAgICAgICAgICAgIGlmICghQ29kZU1pcnJvci5tb2Rlcy5qYXZhc2NyaXB0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5sb2FkQ29kZU1pcnJvck1vZGUoJ2phdmFzY3JpcHQnKTtcclxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFRSQUNFLCdqYXZhU2NyaXB0IHN1cHBvcnQgbG9hZGVkJylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgbGV0IGpzQ29kZSA9IHRoaXMuY3VycmVudENvZGU7XHJcbiAgICAgICAgICAgIHRoaXMuY21FZGl0b3IgPSBDb2RlTWlycm9yKHRoaXMuZWRpdG9yUm9vdEVsZW1lbnQsIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBqc0NvZGUgfHwgXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIGxldCByZXN1bHQgPSAnJztcXG4gIHJldHVybiByZXN1bHQ7IC8vIHJldHVybiB5b3UgcmVzdWx0Llxcbn1cIixcclxuICAgICAgICAgICAgICAgIG1vZGU6IFwiamF2YXNjcmlwdFwiLFxyXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcnM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB0aGVtZTogXCJvYnNpZGlhblwiLFxyXG4gICAgICAgICAgICAgICAgaW5kZW50VW5pdDogNCwgIFxyXG4gICAgICAgICAgICAgICAgbGluZVdyYXBwaW5nOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHJlYWRPbmx5OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIG91dGVySGVpZ2h0OiAnNjAwcHgnLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNtRWRpdG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNtRWRpdG9yLm9uKCdjaGFuZ2UnLCAoY21FZGl0b3I6IENvZGVNaXJyb3IuRWRpdG9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZnVuY3Rpb25UZXN0QnV0dG9uKSB0aGlzLmZ1bmN0aW9uVGVzdEJ1dHRvbi5idXR0b25FbC5hZGRDbGFzcygnbW9kLXdhcm5pbmcnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbUVkaXRvci5vbignYmx1cicsIChjbUVkaXRvcjogQ29kZU1pcnJvci5FZGl0b3IpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDb2RlPSBjbUVkaXRvci5nZXRWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEFkZCBhIGJ1dHRvbiB0byBzYXZlIHRoZSBjb2RlXHJcbiAgICAgICAgICAgIG5ldyBTZXR0aW5nKHJ1bGVPcHRpb25zRGl2KVxyXG4gICAgICAgICAgICAgICAgLmFkZEJ1dHRvbigoYnV0dG9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mdW5jdGlvblRlc3RCdXR0b24gPSBidXR0b247XHJcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFdhcm5pbmcoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KFwiUnVuIENvZGVcIilcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VG9vbHRpcChcIlJ1biB0aGUgY29kZSBhbmQgY2hlY2sgZm9yIGVycm9yc1wiKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY21FZGl0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBqc0NvZGUgPSB0aGlzLmNtRWRpdG9yLmdldFZhbHVlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHVzZXJGdW5jdGlvbiA9ICBwYXJzZUpTQ29kZShqc0NvZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB1c2VyRnVuY3Rpb24gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVycm9ySGludCA9IFwiU2VlIGNvbnNvbGUgZm9yIGRldGFpbHMhXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJGdW5jdGlvbi5jb250YWlucygnVW5leHBlY3RlZCB0b2tlbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ySGludCA9IFwiRGlkIHlvdSBtaXNzZWQgYSBzZW1pY29sb24gKDspP1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mdW5jdGlvblJlc3VsdFRleHRDb21wb25lbnQpIHRoaXMuZnVuY3Rpb25SZXN1bHRUZXh0Q29tcG9uZW50LnNldFZhbHVlKGBTeW50YXggZXJyb3I6ICR7dXNlckZ1bmN0aW9ufSEgJHtlcnJvckhpbnR9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja2VkU3VjY2Vzc2Z1bGx5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLmJ1dHRvbkVsLmFkZENsYXNzKCdtb2Qtd2FybmluZycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlckZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB1c2VyRnVuY3Rpb24odGhpcy5hcHAsIHRoaXMuYWN0aXZlRmlsZSwgdGhpcy5zY3JpcHRpbmdUb29scylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZ1bmN0aW9uUmVzdWx0VGV4dENvbXBvbmVudCkgdGhpcy5mdW5jdGlvblJlc3VsdFRleHRDb21wb25lbnQuc2V0VmFsdWUoYCcke3Jlc3VsdC50b1N0cmluZygpfScgKCR7dHlwZW9mIHJlc3VsdH0pYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVR5cGVJY29ucyhyZXN1bHQsIHR5cGVzQ29udGFpbmVyLCB0aGlzLmV4cGVjdGVkVHlwZSwgdGhpcy5jdXJyZW50VHlwZSwgdGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLmJ1dHRvbkVsLnJlbW92ZUNsYXNzKCdtb2Qtd2FybmluZycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja2VkU3VjY2Vzc2Z1bGx5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZnVuY3Rpb25SZXN1bHRUZXh0Q29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gKGUgaW5zdGFuY2VvZiBFcnJvcikgPyBlLm1lc3NhZ2UgOiBTdHJpbmcoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mdW5jdGlvblJlc3VsdFRleHRDb21wb25lbnQuc2V0VmFsdWUoYFN5bnRheCBlcnJvcjogJHtlcnJvck1lc3NhZ2V9ISBTZWUgY29uc29sZSBmb3IgZGV0YWlscyFgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coRVJST1IsXCJTeW50YXggZXJyb3IuIFwiLCBlLCBqc0NvZGUsIHVzZXJGdW5jdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrZWRTdWNjZXNzZnVsbHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5idXR0b25FbC5hZGRDbGFzcygnbW9kLXdhcm5pbmcnKTsgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKEVSUk9SLFwic3ludGF4IGVycm9yXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrZWRTdWNjZXNzZnVsbHkgPSBmYWxzZTsgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mdW5jdGlvblJlc3VsdFRleHRDb21wb25lbnQgPSB0ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRcclxuICAgICAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ2Z1bmN0aW9uIHJlc3VsdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldERpc2FibGVkKHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mdW5jdGlvblJlc3VsdFRleHRDb21wb25lbnQuaW5wdXRFbC5zdHlsZS53aWR0aCA9ICc1ODBweCc7XHJcblxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVzQ29udGFpbmVyID0gcnVsZU9wdGlvbnNEaXYuY3JlYXRlRGl2KHsgY2xzOiAncHJvcGVydHktaWNvbnMtY29udGFpbmVyJyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gLS0tIEFjdGlvbiBCdXR0b25zIC0tLVxyXG4gICAgICAgIHRoaXMuY3JlYXRlQWN0aW9uQnV0dG9ucyhjb250ZW50RWwpOyAvLyBDcmVhdGUgT0sgYW5kIFJlc2V0IGJ1dHRvbnNcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVUeXBlSWNvbnModmFsdWU6YW55LCBjb250YWluZXI6IEhUTUxEaXZFbGVtZW50LCBleHBlY3RlZFR5cGU6IE9ic2lkaWFuUHJvcGVydHlUeXBlcywgY3VycmVudFR5cGU6IE9ic2lkaWFuUHJvcGVydHlUeXBlcywgc2V0dGluZ3M6IGFueSkge1xyXG4gICAgICAgIGNvbnN0IG5ld1R5cGUgPSB0eXBlb2YgdmFsdWU7XHJcbiAgICAgICAgY29uc3QgdHlwZUljb25zOiB7W2tleTpzdHJpbmddOiBPYnNpZGlhblByb3BlcnR5VHlwZXNbXX0gPSB7XHJcbiAgICAgICAgICAgICdzdHJpbmcnOiBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCcsJ2RhdGUnLCAnZGF0ZXRpbWUnXSxcclxuICAgICAgICAgICAgJ251bWJlcic6IFsnbnVtYmVyJ10sXHJcbiAgICAgICAgICAgICdib29sZWFuJzogWydjaGVja2JveCddLFxyXG4gICAgICAgICAgICAnb2JqZWN0JzogWyd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J11cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChuZXdUeXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuc2NyaXB0aW5nVG9vbHMuaXNJU09TdHJpbmcodmFsdWUsIHt3aXRoRGF0ZTogdHJ1ZX0pKSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlSWNvbnNbbmV3VHlwZV0uc3BsaWNlKHR5cGVJY29uc1tuZXdUeXBlXS5pbmRleE9mKCdkYXRlJyksIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5zY3JpcHRpbmdUb29scy5pc0lTT1N0cmluZyh2YWx1ZSwge3dpdGhEYXRlOiB0cnVlLCB3aXRoVGltZTogdHJ1ZX0pKSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlSWNvbnNbbmV3VHlwZV0uc3BsaWNlKHR5cGVJY29uc1tuZXdUeXBlXS5pbmRleE9mKCdkYXRldGltZScpLCAxKTsgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGFpbmVyLmVtcHR5KCk7IC8vIENsZWFyIHRoZSBjb250YWluZXIgYmVmb3JlIGFkZGluZyBuZXcgaWNvbnNcclxuICAgICAgICBmb3IgKGxldCBvYnNpZGlhblR5cGUgb2YgdHlwZUljb25zW25ld1R5cGVdKSB7XHJcbiAgICAgICAgICAgIGlmIChvYnNpZGlhblR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGljb25FbCA9IGNvbnRhaW5lci5jcmVhdGVTcGFuKHsgY2xzOiAncHJvcGVydHktaWNvbiBzZXR0aW5nLWl0ZW0taWNvbicgfSk7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVQcm9wZXJ0eUljb24oaWNvbkVsLCBvYnNpZGlhblR5cGUpOyAvLyBVcGRhdGUgdGhlIGljb24gYmFzZWQgb24gdGhlIHR5cGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIFwiT0tcIiBhbmQgXCJSZXNldFwiIGJ1dHRvbnMuXHJcbiAgICAgKiBAcGFyYW0gY29udGFpbmVyRWwgLSBUaGUgSFRNTCBlbGVtZW50IHRvIGFwcGVuZCB0aGUgYnV0dG9ucyB0by5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjcmVhdGVBY3Rpb25CdXR0b25zKGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGJ1dHRvbnNFbCA9IGNvbnRhaW5lckVsLmNyZWF0ZURpdih7IGNsczogJ21vZGFsLWJ1dHRvbnMnIH0pO1xyXG4gICAgICAgIGJ1dHRvbnNFbC5zdHlsZS5tYXJnaW5Ub3AgPSAnMTVweCc7XHJcbiAgICAgICAgYnV0dG9uc0VsLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7IC8vIFVzZSBmbGV4IGZvciBhbGlnbm1lbnRcclxuICAgICAgICBidXR0b25zRWwuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSAnZmxleC1lbmQnOyAvLyBBbGlnbiBidXR0b25zIHRvIHRoZSByaWdodFxyXG4gICAgICAgIGJ1dHRvbnNFbC5zdHlsZS5nYXAgPSAnMTBweCc7IC8vIFNwYWNlIGJldHdlZW4gYnV0dG9uc1xyXG5cclxuICAgICAgICAvLyBSZXNldCBCdXR0b24gKFVuZG8gXHUyMUFBXHVGRTBGKVxyXG4gICAgICAgIGNvbnN0IHJlc2V0QnV0dG9uID0gYnV0dG9uc0VsLmNyZWF0ZUVsKCdidXR0b24nKTtcclxuICAgICAgICAvLyBVc2UgT2JzaWRpYW4ncyBzZXRJY29uIGZvciBjb25zaXN0ZW5jeSwgb3IgdXNlIHRleHRcclxuICAgICAgICBzZXRJY29uKHJlc2V0QnV0dG9uLCAncmVzZXQnKTsgLy8gVXNlIGEgc3VpdGFibGUgaWNvbiBsaWtlICdyZXNldCcgb3IgJ3VuZG8nXHJcbiAgICAgICAgcmVzZXRCdXR0b24uYXJpYUxhYmVsID0gJ1Jlc2V0IHNlbGVjdGlvbic7IC8vIEFjY2Vzc2liaWxpdHlcclxuICAgICAgICByZXNldEJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlc2V0U2VsZWN0aW9uVG9Jbml0aWFsKCk7IC8vIFJlc2V0IGludGVybmFsIHN0YXRlXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gQ2xlYXIgQnV0dG9uIChDbGVhciBcdUQ4M0RcdURFQUUpXHJcbiAgICAgICAgY29uc3QgZW1wdHlCdXR0b24gPSBidXR0b25zRWwuY3JlYXRlRWwoJ2J1dHRvbicpO1xyXG4gICAgICAgIC8vIFVzZSBPYnNpZGlhbidzIHNldEljb24gZm9yIGNvbnNpc3RlbmN5LCBvciB1c2UgdGV4dFxyXG4gICAgICAgIHNldEljb24oZW1wdHlCdXR0b24sICdlcmFzZXInKTsgLy8gVXNlIGEgc3VpdGFibGUgaWNvbiBsaWtlICdyZXNldCcgb3IgJ3VuZG8nXHJcbiAgICAgICAgZW1wdHlCdXR0b24uYXJpYUxhYmVsID0gJ0NsZWFyIHNlbGVjdGlvbic7IC8vIEFjY2Vzc2liaWxpdHlcclxuICAgICAgICBlbXB0eUJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlc2V0U2VsZWN0aW9uVG9FbXB0eSgpOyAvLyBDbGVhciBzdGF0ZVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIGNhbmNlbCBCdXR0b25cclxuICAgICAgICBjb25zdCBjYW5jZWxCdXR0b24gPSBidXR0b25zRWwuY3JlYXRlRWwoJ2J1dHRvbicsIHsgdGV4dDogJ0NhbmNlbCcgfSk7XHJcbiAgICAgICAgY2FuY2VsQnV0dG9uLmFyaWFMYWJlbCA9ICdjbG9zZSBhbmQgZGlzY2FyZCBjaGFuZ2VzJzsgLy8gQWNjZXNzaWJpbGl0eVxyXG4gICAgICAgIGNhbmNlbEJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBsb2dnZXIubG9nKFRSQUNFLFwiQ2FuY2VsIENsaWNrZWQgLSBSZXR1cm5pbmdcIik7IC8vIERlYnVnIGxvZ1xyXG4gICAgICAgICAgICB0aGlzLm9rQ2FsbGJhY2soIG51bGwgKTsgLy8gUGFzcyB0aGUgZmluYWwgc2VsZWN0aW9uIGJhY2tcclxuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIE9LIEJ1dHRvblxyXG4gICAgICAgIGNvbnN0IG9rQnV0dG9uID0gYnV0dG9uc0VsLmNyZWF0ZUVsKCdidXR0b24nLCB7IHRleHQ6ICdPSycsIGNsczogJ21vZC1jdGEnIH0pO1xyXG4gICAgICAgIGNhbmNlbEJ1dHRvbi5hcmlhTGFiZWwgPSAnY2xvc2UgYW5kIHNhdmUgY2hhbmdlcyc7IC8vIEFjY2Vzc2liaWxpdHlcclxuICAgICAgICBva0J1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIG1vZGFsIGlzIGNsb3NlZC4gQ2xlYW5zIHVwIHJlc291cmNlcy5cclxuICAgICAqL1xyXG4gICAgb25DbG9zZSgpIHtcclxuICAgICAgICAvLyBHYXRoZXIgdGhlIGZpbmFsIHN0YXRlIE9OTFkgd2hlbiBPSyBpcyBjbGlja2VkXHJcbiAgICAgICAgY29uc3QgcmVzdWx0OiBjb2RlRWRpdG9yTW9kYWxSZXN1bHQgPSB7XHJcbiAgICAgICAgICAgIGNvZGU6IHRoaXMuY3VycmVudENvZGUsXHJcbiAgICAgICAgICAgIGNoZWNrZWQ6IHRoaXMuY2hlY2tlZFN1Y2Nlc3NmdWxseSxcclxuICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhUUkFDRSxcIk9LIENsaWNrZWQgLSBSZXR1cm5pbmcgUmVzdWx0OlwiLCByZXN1bHQpOyAvLyBEZWJ1ZyBsb2dcclxuICAgICAgICB0aGlzLm9rQ2FsbGJhY2socmVzdWx0KTsgLy8gUGFzcyB0aGUgZmluYWwgc2VsZWN0aW9uIGJhY2tcclxuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcclxuICAgICAgICBjb250ZW50RWwuZW1wdHkoKTsgLy8gQ2xlYXIgdGhlIG1vZGFsJ3MgY29udGVudFxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGVhc2lseSBvcGVuIHRoZSBEaXJlY3RvcnkgU2VsZWN0aW9uIE1vZGFsLlxyXG4gKlxyXG4gKiBAcGFyYW0gYXBwIC0gVGhlIE9ic2lkaWFuIEFwcCBpbnN0YW5jZS5cclxuICogQHBhcmFtIGluaXRpYWxDb2RlIC0gU3RyaW5nIHdpdGggdGhlIGluaXRpYWwgY29kZS5cclxuICogQHBhcmFtIGV4cGVjdGVkVHlwZSAtIEV4cGVjdGVkIHJldHVybiB0eXBlLlxyXG4gKiBAcGFyYW0gb2tDYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgdXNlciBjbGlja3MgXCJPS1wiLiBSZWNlaXZlcyB0aGUgc2VsZWN0aW9uIHJlc3VsdC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBvcGVuQ29kZUVkaXRvck1vZGFsKFxyXG4gICAgYXBwOiBBcHAsXHJcbiAgICBwbHVnaW46IGFueSxcclxuICAgIGluaXRpYWxDb2RlOiBzdHJpbmcsXHJcbiAgICBleHBlY3RlZFR5cGU6IE9ic2lkaWFuUHJvcGVydHlUeXBlcyxcclxuICAgIGFjdGl2ZUZpbGU6IFRGaWxlIHwgVEZvbGRlciB8IG51bGwsXHJcbiAgICBmcm9udG1hdHRlcjogYW55LFxyXG4gICAgb2tDYWxsYmFjazogKHJlc3VsdDogY29kZUVkaXRvck1vZGFsUmVzdWx0IHwgbnVsbCkgPT4gdm9pZFxyXG4pOiB2b2lkIHtcclxuICAgIC8vIENyZWF0ZSBhbmQgb3BlbiB0aGUgbW9kYWwgaW5zdGFuY2VcclxuICAgIG5ldyBjb2RlRWRpdG9yTW9kYWwoXHJcbiAgICAgICAgYXBwLFxyXG4gICAgICAgIHBsdWdpbixcclxuICAgICAgICBpbml0aWFsQ29kZSxcclxuICAgICAgICBleHBlY3RlZFR5cGUsXHJcbiAgICAgICAgYWN0aXZlRmlsZSxcclxuICAgICAgICBmcm9udG1hdHRlcixcclxuICAgICAgICBva0NhbGxiYWNrXHJcbiAgICApLm9wZW4oKTtcclxufSIsICJpbXBvcnQgeyBzZXRJY29uLCBUZXh0Q29tcG9uZW50IH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7IE9ic2lkaWFuUHJvcGVydHlUeXBlcywgUHJvcGVydHlJbmZvIH0gZnJvbSBcIi4vdHlwZXNcIjtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJWYWx1ZUlucHV0KGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCwgcHJvcGVydHlJbmZvOiBQcm9wZXJ0eUluZm8gfCB1bmRlZmluZWQsIGN1cnJlbnRWYWx1ZTogYW55LCBjaGFuZ2VDYWxsYmFjazogKHByb3BlcnR5SW5mbzogUHJvcGVydHlJbmZvIHwgdW5kZWZpbmVkLCB2YWx1ZTogYW55KSA9PiB2b2lkKSB7XHJcbiAgICBsZXQgcmV0dXJuQ29tcG9uZW50OmFueTtcclxuICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7IFxyXG5cclxuICAgIGlmICghcHJvcGVydHlJbmZvKSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lckVsLnNldFRleHQoJycpO1xyXG4gICAgICAgICAgICBjb250YWluZXJFbC5hZGRDbGFzcygndGV4dC1tdXRlZCcpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdHlwZSA9IHByb3BlcnR5SW5mby50eXBlO1xyXG5cclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ251bWJlcic6XHJcbiAgICAgICAgICAgIHJldHVybkNvbXBvbmVudCA9IG5ldyBUZXh0Q29tcG9uZW50KGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdOdW1lcmljIFZhbHVlJylcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShjdXJyZW50VmFsdWUgIT09IHVuZGVmaW5lZCAmJiBjdXJyZW50VmFsdWUgIT09IG51bGwgPyBTdHJpbmcoY3VycmVudFZhbHVlKSA6ICcnKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG51bVZhbHVlID0gdmFsdWUgPT09ICcnID8gdW5kZWZpbmVkIDogcGFyc2VGbG9hdCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlQ2FsbGJhY2socHJvcGVydHlJbmZvLCBpc05hTihudW1WYWx1ZSBhcyBudW1iZXIpID8gdW5kZWZpbmVkIDogbnVtVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIHJldHVybkNvbXBvbmVudC5pbnB1dEVsLnR5cGUgPSAnbnVtYmVyJztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxyXG4gICAgICAgICAgICByZXR1cm5Db21wb25lbnQgPSBjb250YWluZXJFbC5jcmVhdGVEaXYoeyBjbHM6ICd0cmktc3RhdGUtY2hlY2tib3ggY2xpY2thYmxlLWljb24nIH0pO1xyXG4gICAgICAgICAgICByZXR1cm5Db21wb25lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgJ0NoZWNrYm94IGNoYW5nZSBzdGF0ZScpO1xyXG4gICAgICAgICAgICByZXR1cm5Db21wb25lbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2NoZWNrYm94Jyk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVDaGVja2JveFZpc3VhbCA9IChzdGF0ZTogYm9vbGVhbiB8IHVuZGVmaW5lZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGljb25OYW1lOiBzdHJpbmc7XHJcbiAgICAgICAgICAgICAgICBsZXQgYXJpYVN0YXRlOiAndHJ1ZScgfCAnZmFsc2UnIHwgJ21peGVkJztcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGljb25OYW1lID0gJ2NoZWNrLXNxdWFyZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJpYVN0YXRlID0gJ3RydWUnO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpY29uTmFtZSA9ICdzcXVhcmUnO1xyXG4gICAgICAgICAgICAgICAgICAgIGFyaWFTdGF0ZSA9ICdmYWxzZSc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyB1bmRlZmluZWQgb3IgbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgIGljb25OYW1lID0gJ21pbnVzLXNxdWFyZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJpYVN0YXRlID0gJ21peGVkJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNldEljb24ocmV0dXJuQ29tcG9uZW50LCBpY29uTmFtZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5Db21wb25lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnLCBhcmlhU3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50LmRhdGFzZXQuc3RhdGUgPSBTdHJpbmcoc3RhdGUpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdXBkYXRlQ2hlY2tib3hWaXN1YWwoY3VycmVudFZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybkNvbXBvbmVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50U3RhdGUgPSByZXR1cm5Db21wb25lbnQuZGF0YXNldC5zdGF0ZTtcclxuICAgICAgICAgICAgICAgIGxldCBuZXh0U3RhdGU6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gJ2ZhbHNlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gJ3RydWUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlID0gdW5kZWZpbmVkOyBcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7IFxyXG4gICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZSA9IGZhbHNlOyBcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VDYWxsYmFjayhwcm9wZXJ0eUluZm8sICBuZXh0U3RhdGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIHVwZGF0ZUNoZWNrYm94VmlzdWFsKG5leHRTdGF0ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnZGF0ZSc6XHJcbiAgICAgICAgICAgIHJldHVybkNvbXBvbmVudCA9IG5ldyBUZXh0Q29tcG9uZW50KGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdZWVlZLU1NLUREJylcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShjdXJyZW50VmFsdWUgfHwgJycpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlQ2FsbGJhY2socHJvcGVydHlJbmZvLCB2YWx1ZSB8fCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIHJldHVybkNvbXBvbmVudC5pbnB1dEVsLnR5cGUgPSAnZGF0ZSc7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2RhdGV0aW1lJzpcclxuICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50ID0gbmV3IFRleHRDb21wb25lbnQoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ1lZWVktTU0tRERUSEg6bW0nKVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKGN1cnJlbnRWYWx1ZSB8fCAnJylcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VDYWxsYmFjayhwcm9wZXJ0eUluZm8sIHZhbHVlIHx8IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50LmlucHV0RWwudHlwZSA9ICdkYXRldGltZS1sb2NhbCc7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2FsaWFzZXMnOlxyXG4gICAgICAgIGNhc2UgJ3RhZ3MnOlxyXG4gICAgICAgIGNhc2UgJ211bHRpdGV4dCc6XHJcbiAgICAgICAgICAgIHJldHVybkNvbXBvbmVudCA9IG5ldyBUZXh0Q29tcG9uZW50KGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCd2YWx1ZXMgKGRpdmlkZWQgYnkgY29tbWEpJylcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShBcnJheS5pc0FycmF5KGN1cnJlbnRWYWx1ZSkgPyBjdXJyZW50VmFsdWUuam9pbignLCAnKSA6IChjdXJyZW50VmFsdWUgfHwgJycpKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5VmFsdWUgPSB2YWx1ZS5zcGxpdCgnLCcpLm1hcChzID0+IHMudHJpbSgpKS5maWx0ZXIocyA9PiBzKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VDYWxsYmFjayhwcm9wZXJ0eUluZm8sIGFycmF5VmFsdWUubGVuZ3RoID4gMCA/IGFycmF5VmFsdWUgOiB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3RleHQnOlxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybkNvbXBvbmVudCA9IG5ldyBUZXh0Q29tcG9uZW50KGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCd2YWx1ZScpXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUoY3VycmVudFZhbHVlIHx8ICcnKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUNhbGxiYWNrKHByb3BlcnR5SW5mbywgdmFsdWUgfHwgdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICBpZiAodHlwZSAhPT0gJ2NoZWNrYm94Jykge1xyXG4gICAgICAgIHJldHVybkNvbXBvbmVudC5pbnB1dEVsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd0cmFuc3BhcmVudCc7IC8vIG1ha2UgaXQgaW52aXNpYmxlXHJcbiAgICAgICAgcmV0dXJuQ29tcG9uZW50LmlucHV0RWwuc3R5bGUud2lkdGggPSAnMTAwJSc7XHJcbiAgICAgICAgcmV0dXJuQ29tcG9uZW50LmlucHV0RWwuc3R5bGUuYm9yZGVyID0gJ25vbmUnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldHVybkNvbXBvbmVudDtcclxufSBcclxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVByb3BlcnR5SWNvbihpY29uRWw6IEhUTUxFbGVtZW50LCB0eXBlOiBPYnNpZGlhblByb3BlcnR5VHlwZXMgfCB1bmRlZmluZWQpIHtcclxuICAgIGxldCBpY29uTmFtZSA9ICdoYXNoJztcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ3RleHQnOiBpY29uTmFtZSA9ICdhbGlnbi1sZWZ0JzsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnbnVtYmVyJzogaWNvbk5hbWUgPSAnYmluYXJ5JzsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnbXVsdGl0ZXh0JzogaWNvbk5hbWUgPSAnbGlzdCc7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2RhdGUnOiBpY29uTmFtZSA9ICdjYWxlbmRhcic7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2RhdGV0aW1lJzogaWNvbk5hbWUgPSAnY2xvY2snOyBicmVhaztcclxuICAgICAgICBjYXNlICdjaGVja2JveCc6IGljb25OYW1lID0gJ2NoZWNrLXNxdWFyZSc7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3RhZ3MnOiBpY29uTmFtZSA9ICd0YWdzJzsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnYWxpYXNlcyc6IGljb25OYW1lID0gJ2ZvcndhcmQnOyBicmVhaztcclxuIFxyXG4gICAgICAgIGRlZmF1bHQ6IGljb25OYW1lID0gJ2hlbHAtY2lyY2xlJztcclxuICAgIH1cclxuICAgIHNldEljb24oaWNvbkVsLCBpY29uTmFtZSk7XHJcbn0iLCAiaW1wb3J0IHsgU2V0dGluZywgRXh0cmFCdXR0b25Db21wb25lbnQgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHR5cGUgeyBQcm9wZXJ0eVR5cGVJbmZvIH0gZnJvbSBcIi4vdHlwZXNcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBNdWx0aVByb3BlcnR5U2V0dGluZyB7XHJcbiAgICBwdWJsaWMgc2V0dGluZ0VsOiBIVE1MRWxlbWVudDtcclxuICAgIHByaXZhdGUgbmFtZTogc3RyaW5nID0gXCJcIjtcclxuICAgIHByaXZhdGUgZGVzYzogc3RyaW5nID0gXCJcIjtcclxuICAgIHByaXZhdGUgdmFsdWU6IHN0cmluZ1tdID0gW107XHJcbiAgICBwcml2YXRlIG9uQ2hhbmdlQ2I6ICh2YWw6IHN0cmluZ1tdKSA9PiB2b2lkID0gKCkgPT4ge307XHJcbiAgICBwcml2YXRlIG9wdGlvbnM6IHN0cmluZ1tdIHwgQXJyYXk8e2lkOiBzdHJpbmcsIG5hbWU6IHN0cmluZ30+ID0gW107XHJcbiAgICBwcml2YXRlIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIGV4dHJhQnV0dG9uQ2FsbGJhY2tzOiAoKHNldHRpbmc6IFNldHRpbmcsIGlkeDogbnVtYmVyKSA9PiB2b2lkKVtdID0gW107XHJcblxyXG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyOiBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgICAgIHRoaXMuc2V0dGluZ0VsID0gY29udGFpbmVyLmNyZWF0ZURpdigpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldE5hbWUobmFtZTogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBzZXREZXNjKGRlc2M6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuZGVzYyA9IGRlc2M7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0VmFsdWUodmFsdWU6IHN0cmluZ1tdKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlLmxlbmd0aCA/IFsuLi52YWx1ZV0gOiBbXCJcIl07XHJcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBzZXRPcHRpb25zKG9wdGlvbnM6IHN0cmluZ1tdIHwgQXJyYXk8e2lkOiBzdHJpbmcsIG5hbWU6IHN0cmluZ30+KSB7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIG9uQ2hhbmdlKGNiOiAodmFsOiBzdHJpbmdbXSkgPT4gdm9pZCkge1xyXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYiA9IGNiO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWxsb3dzIGFkZGluZyBleHRyYSBidXR0b25zIHRvIGVhY2ggcm93LlxyXG4gICAgICogVGhlIGNhbGxiYWNrIHJlY2VpdmVzIHRoZSBTZXR0aW5nIGFuZCB0aGUgcm93IGluZGV4LlxyXG4gICAgICovXHJcbiAgICBhZGRFeHRyYUJ1dHRvbihjYjogKHNldHRpbmc6IFNldHRpbmcsIGlkeDogbnVtYmVyKSA9PiB2b2lkKSB7XHJcbiAgICAgICAgdGhpcy5leHRyYUJ1dHRvbkNhbGxiYWNrcy5wdXNoKGNiKTtcclxuICAgICAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHN0eWxlRGlzYWJsZWQoZWw6IEV4dHJhQnV0dG9uQ29tcG9uZW50LCBkaXNhYmxlZDogYm9vbGVhbikge1xyXG4gICAgICAgIGlmIChkaXNhYmxlZCkge1xyXG4gICAgICAgICAgICBlbC5leHRyYVNldHRpbmdzRWwuYWRkQ2xhc3MoJ21vZC1kaXNhYmxlZCcpO1xyXG4gICAgICAgICAgICBlbC5leHRyYVNldHRpbmdzRWwuc2V0QXR0cignYXJpYS1kaXNhYmxlZCcsICd0cnVlJyk7XHJcbiAgICAgICAgICAgIGVsLmV4dHJhU2V0dGluZ3NFbC50YWJJbmRleCA9IC0xO1xyXG4gICAgICAgICAgICBlbC5leHRyYVNldHRpbmdzRWwucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWxhYmVsJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZWwuZXh0cmFTZXR0aW5nc0VsLnJlbW92ZUNsYXNzKCdtb2QtZGlzYWJsZWQnKTtcclxuICAgICAgICAgICAgZWwuZXh0cmFTZXR0aW5nc0VsLnNldEF0dHIoJ2FyaWEtZGlzYWJsZWQnLCAnZmFsc2UnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSByZW5kZXIoKSB7XHJcbiAgICAgICAgdGhpcy5zZXR0aW5nRWwuZW1wdHkoKTtcclxuICAgICAgICBjb25zdCBhcnIgPSB0aGlzLnZhbHVlO1xyXG5cclxuICAgICAgICBhcnIuZm9yRWFjaCgoc2VsZWN0ZWQsIGlkeCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nID0gbmV3IFNldHRpbmcodGhpcy5zZXR0aW5nRWwpXHJcbiAgICAgICAgICAgICAgICAuc2V0TmFtZShpZHggPT09IDAgPyB0aGlzLm5hbWUgOiBcIlwiKVxyXG4gICAgICAgICAgICAgICAgLnNldERlc2MoaWR4ID09PSAwID8gdGhpcy5kZXNjIDogXCJcIilcclxuICAgICAgICAgICAgICAgIC5hZGREcm9wZG93bihkZCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZvckVhY2goKGl0ZW0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGQuYWRkT3B0aW9uKGl0ZW0sIGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGQuYWRkT3B0aW9uKGl0ZW0uaWQsIGl0ZW0ubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBkZC5zZXRWYWx1ZShzZWxlY3RlZCB8fCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICBkZC5vbkNoYW5nZSgodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyW2lkeF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGFycjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNoYW5nZUNiKFsuLi5hcnJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaWR4ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZy5zZXR0aW5nRWwuc3R5bGUuYm9yZGVyVG9wID0gJ25vbmUnOyAvLyBSZW1vdmUgYm9yZGVyIGZvciBhbGwgYnV0IHRoZSBmaXJzdCBpdGVtXHJcbiAgICAgICAgICAgICAgICBzZXR0aW5nLnNldHRpbmdFbC5zdHlsZS5wYWRkaW5nID0gJzAgMCAwLjc1ZW0nOyAvLyBSZW1vdmUgbWFyZ2luIGZvciBhbGwgYnV0IHRoZSBmaXJzdCBpdGVtXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5nLnNldHRpbmdFbC5zdHlsZS5ib3JkZXJUb3AgPSAnMXB4IHNvbGlkIHZhcigtLWJhY2tncm91bmQtbW9kaWZpZXItYm9yZGVyKSc7IC8vIEFkZCBib3JkZXIgZm9yIHRoZSBmaXJzdCBpdGVtXHJcbiAgICAgICAgICAgICAgICBzZXR0aW5nLnNldHRpbmdFbC5zdHlsZS5wYWRkaW5nID0gJzAuNzVlbSAwJzsgLy8gUmVtb3ZlIG1hcmdpbiBmb3IgYWxsIGJ1dCB0aGUgZmlyc3QgaXRlbVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdDb250cm9sPSBzZXR0aW5nLmNvbnRyb2xFbDtcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdDb250cm9sKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5nQ29udHJvbC5zdHlsZS5nYXAgPSAnMC4xZW0nOyAvLyBBZGQgZ2FwIGJldHdlZW4gYnV0dG9uc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE1vdmUgdXBcclxuICAgICAgICAgICAgc2V0dGluZy5hZGRFeHRyYUJ1dHRvbihidG4gPT4ge1xyXG4gICAgICAgICAgICAgICAgYnRuLnNldEljb24oJ2Fycm93LXVwJylcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VG9vbHRpcCgnTW92ZSB1cCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldERpc2FibGVkKGlkeCA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFthcnJbaWR4IC0gMV0sIGFycltpZHhdXSA9IFthcnJbaWR4XSwgYXJyW2lkeCAtIDFdXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGFycjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNoYW5nZUNiKFsuLi5hcnJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVEaXNhYmxlZChidG4sIGlkeCA9PT0gMCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gTW92ZSBkb3duXHJcbiAgICAgICAgICAgIHNldHRpbmcuYWRkRXh0cmFCdXR0b24oYnRuID0+IHtcclxuICAgICAgICAgICAgICAgIGJ0bi5zZXRJY29uKCdhcnJvdy1kb3duJylcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VG9vbHRpcCgnTW92ZSBkb3duJylcclxuICAgICAgICAgICAgICAgICAgICAuc2V0RGlzYWJsZWQoaWR4ID09PSBhcnIubGVuZ3RoIC0gMSlcclxuICAgICAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFthcnJbaWR4XSwgYXJyW2lkeCArIDFdXSA9IFthcnJbaWR4ICsgMV0sIGFycltpZHhdXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGFycjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNoYW5nZUNiKFsuLi5hcnJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVEaXNhYmxlZChidG4sIGlkeCA9PT0gYXJyLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1pbnVzIChhbHdheXMgZW5hYmxlZCB1bmxlc3Mgb25seSBvbmUgbGVmdClcclxuICAgICAgICAgICAgc2V0dGluZy5hZGRFeHRyYUJ1dHRvbihidG4gPT4ge1xyXG4gICAgICAgICAgICAgICAgYnRuLnNldEljb24oJ21pbnVzLWNpcmNsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoJ1JlbW92ZSBwcm9wZXJ0eScpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldERpc2FibGVkKGFyci5sZW5ndGggPT09IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBhcnIubGVuZ3RoID8gYXJyIDogW1wiXCJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ2hhbmdlQ2IoWy4uLnRoaXMudmFsdWVdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVEaXNhYmxlZChidG4sIGFyci5sZW5ndGggPT09IDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIENhbGwgZXh0cmEgYnV0dG9uIGNhbGxiYWNrcyBmb3IgdGhpcyByb3dcclxuICAgICAgICAgICAgdGhpcy5leHRyYUJ1dHRvbkNhbGxiYWNrcy5mb3JFYWNoKGNiID0+IGNiKHNldHRpbmcsIGlkeCkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBQbHVzIGJ1dHRvbiB1bmRlciB0aGUgbGFzdCByb3dcclxuICAgICAgICBjb25zdCBwbHVzQnV0dG9uID0gbmV3IFNldHRpbmcodGhpcy5zZXR0aW5nRWwpXHJcbiAgICAgICAgICAgIC5hZGRFeHRyYUJ1dHRvbihidG4gPT4ge1xyXG4gICAgICAgICAgICAgICAgYnRuLnNldEljb24oJ3BsdXMtY2lyY2xlJylcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VG9vbHRpcCgnQWRkIHByb3BlcnR5JylcclxuICAgICAgICAgICAgICAgICAgICAuc2V0RGlzYWJsZWQoYXJyW2Fyci5sZW5ndGggLSAxXSA9PT0gXCJcIiB8fCAhYXJyW2Fyci5sZW5ndGggLSAxXSlcclxuICAgICAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcnJbYXJyLmxlbmd0aCAtIDFdICE9PSBcIlwiICYmIGFyclthcnIubGVuZ3RoIC0gMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGFycjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25DaGFuZ2VDYihbLi4uYXJyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlRGlzYWJsZWQoYnRuLCBhcnJbYXJyLmxlbmd0aCAtIDFdID09PSBcIlwiIHx8ICFhcnJbYXJyLmxlbmd0aCAtIDFdKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIHBsdXNCdXR0b24uc2V0dGluZ0VsLnN0eWxlLmJvcmRlclRvcCA9ICdub25lJzsgLy8gUmVtb3ZlIGJvcmRlciBmb3IgYWxsIGJ1dCB0aGUgZmlyc3QgaXRlbVxyXG4gICAgICAgIHBsdXNCdXR0b24uc2V0dGluZ0VsLnN0eWxlLnBhZGRpbmcgPSAnMCAwIDAuNzVlbSc7IC8vIFJlbW92ZSBtYXJnaW4gZm9yIGFsbCBidXQgdGhlIGZpcnN0IGl0ZW1cclxuICAgIH1cclxufSIsICJpbXBvcnQgeyBTZXR0aW5nLCBFeHRyYUJ1dHRvbkNvbXBvbmVudCwgVGV4dENvbXBvbmVudCwgU2VhcmNoQ29tcG9uZW50IH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBsb2dnZXIsIFRSQUNFIH0gZnJvbSBcIi4vTG9nXCI7XG5cbmV4cG9ydCB0eXBlIFRyZWVIaWVyYXJjaHlGb2xkZXIgPSB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgcGFyZW50SWQ/OiBzdHJpbmc7XG4gICAgZGlzYWJsZWQ6IGJvb2xlYW47IC8vIEFkZGVkIHRvIHN1cHBvcnQgZGlzYWJsaW5nIGZvbGRlcnNcbiAgICBjb2xsYXBzZWQ6IGJvb2xlYW47IC8vIEFkZCB0aGlzIGxpbmVcbn07XG5leHBvcnQgdHlwZSBUcmVlSGllcmFyY2h5Um93ID0ge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgZm9sZGVySWQ/OiBzdHJpbmc7XG4gICAga2V5d29yZHM6IHN0cmluZ1tdO1xuICAgIGRpc2FibGVkOiBib29sZWFuOyAvLyBBZGRlZCB0byBzdXBwb3J0IGRpc2FibGluZyByb3dzXG4gICAgcGF5bG9hZD86IGFueTsgLy8gT3B0aW9uYWwgcGF5bG9hZCBmb3IgY3VzdG9tIGRhdGFcbn07XG50eXBlIEZNQUZvbGRlckxpc3REcmFnVGFyZ2V0ID0gXCJmb2xkZXJcIiB8IFwicm93XCIgfCBcInJvb3RcIjtcblxuZXhwb3J0IHR5cGUgVHJlZUhpZXJhcmNoeURhdGEgPSB7XG4gICAgZm9sZGVyczogVHJlZUhpZXJhcmNoeUZvbGRlcltdO1xuICAgIHJvd3M6IFRyZWVIaWVyYXJjaHlSb3dbXTtcbn07XG5cbmV4cG9ydCBjb25zdCBST09UX0ZPTERFUiA9IHVuZGVmaW5lZDsgLy8gU3BlY2lhbCBpZGVudGlmaWVyIGZvciByb290IGZvbGRlclxuXG50eXBlIFJvd1JlbmRlckNhbGxiYWNrID0gKHJvdzogVHJlZUhpZXJhcmNoeVJvdywgcm93RWw6IEhUTUxFbGVtZW50KSA9PiB2b2lkO1xuXG5leHBvcnQgY2xhc3MgVHJlZUhpZXJhcmNoeVNvcnRhYmxlU2V0dGluZ3Mge1xuICAgIHB1YmxpYyBzZXR0aW5nRWw6IEhUTUxFbGVtZW50O1xuICAgIHByaXZhdGUgY29udGFpbmVyOiBIVE1MRWxlbWVudDtcbiAgICBwcml2YXRlIGRhdGE6IFRyZWVIaWVyYXJjaHlEYXRhO1xuICAgIHByaXZhdGUgdGl0bGU6IHN0cmluZyA9IFwiXCI7XG4gICAgcHJpdmF0ZSBkZXNjcmlwdGlvbjogc3RyaW5nID0gXCJcIjtcbiAgICBwcml2YXRlIGZpbHRlcjogc3RyaW5nID0gXCJcIjtcbiAgICBwcml2YXRlIHJvd1JlbmRlckNiOiBSb3dSZW5kZXJDYWxsYmFjaztcbiAgICBwcml2YXRlIG9uQ2hhbmdlQ2I6IChkYXRhOiBUcmVlSGllcmFyY2h5RGF0YSkgPT4gdm9pZCA9ICgpID0+IHt9O1xuICAgIHByaXZhdGUgb25Sb3dDcmVhdGVkQ2I6IChyb3c6IFRyZWVIaWVyYXJjaHlSb3cpID0+IHZvaWQgPSAoKSA9PiB7fTtcbiAgICBwcml2YXRlIG9uUm93RGVsZXRlZENiOiAocm93OiBUcmVlSGllcmFyY2h5Um93KSA9PiB2b2lkID0gKCkgPT4ge307XG4gICAgcHJpdmF0ZSBvbkRlbGV0ZUJ0Q2I6ICgpID0+IHZvaWQgPSAoKSA9PiB7fTtcbiAgICBwcml2YXRlIG9uUmVuZGVyZWRDYjogKCkgPT4gdm9pZCA9ICgpID0+IHt9O1xuICAgIHByaXZhdGUgZXh0cmFCdXR0b25DYnM6ICgoYnRuOiBTZXR0aW5nKSA9PiB2b2lkKVtdID0gW107XG4gICAgXG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyOiBIVE1MRWxlbWVudCwgZGF0YTogVHJlZUhpZXJhcmNoeURhdGEsIHJvd1JlbmRlckNiOiBSb3dSZW5kZXJDYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5zZXR0aW5nRWwgPSBjb250YWluZXIuY3JlYXRlRGl2KHsgY2xzOiBcIkZNQS1mb2xkZXItbGlzdC1zZXR0aW5nXCIgfSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGEgfHwgeyBmb2xkZXJzOiBbXSwgcm93czogW10gfTtcbiAgICAgICAgdGhpcy5yb3dSZW5kZXJDYiA9IHJvd1JlbmRlckNiO1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cbiAgICBzZXRUaXRsZSh0aXRsZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMudGl0bGUgPSB0aXRsZTtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldERlc2NyaXB0aW9uKGRlc2NyaXB0aW9uOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkRXh0cmFCdXR0b25Ub0hlYWRlcihjYjogKGJ0bjogU2V0dGluZykgPT4gdm9pZCkge1xuICAgICAgICB0aGlzLmV4dHJhQnV0dG9uQ2JzLnB1c2goY2IpO1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb25EZWxldGVCdChjYjogKCkgPT4gdm9pZCkge1xuICAgICAgICB0aGlzLm9uRGVsZXRlQnRDYiA9IGNiO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkUm93KGZvbGRlcklkOiBzdHJpbmcgfCB1bmRlZmluZWQsIGtleXdvcmRzOiBzdHJpbmdbXSA9IFtdLCBwYXlsb2FkPzogYW55KSB7XG4gICAgICAgIGNvbnN0IG5ld1JvdzogVHJlZUhpZXJhcmNoeVJvdyA9IHtcbiAgICAgICAgICAgIGlkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxuICAgICAgICAgICAgZm9sZGVySWQsXG4gICAgICAgICAgICBrZXl3b3JkcyxcbiAgICAgICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICghZm9sZGVySWQpIHtcbiAgICAgICAgICAgIC8vIElmIG5vIGZvbGRlcklkLCBhZGQgdG8gcm9vdCAodW5kZWZpbmVkIGZvbGRlcilcbiAgICAgICAgICAgIHRoaXMuZGF0YS5yb3dzLnB1c2gobmV3Um93KTtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2VDYih0aGlzLmRhdGEpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgdGhlIGxhc3Qgcm93IHdpdGggdGhlIHNhbWUgZm9sZGVySWRcbiAgICAgICAgY29uc3QgbGFzdElkeCA9IHRoaXMuZGF0YS5yb3dzLm1hcChyID0+IHIuZm9sZGVySWQpLmxhc3RJbmRleE9mKGZvbGRlcklkKTtcbiAgICAgICAgaWYgKGxhc3RJZHggPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBObyByb3dzIGluIHRoaXMgZm9sZGVyLCBpbnNlcnQgYXQgdGhlIHN0YXJ0XG4gICAgICAgICAgICB0aGlzLmRhdGEucm93cy51bnNoaWZ0KG5ld1Jvdyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJbnNlcnQgYWZ0ZXIgdGhlIGxhc3Qgcm93IGluIHRoaXMgZm9sZGVyXG4gICAgICAgICAgICB0aGlzLmRhdGEucm93cy5zcGxpY2UobGFzdElkeCArIDEsIDAsIG5ld1Jvdyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vblJvd0NyZWF0ZWRDYihuZXdSb3cpO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2IodGhpcy5kYXRhKTtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkZEZvbGRlcihuYW1lOiBzdHJpbmcsIHBhcmVudElkPzogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IG5ld0ZvbGRlcjogVHJlZUhpZXJhcmNoeUZvbGRlciA9IHtcbiAgICAgICAgICAgIGlkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHBhcmVudElkLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLCAvLyBEZWZhdWx0IHRvIGVuYWJsZWRcbiAgICAgICAgICAgIGNvbGxhcHNlZDogZmFsc2UsIC8vIERlZmF1bHQgdG8gZXhwYW5kZWRcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kYXRhLmZvbGRlcnMucHVzaChuZXdGb2xkZXIpO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2IodGhpcy5kYXRhKTtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgc2V0RGF0YShkYXRhOiBUcmVlSGllcmFyY2h5RGF0YSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBvbkNoYW5nZShjYjogKGRhdGE6IFRyZWVIaWVyYXJjaHlEYXRhKSA9PiB2b2lkKSB7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYiA9IGNiO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcHVibGljIG9uUm93Q3JlYXRlZChjYjogKHJvdzogVHJlZUhpZXJhcmNoeVJvdykgPT4gdm9pZCkge1xuICAgICAgICB0aGlzLm9uUm93Q3JlYXRlZENiID0gY2I7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBwdWJsaWMgb25Sb3dEZWxldGVkKGNiOiAocm93OiBUcmVlSGllcmFyY2h5Um93KSA9PiB2b2lkKSB7XG4gICAgICAgIHRoaXMub25Sb3dEZWxldGVkQ2IgPSBjYjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9uUmVuZGVyZWQoY2I6ICgpID0+IHZvaWQpIHtcbiAgICAgICAgdGhpcy5vblJlbmRlcmVkQ2IgPSBjYjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHByaXZhdGUgbW92ZVJvdyhyb3dJZDogc3RyaW5nLCB0YXJnZXRSb3dJZD86IHN0cmluZykge1xuICAgICAgICBjb25zdCBmcm9tSWR4ID0gdGhpcy5kYXRhLnJvd3MuZmluZEluZGV4KHIgPT4gci5pZCA9PT0gcm93SWQpO1xuICAgICAgICBpZiAoZnJvbUlkeCA9PT0gLTEpIHJldHVybjtcbiAgICAgICAgaWYgKHJvd0lkID09PSB0YXJnZXRSb3dJZCkgcmV0dXJuOyAvLyBEb24ndCBtb3ZlIG9udG8gaXRzZWxmXG5cbiAgICAgICAgY29uc3QgbW92ZWQgPSB0aGlzLmRhdGEucm93c1tmcm9tSWR4XTtcbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gb2xkIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IHJvdyA9IHRoaXMuZGF0YS5yb3dzW2Zyb21JZHhdO1xuICAgICAgICB0aGlzLm9uUm93RGVsZXRlZENiKHJvdyk7XG4gICAgICAgIGxvZ2dlci5sb2coVFJBQ0UsYHJlbW92aW5nIGlkJHtyb3dJZH0gZnJvbSAke2Zyb21JZHh9YCwgdGhpcy5kYXRhLnJvd3MpO1xuICAgICAgICB0aGlzLmRhdGEucm93cy5zcGxpY2UoZnJvbUlkeCwgMSk7XG5cbiAgICAgICAgbGV0IGluc2VydElkeDogbnVtYmVyO1xuICAgICAgICBpZiAodGFyZ2V0Um93SWQpIHtcbiAgICAgICAgICAgIGluc2VydElkeCA9IHRoaXMuZGF0YS5yb3dzLmZpbmRJbmRleChyID0+IHIuaWQgPT09IHRhcmdldFJvd0lkKTtcbiAgICAgICAgICAgIGlmIChpbnNlcnRJZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gdGFyZ2V0Um93SWQgbm90IGZvdW5kLCBpbnNlcnQgYXQgZW5kXG4gICAgICAgICAgICAgICAgaW5zZXJ0SWR4ID0gdGhpcy5kYXRhLnJvd3MubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2V0IGZvbGRlcklkIHRvIG1hdGNoIHRoZSB0YXJnZXQgcm93XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRSb3cgPSB0aGlzLmRhdGEucm93c1tpbnNlcnRJZHhdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBPbmx5IGluc2VydCBhZnRlciBpZiBtb3ZpbmcgZG93biBidXQgb25seSBpbnNpZGUgYSBmb2xkZXJcbiAgICAgICAgICAgIGlmIChmcm9tSWR4IDw9IGluc2VydElkeCAmJiBtb3ZlZC5mb2xkZXJJZCA9PT0gdGFyZ2V0Um93Py5mb2xkZXJJZCkgaW5zZXJ0SWR4Kys7XG4gICAgICAgICAgICBtb3ZlZC5mb2xkZXJJZCA9IHRhcmdldFJvdz8uZm9sZGVySWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBObyB0YXJnZXRSb3dJZDogaW5zZXJ0IGF0IGVuZFxuICAgICAgICAgICAgaW5zZXJ0SWR4ID0gdGhpcy5kYXRhLnJvd3MubGVuZ3RoO1xuICAgICAgICAgICAgLy8gT3B0aW9uYWxseSwgc2V0IGZvbGRlcklkIHRvIHVuZGVmaW5lZCBvciBrZWVwIGFzIGlzXG4gICAgICAgICAgICAvLyBtb3ZlZC5mb2xkZXJJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIubG9nKFRSQUNFLGBJbnNlcnRpbmcgbW92ZWQgcm93IGlkJHtyb3dJZH0gYXQgJHtpbnNlcnRJZHh9YCwgdGhpcy5kYXRhLnJvd3MpO1xuICAgICAgICB0aGlzLmRhdGEucm93cy5zcGxpY2UoaW5zZXJ0SWR4LCAwLCBtb3ZlZCk7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYih0aGlzLmRhdGEpO1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cbiAgICBwcml2YXRlIG1vdmVSb3dUb0ZvbGRlcihyb3dJZDogc3RyaW5nLCBmb2xkZXJJZDogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGZyb21JZHggPSB0aGlzLmRhdGEucm93cy5maW5kSW5kZXgociA9PiByLmlkID09PSByb3dJZCk7XG4gICAgICAgIGlmIChmcm9tSWR4ID09PSAtMSkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IG1vdmVkID0gdGhpcy5kYXRhLnJvd3NbZnJvbUlkeF07XG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIG9sZCBwb3NpdGlvblxuICAgICAgICB0aGlzLmRhdGEucm93cy5zcGxpY2UoZnJvbUlkeCwgMSk7XG5cbiAgICAgICAgLy8gU2V0IG5ldyBmb2xkZXJJZFxuICAgICAgICBtb3ZlZC5mb2xkZXJJZCA9IGZvbGRlcklkO1xuXG4gICAgICAgIC8vIEluc2VydCBhdCB0aGUgZW5kIG9mIHRoZSBuZXcgZm9sZGVyIG9yIHJvb3RcbiAgICAgICAgdGhpcy5kYXRhLnJvd3MucHVzaChtb3ZlZCk7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYih0aGlzLmRhdGEpO1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cbiAgICBwcml2YXRlIG1vdmVGb2xkZXJUb0ZvbGRlcihmb2xkZXJJZDogc3RyaW5nLCB0YXJnZXRGb2xkZXJJZDogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChmb2xkZXJJZCA9PT0gdGFyZ2V0Rm9sZGVySWQpIHJldHVybjsgLy8gRG9uJ3QgbW92ZSBvbnRvIGl0c2VsZlxuICAgICAgICBjb25zdCBmcm9tSWR4ID0gdGhpcy5kYXRhLmZvbGRlcnMuZmluZEluZGV4KGYgPT4gZi5pZCA9PT0gZm9sZGVySWQpO1xuICAgICAgICBpZiAoZnJvbUlkeCA9PT0gLTEpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IG1vdmVkID0gdGhpcy5kYXRhLmZvbGRlcnNbZnJvbUlkeF07XG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIG9sZCBwb3NpdGlvblxuICAgICAgICB0aGlzLmRhdGEuZm9sZGVycy5zcGxpY2UoZnJvbUlkeCwgMSk7XG5cbiAgICAgICAgLy8gU2V0IG5ldyBwYXJlbnRJZFxuICAgICAgICBtb3ZlZC5wYXJlbnRJZCA9IHRhcmdldEZvbGRlcklkO1xuXG4gICAgICAgIC8vIEluc2VydCBhdCB0aGUgZW5kIG9mIHRoZSBuZXcgZm9sZGVyIG9yIHJvb3RcbiAgICAgICAgdGhpcy5kYXRhLmZvbGRlcnMucHVzaChtb3ZlZCk7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYih0aGlzLmRhdGEpO1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cbiAgICBwcml2YXRlIHByb3BhZ2F0ZUZvbGRlckRpc2FibGVkKGZvbGRlcklkOiBzdHJpbmcsIGRpc2FibGVkOiBib29sZWFuKSB7XG4gICAgICAgIC8vIERpc2FibGUgYWxsIGNoaWxkIGZvbGRlcnNcbiAgICAgICAgZm9yIChjb25zdCBmb2xkZXIgb2YgdGhpcy5kYXRhLmZvbGRlcnMpIHtcbiAgICAgICAgICAgIGlmIChmb2xkZXIucGFyZW50SWQgPT09IGZvbGRlcklkKSB7XG4gICAgICAgICAgICAgICAgZm9sZGVyLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wYWdhdGVGb2xkZXJEaXNhYmxlZChmb2xkZXIuaWQsIGRpc2FibGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEaXNhYmxlIGFsbCByb3dzIGluIHRoaXMgZm9sZGVyXG4gICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRoaXMuZGF0YS5yb3dzKSB7XG4gICAgICAgICAgICBpZiAocm93LmZvbGRlcklkID09PSBmb2xkZXJJZCkge1xuICAgICAgICAgICAgICAgIHJvdy5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHByaXZhdGUgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLnNldHRpbmdFbC5lbXB0eSgpO1xuXG4gICAgICAgIC8vIC0tLSBSb290IEhlYWRlciBhcyBhIFNldHRpbmcgUm93IC0tLVxuICAgICAgICBjb25zdCBoZWFkZXJTZXR0aW5nID0gbmV3IFNldHRpbmcodGhpcy5zZXR0aW5nRWwpXG4gICAgICAgICAgICAuc2V0Q2xhc3MoXCJGTUEtZm9sZGVyLWxpc3Qtcm9vdC1oZWFkZXJcIik7XG5cbiAgICAgICAgLy8gRHJhZyBoYW5kbGUgcGxhY2Vob2xkZXIgKGZvciBhbGlnbm1lbnQpXG4gICAgICAgIGhlYWRlclNldHRpbmcuc2V0dGluZ0VsLmNyZWF0ZVNwYW4oeyBjbHM6IFwiRk1BLWZvbGRlci1saXN0LWRyYWctaGFuZGxlXCIsIHRleHQ6IFwiIFwiIH0pO1xuICAgICAgICBoZWFkZXJTZXR0aW5nLnNldHRpbmdFbC5zdHlsZS5ib3JkZXJUb3AgPSBcIjFweCBzb2xpZCB2YXIoLS1iYWNrZ3JvdW5kLW1vZGlmaWVyLWJvcmRlcilcIjsgLy8gQWRkIGJvdHRvbSBib3JkZXIgZm9yIHNlcGFyYXRpb25cbiAgICAgICAgaGVhZGVyU2V0dGluZy5zZXR0aW5nRWwuc3R5bGUucGFkZGluZyA9IFwiMC43NWVtIDBcIjsgLy8gQWRkIHNvbWUgcGFkZGluZyBmb3IgYmV0dGVyIHNwYWNpbmdcblxuICAgICAgICAvLyBUaXRsZSAoY291bGQgYmUgXCJSb290XCIgb3IgeW91ciBjdXN0b20gbGFiZWwpXG4gICAgICAgIGhlYWRlclNldHRpbmcuc2V0TmFtZSh0aGlzLnRpdGxlIHx8IFwiXCIpO1xuICAgICAgICBoZWFkZXJTZXR0aW5nLnNldERlc2ModGhpcy5kZXNjcmlwdGlvbiB8fCBcIlwiKTtcblxuICAgICAgICAvLyBGaWx0ZXIgaW5wdXQgKGlubGluZSwgbGVmdCBvZiBidXR0b25zKVxuICAgICAgICBjb25zdCBmaWx0ZXJJbnB1dCA9IG5ldyBTZWFyY2hDb21wb25lbnQoaGVhZGVyU2V0dGluZy5jb250cm9sRWwpO1xuICAgICAgICBmaWx0ZXJJbnB1dC5zZXRQbGFjZWhvbGRlcihcIkZpbHRlciBmb2xkZXJzL3Jvd3MuLi5cIik7XG4gICAgICAgIGZpbHRlcklucHV0LnNldFZhbHVlKHRoaXMuZmlsdGVyKTtcbiAgICAgICAgZmlsdGVySW5wdXQuaW5wdXRFbC5zdHlsZS53aWR0aCA9IFwiMjAwcHhcIjtcbiAgICAgICAgZmlsdGVySW5wdXQub25DaGFuZ2UoKHZhbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXIgPSB2YWw7XG4gICAgICAgICAgICAvLyBPbmx5IHJlLXJlbmRlciB0aGUgcm93cy9mb2xkZXJzLCBub3QgdGhlIHdob2xlIFVJXG4gICAgICAgICAgICB0aGlzLnJlbmRlckxpc3QoKTtcbiAgICAgICAgfSk7IFxuXG4gICAgICAgIC8vIEFkZCByb3cgYnV0dG9uIChyaWdodClcbiAgICAgICAgaGVhZGVyU2V0dGluZy5hZGRFeHRyYUJ1dHRvbihidG4gPT4ge1xuICAgICAgICAgICAgYnRuLnNldEljb24oXCJwbHVzLWNpcmNsZVwiKVxuICAgICAgICAgICAgICAgIC5zZXRUb29sdGlwKFwiQWRkIHJvdyB0byByb290XCIpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFJvdyh1bmRlZmluZWQsIFtdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQWRkIGZvbGRlciBidXR0b24gKHJpZ2h0KVxuICAgICAgICBoZWFkZXJTZXR0aW5nLmFkZEV4dHJhQnV0dG9uKGJ0biA9PiB7XG4gICAgICAgICAgICBidG4uc2V0SWNvbihcImZvbGRlclwiKVxuICAgICAgICAgICAgICAgIC5zZXRUb29sdGlwKFwiQWRkIGZvbGRlciB0byByb290XCIpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEZvbGRlcih0aGlzLmdldE5leHRGb2xkZXJOYW1lKCksIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaGVhZGVyU2V0dGluZy5hZGRFeHRyYUJ1dHRvbihidG4gPT4ge1xuICAgICAgICAgICAgYnRuLnNldEljb24oXCJ0cmFzaFwiKVxuICAgICAgICAgICAgICAgIC5zZXRUb29sdGlwKFwiRHJvcCBoZXJlIHRvIGRlbGV0ZSByb3cgb3IgZm9sZGVyXCIpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRGVsZXRlQnRDYigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ2hhbmdlQ2IodGhpcy5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGJpbkVsID0gYnRuLmV4dHJhU2V0dGluZ3NFbDtcblxuICAgICAgICAgICAgYmluRWwuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGJpbkVsLmNsYXNzTGlzdC5hZGQoXCJGTUEtYmluLWRyb3AtdGFyZ2V0XCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBiaW5FbC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2xlYXZlXCIsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgYmluRWwuY2xhc3NMaXN0LnJlbW92ZShcIkZNQS1iaW4tZHJvcC10YXJnZXRcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJpbkVsLmFkZEV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGJpbkVsLmNsYXNzTGlzdC5yZW1vdmUoXCJGTUEtYmluLWRyb3AtdGFyZ2V0XCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBlLmRhdGFUcmFuc2Zlcj8uZ2V0RGF0YShcInRleHQvcGxhaW5cIik7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhKSByZXR1cm47XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0eXBlLCBpZCB9ID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJyb3dcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEucm93cyA9IHRoaXMuZGF0YS5yb3dzLmZpbHRlcihyID0+IHIuaWQgIT09IGlkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiZm9sZGVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxldGVGb2xkZXJBbmRDb250ZW50cyhpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMub25DaGFuZ2VDYih0aGlzLmRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQWRkIGV4dHJhIGJ1dHRvbnMgdG8gdGhlIGhlYWRlclxuICAgICAgICB0aGlzLmV4dHJhQnV0dG9uQ2JzLmZvckVhY2goY2IgPT4ge1xuICAgICAgICAgICAgY2IoaGVhZGVyU2V0dGluZyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucmVuZGVyTGlzdCgpO1xuXG5cbiAgICB9XG5cbiAgICBwcml2YXRlIHJlbmRlckxpc3QoKSB7XG4gICAgICAgIC8vIFJlbW92ZSBvbGQgbGlzdCAoYnV0IGtlZXAgaGVhZGVyL2ZpbHRlcilcbiAgICAgICAgY29uc3Qgb2xkTGlzdCA9IHRoaXMuc2V0dGluZ0VsLnF1ZXJ5U2VsZWN0b3IoXCIuRk1BLWZvbGRlci1saXN0LWNvbnRlbnRcIik7XG4gICAgICAgIGlmIChvbGRMaXN0KSBvbGRMaXN0LnJlbW92ZSgpO1xuXG4gICAgICAgIGNvbnN0IGxpc3RFbCA9IHRoaXMuc2V0dGluZ0VsLmNyZWF0ZURpdih7IGNsczogXCJGTUEtZm9sZGVyLWxpc3QtY29udGVudFwiIH0pO1xuICAgICAgICB0aGlzLnJlbmRlckZvbGRlcih1bmRlZmluZWQsIGxpc3RFbCwgMCk7XG4gICAgICAgIHRoaXMucmVuZGVyUm93cyh1bmRlZmluZWQsIGxpc3RFbCwgMCk7XG5cbiAgICAgICAgLy8gUmVuZGVyIGEgZHJvcCB6b25lIGF0IHRoZSBlbmQgb2YgdGhlIGZvbGRlciBsaXN0XG4gICAgICAgIGNvbnN0IGRyb3Bab25lID0gbmV3IFNldHRpbmcobGlzdEVsKSAvLyA8LS0gQ0hBTkdFRCBmcm9tIHRoaXMuc2V0dGluZ0VsIHRvIGxpc3RFbFxuICAgICAgICAgICAgLnNldENsYXNzKFwiRk1BLWZvbGRlci1saXN0LWRyb3Atem9uZVwiKTtcbiAgICAgICAgZHJvcFpvbmUuc2V0dGluZ0VsLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnb3ZlclwiLCAoZSkgPT4gdGhpcy5vbkRyYWdPdmVyKGUsIFwicm9vdFwiLCBcImZvbGRlci1kcm9wem9uZVwiKSk7XG4gICAgICAgIGRyb3Bab25lLnNldHRpbmdFbC5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTsgLy8gUHJldmVudCBtdWx0aXBsZSBldmVudHNcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBlLmRhdGFUcmFuc2Zlcj8uZ2V0RGF0YShcInRleHQvcGxhaW5cIik7XG4gICAgICAgICAgICBpZiAoIWRhdGEpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSwgaWQgfSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJyb3dcIikge1xuICAgICAgICAgICAgICAgIC8vIE1vdmUgcm93IHRvIHRoaXMgZm9sZGVyXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlUm93VG9Gb2xkZXIoaWQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiZm9sZGVyXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIGZvbGRlciB0byB0aGlzIGZvbGRlclxuICAgICAgICAgICAgICAgIHRoaXMubW92ZUZvbGRlclRvRm9sZGVyKGlkLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZHJvcFpvbmUuc2V0dGluZ0VsLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnZW50ZXJcIiwgKGUpID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBkcm9wWm9uZS5zZXR0aW5nRWwuY2xhc3NMaXN0LmFkZChcIkZNQS1kcm9wem9uZS10YXJnZXRcIik7XG4gICAgICAgIH0pO1xuICAgICAgICBkcm9wWm9uZS5zZXR0aW5nRWwuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdsZWF2ZVwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGRyb3Bab25lLnNldHRpbmdFbC5jbGFzc0xpc3QucmVtb3ZlKFwiRk1BLWRyb3B6b25lLXRhcmdldFwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25SZW5kZXJlZENiKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZW5kZXJGb2xkZXIocGFyZW50SWQ6IHN0cmluZyB8IHVuZGVmaW5lZCwgcGFyZW50RWw6IEhUTUxFbGVtZW50LCBkZXB0aDogbnVtYmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5kYXRhIHx8ICF0aGlzLmRhdGEuZm9sZGVycykgcmV0dXJuO1xuICAgICAgICBjb25zdCBmb2xkZXJzID0gdGhpcy5kYXRhLmZvbGRlcnMuZmlsdGVyKGYgPT4gZi5wYXJlbnRJZCA9PT0gcGFyZW50SWQpO1xuICAgICAgICBmb2xkZXJzLmZvckVhY2goZm9sZGVyID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmcgPSBuZXcgU2V0dGluZyhwYXJlbnRFbClcbiAgICAgICAgICAgICAgICAuc2V0Q2xhc3MoXCJGTUEtZm9sZGVyLWxpc3QtZm9sZGVyLXNldHRpbmdcIik7XG5cbiAgICAgICAgICAgIC8vIC0tLSBMRUZUIFNJREU6IERyYWcgaGFuZGxlICsgZWRpdGFibGUgbmFtZSAtLS1cbiAgICAgICAgICAgIHNldHRpbmcubmFtZUVsLmVtcHR5KCk7XG5cbiAgICAgICAgICAgIC8vIEluZGVudCBmb2xkZXJzIGJ5IDIwcHggcGVyIGRlcHRoIChmcmFtZSBhbmQgY29udGVudClcbiAgICAgICAgICAgIHNldHRpbmcuc2V0dGluZ0VsLnN0eWxlLm1hcmdpbkxlZnQgPSBgJHtkZXB0aCAqIDIwfXB4YDtcblxuICAgICAgICAgICAgLy8gRHJhZyBoYW5kbGUgKGxlZnQpXG4gICAgICAgICAgICBjb25zdCBkcmFnSGFuZGxlID0gc2V0dGluZy5uYW1lRWwuY3JlYXRlU3Bhbih7IGNsczogXCJGTUEtZm9sZGVyLWxpc3QtZHJhZy1oYW5kbGVcIiB9KTtcbiAgICAgICAgICAgIGRyYWdIYW5kbGUuc2V0VGV4dChcIlx1MjYzMFwiKTtcbiAgICAgICAgICAgIGRyYWdIYW5kbGUuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGRyYWdIYW5kbGUuc3R5bGUubWFyZ2luUmlnaHQgPSBcIjAuNWVtXCI7XG4gICAgICAgICAgICBkcmFnSGFuZGxlLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnc3RhcnRcIiwgKGUpID0+IHRoaXMub25EcmFnU3RhcnQoZSwgXCJmb2xkZXJcIiwgZm9sZGVyLmlkKSk7XG4gICAgICAgICAgICBkcmFnSGFuZGxlLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnb3ZlclwiLCAoZSkgPT4gdGhpcy5vbkRyYWdPdmVyKGUsIFwiZm9sZGVyXCIsIGZvbGRlci5pZCkpO1xuICAgICAgICAgICAgZHJhZ0hhbmRsZS5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLCAoZSkgPT4gdGhpcy5vbkRyb3AoZSwgXCJmb2xkZXJcIiwgZm9sZGVyLmlkKSk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBjaGVja2JveCBmb3IgZGlzYWJsaW5nIGZvbGRlclxuICAgICAgICAgICAgc2V0dGluZy5hZGRUb2dnbGUodG9nZ2xlID0+IHtcbiAgICAgICAgICAgICAgICB0b2dnbGVcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKCFmb2xkZXIuZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZSgodmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2xkZXIuZGlzYWJsZWQgPSAhdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wYWdhdGVGb2xkZXJEaXNhYmxlZChmb2xkZXIuaWQsIGZvbGRlci5kaXNhYmxlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ2hhbmdlQ2IodGhpcy5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGlzdCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLnNldFRvb2x0aXAoXCJEaXNhYmxlIGFsbCBydWxlcyBpbiB0aGlzIGZvbGRlciBhbmQgc3ViZm9sZGVyc1wiKTtcblxuICAgICAgICAgICAgLy8gRWRpdGFibGUgZm9sZGVyIG5hbWVcbiAgICAgICAgICAgIGNvbnN0IG5hbWVJbnB1dCA9IG5ldyBUZXh0Q29tcG9uZW50KHNldHRpbmcubmFtZUVsKTtcbiAgICAgICAgICAgIG5hbWVJbnB1dC5zZXRWYWx1ZShmb2xkZXIubmFtZSk7XG4gICAgICAgICAgICBuYW1lSW5wdXQuaW5wdXRFbC5zdHlsZS5tYXhXaWR0aCA9IFwiMTAwJVwiO1xuICAgICAgICAgICAgbmFtZUlucHV0LmlucHV0RWwuc3R5bGUuYm9yZGVyID0gXCIwXCJcbiAgICAgICAgICAgIG5hbWVJbnB1dC5pbnB1dEVsLnN0eWxlLm1hcmdpblJpZ2h0ID0gXCIwLjVlbVwiO1xuICAgICAgICAgICAgbmFtZUlucHV0Lm9uQ2hhbmdlKCh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICBmb2xkZXIubmFtZSA9IHZhbDtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2hhbmdlQ2IodGhpcy5kYXRhKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyAtLS0gUklHSFQgU0lERTogQWN0aW9uIGJ1dHRvbnMgLS0tXG4gICAgICAgICAgICBzZXR0aW5nLmFkZEV4dHJhQnV0dG9uKGJ0biA9PiB7XG4gICAgICAgICAgICAgICAgYnRuLnNldEljb24oXCJwbHVzLWNpcmNsZVwiKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VG9vbHRpcChcIkFkZCByb3cgdG8gZm9sZGVyXCIpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkUm93KGZvbGRlci5pZCwgW10pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzZXR0aW5nLmFkZEV4dHJhQnV0dG9uKGJ0biA9PiB7XG4gICAgICAgICAgICAgICAgYnRuLnNldEljb24oXCJmb2xkZXJcIilcbiAgICAgICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoXCJBZGQgc3ViZm9sZGVyXCIpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRm9sZGVyKHRoaXMuZ2V0TmV4dEZvbGRlck5hbWUoKSwgZm9sZGVyLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc2V0dGluZy5hZGRFeHRyYUJ1dHRvbihidG4gPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQ29sbGFwc2VkID0gZm9sZGVyLmNvbGxhcHNlZCA/PyBmYWxzZTtcbiAgICAgICAgICAgICAgICBidG4uc2V0SWNvbihpc0NvbGxhcHNlZCA/IFwiY2hldnJvbi1yaWdodFwiIDogXCJjaGV2cm9uLWRvd25cIilcbiAgICAgICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoaXNDb2xsYXBzZWQgPyBcIkV4cGFuZFwiIDogXCJDb2xsYXBzZVwiKVxuICAgICAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2xkZXIuY29sbGFwc2VkID0gIWlzQ29sbGFwc2VkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNoYW5nZUNiKHRoaXMuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxpc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gSW4gcmVuZGVyRm9sZGVyLCBiZWZvcmUgYWRkaW5nIGV2ZW50IGxpc3RlbmVyczpcbiAgICAgICAgICAgIChzZXR0aW5nLnNldHRpbmdFbCBhcyBhbnkpLl9kcmFnRW50ZXJDb3VudCA9IDA7XG5cbiAgICAgICAgICAgIHNldHRpbmcuc2V0dGluZ0VsLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnZW50ZXJcIiwgKGUpID0+IHtcbiAgICAgICAgICAgICAgICAoc2V0dGluZy5zZXR0aW5nRWwgYXMgYW55KS5fZHJhZ0VudGVyQ291bnQrKztcbiAgICAgICAgICAgICAgICBzZXR0aW5nLnNldHRpbmdFbC5jbGFzc0xpc3QuYWRkKFwiRk1BLWRyb3AtdGFyZ2V0XCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXR0aW5nLnNldHRpbmdFbC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2xlYXZlXCIsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgKHNldHRpbmcuc2V0dGluZ0VsIGFzIGFueSkuX2RyYWdFbnRlckNvdW50LS07XG4gICAgICAgICAgICAgICAgaWYgKChzZXR0aW5nLnNldHRpbmdFbCBhcyBhbnkpLl9kcmFnRW50ZXJDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmcuc2V0dGluZ0VsLmNsYXNzTGlzdC5yZW1vdmUoXCJGTUEtZHJvcC10YXJnZXRcIik7XG4gICAgICAgICAgICAgICAgICAgIChzZXR0aW5nLnNldHRpbmdFbCBhcyBhbnkpLl9kcmFnRW50ZXJDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIERyYWcgZXZlbnRzIGZvciBmb2xkZXIgcm93XG4gICAgICAgICAgICBzZXR0aW5nLnNldHRpbmdFbC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIiwgKGUpID0+IHRoaXMub25EcmFnT3ZlcihlLCBcImZvbGRlclwiLCBmb2xkZXIuaWQpKTtcbiAgICAgICAgICAgIHNldHRpbmcuc2V0dGluZ0VsLmFkZEV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIChlKSA9PiB0aGlzLm9uRHJvcChlLCBcImZvbGRlclwiLCBmb2xkZXIuaWQpKTtcbiAgICAgICAgICAgIHNldHRpbmcuc2V0dGluZ0VsLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnbGVhdmVcIiwgKGUpID0+IHRoaXMub25EcmFnTGVhdmUoZSkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZm9sZGVyLmRpc2FibGVkKSBzZXR0aW5nLnNldHRpbmdFbC5jbGFzc0xpc3QuYWRkKFwiRk1BLW1vZC1Gb2xkZXJMaXN0LWRpc2FibGVkXCIpO1xuXG4gICAgICAgICAgICAvLyBSZW5kZXIgcm93cyBhbmQgc3ViZm9sZGVyc1xuICAgICAgICAgICAgaWYgKCFmb2xkZXIuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGb2xkZXIoZm9sZGVyLmlkLCBwYXJlbnRFbCwgZGVwdGggKyAxKTsgLy8gc3ViZm9sZGVyc1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUm93cyhmb2xkZXIuaWQsIHBhcmVudEVsLCBkZXB0aCArIDEpOyAvLyByb3dzIGluIHRoaXMgZm9sZGVyXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgcmVuZGVyUm93cyhmb2xkZXJJZDogc3RyaW5nIHwgdW5kZWZpbmVkLCBwYXJlbnRFbDogSFRNTEVsZW1lbnQsIGRlcHRoOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRhdGEgfHwgIXRoaXMuZGF0YS5yb3dzKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHJvd3MgPSB0aGlzLmRhdGEucm93cy5maWx0ZXIociA9PiByLmZvbGRlcklkID09PSBmb2xkZXJJZCAmJiB0aGlzLnJvd01hdGNoZXNGaWx0ZXIocikpO1xuICAgICAgICByb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmcgPSBuZXcgU2V0dGluZyhwYXJlbnRFbClcbiAgICAgICAgICAgICAgICAuc2V0Q2xhc3MoXCJGTUEtZm9sZGVyLWxpc3Qtcm93LXNldHRpbmdcIik7XG5cbiAgICAgICAgICAgIC8vIC0tLSBMRUZUIFNJREU6IERyYWcgaGFuZGxlICsga2V5d29yZHMgLS0tXG4gICAgICAgICAgICBzZXR0aW5nLm5hbWVFbC5lbXB0eSgpO1xuXG4gICAgICAgICAgICAvLyBJbmRlbnQgcm93cyBieSAyMHB4IHBlciBkZXB0aCAoZnJhbWUgYW5kIGNvbnRlbnQpXG4gICAgICAgICAgICBzZXR0aW5nLnNldHRpbmdFbC5zdHlsZS5tYXJnaW5MZWZ0ID0gYCR7ZGVwdGggKiAyMH1weGA7XG4gICAgICAgICAgICBpZiAoc2V0dGluZy5uYW1lRWwucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHNldHRpbmcubmFtZUVsLnBhcmVudEVsZW1lbnQuc3R5bGUubWFyZ2luSW5saW5lRW5kID0gXCIwcHhcIjtcbiAgICAgICAgICAgICAgICBzZXR0aW5nLm5hbWVFbC5wYXJlbnRFbGVtZW50LnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgICAgICAgICAgICAgc2V0dGluZy5uYW1lRWwucGFyZW50RWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJmbGV4XCI7XG4gICAgICAgICAgICAgICAgc2V0dGluZy5uYW1lRWwucGFyZW50RWxlbWVudC5zdHlsZS5mbGV4RGlyZWN0aW9uID0gXCJjb2x1bW5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldHRpbmcubmFtZUVsLnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcbiAgICAgICAgICAgIHNldHRpbmcubmFtZUVsLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG5cbiAgICAgICAgICAgIC8vIERyYWcgaGFuZGxlIChsZWZ0KVxuICAgICAgICAgICAgY29uc3QgZHJhZ0hhbmRsZSA9IHNldHRpbmcubmFtZUVsLmNyZWF0ZVNwYW4oeyBjbHM6IFwiRk1BLWZvbGRlci1saXN0LWRyYWctaGFuZGxlXCIgfSk7XG4gICAgICAgICAgICBkcmFnSGFuZGxlLnNldFRleHQoXCJcdTIyNjFcIik7XG4gICAgICAgICAgICBkcmFnSGFuZGxlLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBkcmFnSGFuZGxlLnN0eWxlLm1hcmdpblJpZ2h0ID0gXCIwLjVlbVwiO1xuICAgICAgICAgICAgZHJhZ0hhbmRsZS5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ3N0YXJ0XCIsIChlKSA9PiB0aGlzLm9uRHJhZ1N0YXJ0KGUsIFwicm93XCIsIHJvdy5pZCkpO1xuICAgICAgICAgICAgZHJhZ0hhbmRsZS5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIiwgKGUpID0+IHRoaXMub25EcmFnT3ZlcihlLCBcInJvd1wiLCByb3cuaWQpKTtcbiAgICAgICAgICAgIGRyYWdIYW5kbGUuYWRkRXZlbnRMaXN0ZW5lcihcImRyb3BcIiwgKGUpID0+IHRoaXMub25Ecm9wKGUsIFwicm93XCIsIHJvdy5pZCkpO1xuXG4gICAgICAgICAgICBpZiAocm93LmRpc2FibGVkKSBzZXR0aW5nLnNldHRpbmdFbC5hZGRDbGFzcyhcIkZNQS1tb2QtRm9sZGVyTGlzdC1kaXNhYmxlZFwiKTtcbiAgICAgICAgICAgIC8vIFJvdyBjb250ZW50IChjdXN0b21pemFibGUsIGUuZy4ga2V5d29yZHMpXG4gICAgICAgICAgICB0aGlzLnJvd1JlbmRlckNiKHJvdywgc2V0dGluZy5uYW1lRWwpOyAgXG5cbiAgICAgICAgICAgIC8vIERyYWcgZXZlbnRzIGZvciByb3dcbiAgICAgICAgICAgIHNldHRpbmcuc2V0dGluZ0VsLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnb3ZlclwiLCAoZSkgPT4gdGhpcy5vbkRyYWdPdmVyKGUsIFwicm93XCIsIHJvdy5pZCkpO1xuICAgICAgICAgICAgc2V0dGluZy5zZXR0aW5nRWwuYWRkRXZlbnRMaXN0ZW5lcihcImRyb3BcIiwgKGUpID0+IHRoaXMub25Ecm9wKGUsIFwicm93XCIsIHJvdy5pZCkpO1xuICAgICAgICAgICAgc2V0dGluZy5zZXR0aW5nRWwuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdsZWF2ZVwiLCAoZSkgPT4gdGhpcy5vbkRyYWdMZWF2ZShlKSk7IC8vIDwtLSBBREQgVEhJUyBMSU5FXG5cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gLS0tIERyYWcgJiBEcm9wIEhhbmRsZXJzIChzaW1wbGlmaWVkLCBleHBhbmQgYXMgbmVlZGVkKSAtLS1cbiAgICBwcml2YXRlIG9uRHJhZ1N0YXJ0KGU6IERyYWdFdmVudCwgdHlwZTogRk1BRm9sZGVyTGlzdERyYWdUYXJnZXQsIGlkOiBzdHJpbmcpIHtcbiAgICAgICAgZS5kYXRhVHJhbnNmZXI/LnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIEpTT04uc3RyaW5naWZ5KHsgdHlwZSwgaWQgfSkpO1xuICAgIH1cbiAgICBwcml2YXRlIG9uRHJhZ092ZXIoZTogRHJhZ0V2ZW50LCB0eXBlOiBGTUFGb2xkZXJMaXN0RHJhZ1RhcmdldCwgaWQ6IHN0cmluZykge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGUuY3VycmVudFRhcmdldCBhcyBIVE1MRWxlbWVudDtcblxuICAgICAgICAvLyBQcmV2ZW50IGRyYWdnaW5nIGZvbGRlcnMgb250byByb3dzXG4gICAgICAgIGNvbnN0IGRhdGEgPSBlLmRhdGFUcmFuc2Zlcj8uZ2V0RGF0YShcInRleHQvcGxhaW5cIik7XG4gICAgICAgIGlmICh0eXBlID09PSBcInJvd1wiICYmIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZTogZHJhZ1R5cGUgfSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBpZiAoZHJhZ1R5cGUgPT09IFwiZm9sZGVyXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBhbGxvdyBmb2xkZXIgZHJvcCBvbiByb3dcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb2xkZXIgaGlnaGxpZ2h0XG4gICAgICAgIGlmICh0eXBlID09PSBcImZvbGRlclwiKSB7XG4gICAgICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZChcIkZNQS1kcm9wLXRhcmdldFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJvdzogc2hvdyBhYm92ZS9iZWxvdyBpbmRpY2F0b3JcbiAgICAgICAgaWYgKHR5cGUgPT09IFwicm93XCIpIHtcbiAgICAgICAgICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKFwiRk1BLWRyb3AtdGFyZ2V0XCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvbkRyYWdMZWF2ZShlOiBEcmFnRXZlbnQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xuICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZShcIkZNQS1kcm9wLXRhcmdldFwiKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uRHJvcChlOiBEcmFnRXZlbnQsIHR5cGU6IEZNQUZvbGRlckxpc3REcmFnVGFyZ2V0LCB0YXJnZXRJZDogc3RyaW5nKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTsgLy8gUHJldmVudCBtdWx0aXBsZSBldmVudHNcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xuICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZShcIkZNQS1kcm9wLXRhcmdldFwiKTtcblxuICAgICAgICBjb25zdCBkYXRhID0gZS5kYXRhVHJhbnNmZXI/LmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpO1xuICAgICAgICBpZiAoIWRhdGEpIHJldHVybjtcbiAgICAgICAgY29uc3QgeyB0eXBlOiBkcmFnVHlwZSwgaWQ6IGRyYWdJZCB9ID0gSlNPTi5wYXJzZShkYXRhKTtcblxuICAgICAgICBpZiAoZHJhZ1R5cGUgPT09IFwicm93XCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImZvbGRlclwiKSB7XG4gICAgICAgICAgICAgICAgLy8gTW92ZSByb3cgdG8gdGhpcyBmb2xkZXJcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVSb3dUb0ZvbGRlcihkcmFnSWQsIHRhcmdldElkKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJyb3dcIikge1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZVJvdyhkcmFnSWQsIHRhcmdldElkKTsgLy8gTW92ZSByb3cgdG8gbmV3IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRHJvcHBpbmcgb24gdGhlIGRyb3Agem9uZSBhdCB0aGUgZW5kXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJyb290XCIgJiYgdGFyZ2V0SWQgPT09IFwicm93LWRyb3B6b25lXCIpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZHJhZ1R5cGUgPT09IFwiZm9sZGVyXCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImZvbGRlclwiKSB7XG4gICAgICAgICAgICAgICAgLy8gTW92ZSBmb2xkZXIgdG8gdGhpcyBmb2xkZXJcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVGb2xkZXJUb0ZvbGRlcihkcmFnSWQsIHRhcmdldElkKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEcm9wcGluZyBvbiB0aGUgZHJvcCB6b25lIGF0IHRoZSBlbmRcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcInJvb3RcIiAmJiB0YXJnZXRJZCA9PT0gXCJmb2xkZXItZHJvcHpvbmVcIikge1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZUZvbGRlclRvRm9sZGVyKGRyYWdJZCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHJvd01hdGNoZXNGaWx0ZXIocm93OiBUcmVlSGllcmFyY2h5Um93KTogYm9vbGVhbiB7XG4gICAgICAgIGlmICghdGhpcy5maWx0ZXIpIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gcm93LmtleXdvcmRzLnNvbWUoayA9PiBrLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXModGhpcy5maWx0ZXIudG9Mb3dlckNhc2UoKSkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0TmV4dEZvbGRlck5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IGkgPSAxO1xuICAgICAgICBsZXQgbmFtZSA6IHN0cmluZztcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgbmFtZSA9IGBGb2xkZXIgJHtpKyt9YDtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5kYXRhLmZvbGRlcnMuc29tZShmID0+IGYubmFtZSA9PT0gbmFtZSkpO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGRlbGV0ZUZvbGRlckFuZENvbnRlbnRzKGZvbGRlcklkOiBzdHJpbmcpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBzdWJmb2xkZXJzIGFuZCByb3dzIHJlY3Vyc2l2ZWx5XG4gICAgICAgIGNvbnN0IHN1YmZvbGRlcnMgPSB0aGlzLmRhdGEuZm9sZGVycy5maWx0ZXIoZiA9PiBmLnBhcmVudElkID09PSBmb2xkZXJJZCk7XG4gICAgICAgIHN1YmZvbGRlcnMuZm9yRWFjaChmID0+IHRoaXMuZGVsZXRlRm9sZGVyQW5kQ29udGVudHMoZi5pZCkpO1xuXG4gICAgICAgIC8vIENhbGwgb25Sb3dEZWxldGVkQ2IgZm9yIGVhY2ggcm93IGluIHRoaXMgZm9sZGVyXG4gICAgICAgIGNvbnN0IHJvd3NUb0RlbGV0ZSA9IHRoaXMuZGF0YS5yb3dzLmZpbHRlcihyID0+IHIuZm9sZGVySWQgPT09IGZvbGRlcklkKTtcbiAgICAgICAgcm93c1RvRGVsZXRlLmZvckVhY2gocm93ID0+IHRoaXMub25Sb3dEZWxldGVkQ2Iocm93KSk7XG5cbiAgICAgICAgdGhpcy5kYXRhLmZvbGRlcnMgPSB0aGlzLmRhdGEuZm9sZGVycy5maWx0ZXIoZiA9PiBmLmlkICE9PSBmb2xkZXJJZCk7XG4gICAgICAgIHRoaXMuZGF0YS5yb3dzID0gdGhpcy5kYXRhLnJvd3MuZmlsdGVyKHIgPT4gci5mb2xkZXJJZCAhPT0gZm9sZGVySWQpO1xuICAgIH1cbn0iLCAiaW1wb3J0IHsgTW9kYWwsIE1hcmtkb3duUmVuZGVyZXIsIEFwcCB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIE1hcmtkb3duSGVscE1vZGFsIGV4dGVuZHMgTW9kYWwge1xyXG4gICAgbWFya2Rvd246IHN0cmluZztcclxuICAgIHNvdXJjZVBhdGg6IHN0cmluZztcclxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBtYXJrZG93bjogc3RyaW5nLCBzb3VyY2VQYXRoOiBzdHJpbmcgPSBcIlwiKSB7XHJcbiAgICAgICAgc3VwZXIoYXBwKTtcclxuICAgICAgICB0aGlzLm1hcmtkb3duID0gbWFya2Rvd247XHJcbiAgICAgICAgdGhpcy5zb3VyY2VQYXRoID0gc291cmNlUGF0aDtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uT3BlbigpIHtcclxuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcclxuICAgICAgICBjb250ZW50RWwuZW1wdHkoKTtcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgYXdhaXQgTWFya2Rvd25SZW5kZXJlci5yZW5kZXIodGhpcy5hcHAsIHRoaXMubWFya2Rvd24sIGNvbnRlbnRFbCwgdGhpcy5zb3VyY2VQYXRoLCB0aGlzKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hNYXJrZG93bkZyb21HaXRIdWIodXJsOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xyXG4gICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGxvYWQgZmlsZSBmcm9tIEdpdEh1YlwiKTtcclxuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS50ZXh0KCk7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkUGx1Z2luRG9jRmlsZSh0aGlzOiBhbnksIGZpbGVuYW1lOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgY29uc3QgZmlsZVBhdGggPSBgLm9ic2lkaWFuL3BsdWdpbnMvZm9sZGVyLXRvLXRhZ3MtcGx1Z2luL2RvYy8ke2ZpbGVuYW1lfWA7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLnJlYWQoZmlsZVBhdGgpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcmVhZCBmaWxlICcke2ZpbGVQYXRofSc6ICR7bWVzc2FnZX1gKTtcclxuICAgIH1cclxufSIsICJpbXBvcnQgeyBSdWxlUHJvdG90eXBlLCBydWxlc01hbmFnZXIgfSBmcm9tIFwiLi9ydWxlc1wiO1xyXG5pbXBvcnQgeyBTY3JpcHRpbmdUb29scyB9IGZyb20gXCIuLi90b29sc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFNldHRpbmcsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MgfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuXHJcblxyXG4vKipcclxuICogQSBydWxlIGNsYXNzIHRoYXQgYWRkcyBhIGNvbmZpZ3VyYWJsZSBwcmVmaXggdG8gYW4gaW5wdXQgdmFsdWUuXHJcbiAqIFxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUaGlzIHJ1bGUgaXMgaW50ZW5kZWQgZm9yIHVzZSBpbiBmb3JtYXR0aW5nIG9wZXJhdGlvbnMsIHN1Y2ggYXMgYWRkaW5nIGEgcHJlZml4IHRvIHRleHQsIHRhZ3MsIGFsaWFzZXMsIG9yIG11bHRpLXRleHQgZmllbGRzLlxyXG4gKiBUaGUgcHJlZml4IHZhbHVlIGlzIGNvbmZpZ3VyYWJsZSB2aWEgdGhlIHBsdWdpbidzIHNldHRpbmdzIFVJLlxyXG4gKiBcclxuICogQGV4dGVuZHMgUnVsZVByb3RvdHlwZVxyXG4gKiBcclxuICogQGV4YW1wbGVcclxuICogLy8gVXNhZ2UgaW4gYSBmb3JtYXR0aW5nIHBpcGVsaW5lOlxyXG4gKiBjb25zdCByZXN1bHQgPSBydWxlQWRkUHJlZml4LmZ4KGFwcCwgZmlsZSwgdG9vbHMsIFwiZXhhbXBsZVwiKTtcclxuICogLy8gSWYgcHJlZml4IGlzIHNldCB0byBcInByZS1cIiwgcmVzdWx0IHdpbGwgYmUgXCJwcmUtZXhhbXBsZVwiXHJcbiAqIFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBydWxlICgnYWRkUHJlZml4JykuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIGRpc3BsYXkgbmFtZSBmb3IgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXNjcmlwdGlvbiAtIEEgc2hvcnQgZGVzY3JpcHRpb24gb2Ygd2hhdCB0aGUgcnVsZSBkb2VzLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcnVsZVR5cGUgLSBUaGUgdHlwZSBvZiBydWxlICgnZm9ybWF0dGVyJykuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBUaGUgc291cmNlIGNvZGUgZm9yIHRoZSBydWxlIGFzIGEgc3RyaW5nLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSB0eXBlIC0gVGhlIHR5cGVzIG9mIGZpZWxkcyB0aGlzIHJ1bGUgY2FuIGJlIGFwcGxpZWQgdG8uXHJcbiAqIEBwcm9wZXJ0eSB7YW55fSBjb25maWdFbGVtZW50cyAtIFRoZSBjb25maWd1cmF0aW9uIGVsZW1lbnRzIGZvciB0aGUgcnVsZS5cclxuICogXHJcbiAqIEBtZXRob2QgZnhcclxuICogQWRkcyB0aGUgY29uZmlndXJlZCBwcmVmaXggdG8gdGhlIHByb3ZpZGVkIGlucHV0IHZhbHVlLlxyXG4gKiBcclxuICogQG1ldGhvZCBjb25maWdUYWJcclxuICogUmVuZGVycyB0aGUgY29uZmlndXJhdGlvbiBVSSBmb3Igc2V0dGluZyB0aGUgcHJlZml4IHZhbHVlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVBZGRQcmVmaXggZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9ICdhZGRQcmVmaXgnO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdBZGQgYSBQcmVmaXgnO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnQWRkcyBhIHByZWZpeCB0byB0aGUgaW5wdXQgdmFsdWUuJztcclxuICAgICAgICB0aGlzLnJ1bGVUeXBlID0gJ2Zvcm1hdHRlcic7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgbGV0IHJlc3VsdCA9ICcnO1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59XCI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZnggKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBhbnksIHRvb2xzOiBTY3JpcHRpbmdUb29scywgaW5wdXQ/OmFueSkgeyAvLyBEZWZhdWx0IGZ1bmN0aW9uIHNpZ25hdHVyZVxyXG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHRvb2xzLmdldE9wdGlvbkNvbmZpZyh0b29scy5nZXRSdWxlKCk/LmlkLCAncHJlZml4Jyk7XHJcbiAgICAgICAgcmV0dXJuIGAke3ByZWZpeH0ke2lucHV0fWA7IC8vIFJldHVybiB0aGUgaW5wdXQgd2l0aCBhIHByZWZpeCBhZGRlZFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25maWdUYWIob3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOiBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCB0aGF0OiBhbnksIHByZXZpZXdDb21wb25lbnQ6IGFueSkge1xyXG4gICAgICAgIG9wdGlvbkVMLmVtcHR5KCk7XHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgc2V0dGluZyBmb3IgdGhlIHNtYWxsIHdvcmRzXHJcbiAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWdEZWZhdWx0cyhydWxlLmlkLCB7XHJcbiAgICAgICAgICAgIHByZWZpeCA6ICcnLCAvLyBEZWZhdWx0IHByZWZpeFxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnUHJlZml4JylcclxuICAgICAgICAgICAgLnNldERlc2MoJ0VudGVyIGEgcHJlZml4IHRvIGJlIGFkZGVkIGF0IHRoZSBiZWdpbm5pbmcuJylcclxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ2UuZy4gXCJwcmUtXCInKVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoYXQuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQgLCdwcmVmaXgnKSB8fCAnJylcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZyhydWxlLmlkLCdwcmVmaXgnLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC51cGRhdGVQcmV2aWV3KHJ1bGUsIHByZXZpZXdDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgIH07XHJcbn0iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgQXBwLCBTZXR0aW5nLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgeyBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzIH0gZnJvbSBcIi4uL3R5cGVzXCI7XHJcblxyXG4vKipcclxuICogQSBydWxlIGNsYXNzIHRoYXQgYXBwZW5kcyBhIGNvbmZpZ3VyYWJsZSBzdWZmaXggdG8gdGhlIGlucHV0IHZhbHVlLlxyXG4gKiBcclxuICogQHJlbWFya3NcclxuICogVGhpcyBydWxlIGlzIGludGVuZGVkIGZvciB1c2Ugd2l0aGluIHRoZSBGb2xkZXIgdG8gVGFncyBwbHVnaW4sIGFsbG93aW5nIHVzZXJzIHRvIGZvcm1hdCB0ZXh0LCB0YWdzLCBhbGlhc2VzLCBvciBtdWx0aXRleHQgZmllbGRzIGJ5IGFkZGluZyBhIHNwZWNpZmllZCBzdWZmaXguXHJcbiAqIFxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBVc2FnZSBpbiBhIHJ1bGUgY2hhaW5cclxuICogY29uc3QgcmVzdWx0ID0gcnVsZUFkZFN1ZmZpeC5meChhcHAsIGZpbGUsIHRvb2xzLCBcIm5vdGVcIik7XHJcbiAqIC8vIElmIHN1ZmZpeCBpcyBcIl9kb25lXCIsIHJlc3VsdCB3aWxsIGJlIFwibm90ZV9kb25lXCJcclxuICogXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHJ1bGUgKFwiYWRkU3VmZml4XCIpLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBkaXNwbGF5IG5hbWUgZm9yIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGVzY3JpcHRpb24gLSBBIGJyaWVmIGRlc2NyaXB0aW9uIG9mIHRoZSBydWxlJ3MgcHVycG9zZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJ1bGVUeXBlIC0gVGhlIHR5cGUgb2YgcnVsZSAoXCJmb3JtYXR0ZXJcIikuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBUaGUgc291cmNlIGNvZGUgZm9yIHRoZSBydWxlIGFzIGEgc3RyaW5nLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSB0eXBlIC0gVGhlIHR5cGVzIG9mIGZpZWxkcyB0aGlzIHJ1bGUgY2FuIGJlIGFwcGxpZWQgdG8uXHJcbiAqIEBwcm9wZXJ0eSB7YW55fSBjb25maWdFbGVtZW50cyAtIFRoZSBjb25maWd1cmF0aW9uIGVsZW1lbnRzIGZvciB0aGUgcnVsZS5cclxuICogXHJcbiAqIEBtZXRob2QgZnhcclxuICogQXBwZW5kcyB0aGUgY29uZmlndXJlZCBzdWZmaXggdG8gdGhlIHByb3ZpZGVkIGlucHV0IHZhbHVlLlxyXG4gKiBcclxuICogQG1ldGhvZCBjb25maWdUYWJcclxuICogUmVuZGVycyB0aGUgY29uZmlndXJhdGlvbiBVSSBmb3Igc2V0dGluZyB0aGUgc3VmZml4IGluIHRoZSBwbHVnaW4ncyBzZXR0aW5ncyB0YWIuXHJcbiAqIFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVBZGRTdWZmaXggZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9ICdhZGRTdWZmaXgnO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdBZGQgYSBTdWZmaXgnO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnQWRkcyBhIHN1ZmZpeCB0byB0aGUgaW5wdXQgdmFsdWUuJztcclxuICAgICAgICB0aGlzLnJ1bGVUeXBlID0gJ2Zvcm1hdHRlcic7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgbGV0IHJlc3VsdCA9ICcnO1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59XCI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZnggKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBhbnksIHRvb2xzOiBTY3JpcHRpbmdUb29scywgaW5wdXQ/OmFueSkgeyAvLyBEZWZhdWx0IGZ1bmN0aW9uIHNpZ25hdHVyZVxyXG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IHRvb2xzLmdldE9wdGlvbkNvbmZpZyh0b29scy5nZXRSdWxlKCk/LmlkLCAnc3VmZml4Jyk7XHJcbiAgICAgICAgcmV0dXJuIGAke2lucHV0fSR7c3VmZml4fWA7IC8vIFJldHVybiB0aGUgaW5wdXQgd2l0aCBhIHN1ZmZpeCBhZGRlZFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25maWdUYWIob3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOiBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCB0aGF0OiBhbnksIHByZXZpZXdDb21wb25lbnQ6IGFueSkge1xyXG4gICAgICAgIG9wdGlvbkVMLmVtcHR5KCk7XHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgc2V0dGluZyBmb3IgdGhlIHNtYWxsIHdvcmRzXHJcbiAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWdEZWZhdWx0cyhydWxlLmlkLCB7XHJcbiAgICAgICAgICAgIHN1ZmZpeCA6ICcnLCAvLyBEZWZhdWx0IHN1ZmZpeFxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnU3VmZml4JylcclxuICAgICAgICAgICAgLnNldERlc2MoJ0VudGVyIGEgc3VmZml4IHRvIGJlIGFkZGVkIGF0IHRoZSBlbmQuJylcclxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ2UuZy4gXCJfZG9uZVwiJylcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGF0LmdldE9wdGlvbkNvbmZpZyhydWxlLmlkICwnc3VmZml4JykgfHwgJycpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWcocnVsZS5pZCwnc3VmZml4JywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudXBkYXRlUHJldmlldyhydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICk7XHJcbiAgICB9O1xyXG59IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MgfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuaW1wb3J0IHsgQXBwLCBTZWFyY2hDb21wb25lbnQsIFNldHRpbmcsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7IEZvbGRlclN1Z2dlc3QgfSBmcm9tIFwiLi4vc3VnZ2VzdGVycy9Gb2xkZXJTdWdnZXN0ZXJcIjtcclxuaW1wb3J0IHsgRGlyZWN0b3J5U2VsZWN0aW9uUmVzdWx0LCBvcGVuRGlyZWN0b3J5U2VsZWN0aW9uTW9kYWwgfSBmcm9tIFwiLi4vZGlyZWN0b3J5U2VsZWN0aW9uTW9kYWxcIjtcclxuaW1wb3J0IHsgRmlsZVN1Z2dlc3QgfSBmcm9tIFwiLi4vc3VnZ2VzdGVycy9GaWxlU3VnZ2VzdGVyXCI7XHJcbmltcG9ydCB7IEFsZXJ0TW9kYWwgfSBmcm9tIFwiLi4vYWxlcnRCb3hcIjtcclxuaW1wb3J0IHsgRVJST1IsIGxvZ2dlciB9IGZyb20gXCIuLi9Mb2dcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBSdWxlQXV0b21hdGlvbkF1dG9MaW5rIGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaWQgPSAnYXV0b0xpbmsnO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdBdXRvIExpbmsgKGFkdmFuY2VkKSc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdDaGVja3MgaWYgYSBsaW5rIGV4aXN0cyBpbiBhIHNwZWNpZmllZCBmb2xkZXIuIElmIG5vdCwgaXQgY3JlYXRlcyBhIG5ldyBmaWxlIGJhc2VkIG9uIGEgc3BlY2lmaWVkIHRlbXBsYXRlIGFuZCBhZGRzIGEgbGluayB0byBpdC4nO1xyXG4gICAgICAgIHRoaXMucnVsZVR5cGUgPSAnYXV0b21hdGlvbic7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgbGV0IHJlc3VsdCA9ICcnO1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59XCI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gWyd0ZXh0JywgJ211bHRpdGV4dCddO1xyXG4gICAgICAgIHRoaXMuY29uZmlnRWxlbWVudHMgPSB0aGlzLmRlZmF1bHRDb25maWdFbGVtZW50cyh7cmVtb3ZlQ29udGVudDogZmFsc2UsICBpbnB1dFByb3BlcnR5OiBmYWxzZSwgYWRkUHJlZml4OiBmYWxzZSwgc3BhY2VSZXBsYWNlbWVudDogZmFsc2UsIHNwZWNpYWxDaGFyYWN0ZXJSZXBsYWNlbWVudDogZmFsc2UsIGNvbnZlcnRUb0xvd2VyQ2FzZTogZmFsc2UsIHJlc3VsdEFzTGluazogZmFsc2UsIHNjcmlwdDogZmFsc2V9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIHRvIGNyZWF0ZSBhIGxpbmsgdG8gYSBmaWxlLiBJZiB0aGUgZmlsZSBkb2VzIG5vdCBleGlzdCwgaXQgY3JlYXRlcyBhIG5ldyBmaWxlIGJhc2VkIG9uIGEgdGVtcGxhdGUuXHJcbiAgICAgKiBAcGFyYW0gYXBwIC0gVGhlIE9ic2lkaWFuIGFwcCBpbnN0YW5jZS5cclxuICAgICAqIEBwYXJhbSBmaWxlIC0gVGhlIGN1cnJlbnQgZmlsZS5cclxuICAgICAqIEBwYXJhbSB0b29scyAtIFRoZSBzY3JpcHRpbmcgdG9vbHMgaW5zdGFuY2UuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3IGNvbnRlbnQgZm9yIHRoZSBmcm9udG1hdHRlciBwcm9wZXJ0eS5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZnggKGFwcDpBcHAsIGZpbGU6VEZpbGUsIHRvb2xzOlNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRDb250ZW50ID0gdG9vbHMuZ2V0Q3VycmVudENvbnRlbnQoKTtcclxuICAgICAgICBsZXQgbmV3Q29udGVudCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XHJcbiAgICAgICAgY29uc3QgcnVsZSA9IHRvb2xzLmdldFJ1bGUoKTtcclxuICAgICAgICBpZiAoIXJ1bGUpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmxvZyhFUlJPUixgYXV0b0xpbms6IHJ1bGUgbm90IGZvdW5kLCByZXR1cm5pbmcgY3VycmVudCBjb250ZW50ICR7Y3VycmVudENvbnRlbnR9YCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50Q29udGVudDtcclxuICAgICAgICB9IFxyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0b29scy5nZXRPcHRpb25Db25maWcocnVsZS5pZCk7XHJcbiAgICAgICAgY29uc3QgZmlsZXNUb0NoZWNrID0gdG9vbHMuZ2V0RmlsZXNJblZhdWx0KG9wdGlvbnMuZGVzdGluYXRpb25Gb2xkZXIpO1xyXG4gICAgICAgIGxldCBsaW5rcyA9IGN1cnJlbnRDb250ZW50IHx8IFtdO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbGlua3MgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGxpbmtzKSkge1xyXG4gICAgICAgICAgICBsaW5rcyA9IFtdOyAvLyBjb252ZXJ0IG9iamVjdCB0byBhcnJheVxyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpbmtzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBsaW5rcyA9IFtsaW5rc107IC8vIGNvbnZlcnQgdG8gYXJyYXkgaWYgbm90IGFscmVhZHkgYW4gYXJyYXlcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbG9nZ2VyLmxvZyhERUJVRyxgYXV0b0xpbms6IGxpbmtzIHRvIGNoZWNrYCwgbGlua3MsIGZpbGVzVG9DaGVjayk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIGxpbmtzKSAge1xyXG4gICAgICAgICAgICBsZXQgbGluayA9IHRvb2xzLmV4dHJhY3RMaW5rUGFydHMocGFydCk7XHJcbiAgICAgICAgICAgIGxldCBsaW5rRmlsZSA9IHRvb2xzLmdldFRGaWxlRnJvbVBhdGgobGluay5wYXRoLCBmaWxlc1RvQ2hlY2spO1xyXG4gICAgICAgICAgICBpZiAoIWxpbmtGaWxlKSB7IC8vIGNyZWF0ZSBuZXcgRmlsZVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hc2tDb25maXJtYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG5ldyBBbGVydE1vZGFsKGFwcCwgJ0NyZWF0ZSBuZXcgZmlsZScsIGBGaWxlICR7bGluay5wYXRofSBkb2VzIG5vdCBleGlzdC4gRG8geW91IHdhbnQgdG8gY3JlYXRlIGl0P2AsICdDcmVhdGUnLCAnQ2FuY2VsJywgXCJEb24ndCBhc2sgYWdhaW4uXCIpLm9wZW5BbmRHZXRWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQucHJvY2VlZCkgcmV0dXJuOyAvLyBkbyBub3QgY3JlYXRlIHRoZSBmaWxlIGlmIHRoZSB1c2VyIGRvZXMgbm90IGNvbmZpcm1cclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuYXNrQ29uZmlybWF0aW9uID0gIXJlc3VsdC5kYXRhLmFza0NvbmZpcm1hdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsaW5rLnBhdGggPSBvcHRpb25zLmRlc3RpbmF0aW9uRm9sZGVyICsgJy8nICsgbGluay50aXRsZSArICcubWQnOyAvLyBhZGQgdGhlIGRlc3RpbmF0aW9uIGZvbGRlciB0byB0aGUgbGluayBwYXRoXHJcbiAgICAgICAgICAgIC8vbG9nZ2VyLmxvZyhERUJVRyxgYXV0b0xpbms6IGNyZWF0aW5nIG5ldyBmaWxlICR7bGluay5wYXRofWApO1xyXG4gICAgICAgICAgICBsaW5rRmlsZSA9IGF3YWl0IHRvb2xzLmNyZWF0ZUZpbGVGcm9tUGF0aChsaW5rLnBhdGgsIG9wdGlvbnMuYWRkVGVtcGxhdGUgPyBvcHRpb25zLnRlbXBsYXRlRmlsZSA6IHVuZGVmaW5lZCk7IC8vIGNyZWF0ZSB0aGUgZmlsZSBpZiBpdCBkb2VzIG5vdCBleGlzdFxyXG4gICAgICAgICAgICAvL2xvZ2dlci5sb2coREVCVUcsYGF1dG9MaW5rOiBuZXcgZmlsZSBjcmVhdGVkICR7bGlua0ZpbGUucGF0aH1gKTtcclxuICAgICAgICAgICAgdG9vbHMudXBkYXRlRnJvbnRtYXR0ZXIocnVsZS5wcm9wZXJ0eSwgW2BbWyR7dG9vbHMucmVtb3ZlTGVhZGluZ1NsYXNoKGxpbmsucGF0aCl9fCR7bGluay50aXRsZX1dXWBdLCBsaW5rRmlsZSk7IC8vIGFkZCBsb2NhdGlvbiBvZiBuZXcgcGF0aCB0byBpdHNlbGZcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy9sb2dnZXIubG9nKERFQlVHLGBhdXRvTGluazogY3JlYXRpbmcgTGluayB0byBleGlzdGluZyBGaWxlICR7bGlua0ZpbGUucGF0aH1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGlua0ZpbGUpIHtcclxuICAgICAgICAgICAgbGluay5wYXRoID0gbGlua0ZpbGUucGF0aDtcclxuICAgICAgICAgICAgbmV3Q29udGVudC5wdXNoKGBbWyR7dG9vbHMucmVtb3ZlTGVhZGluZ1NsYXNoKGxpbmsucGF0aCl9fCR7bGluay50aXRsZX1dXWApOyAvLyBhZGQgdGhlIGZpbGUgcGF0aCB0byB0aGUgbmV3IGNvbnRlbnRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2xvZ2dlci5sb2coREVCVUcsYGF1dG9MaW5rOiBuZXcgY29udGVudGAsIG5ld0NvbnRlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL2xvZ2dlci5sb2coREVCVUcsYGF1dG9MaW5rOiB3cml0ZSBjb250ZW50YCwgbmV3Q29udGVudCk7XHJcbiAgICAgICAgdG9vbHMudXBkYXRlRnJvbnRtYXR0ZXIocnVsZS5wcm9wZXJ0eSwgbmV3Q29udGVudCk7IC8vIHVwZGF0ZSB0aGUgZnJvbnRtYXR0ZXIgd2l0aCB0aGUgbmV3IGNvbnRlbnRcclxuICAgICAgICByZXR1cm4gbmV3Q29udGVudDsgICAgXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbmZpZ1RhYiAob3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOkZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIHRoYXQ6YW55LCBwcmV2aWV3Q29tcG9uZW50OiBhbnkpIHtcclxuICAgICAgICBvcHRpb25FTC5lbXB0eSgpO1xyXG4gICAgICAgIC8vIENyZWF0ZSBhIHNldHRpbmcgZm9yIHRoZSBhdXRvIGxpbmtcclxuICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZ0RlZmF1bHRzKHJ1bGUuaWQsIHtcclxuICAgICAgICAgICAgYWRkVGVtcGxhdGU6IHRydWUsXHJcbiAgICAgICAgICAgIGFza0NvbmZpcm1hdGlvbjogdHJ1ZSxcclxuICAgICAgICAgICAgZGVzdGluYXRpb25Gb2xkZXI6ICcvJyxcclxuICAgICAgICAgICAgdGVtcGxhdGVGaWxlOiAnJyxcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBuZXcgU2V0dGluZyhvcHRpb25FTClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ0FkZCB0ZW1wbGF0ZSB0byBuZXcgZmlsZXMnKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnQXV0b21hdGljYWxseSBhZGQgdGVtcGxhdGUgdG8gbmV3IGZpbGVzJylcclxuICAgICAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhhdC5nZXRPcHRpb25Db25maWcocnVsZS5pZCAsJ2FkZFRlbXBsYXRlJykgfHwgZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWcocnVsZS5pZCwnYWRkVGVtcGxhdGUnLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnQXNrIGZvciBjb25maXJtYXRpb24nKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnQXNrIGZvciBjb25maXJtYXRpb24gYmVmb3JlIGNyZWF0aW5nIG5ldyBmaWxlcycpXHJcbiAgICAgICAgICAgIC5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoYXQuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQgLCdhc2tDb25maXJtYXRpb24nKSB8fCBmYWxzZSlcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZyhydWxlLmlkLCdhc2tDb25maXJtYXRpb24nLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIGxldCBkZXN0aW5hdGlvbkZvbGRlckVsOlNlYXJjaENvbXBvbmVudDsgIFxyXG4gICAgICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnRGVzdGluYXRpb24gRm9sZGVyJylcclxuICAgICAgICAgICAgLnNldERlc2MoJ0ZvbGRlciB0byBwbGFjZSBuZXcgZmlsZXMnKVxyXG4gICAgICAgICAgICAuYWRkU2VhcmNoKChjYikgPT4ge1xyXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25Gb2xkZXJFbCA9IGNiO1xyXG4gICAgICAgICAgICAgICAgbmV3IEZvbGRlclN1Z2dlc3QodGhhdC5hcHAsIGNiLmlucHV0RWwpO1xyXG4gICAgICAgICAgICAgICAgY2Iuc2V0UGxhY2Vob2xkZXIoXCJlbnRlciBmb2xkZXIgb3IgYnJvd3NlIC4uLlwiKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGF0LmdldE9wdGlvbkNvbmZpZyhydWxlLmlkICwnZGVzdGluYXRpb25Gb2xkZXInKSB8fCAnJylcclxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoKG5ld0ZvbGRlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdGb2xkZXIgPSBuZXdGb2xkZXIudHJpbSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0ZvbGRlciA9IG5ld0ZvbGRlci5yZXBsYWNlKC9cXC8kLywgXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQsJ2Rlc3RpbmF0aW9uRm9sZGVyJywgbmV3Rm9sZGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgICAgIGNiLmNvbnRhaW5lckVsLmFkZENsYXNzKFwiZnJvbnRtYXR0ZXItYXV0b21hdGUtc2VhcmNoXCIpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYWRkRXh0cmFCdXR0b24oKGJ1dHRvbikgPT5cclxuICAgICAgICAgICAgYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAuc2V0SWNvbignZm9sZGVyLXRyZWUnKVxyXG4gICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoJ1NlbGVjdCB0ZW1wbGF0ZSBmb2xkZXInKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgb3BlbkRpcmVjdG9yeVNlbGVjdGlvbk1vZGFsKFxyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYXBwLFxyXG4gICAgICAgICAgICAgICAgICAgIFt0aGF0LmdldE9wdGlvbkNvbmZpZyhydWxlLmlkICwnZGVzdGluYXRpb25Gb2xkZXInKV0sXHJcbiAgICAgICAgICAgICAgICAgICAgW10sXHJcbiAgICAgICAgICAgICAgICAgICAgeyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdTZWxlY3QgZm9sZGVyIHRvIHBsYWNlIG5ldyBmaWxlcycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbk1vZGU6ICdpbmNsdWRlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU1vZGU6ICdmb2xkZXInLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25TZWxlY3Rpb25Nb2RlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uU2hvd0ZpbGVzOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQ6IERpcmVjdG9yeVNlbGVjdGlvblJlc3VsdCB8IG51bGwpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5mb2xkZXJzLmxlbmd0aCA9PT0gMCB8fCAhcmVzdWx0LmZvbGRlcnNbMF0gfHwgdHlwZW9mIHJlc3VsdC5mb2xkZXJzWzBdICE9PSAnc3RyaW5nJykgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2VsZWN0ZWRGb2xkZXIgPSByZXN1bHQuZm9sZGVyc1swXS50cmltKCkucmVwbGFjZSgvXFwvJC8sIFwiXCIpOyAvLyByZW1vdmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAoL15cXC98XFwvJC9nLCBcIlwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRGb2xkZXIgPT09ICcnKSBzZWxlY3RlZEZvbGRlciA9ICcvJzsgLy8gaWYgZW1wdHksIHNldCB0byByb290IGZvbGRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdGVkRm9sZGVyKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uRm9sZGVyRWwuc2V0VmFsdWUoc2VsZWN0ZWRGb2xkZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZyhydWxlLmlkLCdkZXN0aW5hdGlvbkZvbGRlcicsIHNlbGVjdGVkRm9sZGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICBcclxuICAgICAgICBsZXQgZGVzdGluYXRpb25GaWxlRWw6U2VhcmNoQ29tcG9uZW50OyAgXHJcbiAgICAgICAgbmV3IFNldHRpbmcob3B0aW9uRUwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdUZW1wbGF0ZSBGaWxlJylcclxuICAgICAgICAgICAgLnNldERlc2MoJ1NlbGVjdCBhIHRlbXBsYXRlIGZpbGUgdG8gYWRkIHRvIG5ldyBmaWxlcycpXHJcbiAgICAgICAgICAgIC5hZGRTZWFyY2goKGNiKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbkZpbGVFbCA9IGNiO1xyXG4gICAgICAgICAgICAgICAgbmV3IEZpbGVTdWdnZXN0KGNiLmlucHV0RWwsIHRoYXQucGx1Z2luLCAnJyk7XHJcbiAgICAgICAgICAgICAgICBjYi5zZXRQbGFjZWhvbGRlcihcImVudGVyIGZvbGRlciBvciBicm93c2UgLi4uXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoYXQuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQgLCd0ZW1wbGF0ZUZpbGUnKSB8fCAnJylcclxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoKG5ld0ZpbGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RmlsZSA9IG5ld0ZpbGUudHJpbSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0ZpbGUgPSBuZXdGaWxlLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWcocnVsZS5pZCwndGVtcGxhdGVGaWxlJywgbmV3RmlsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgICAgICBjYi5jb250YWluZXJFbC5hZGRDbGFzcyhcImZyb250bWF0dGVyLWF1dG9tYXRlLXNlYXJjaFwiKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmFkZEV4dHJhQnV0dG9uKChidXR0b24pID0+XHJcbiAgICAgICAgICAgICAgICBidXR0b25cclxuICAgICAgICAgICAgICAgIC5zZXRJY29uKCdmb2xkZXItdHJlZScpXHJcbiAgICAgICAgICAgICAgICAuc2V0VG9vbHRpcCgnU2VsZWN0IHRlbXBsYXRlIGZpbGUnKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgb3BlbkRpcmVjdG9yeVNlbGVjdGlvbk1vZGFsKFxyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYXBwLFxyXG4gICAgICAgICAgICAgICAgICAgIFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIFt0aGF0LmdldE9wdGlvbkNvbmZpZyhydWxlLmlkLCd0ZW1wbGF0ZUZpbGUnKV0sXHJcbiAgICAgICAgICAgICAgICAgICAgeyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdTZWxlY3QgdGVtcGxhdGUgZm9yIG5ldyBmaWxlcycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbk1vZGU6ICdpbmNsdWRlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU1vZGU6ICdmaWxlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uU2VsZWN0aW9uTW9kZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvblNob3dGaWxlczogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQ6IERpcmVjdG9yeVNlbGVjdGlvblJlc3VsdCB8IG51bGwpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5maWxlcy5sZW5ndGggPT09IDAgfHwgIXJlc3VsdC5maWxlc1swXSB8fCB0eXBlb2YgcmVzdWx0LmZpbGVzWzBdICE9PSAnc3RyaW5nJykgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2VsZWN0ZWRGaWxlID0gcmVzdWx0LmZpbGVzWzBdLnRyaW0oKS5yZXBsYWNlKC9cXC8kLywgXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VsZWN0ZWRGaWxlKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uRmlsZUVsLnNldFZhbHVlKHNlbGVjdGVkRmlsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQsJ3RlbXBsYXRlRmlsZScsIHNlbGVjdGVkRmlsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuIiwgIi8vIENyZWRpdHMgZ28gdG8gTGlhbSdzIFBlcmlvZGljIE5vdGVzIFBsdWdpbjogaHR0cHM6Ly9naXRodWIuY29tL2xpYW1jYWluL29ic2lkaWFuLXBlcmlvZGljLW5vdGVzXG4vLyBhbmQgVGVtcGxhdGVyIHBsdWdpbjogaHR0cHM6Ly9naXRodWIuY29tL1NpbGVudFZvaWQxMy9UZW1wbGF0ZXIgd2hlcmUgSSBnb3QgdGhlIGNvZGUgZm9yIHRoZSBzdWdnZXN0ZXJzXG5cbmltcG9ydCB7IEFwcCwgVEFic3RyYWN0RmlsZSwgVEZvbGRlciB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgVGV4dElucHV0U3VnZ2VzdCB9IGZyb20gXCIuL3N1Z2dlc3RcIjtcblxuZXhwb3J0IGNsYXNzIEZvbGRlclN1Z2dlc3QgZXh0ZW5kcyBUZXh0SW5wdXRTdWdnZXN0PFRGb2xkZXI+IHtcbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgaW5wdXRFbDogSFRNTElucHV0RWxlbWVudCB8IEhUTUxUZXh0QXJlYUVsZW1lbnQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCBpbnB1dEVsKTtcbiAgICB9XG5cbiAgICBnZXRTdWdnZXN0aW9ucyhpbnB1dFN0cjogc3RyaW5nKTogVEZvbGRlcltdIHtcbiAgICAgICAgY29uc3QgYWJzdHJhY3RGaWxlcyA9IHRoaXMuYXBwLnZhdWx0LmdldEFsbExvYWRlZEZpbGVzKCk7XG4gICAgICAgIGNvbnN0IGZvbGRlcnM6IFRGb2xkZXJbXSA9IFtdO1xuICAgICAgICBjb25zdCBsb3dlckNhc2VJbnB1dFN0ciA9IGlucHV0U3RyLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgYWJzdHJhY3RGaWxlcy5mb3JFYWNoKChmb2xkZXI6IFRBYnN0cmFjdEZpbGUpID0+IHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBmb2xkZXIgaW5zdGFuY2VvZiBURm9sZGVyICYmXG4gICAgICAgICAgICAgICAgZm9sZGVyLnBhdGgudG9Mb3dlckNhc2UoKS5jb250YWlucyhsb3dlckNhc2VJbnB1dFN0cilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGZvbGRlcnMucHVzaChmb2xkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZm9sZGVycy5zbGljZSgwLCAxMDAwKTtcbiAgICB9XG5cbiAgICByZW5kZXJTdWdnZXN0aW9uKGZpbGU6IFRGb2xkZXIsIGVsOiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgICAgICBlbC5zZXRUZXh0KGZpbGUucGF0aC5yZXBsYWNlKC9eKD8hXFwvKS8sIFwiL1wiKSk7XG4gICAgfVxuXG4gICAgc2VsZWN0U3VnZ2VzdGlvbihmaWxlOiBURm9sZGVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaW5wdXRFbC52YWx1ZSA9IGZpbGUucGF0aC5yZXBsYWNlKC9eKD8hXFwvKS8sIFwiL1wiKTtcbiAgICAgICAgdGhpcy5pbnB1dEVsLnRyaWdnZXIoXCJpbnB1dFwiKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbn1cbiIsICIvLyBDcmVkaXRzIGdvIHRvIExpYW0ncyBQZXJpb2RpYyBOb3RlcyBQbHVnaW46IGh0dHBzOi8vZ2l0aHViLmNvbS9saWFtY2Fpbi9vYnNpZGlhbi1wZXJpb2RpYy1ub3Rlc1xuLy8gYW5kIFRlbXBsYXRlciBwbHVnaW46IGh0dHBzOi8vZ2l0aHViLmNvbS9TaWxlbnRWb2lkMTMvVGVtcGxhdGVyIHdoZXJlIEkgZ290IHRoZSBjb2RlIGZvciB0aGUgc3VnZ2VzdGVyc1xuXG5pbXBvcnQgeyBBcHAsIElTdWdnZXN0T3duZXIsIFNjb3BlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBjcmVhdGVQb3BwZXIsIEluc3RhbmNlIGFzIFBvcHBlckluc3RhbmNlIH0gZnJvbSBcIkBwb3BwZXJqcy9jb3JlXCI7XG5cbmNvbnN0IHdyYXBBcm91bmQgPSAodmFsdWU6IG51bWJlciwgc2l6ZTogbnVtYmVyKTogbnVtYmVyID0+IHtcbiAgICByZXR1cm4gKCh2YWx1ZSAlIHNpemUpICsgc2l6ZSkgJSBzaXplO1xufTtcblxuY2xhc3MgU3VnZ2VzdDxUPiB7XG4gICAgcHJpdmF0ZSBvd25lcjogSVN1Z2dlc3RPd25lcjxUPjtcbiAgICBwcml2YXRlIHZhbHVlcyE6IFRbXTtcbiAgICBwcml2YXRlIHN1Z2dlc3Rpb25zITogSFRNTERpdkVsZW1lbnRbXTtcbiAgICBwcml2YXRlIHNlbGVjdGVkSXRlbSE6IG51bWJlcjtcbiAgICBwcml2YXRlIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudDtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBvd25lcjogSVN1Z2dlc3RPd25lcjxUPixcbiAgICAgICAgY29udGFpbmVyRWw6IEhUTUxFbGVtZW50LFxuICAgICAgICBzY29wZTogU2NvcGVcbiAgICApIHtcbiAgICAgICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgICAgICB0aGlzLmNvbnRhaW5lckVsID0gY29udGFpbmVyRWw7XG5cbiAgICAgICAgY29udGFpbmVyRWwub24oXG4gICAgICAgICAgICBcImNsaWNrXCIsXG4gICAgICAgICAgICBcIi5zdWdnZXN0aW9uLWl0ZW1cIixcbiAgICAgICAgICAgIHRoaXMub25TdWdnZXN0aW9uQ2xpY2suYmluZCh0aGlzKVxuICAgICAgICApO1xuICAgICAgICBjb250YWluZXJFbC5vbihcbiAgICAgICAgICAgIFwibW91c2Vtb3ZlXCIsXG4gICAgICAgICAgICBcIi5zdWdnZXN0aW9uLWl0ZW1cIixcbiAgICAgICAgICAgIHRoaXMub25TdWdnZXN0aW9uTW91c2VvdmVyLmJpbmQodGhpcylcbiAgICAgICAgKTtcblxuICAgICAgICBzY29wZS5yZWdpc3RlcihbXSwgXCJBcnJvd1VwXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFldmVudC5pc0NvbXBvc2luZykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0ZWRJdGVtKHRoaXMuc2VsZWN0ZWRJdGVtIC0gMSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBzY29wZS5yZWdpc3RlcihbXSwgXCJBcnJvd0Rvd25cIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50LmlzQ29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3RlZEl0ZW0odGhpcy5zZWxlY3RlZEl0ZW0gKyAxLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNjb3BlLnJlZ2lzdGVyKFtdLCBcIkVudGVyXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFldmVudC5pc0NvbXBvc2luZykge1xuICAgICAgICAgICAgICAgIHRoaXMudXNlU2VsZWN0ZWRJdGVtKGV2ZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9uU3VnZ2VzdGlvbkNsaWNrKGV2ZW50OiBNb3VzZUV2ZW50LCBlbDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5zdWdnZXN0aW9ucy5pbmRleE9mKGVsIGFzIEhUTUxEaXZFbGVtZW50KTtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3RlZEl0ZW0oaXRlbSwgZmFsc2UpO1xuICAgICAgICB0aGlzLnVzZVNlbGVjdGVkSXRlbShldmVudCk7XG4gICAgfVxuXG4gICAgb25TdWdnZXN0aW9uTW91c2VvdmVyKF9ldmVudDogTW91c2VFdmVudCwgZWw6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLnN1Z2dlc3Rpb25zLmluZGV4T2YoZWwgYXMgSFRNTERpdkVsZW1lbnQpO1xuICAgICAgICB0aGlzLnNldFNlbGVjdGVkSXRlbShpdGVtLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgc2V0U3VnZ2VzdGlvbnModmFsdWVzOiBUW10pIHtcbiAgICAgICAgdGhpcy5jb250YWluZXJFbC5lbXB0eSgpO1xuICAgICAgICBjb25zdCBzdWdnZXN0aW9uRWxzOiBIVE1MRGl2RWxlbWVudFtdID0gW107XG5cbiAgICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdWdnZXN0aW9uRWwgPSB0aGlzLmNvbnRhaW5lckVsLmNyZWF0ZURpdihcInN1Z2dlc3Rpb24taXRlbVwiKTtcbiAgICAgICAgICAgIHRoaXMub3duZXIucmVuZGVyU3VnZ2VzdGlvbih2YWx1ZSwgc3VnZ2VzdGlvbkVsKTtcbiAgICAgICAgICAgIHN1Z2dlc3Rpb25FbHMucHVzaChzdWdnZXN0aW9uRWwpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICAgICAgdGhpcy5zdWdnZXN0aW9ucyA9IHN1Z2dlc3Rpb25FbHM7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0ZWRJdGVtKDAsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB1c2VTZWxlY3RlZEl0ZW0oZXZlbnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMudmFsdWVzW3RoaXMuc2VsZWN0ZWRJdGVtXTtcbiAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5vd25lci5zZWxlY3RTdWdnZXN0aW9uKGN1cnJlbnRWYWx1ZSwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0U2VsZWN0ZWRJdGVtKHNlbGVjdGVkSW5kZXg6IG51bWJlciwgc2Nyb2xsSW50b1ZpZXc6IGJvb2xlYW4pIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEluZGV4ID0gd3JhcEFyb3VuZChcbiAgICAgICAgICAgIHNlbGVjdGVkSW5kZXgsXG4gICAgICAgICAgICB0aGlzLnN1Z2dlc3Rpb25zLmxlbmd0aFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBwcmV2U2VsZWN0ZWRTdWdnZXN0aW9uID0gdGhpcy5zdWdnZXN0aW9uc1t0aGlzLnNlbGVjdGVkSXRlbV07XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkU3VnZ2VzdGlvbiA9IHRoaXMuc3VnZ2VzdGlvbnNbbm9ybWFsaXplZEluZGV4XTtcblxuICAgICAgICBwcmV2U2VsZWN0ZWRTdWdnZXN0aW9uPy5yZW1vdmVDbGFzcyhcImlzLXNlbGVjdGVkXCIpO1xuICAgICAgICBzZWxlY3RlZFN1Z2dlc3Rpb24/LmFkZENsYXNzKFwiaXMtc2VsZWN0ZWRcIik7XG5cbiAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW0gPSBub3JtYWxpemVkSW5kZXg7XG5cbiAgICAgICAgaWYgKHNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgICAgICBzZWxlY3RlZFN1Z2dlc3Rpb24uc2Nyb2xsSW50b1ZpZXcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVGV4dElucHV0U3VnZ2VzdDxUPiBpbXBsZW1lbnRzIElTdWdnZXN0T3duZXI8VD4ge1xuICAgIHByb3RlY3RlZCBhcHA6IEFwcDtcbiAgICBwcm90ZWN0ZWQgaW5wdXRFbDogSFRNTElucHV0RWxlbWVudCB8IEhUTUxUZXh0QXJlYUVsZW1lbnQ7XG5cbiAgICBwcml2YXRlIHBvcHBlciE6IFBvcHBlckluc3RhbmNlO1xuICAgIHByaXZhdGUgc2NvcGU6IFNjb3BlO1xuICAgIHByaXZhdGUgc3VnZ2VzdEVsOiBIVE1MRWxlbWVudDtcbiAgICBwcml2YXRlIHN1Z2dlc3Q6IFN1Z2dlc3Q8VD47XG5cbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgaW5wdXRFbDogSFRNTElucHV0RWxlbWVudCB8IEhUTUxUZXh0QXJlYUVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgICAgIHRoaXMuaW5wdXRFbCA9IGlucHV0RWw7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBuZXcgU2NvcGUoKTtcblxuICAgICAgICB0aGlzLnN1Z2dlc3RFbCA9IGNyZWF0ZURpdihcInN1Z2dlc3Rpb24tY29udGFpbmVyXCIpO1xuICAgICAgICBjb25zdCBzdWdnZXN0aW9uID0gdGhpcy5zdWdnZXN0RWwuY3JlYXRlRGl2KFwic3VnZ2VzdGlvblwiKTtcbiAgICAgICAgdGhpcy5zdWdnZXN0ID0gbmV3IFN1Z2dlc3QodGhpcywgc3VnZ2VzdGlvbiwgdGhpcy5zY29wZSk7XG5cbiAgICAgICAgdGhpcy5zY29wZS5yZWdpc3RlcihbXSwgXCJFc2NhcGVcIiwgdGhpcy5jbG9zZS5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLmlucHV0RWwuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMub25JbnB1dENoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuaW5wdXRFbC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5vbklucHV0Q2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5pbnB1dEVsLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuY2xvc2UuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuc3VnZ2VzdEVsLm9uKFxuICAgICAgICAgICAgXCJtb3VzZWRvd25cIixcbiAgICAgICAgICAgIFwiLnN1Z2dlc3Rpb24tY29udGFpbmVyXCIsXG4gICAgICAgICAgICAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cblxuICAgIG9uSW5wdXRDaGFuZ2VkKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBpbnB1dFN0ciA9IHRoaXMuaW5wdXRFbC52YWx1ZTtcbiAgICAgICAgY29uc3Qgc3VnZ2VzdGlvbnMgPSB0aGlzLmdldFN1Z2dlc3Rpb25zKGlucHV0U3RyKTtcblxuICAgICAgICBpZiAoIXN1Z2dlc3Rpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3VnZ2VzdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zdWdnZXN0LnNldFN1Z2dlc3Rpb25zKHN1Z2dlc3Rpb25zKTtcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5vcGVuKHRoaXMuYXBwLmRvbS5hcHBDb250YWluZXJFbCwgdGhpcy5pbnB1dEVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9wZW4oY29udGFpbmVyOiBIVE1MRWxlbWVudCwgaW5wdXRFbDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hcHAua2V5bWFwLnB1c2hTY29wZSh0aGlzLnNjb3BlKTtcblxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zdWdnZXN0RWwpO1xuICAgICAgICB0aGlzLnBvcHBlciA9IGNyZWF0ZVBvcHBlcihpbnB1dEVsLCB0aGlzLnN1Z2dlc3RFbCwge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBcImJvdHRvbS1zdGFydFwiLFxuICAgICAgICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInNhbWVXaWR0aFwiLFxuICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBmbjogKHsgc3RhdGUsIGluc3RhbmNlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IHBvc2l0aW9uaW5nIG5lZWRzIHRvIGJlIGNhbGN1bGF0ZWQgdHdpY2UgLVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmlyc3QgcGFzcyAtIHBvc2l0aW9uaW5nIGl0IGFjY29yZGluZyB0byB0aGUgd2lkdGggb2YgdGhlIHBvcHBlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2Vjb25kIHBhc3MgLSBwb3NpdGlvbiBpdCB3aXRoIHRoZSB3aWR0aCBib3VuZCB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gZWFybHkgZXhpdCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRXaWR0aCA9IGAke3N0YXRlLnJlY3RzLnJlZmVyZW5jZS53aWR0aH1weGA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc3R5bGVzLnBvcHBlci53aWR0aCA9PT0gdGFyZ2V0V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zdHlsZXMucG9wcGVyLndpZHRoID0gdGFyZ2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGhhc2U6IFwiYmVmb3JlV3JpdGVcIixcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZXM6IFtcImNvbXB1dGVTdHlsZXNcIl0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNsb3NlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmFwcC5rZXltYXAucG9wU2NvcGUodGhpcy5zY29wZSk7XG5cbiAgICAgICAgdGhpcy5zdWdnZXN0LnNldFN1Z2dlc3Rpb25zKFtdKTtcbiAgICAgICAgaWYgKHRoaXMucG9wcGVyKSB0aGlzLnBvcHBlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc3VnZ2VzdEVsLmRldGFjaCgpO1xuICAgIH1cblxuICAgIGFic3RyYWN0IGdldFN1Z2dlc3Rpb25zKGlucHV0U3RyOiBzdHJpbmcpOiBUW107XG4gICAgYWJzdHJhY3QgcmVuZGVyU3VnZ2VzdGlvbihpdGVtOiBULCBlbDogSFRNTEVsZW1lbnQpOiB2b2lkO1xuICAgIGFic3RyYWN0IHNlbGVjdFN1Z2dlc3Rpb24oaXRlbTogVCk6IHZvaWQ7XG59XG4iLCAiZXhwb3J0IHZhciB0b3AgPSAndG9wJztcbmV4cG9ydCB2YXIgYm90dG9tID0gJ2JvdHRvbSc7XG5leHBvcnQgdmFyIHJpZ2h0ID0gJ3JpZ2h0JztcbmV4cG9ydCB2YXIgbGVmdCA9ICdsZWZ0JztcbmV4cG9ydCB2YXIgYXV0byA9ICdhdXRvJztcbmV4cG9ydCB2YXIgYmFzZVBsYWNlbWVudHMgPSBbdG9wLCBib3R0b20sIHJpZ2h0LCBsZWZ0XTtcbmV4cG9ydCB2YXIgc3RhcnQgPSAnc3RhcnQnO1xuZXhwb3J0IHZhciBlbmQgPSAnZW5kJztcbmV4cG9ydCB2YXIgY2xpcHBpbmdQYXJlbnRzID0gJ2NsaXBwaW5nUGFyZW50cyc7XG5leHBvcnQgdmFyIHZpZXdwb3J0ID0gJ3ZpZXdwb3J0JztcbmV4cG9ydCB2YXIgcG9wcGVyID0gJ3BvcHBlcic7XG5leHBvcnQgdmFyIHJlZmVyZW5jZSA9ICdyZWZlcmVuY2UnO1xuZXhwb3J0IHZhciB2YXJpYXRpb25QbGFjZW1lbnRzID0gLyojX19QVVJFX18qL2Jhc2VQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCArIFwiLVwiICsgc3RhcnQsIHBsYWNlbWVudCArIFwiLVwiICsgZW5kXSk7XG59LCBbXSk7XG5leHBvcnQgdmFyIHBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovW10uY29uY2F0KGJhc2VQbGFjZW1lbnRzLCBbYXV0b10pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCwgcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTsgLy8gbW9kaWZpZXJzIHRoYXQgbmVlZCB0byByZWFkIHRoZSBET01cblxuZXhwb3J0IHZhciBiZWZvcmVSZWFkID0gJ2JlZm9yZVJlYWQnO1xuZXhwb3J0IHZhciByZWFkID0gJ3JlYWQnO1xuZXhwb3J0IHZhciBhZnRlclJlYWQgPSAnYWZ0ZXJSZWFkJzsgLy8gcHVyZS1sb2dpYyBtb2RpZmllcnNcblxuZXhwb3J0IHZhciBiZWZvcmVNYWluID0gJ2JlZm9yZU1haW4nO1xuZXhwb3J0IHZhciBtYWluID0gJ21haW4nO1xuZXhwb3J0IHZhciBhZnRlck1haW4gPSAnYWZ0ZXJNYWluJzsgLy8gbW9kaWZpZXIgd2l0aCB0aGUgcHVycG9zZSB0byB3cml0ZSB0byB0aGUgRE9NIChvciB3cml0ZSBpbnRvIGEgZnJhbWV3b3JrIHN0YXRlKVxuXG5leHBvcnQgdmFyIGJlZm9yZVdyaXRlID0gJ2JlZm9yZVdyaXRlJztcbmV4cG9ydCB2YXIgd3JpdGUgPSAnd3JpdGUnO1xuZXhwb3J0IHZhciBhZnRlcldyaXRlID0gJ2FmdGVyV3JpdGUnO1xuZXhwb3J0IHZhciBtb2RpZmllclBoYXNlcyA9IFtiZWZvcmVSZWFkLCByZWFkLCBhZnRlclJlYWQsIGJlZm9yZU1haW4sIG1haW4sIGFmdGVyTWFpbiwgYmVmb3JlV3JpdGUsIHdyaXRlLCBhZnRlcldyaXRlXTsiLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZU5hbWUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudCA/IChlbGVtZW50Lm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbn0iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAobm9kZS50b1N0cmluZygpICE9PSAnW29iamVjdCBXaW5kb3ddJykge1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cgOiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn0iLCAiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcblxuZnVuY3Rpb24gaXNFbGVtZW50KG5vZGUpIHtcbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KG5vZGUpIHtcbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuSFRNTEVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzU2hhZG93Um9vdChub2RlKSB7XG4gIC8vIElFIDExIGhhcyBubyBTaGFkb3dSb290XG4gIGlmICh0eXBlb2YgU2hhZG93Um9vdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5TaGFkb3dSb290O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Q7XG59XG5cbmV4cG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCwgaXNTaGFkb3dSb290IH07IiwgImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4uL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7IC8vIFRoaXMgbW9kaWZpZXIgdGFrZXMgdGhlIHN0eWxlcyBwcmVwYXJlZCBieSB0aGUgYGNvbXB1dGVTdHlsZXNgIG1vZGlmaWVyXG4vLyBhbmQgYXBwbGllcyB0aGVtIHRvIHRoZSBIVE1MRWxlbWVudHMgc3VjaCBhcyBwb3BwZXIgYW5kIGFycm93XG5cbmZ1bmN0aW9uIGFwcGx5U3R5bGVzKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZTtcbiAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS5zdHlsZXNbbmFtZV0gfHwge307XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07IC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuXG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRmxvdyBkb2Vzbid0IHN1cHBvcnQgdG8gZXh0ZW5kIHRoaXMgcHJvcGVydHksIGJ1dCBpdCdzIHRoZSBtb3N0XG4gICAgLy8gZWZmZWN0aXZlIHdheSB0byBhcHBseSBzdHlsZXMgdG8gYW4gSFRNTEVsZW1lbnRcbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cblxuXG4gICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcblxuICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGU7XG4gIHZhciBpbml0aWFsU3R5bGVzID0ge1xuICAgIHBvcHBlcjoge1xuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAnMCcsXG4gICAgICB0b3A6ICcwJyxcbiAgICAgIG1hcmdpbjogJzAnXG4gICAgfSxcbiAgICBhcnJvdzoge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICB9LFxuICAgIHJlZmVyZW5jZToge31cbiAgfTtcbiAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGluaXRpYWxTdHlsZXMucG9wcGVyKTtcbiAgc3RhdGUuc3R5bGVzID0gaW5pdGlhbFN0eWxlcztcblxuICBpZiAoc3RhdGUuZWxlbWVudHMuYXJyb3cpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLmFycm93LnN0eWxlLCBpbml0aWFsU3R5bGVzLmFycm93KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgICB2YXIgc3R5bGVQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoc3RhdGUuc3R5bGVzLmhhc093blByb3BlcnR5KG5hbWUpID8gc3RhdGUuc3R5bGVzW25hbWVdIDogaW5pdGlhbFN0eWxlc1tuYW1lXSk7IC8vIFNldCBhbGwgdmFsdWVzIHRvIGFuIGVtcHR5IHN0cmluZyB0byB1bnNldCB0aGVtXG5cbiAgICAgIHZhciBzdHlsZSA9IHN0eWxlUHJvcGVydGllcy5yZWR1Y2UoZnVuY3Rpb24gKHN0eWxlLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdHlsZVtwcm9wZXJ0eV0gPSAnJztcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfSwge30pOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBhcHBseVN0eWxlcyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ2NvbXB1dGVTdHlsZXMnXVxufTsiLCAiaW1wb3J0IHsgYXV0byB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufSIsICJleHBvcnQgdmFyIG1heCA9IE1hdGgubWF4O1xuZXhwb3J0IHZhciBtaW4gPSBNYXRoLm1pbjtcbmV4cG9ydCB2YXIgcm91bmQgPSBNYXRoLnJvdW5kOyIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRVQVN0cmluZygpIHtcbiAgdmFyIHVhRGF0YSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhO1xuXG4gIGlmICh1YURhdGEgIT0gbnVsbCAmJiB1YURhdGEuYnJhbmRzICYmIEFycmF5LmlzQXJyYXkodWFEYXRhLmJyYW5kcykpIHtcbiAgICByZXR1cm4gdWFEYXRhLmJyYW5kcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLmJyYW5kICsgXCIvXCIgKyBpdGVtLnZlcnNpb247XG4gICAgfSkuam9pbignICcpO1xuICB9XG5cbiAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XG59IiwgImltcG9ydCBnZXRVQVN0cmluZyBmcm9tIFwiLi4vdXRpbHMvdXNlckFnZW50LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0xheW91dFZpZXdwb3J0KCkge1xuICByZXR1cm4gIS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XG59IiwgImltcG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgaXNMYXlvdXRWaWV3cG9ydCBmcm9tIFwiLi9pc0xheW91dFZpZXdwb3J0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlLCBpc0ZpeGVkU3RyYXRlZ3kpIHtcbiAgaWYgKGluY2x1ZGVTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNGaXhlZFN0cmF0ZWd5ID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBjbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNjYWxlWCA9IDE7XG4gIHZhciBzY2FsZVkgPSAxO1xuXG4gIGlmIChpbmNsdWRlU2NhbGUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIHNjYWxlWCA9IGVsZW1lbnQub2Zmc2V0V2lkdGggPiAwID8gcm91bmQoY2xpZW50UmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDEgOiAxO1xuICAgIHNjYWxlWSA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ID4gMCA/IHJvdW5kKGNsaWVudFJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDEgOiAxO1xuICB9XG5cbiAgdmFyIF9yZWYgPSBpc0VsZW1lbnQoZWxlbWVudCkgPyBnZXRXaW5kb3coZWxlbWVudCkgOiB3aW5kb3csXG4gICAgICB2aXN1YWxWaWV3cG9ydCA9IF9yZWYudmlzdWFsVmlld3BvcnQ7XG5cbiAgdmFyIGFkZFZpc3VhbE9mZnNldHMgPSAhaXNMYXlvdXRWaWV3cG9ydCgpICYmIGlzRml4ZWRTdHJhdGVneTtcbiAgdmFyIHggPSAoY2xpZW50UmVjdC5sZWZ0ICsgKGFkZFZpc3VhbE9mZnNldHMgJiYgdmlzdWFsVmlld3BvcnQgPyB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0IDogMCkpIC8gc2NhbGVYO1xuICB2YXIgeSA9IChjbGllbnRSZWN0LnRvcCArIChhZGRWaXN1YWxPZmZzZXRzICYmIHZpc3VhbFZpZXdwb3J0ID8gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wIDogMCkpIC8gc2NhbGVZO1xuICB2YXIgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoIC8gc2NhbGVYO1xuICB2YXIgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZVk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHRvcDogeSxcbiAgICByaWdodDogeCArIHdpZHRoLFxuICAgIGJvdHRvbTogeSArIGhlaWdodCxcbiAgICBsZWZ0OiB4LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufSIsICJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiOyAvLyBSZXR1cm5zIHRoZSBsYXlvdXQgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuIExheW91dFxuLy8gbWVhbnMgaXQgZG9lc24ndCB0YWtlIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zLlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRMYXlvdXRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7IC8vIFVzZSB0aGUgY2xpZW50UmVjdCBzaXplcyBpZiBpdCdzIG5vdCBiZWVuIHRyYW5zZm9ybWVkLlxuICAvLyBGaXhlcyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEyMjNcblxuICB2YXIgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3Qud2lkdGggLSB3aWR0aCkgPD0gMSkge1xuICAgIHdpZHRoID0gY2xpZW50UmVjdC53aWR0aDtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LmhlaWdodCAtIGhlaWdodCkgPD0gMSkge1xuICAgIGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBlbGVtZW50Lm9mZnNldExlZnQsXG4gICAgeTogZWxlbWVudC5vZmZzZXRUb3AsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59IiwgImltcG9ydCB7IGlzU2hhZG93Um9vdCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgdmFyIHJvb3ROb2RlID0gY2hpbGQuZ2V0Um9vdE5vZGUgJiYgY2hpbGQuZ2V0Um9vdE5vZGUoKTsgLy8gRmlyc3QsIGF0dGVtcHQgd2l0aCBmYXN0ZXIgbmF0aXZlIG1ldGhvZFxuXG4gIGlmIChwYXJlbnQuY29udGFpbnMoY2hpbGQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcbiAgZWxzZSBpZiAocm9vdE5vZGUgJiYgaXNTaGFkb3dSb290KHJvb3ROb2RlKSkge1xuICAgICAgdmFyIG5leHQgPSBjaGlsZDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAobmV4dCAmJiBwYXJlbnQuaXNTYW1lTm9kZShuZXh0KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXTogbmVlZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMuLi5cblxuXG4gICAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGUgfHwgbmV4dC5ob3N0O1xuICAgICAgfSB3aGlsZSAobmV4dCk7XG4gICAgfSAvLyBHaXZlIHVwLCB0aGUgcmVzdWx0IGlzIGZhbHNlXG5cblxuICByZXR1cm4gZmFsc2U7XG59IiwgImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufSIsICJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFsndGFibGUnLCAndGQnLCAndGgnXS5pbmRleE9mKGdldE5vZGVOYW1lKGVsZW1lbnQpKSA+PSAwO1xufSIsICJpbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkge1xuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gIHJldHVybiAoKGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQub3duZXJEb2N1bWVudCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICBlbGVtZW50LmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudDtcbn0iLCAiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IHsgaXNTaGFkb3dSb290IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gIGlmIChnZXROb2RlTmFtZShlbGVtZW50KSA9PT0gJ2h0bWwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gKC8vIHRoaXMgaXMgYSBxdWlja2VyIChidXQgbGVzcyB0eXBlIHNhZmUpIHdheSB0byBzYXZlIHF1aXRlIHNvbWUgYnl0ZXMgZnJvbSB0aGUgYnVuZGxlXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIGVsZW1lbnQuYXNzaWduZWRTbG90IHx8IC8vIHN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlXG4gICAgZWxlbWVudC5wYXJlbnROb2RlIHx8ICggLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWRcbiAgICBpc1NoYWRvd1Jvb3QoZWxlbWVudCkgPyBlbGVtZW50Lmhvc3QgOiBudWxsKSB8fCAvLyBTaGFkb3dSb290IGRldGVjdGVkXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IEhUTUxFbGVtZW50IGlzIGEgTm9kZVxuICAgIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSAvLyBmYWxsYmFja1xuXG4gICk7XG59IiwgImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQsIGlzU2hhZG93Um9vdCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBpc1RhYmxlRWxlbWVudCBmcm9tIFwiLi9pc1RhYmxlRWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGdldFVBU3RyaW5nIGZyb20gXCIuLi91dGlscy91c2VyQWdlbnQuanNcIjtcblxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzgzN1xuICBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG59IC8vIGAub2Zmc2V0UGFyZW50YCByZXBvcnRzIGBudWxsYCBmb3IgZml4ZWQgZWxlbWVudHMsIHdoaWxlIGFic29sdXRlIGVsZW1lbnRzXG4vLyByZXR1cm4gdGhlIGNvbnRhaW5pbmcgYmxvY2tcblxuXG5mdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICB2YXIgaXNGaXJlZm94ID0gL2ZpcmVmb3gvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xuICB2YXIgaXNJRSA9IC9UcmlkZW50L2kudGVzdChnZXRVQVN0cmluZygpKTtcblxuICBpZiAoaXNJRSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgLy8gSW4gSUUgOSwgMTAgYW5kIDExIGZpeGVkIGVsZW1lbnRzIGNvbnRhaW5pbmcgYmxvY2sgaXMgYWx3YXlzIGVzdGFibGlzaGVkIGJ5IHRoZSB2aWV3cG9ydFxuICAgIHZhciBlbGVtZW50Q3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgIGlmIChlbGVtZW50Q3NzLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuXG4gIGlmIChpc1NoYWRvd1Jvb3QoY3VycmVudE5vZGUpKSB7XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5ob3N0O1xuICB9XG5cbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmIFsnaHRtbCcsICdib2R5J10uaW5kZXhPZihnZXROb2RlTmFtZShjdXJyZW50Tm9kZSkpIDwgMCkge1xuICAgIHZhciBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnROb2RlKTsgLy8gVGhpcyBpcyBub24tZXhoYXVzdGl2ZSBidXQgY292ZXJzIHRoZSBtb3N0IGNvbW1vbiBDU1MgcHJvcGVydGllcyB0aGF0XG4gICAgLy8gY3JlYXRlIGEgY29udGFpbmluZyBibG9jay5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuXG4gICAgaWYgKGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fCBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fCBjc3MuY29udGFpbiA9PT0gJ3BhaW50JyB8fCBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZSddLmluZGV4T2YoY3NzLndpbGxDaGFuZ2UpICE9PSAtMSB8fCBpc0ZpcmVmb3ggJiYgY3NzLndpbGxDaGFuZ2UgPT09ICdmaWx0ZXInIHx8IGlzRmlyZWZveCAmJiBjc3MuZmlsdGVyICYmIGNzcy5maWx0ZXIgIT09ICdub25lJykge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59IC8vIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgcG9zaXRpb25lZCBlbGVtZW50LiBIYW5kbGVzIHNvbWUgZWRnZSBjYXNlcyxcbi8vIHN1Y2ggYXMgdGFibGUgYW5jZXN0b3JzIGFuZCBjcm9zcyBicm93c2VyIGJ1Z3MuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCk7XG5cbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICBpZiAob2Zmc2V0UGFyZW50ICYmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnaHRtbCcgfHwgZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2JvZHknICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbmRvdztcbn0iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpID49IDAgPyAneCcgOiAneSc7XG59IiwgImltcG9ydCB7IG1heCBhcyBtYXRoTWF4LCBtaW4gYXMgbWF0aE1pbiB9IGZyb20gXCIuL21hdGguanNcIjtcbmV4cG9ydCBmdW5jdGlvbiB3aXRoaW4obWluLCB2YWx1ZSwgbWF4KSB7XG4gIHJldHVybiBtYXRoTWF4KG1pbiwgbWF0aE1pbih2YWx1ZSwgbWF4KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gd2l0aGluTWF4Q2xhbXAobWluLCB2YWx1ZSwgbWF4KSB7XG4gIHZhciB2ID0gd2l0aGluKG1pbiwgdmFsdWUsIG1heCk7XG4gIHJldHVybiB2ID4gbWF4ID8gbWF4IDogdjtcbn0iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RnJlc2hTaWRlT2JqZWN0KCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9O1xufSIsICJpbXBvcnQgZ2V0RnJlc2hTaWRlT2JqZWN0IGZyb20gXCIuL2dldEZyZXNoU2lkZU9iamVjdC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VQYWRkaW5nT2JqZWN0KHBhZGRpbmdPYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGdldEZyZXNoU2lkZU9iamVjdCgpLCBwYWRkaW5nT2JqZWN0KTtcbn0iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXhwYW5kVG9IYXNoTWFwKHZhbHVlLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoaGFzaE1hcCwga2V5KSB7XG4gICAgaGFzaE1hcFtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIGhhc2hNYXA7XG4gIH0sIHt9KTtcbn0iLCAiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuLi9kb20tdXRpbHMvY29udGFpbnMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgd2l0aGluIH0gZnJvbSBcIi4uL3V0aWxzL3dpdGhpbi5qc1wiO1xuaW1wb3J0IG1lcmdlUGFkZGluZ09iamVjdCBmcm9tIFwiLi4vdXRpbHMvbWVyZ2VQYWRkaW5nT2JqZWN0LmpzXCI7XG5pbXBvcnQgZXhwYW5kVG9IYXNoTWFwIGZyb20gXCIuLi91dGlscy9leHBhbmRUb0hhc2hNYXAuanNcIjtcbmltcG9ydCB7IGxlZnQsIHJpZ2h0LCBiYXNlUGxhY2VtZW50cywgdG9wLCBib3R0b20gfSBmcm9tIFwiLi4vZW51bXMuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgdG9QYWRkaW5nT2JqZWN0ID0gZnVuY3Rpb24gdG9QYWRkaW5nT2JqZWN0KHBhZGRpbmcsIHN0YXRlKSB7XG4gIHBhZGRpbmcgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ2Z1bmN0aW9uJyA/IHBhZGRpbmcoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiBwYWRkaW5nO1xuICByZXR1cm4gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbn07XG5cbmZ1bmN0aW9uIGFycm93KF9yZWYpIHtcbiAgdmFyIF9zdGF0ZSRtb2RpZmllcnNEYXRhJDtcblxuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgYXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgdmFyIGlzVmVydGljYWwgPSBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgaWYgKCFhcnJvd0VsZW1lbnQgfHwgIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGFkZGluZ09iamVjdCA9IHRvUGFkZGluZ09iamVjdChvcHRpb25zLnBhZGRpbmcsIHN0YXRlKTtcbiAgdmFyIGFycm93UmVjdCA9IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KTtcbiAgdmFyIG1pblByb3AgPSBheGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICB2YXIgbWF4UHJvcCA9IGF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICB2YXIgZW5kRGlmZiA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtsZW5dICsgc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnBvcHBlcltsZW5dO1xuICB2YXIgc3RhcnREaWZmID0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXTtcbiAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGFycm93RWxlbWVudCk7XG4gIHZhciBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBheGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoIHx8IDAgOiAwO1xuICB2YXIgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7IC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgcG9wcGVyIGlmIHRoZSBjZW50ZXIgcG9pbnQgaXNcbiAgLy8gb3V0c2lkZSBvZiB0aGUgcG9wcGVyIGJvdW5kc1xuXG4gIHZhciBtaW4gPSBwYWRkaW5nT2JqZWN0W21pblByb3BdO1xuICB2YXIgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93UmVjdFtsZW5dIC0gcGFkZGluZ09iamVjdFttYXhQcm9wXTtcbiAgdmFyIGNlbnRlciA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dSZWN0W2xlbl0gLyAyICsgY2VudGVyVG9SZWZlcmVuY2U7XG4gIHZhciBvZmZzZXQgPSB3aXRoaW4obWluLCBjZW50ZXIsIG1heCk7IC8vIFByZXZlbnRzIGJyZWFraW5nIHN5bnRheCBoaWdobGlnaHRpbmcuLi5cblxuICB2YXIgYXhpc1Byb3AgPSBheGlzO1xuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gKF9zdGF0ZSRtb2RpZmllcnNEYXRhJCA9IHt9LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSRbYXhpc1Byb3BdID0gb2Zmc2V0LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQuY2VudGVyT2Zmc2V0ID0gb2Zmc2V0IC0gY2VudGVyLCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQpO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQsXG4gICAgICBhcnJvd0VsZW1lbnQgPSBfb3B0aW9ucyRlbGVtZW50ID09PSB2b2lkIDAgPyAnW2RhdGEtcG9wcGVyLWFycm93XScgOiBfb3B0aW9ucyRlbGVtZW50O1xuXG4gIGlmIChhcnJvd0VsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBDU1Mgc2VsZWN0b3JcblxuXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29udGFpbnMoc3RhdGUuZWxlbWVudHMucG9wcGVyLCBhcnJvd0VsZW1lbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhdGUuZWxlbWVudHMuYXJyb3cgPSBhcnJvd0VsZW1lbnQ7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdhcnJvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBhcnJvdyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXVxufTsiLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59IiwgImltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgZW5kIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgdW5zZXRTaWRlcyA9IHtcbiAgdG9wOiAnYXV0bycsXG4gIHJpZ2h0OiAnYXV0bycsXG4gIGJvdHRvbTogJ2F1dG8nLFxuICBsZWZ0OiAnYXV0bydcbn07IC8vIFJvdW5kIHRoZSBvZmZzZXRzIHRvIHRoZSBuZWFyZXN0IHN1aXRhYmxlIHN1YnBpeGVsIGJhc2VkIG9uIHRoZSBEUFIuXG4vLyBab29taW5nIGNhbiBjaGFuZ2UgdGhlIERQUiwgYnV0IGl0IHNlZW1zIHRvIHJlcG9ydCBhIHZhbHVlIHRoYXQgd2lsbFxuLy8gY2xlYW5seSBkaXZpZGUgdGhlIHZhbHVlcyBpbnRvIHRoZSBhcHByb3ByaWF0ZSBzdWJwaXhlbHMuXG5cbmZ1bmN0aW9uIHJvdW5kT2Zmc2V0c0J5RFBSKF9yZWYsIHdpbikge1xuICB2YXIgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnk7XG4gIHZhciBkcHIgPSB3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4ge1xuICAgIHg6IHJvdW5kKHggKiBkcHIpIC8gZHByIHx8IDAsXG4gICAgeTogcm91bmQoeSAqIGRwcikgLyBkcHIgfHwgMFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwVG9TdHlsZXMoX3JlZjIpIHtcbiAgdmFyIF9PYmplY3QkYXNzaWduMjtcblxuICB2YXIgcG9wcGVyID0gX3JlZjIucG9wcGVyLFxuICAgICAgcG9wcGVyUmVjdCA9IF9yZWYyLnBvcHBlclJlY3QsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmMi5wbGFjZW1lbnQsXG4gICAgICB2YXJpYXRpb24gPSBfcmVmMi52YXJpYXRpb24sXG4gICAgICBvZmZzZXRzID0gX3JlZjIub2Zmc2V0cyxcbiAgICAgIHBvc2l0aW9uID0gX3JlZjIucG9zaXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfcmVmMi5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBhZGFwdGl2ZSA9IF9yZWYyLmFkYXB0aXZlLFxuICAgICAgcm91bmRPZmZzZXRzID0gX3JlZjIucm91bmRPZmZzZXRzLFxuICAgICAgaXNGaXhlZCA9IF9yZWYyLmlzRml4ZWQ7XG4gIHZhciBfb2Zmc2V0cyR4ID0gb2Zmc2V0cy54LFxuICAgICAgeCA9IF9vZmZzZXRzJHggPT09IHZvaWQgMCA/IDAgOiBfb2Zmc2V0cyR4LFxuICAgICAgX29mZnNldHMkeSA9IG9mZnNldHMueSxcbiAgICAgIHkgPSBfb2Zmc2V0cyR5ID09PSB2b2lkIDAgPyAwIDogX29mZnNldHMkeTtcblxuICB2YXIgX3JlZjMgPSB0eXBlb2Ygcm91bmRPZmZzZXRzID09PSAnZnVuY3Rpb24nID8gcm91bmRPZmZzZXRzKHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfSkgOiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG5cbiAgeCA9IF9yZWYzLng7XG4gIHkgPSBfcmVmMy55O1xuICB2YXIgaGFzWCA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3gnKTtcbiAgdmFyIGhhc1kgPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd5Jyk7XG4gIHZhciBzaWRlWCA9IGxlZnQ7XG4gIHZhciBzaWRlWSA9IHRvcDtcbiAgdmFyIHdpbiA9IHdpbmRvdztcblxuICBpZiAoYWRhcHRpdmUpIHtcbiAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KHBvcHBlcik7XG4gICAgdmFyIGhlaWdodFByb3AgPSAnY2xpZW50SGVpZ2h0JztcbiAgICB2YXIgd2lkdGhQcm9wID0gJ2NsaWVudFdpZHRoJztcblxuICAgIGlmIChvZmZzZXRQYXJlbnQgPT09IGdldFdpbmRvdyhwb3BwZXIpKSB7XG4gICAgICBvZmZzZXRQYXJlbnQgPSBnZXREb2N1bWVudEVsZW1lbnQocG9wcGVyKTtcblxuICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiAhPT0gJ3N0YXRpYycgJiYgcG9zaXRpb24gPT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgaGVpZ2h0UHJvcCA9ICdzY3JvbGxIZWlnaHQnO1xuICAgICAgICB3aWR0aFByb3AgPSAnc2Nyb2xsV2lkdGgnO1xuICAgICAgfVxuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FzdF06IGZvcmNlIHR5cGUgcmVmaW5lbWVudCwgd2UgY29tcGFyZSBvZmZzZXRQYXJlbnQgd2l0aCB3aW5kb3cgYWJvdmUsIGJ1dCBGbG93IGRvZXNuJ3QgZGV0ZWN0IGl0XG5cblxuICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudDtcblxuICAgIGlmIChwbGFjZW1lbnQgPT09IHRvcCB8fCAocGxhY2VtZW50ID09PSBsZWZ0IHx8IHBsYWNlbWVudCA9PT0gcmlnaHQpICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XG4gICAgICBzaWRlWSA9IGJvdHRvbTtcbiAgICAgIHZhciBvZmZzZXRZID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQuaGVpZ2h0IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICBvZmZzZXRQYXJlbnRbaGVpZ2h0UHJvcF07XG4gICAgICB5IC09IG9mZnNldFkgLSBwb3BwZXJSZWN0LmhlaWdodDtcbiAgICAgIHkgKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cblxuICAgIGlmIChwbGFjZW1lbnQgPT09IGxlZnQgfHwgKHBsYWNlbWVudCA9PT0gdG9wIHx8IHBsYWNlbWVudCA9PT0gYm90dG9tKSAmJiB2YXJpYXRpb24gPT09IGVuZCkge1xuICAgICAgc2lkZVggPSByaWdodDtcbiAgICAgIHZhciBvZmZzZXRYID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQud2lkdGggOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgIG9mZnNldFBhcmVudFt3aWR0aFByb3BdO1xuICAgICAgeCAtPSBvZmZzZXRYIC0gcG9wcGVyUmVjdC53aWR0aDtcbiAgICAgIHggKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21tb25TdHlsZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgfSwgYWRhcHRpdmUgJiYgdW5zZXRTaWRlcyk7XG5cbiAgdmFyIF9yZWY0ID0gcm91bmRPZmZzZXRzID09PSB0cnVlID8gcm91bmRPZmZzZXRzQnlEUFIoe1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9LCBnZXRXaW5kb3cocG9wcGVyKSkgOiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG5cbiAgeCA9IF9yZWY0Lng7XG4gIHkgPSBfcmVmNC55O1xuXG4gIGlmIChncHVBY2NlbGVyYXRpb24pIHtcbiAgICB2YXIgX09iamVjdCRhc3NpZ247XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24gPSB7fSwgX09iamVjdCRhc3NpZ25bc2lkZVldID0gaGFzWSA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbltzaWRlWF0gPSBoYXNYID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduLnRyYW5zZm9ybSA9ICh3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSA8PSAxID8gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweClcIiA6IFwidHJhbnNsYXRlM2QoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweCwgMClcIiwgX09iamVjdCRhc3NpZ24pKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbjIgPSB7fSwgX09iamVjdCRhc3NpZ24yW3NpZGVZXSA9IGhhc1kgPyB5ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMltzaWRlWF0gPSBoYXNYID8geCArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjIudHJhbnNmb3JtID0gJycsIF9PYmplY3QkYXNzaWduMikpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlU3R5bGVzKF9yZWY1KSB7XG4gIHZhciBzdGF0ZSA9IF9yZWY1LnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWY1Lm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPSBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGdwdUFjY2VsZXJhdCxcbiAgICAgIF9vcHRpb25zJGFkYXB0aXZlID0gb3B0aW9ucy5hZGFwdGl2ZSxcbiAgICAgIGFkYXB0aXZlID0gX29wdGlvbnMkYWRhcHRpdmUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhZGFwdGl2ZSxcbiAgICAgIF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9IG9wdGlvbnMucm91bmRPZmZzZXRzLFxuICAgICAgcm91bmRPZmZzZXRzID0gX29wdGlvbnMkcm91bmRPZmZzZXRzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcm91bmRPZmZzZXRzO1xuICB2YXIgY29tbW9uU3R5bGVzID0ge1xuICAgIHBsYWNlbWVudDogZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHZhcmlhdGlvbjogZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCksXG4gICAgcG9wcGVyOiBzdGF0ZS5lbGVtZW50cy5wb3BwZXIsXG4gICAgcG9wcGVyUmVjdDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIGdwdUFjY2VsZXJhdGlvbjogZ3B1QWNjZWxlcmF0aW9uLFxuICAgIGlzRml4ZWQ6IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCdcbiAgfTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLnBvcHBlciwgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGFkYXB0aXZlOiBhZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMuYXJyb3cgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMuYXJyb3csIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgYWRhcHRpdmU6IGZhbHNlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1wbGFjZW1lbnQnOiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdjb21wdXRlU3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdiZWZvcmVXcml0ZScsXG4gIGZuOiBjb21wdXRlU3R5bGVzLFxuICBkYXRhOiB7fVxufTsiLCAiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldFdpbmRvdy5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciBwYXNzaXZlID0ge1xuICBwYXNzaXZlOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJHNjcm9sbCA9IG9wdGlvbnMuc2Nyb2xsLFxuICAgICAgc2Nyb2xsID0gX29wdGlvbnMkc2Nyb2xsID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkc2Nyb2xsLFxuICAgICAgX29wdGlvbnMkcmVzaXplID0gb3B0aW9ucy5yZXNpemUsXG4gICAgICByZXNpemUgPSBfb3B0aW9ucyRyZXNpemUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyZXNpemU7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coc3RhdGUuZWxlbWVudHMucG9wcGVyKTtcbiAgdmFyIHNjcm9sbFBhcmVudHMgPSBbXS5jb25jYXQoc3RhdGUuc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2UsIHN0YXRlLnNjcm9sbFBhcmVudHMucG9wcGVyKTtcblxuICBpZiAoc2Nyb2xsKSB7XG4gICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgIHNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJlc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgICBzY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH1cbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBmdW5jdGlvbiBmbigpIHt9LFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgZGF0YToge31cbn07IiwgInZhciBoYXNoID0ge1xuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnLFxuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufSIsICJ2YXIgaGFzaCA9IHtcbiAgc3RhcnQ6ICdlbmQnLFxuICBlbmQ6ICdzdGFydCdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59IiwgImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGwobm9kZSkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KG5vZGUpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IHdpbi5wYWdlWE9mZnNldDtcbiAgdmFyIHNjcm9sbFRvcCA9IHdpbi5wYWdlWU9mZnNldDtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wXG4gIH07XG59IiwgImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCkge1xuICAvLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4gIC8vIGluY29ycmVjdCBmb3IgUlRMLlxuICAvLyBQb3BwZXIgMSBpcyBicm9rZW4gaW4gdGhpcyBjYXNlIGFuZCBuZXZlciBoYWQgYSBidWcgcmVwb3J0IHNvIGxldCdzIGFzc3VtZVxuICAvLyBpdCdzIG5vdCBhbiBpc3N1ZS4gSSBkb24ndCB0aGluayBhbnlvbmUgZXZlciBzcGVjaWZpZXMgd2lkdGggb24gPGh0bWw+XG4gIC8vIGFueXdheS5cbiAgLy8gQnJvd3NlcnMgd2hlcmUgdGhlIGxlZnQgc2Nyb2xsYmFyIGRvZXNuJ3QgY2F1c2UgYW4gaXNzdWUgcmVwb3J0IGAwYCBmb3JcbiAgLy8gdGhpcyAoZS5nLiBFZGdlIDIwMTksIElFMTEsIFNhZmFyaSlcbiAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcbn0iLCAiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgaXNMYXlvdXRWaWV3cG9ydCBmcm9tIFwiLi9pc0xheW91dFZpZXdwb3J0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciB2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcbiAgdmFyIHdpZHRoID0gaHRtbC5jbGllbnRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IGh0bWwuY2xpZW50SGVpZ2h0O1xuICB2YXIgeCA9IDA7XG4gIHZhciB5ID0gMDtcblxuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDtcbiAgICB2YXIgbGF5b3V0Vmlld3BvcnQgPSBpc0xheW91dFZpZXdwb3J0KCk7XG5cbiAgICBpZiAobGF5b3V0Vmlld3BvcnQgfHwgIWxheW91dFZpZXdwb3J0ICYmIHN0cmF0ZWd5ID09PSAnZml4ZWQnKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCksXG4gICAgeTogeVxuICB9O1xufSIsICJpbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmltcG9ydCB7IG1heCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7IC8vIEdldHMgdGhlIGVudGlyZSBzaXplIG9mIHRoZSBzY3JvbGxhYmxlIGRvY3VtZW50IGFyZWEsIGV2ZW4gZXh0ZW5kaW5nIG91dHNpZGVcbi8vIG9mIHRoZSBgPGh0bWw+YCBhbmQgYDxib2R5PmAgcmVjdCBib3VuZHMgaWYgaG9yaXpvbnRhbGx5IHNjcm9sbGFibGVcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcblxuICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgdmFyIHdpblNjcm9sbCA9IGdldFdpbmRvd1Njcm9sbChlbGVtZW50KTtcbiAgdmFyIGJvZHkgPSAoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHk7XG4gIHZhciB3aWR0aCA9IG1heChodG1sLnNjcm9sbFdpZHRoLCBodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5zY3JvbGxXaWR0aCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCk7XG4gIHZhciBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5ID8gYm9keS5zY3JvbGxIZWlnaHQgOiAwLCBib2R5ID8gYm9keS5jbGllbnRIZWlnaHQgOiAwKTtcbiAgdmFyIHggPSAtd2luU2Nyb2xsLnNjcm9sbExlZnQgKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpO1xuICB2YXIgeSA9IC13aW5TY3JvbGwuc2Nyb2xsVG9wO1xuXG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKGJvZHkgfHwgaHRtbCkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHggKz0gbWF4KGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCkgLSB3aWR0aDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufSIsICJpbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1Njcm9sbFBhcmVudChlbGVtZW50KSB7XG4gIC8vIEZpcmVmb3ggd2FudHMgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcbiAgdmFyIF9nZXRDb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSxcbiAgICAgIG92ZXJmbG93ID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3csXG4gICAgICBvdmVyZmxvd1ggPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvd1gsXG4gICAgICBvdmVyZmxvd1kgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvd1k7XG5cbiAgcmV0dXJuIC9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbi8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCk7XG59IiwgImltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KG5vZGUpIHtcbiAgaWYgKFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUobm9kZSkpID49IDApIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgaWYgKGlzSFRNTEVsZW1lbnQobm9kZSkgJiYgaXNTY3JvbGxQYXJlbnQobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShub2RlKSk7XG59IiwgImltcG9ydCBnZXRTY3JvbGxQYXJlbnQgZnJvbSBcIi4vZ2V0U2Nyb2xsUGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7XG4vKlxuZ2l2ZW4gYSBET00gZWxlbWVudCwgcmV0dXJuIHRoZSBsaXN0IG9mIGFsbCBzY3JvbGwgcGFyZW50cywgdXAgdGhlIGxpc3Qgb2YgYW5jZXNvcnNcbnVudGlsIHdlIGdldCB0byB0aGUgdG9wIHdpbmRvdyBvYmplY3QuIFRoaXMgbGlzdCBpcyB3aGF0IHdlIGF0dGFjaCBzY3JvbGwgbGlzdGVuZXJzXG50bywgYmVjYXVzZSBpZiBhbnkgb2YgdGhlc2UgcGFyZW50IGVsZW1lbnRzIHNjcm9sbCwgd2UnbGwgbmVlZCB0byByZS1jYWxjdWxhdGUgdGhlXG5yZWZlcmVuY2UgZWxlbWVudCdzIHBvc2l0aW9uLlxuKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGlzdFNjcm9sbFBhcmVudHMoZWxlbWVudCwgbGlzdCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIGlmIChsaXN0ID09PSB2b2lkIDApIHtcbiAgICBsaXN0ID0gW107XG4gIH1cblxuICB2YXIgc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpO1xuICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50ID09PSAoKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5KTtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhzY3JvbGxQYXJlbnQpO1xuICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gW3dpbl0uY29uY2F0KHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSwgaXNTY3JvbGxQYXJlbnQoc2Nyb2xsUGFyZW50KSA/IHNjcm9sbFBhcmVudCA6IFtdKSA6IHNjcm9sbFBhcmVudDtcbiAgdmFyIHVwZGF0ZWRMaXN0ID0gbGlzdC5jb25jYXQodGFyZ2V0KTtcbiAgcmV0dXJuIGlzQm9keSA/IHVwZGF0ZWRMaXN0IDogLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IGlzQm9keSB0ZWxscyB1cyB0YXJnZXQgd2lsbCBiZSBhbiBIVE1MRWxlbWVudCBoZXJlXG4gIHVwZGF0ZWRMaXN0LmNvbmNhdChsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKHRhcmdldCkpKTtcbn0iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVjdFRvQ2xpZW50UmVjdChyZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCByZWN0LCB7XG4gICAgbGVmdDogcmVjdC54LFxuICAgIHRvcDogcmVjdC55LFxuICAgIHJpZ2h0OiByZWN0LnggKyByZWN0LndpZHRoLFxuICAgIGJvdHRvbTogcmVjdC55ICsgcmVjdC5oZWlnaHRcbiAgfSk7XG59IiwgImltcG9ydCB7IHZpZXdwb3J0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0Vmlld3BvcnRSZWN0IGZyb20gXCIuL2dldFZpZXdwb3J0UmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50UmVjdCBmcm9tIFwiLi9nZXREb2N1bWVudFJlY3QuanNcIjtcbmltcG9ydCBsaXN0U2Nyb2xsUGFyZW50cyBmcm9tIFwiLi9saXN0U2Nyb2xsUGFyZW50cy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuL2NvbnRhaW5zLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gXCIuLi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgeyBtYXgsIG1pbiB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGZhbHNlLCBzdHJhdGVneSA9PT0gJ2ZpeGVkJyk7XG4gIHJlY3QudG9wID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgcmVjdC5sZWZ0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LndpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC5oZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC54ID0gcmVjdC5sZWZ0O1xuICByZWN0LnkgPSByZWN0LnRvcDtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkge1xuICByZXR1cm4gY2xpcHBpbmdQYXJlbnQgPT09IHZpZXdwb3J0ID8gcmVjdFRvQ2xpZW50UmVjdChnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpKSA6IGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgPyBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpIDogcmVjdFRvQ2xpZW50UmVjdChnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKSk7XG59IC8vIEEgXCJjbGlwcGluZyBwYXJlbnRcIiBpcyBhbiBvdmVyZmxvd2FibGUgY29udGFpbmVyIHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBvdmVyZmxvd2luZyBlbGVtZW50cyB3aXRoIGEgcG9zaXRpb24gZGlmZmVyZW50IGZyb21cbi8vIGBpbml0aWFsYFxuXG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSB7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbiAgdmFyIGNhbkVzY2FwZUNsaXBwaW5nID0gWydhYnNvbHV0ZScsICdmaXhlZCddLmluZGV4T2YoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbikgPj0gMDtcbiAgdmFyIGNsaXBwZXJFbGVtZW50ID0gY2FuRXNjYXBlQ2xpcHBpbmcgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldE9mZnNldFBhcmVudChlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgaWYgKCFpc0VsZW1lbnQoY2xpcHBlckVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8xNDE0XG5cblxuICByZXR1cm4gY2xpcHBpbmdQYXJlbnRzLmZpbHRlcihmdW5jdGlvbiAoY2xpcHBpbmdQYXJlbnQpIHtcbiAgICByZXR1cm4gaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSAmJiBjb250YWlucyhjbGlwcGluZ1BhcmVudCwgY2xpcHBlckVsZW1lbnQpICYmIGdldE5vZGVOYW1lKGNsaXBwaW5nUGFyZW50KSAhPT0gJ2JvZHknO1xuICB9KTtcbn0gLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgcGFyZW50c1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChlbGVtZW50LCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5LCBzdHJhdGVneSkge1xuICB2YXIgbWFpbkNsaXBwaW5nUGFyZW50cyA9IGJvdW5kYXJ5ID09PSAnY2xpcHBpbmdQYXJlbnRzJyA/IGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBbXS5jb25jYXQobWFpbkNsaXBwaW5nUGFyZW50cywgW3Jvb3RCb3VuZGFyeV0pO1xuICB2YXIgZmlyc3RDbGlwcGluZ1BhcmVudCA9IGNsaXBwaW5nUGFyZW50c1swXTtcbiAgdmFyIGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nUGFyZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY1JlY3QsIGNsaXBwaW5nUGFyZW50KSB7XG4gICAgdmFyIHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpO1xuICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IG1pbihyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcbiAgICBhY2NSZWN0LmJvdHRvbSA9IG1pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGZpcnN0Q2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSk7XG4gIGNsaXBwaW5nUmVjdC53aWR0aCA9IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QuaGVpZ2h0ID0gY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3A7XG4gIGNsaXBwaW5nUmVjdC54ID0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC55ID0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgcmV0dXJuIGNsaXBwaW5nUmVjdDtcbn0iLCAiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4vZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHN0YXJ0LCBlbmQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVPZmZzZXRzKF9yZWYpIHtcbiAgdmFyIHJlZmVyZW5jZSA9IF9yZWYucmVmZXJlbmNlLFxuICAgICAgZWxlbWVudCA9IF9yZWYuZWxlbWVudCxcbiAgICAgIHBsYWNlbWVudCA9IF9yZWYucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudCA/IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA6IG51bGw7XG4gIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQgPyBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA6IG51bGw7XG4gIHZhciBjb21tb25YID0gcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGggLyAyIC0gZWxlbWVudC53aWR0aCAvIDI7XG4gIHZhciBjb21tb25ZID0gcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0IC8gMiAtIGVsZW1lbnQuaGVpZ2h0IC8gMjtcbiAgdmFyIG9mZnNldHM7XG5cbiAgc3dpdGNoIChiYXNlUGxhY2VtZW50KSB7XG4gICAgY2FzZSB0b3A6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSAtIGVsZW1lbnQuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGJvdHRvbTpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSByaWdodDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGxlZnQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCAtIGVsZW1lbnQud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnlcbiAgICAgIH07XG4gIH1cblxuICB2YXIgbWFpbkF4aXMgPSBiYXNlUGxhY2VtZW50ID8gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpIDogbnVsbDtcblxuICBpZiAobWFpbkF4aXMgIT0gbnVsbCkge1xuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgc3dpdGNoICh2YXJpYXRpb24pIHtcbiAgICAgIGNhc2Ugc3RhcnQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gLSAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIGVuZDpcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSArIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldHM7XG59IiwgImltcG9ydCBnZXRDbGlwcGluZ1JlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tIFwiLi9jb21wdXRlT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IHJlY3RUb0NsaWVudFJlY3QgZnJvbSBcIi4vcmVjdFRvQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IHsgY2xpcHBpbmdQYXJlbnRzLCByZWZlcmVuY2UsIHBvcHBlciwgYm90dG9tLCB0b3AsIHJpZ2h0LCBiYXNlUGxhY2VtZW50cywgdmlld3BvcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IG1lcmdlUGFkZGluZ09iamVjdCBmcm9tIFwiLi9tZXJnZVBhZGRpbmdPYmplY3QuanNcIjtcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSBcIi4vZXhwYW5kVG9IYXNoTWFwLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyRwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucyRwbGFjZW1lbnQgPT09IHZvaWQgMCA/IHN0YXRlLnBsYWNlbWVudCA6IF9vcHRpb25zJHBsYWNlbWVudCxcbiAgICAgIF9vcHRpb25zJHN0cmF0ZWd5ID0gX29wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBzdHJhdGVneSA9IF9vcHRpb25zJHN0cmF0ZWd5ID09PSB2b2lkIDAgPyBzdGF0ZS5zdHJhdGVneSA6IF9vcHRpb25zJHN0cmF0ZWd5LFxuICAgICAgX29wdGlvbnMkYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMkYm91bmRhcnkgPT09IHZvaWQgMCA/IGNsaXBwaW5nUGFyZW50cyA6IF9vcHRpb25zJGJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyB2aWV3cG9ydCA6IF9vcHRpb25zJHJvb3RCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJGVsZW1lbnRDb250ZSA9IF9vcHRpb25zLmVsZW1lbnRDb250ZXh0LFxuICAgICAgZWxlbWVudENvbnRleHQgPSBfb3B0aW9ucyRlbGVtZW50Q29udGUgPT09IHZvaWQgMCA/IHBvcHBlciA6IF9vcHRpb25zJGVsZW1lbnRDb250ZSxcbiAgICAgIF9vcHRpb25zJGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IF9vcHRpb25zJGFsdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBwYWRkaW5nID0gX29wdGlvbnMkcGFkZGluZyA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHBhZGRpbmc7XG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbiAgdmFyIGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcmVmZXJlbmNlIDogcG9wcGVyO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG4gIHZhciBjbGlwcGluZ0NsaWVudFJlY3QgPSBnZXRDbGlwcGluZ1JlY3QoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgZ2V0RG9jdW1lbnRFbGVtZW50KHN0YXRlLmVsZW1lbnRzLnBvcHBlciksIGJvdW5kYXJ5LCByb290Qm91bmRhcnksIHN0cmF0ZWd5KTtcbiAgdmFyIHJlZmVyZW5jZUNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qoc3RhdGUuZWxlbWVudHMucmVmZXJlbmNlKTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VDbGllbnRSZWN0LFxuICAgIGVsZW1lbnQ6IHBvcHBlclJlY3QsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSk7XG4gIHZhciBwb3BwZXJDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChPYmplY3QuYXNzaWduKHt9LCBwb3BwZXJSZWN0LCBwb3BwZXJPZmZzZXRzKSk7XG4gIHZhciBlbGVtZW50Q2xpZW50UmVjdCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyBwb3BwZXJDbGllbnRSZWN0IDogcmVmZXJlbmNlQ2xpZW50UmVjdDsgLy8gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgcmVjdFxuICAvLyAwIG9yIG5lZ2F0aXZlID0gd2l0aGluIHRoZSBjbGlwcGluZyByZWN0XG5cbiAgdmFyIG92ZXJmbG93T2Zmc2V0cyA9IHtcbiAgICB0b3A6IGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCxcbiAgICBib3R0b206IGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSxcbiAgICBsZWZ0OiBjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQsXG4gICAgcmlnaHQ6IGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodFxuICB9O1xuICB2YXIgb2Zmc2V0RGF0YSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0OyAvLyBPZmZzZXRzIGNhbiBiZSBhcHBsaWVkIG9ubHkgdG8gdGhlIHBvcHBlciBlbGVtZW50XG5cbiAgaWYgKGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgJiYgb2Zmc2V0RGF0YSkge1xuICAgIHZhciBvZmZzZXQgPSBvZmZzZXREYXRhW3BsYWNlbWVudF07XG4gICAgT2JqZWN0LmtleXMob3ZlcmZsb3dPZmZzZXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBtdWx0aXBseSA9IFtyaWdodCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/IDEgOiAtMTtcbiAgICAgIHZhciBheGlzID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/ICd5JyA6ICd4JztcbiAgICAgIG92ZXJmbG93T2Zmc2V0c1trZXldICs9IG9mZnNldFtheGlzXSAqIG11bHRpcGx5O1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG92ZXJmbG93T2Zmc2V0cztcbn0iLCAiaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCB7IHZhcmlhdGlvblBsYWNlbWVudHMsIGJhc2VQbGFjZW1lbnRzLCBwbGFjZW1lbnRzIGFzIGFsbFBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgX29wdGlvbnMkYWxsb3dlZEF1dG9QID0gX29wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gX29wdGlvbnMkYWxsb3dlZEF1dG9QID09PSB2b2lkIDAgPyBhbGxQbGFjZW1lbnRzIDogX29wdGlvbnMkYWxsb3dlZEF1dG9QO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCk7XG4gIHZhciBwbGFjZW1lbnRzID0gdmFyaWF0aW9uID8gZmxpcFZhcmlhdGlvbnMgPyB2YXJpYXRpb25QbGFjZW1lbnRzIDogdmFyaWF0aW9uUGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gdmFyaWF0aW9uO1xuICB9KSA6IGJhc2VQbGFjZW1lbnRzO1xuICB2YXIgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFsbG93ZWRBdXRvUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCkgPj0gMDtcbiAgfSk7XG5cbiAgaWYgKGFsbG93ZWRQbGFjZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cztcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXTogRmxvdyBzZWVtcyB0byBoYXZlIHByb2JsZW1zIHdpdGggdHdvIGFycmF5IHVuaW9ucy4uLlxuXG5cbiAgdmFyIG92ZXJmbG93cyA9IGFsbG93ZWRQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pW2dldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KV07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmtleXMob3ZlcmZsb3dzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93c1thXSAtIG92ZXJmbG93c1tiXTtcbiAgfSk7XG59IiwgImltcG9ydCBnZXRPcHBvc2l0ZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgY29tcHV0ZUF1dG9QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyBib3R0b20sIHRvcCwgc3RhcnQsIHJpZ2h0LCBsZWZ0LCBhdXRvIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5mdW5jdGlvbiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwbGFjZW1lbnQpIHtcbiAgaWYgKGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0bykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHJldHVybiBbZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSwgb3Bwb3NpdGVQbGFjZW1lbnQsIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KG9wcG9zaXRlUGxhY2VtZW50KV07XG59XG5cbmZ1bmN0aW9uIGZsaXAoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxuICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXG4gICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFsdEF4aXMsXG4gICAgICBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgPSBvcHRpb25zLmZhbGxiYWNrUGxhY2VtZW50cyxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXG4gICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBvcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJGZsaXBWYXJpYXRpbyA9IG9wdGlvbnMuZmxpcFZhcmlhdGlvbnMsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zJGZsaXBWYXJpYXRpbyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGZsaXBWYXJpYXRpbyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IG9wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzO1xuICB2YXIgcHJlZmVycmVkUGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gYmFzZVBsYWNlbWVudCA9PT0gcHJlZmVycmVkUGxhY2VtZW50O1xuICB2YXIgZmFsbGJhY2tQbGFjZW1lbnRzID0gc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIHx8IChpc0Jhc2VQbGFjZW1lbnQgfHwgIWZsaXBWYXJpYXRpb25zID8gW2dldE9wcG9zaXRlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCldIDogZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocHJlZmVycmVkUGxhY2VtZW50KSk7XG4gIHZhciBwbGFjZW1lbnRzID0gW3ByZWZlcnJlZFBsYWNlbWVudF0uY29uY2F0KGZhbGxiYWNrUGxhY2VtZW50cykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0byA/IGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZyxcbiAgICAgIGZsaXBWYXJpYXRpb25zOiBmbGlwVmFyaWF0aW9ucyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50czogYWxsb3dlZEF1dG9QbGFjZW1lbnRzXG4gICAgfSkgOiBwbGFjZW1lbnQpO1xuICB9LCBbXSk7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGNoZWNrc01hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIG1ha2VGYWxsYmFja0NoZWNrcyA9IHRydWU7XG4gIHZhciBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzWzBdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGxhY2VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwbGFjZW1lbnQgPSBwbGFjZW1lbnRzW2ldO1xuXG4gICAgdmFyIF9iYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuXG4gICAgdmFyIGlzU3RhcnRWYXJpYXRpb24gPSBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gc3RhcnQ7XG4gICAgdmFyIGlzVmVydGljYWwgPSBbdG9wLCBib3R0b21dLmluZGV4T2YoX2Jhc2VQbGFjZW1lbnQpID49IDA7XG4gICAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgfSk7XG4gICAgdmFyIG1haW5WYXJpYXRpb25TaWRlID0gaXNWZXJ0aWNhbCA/IGlzU3RhcnRWYXJpYXRpb24gPyByaWdodCA6IGxlZnQgOiBpc1N0YXJ0VmFyaWF0aW9uID8gYm90dG9tIDogdG9wO1xuXG4gICAgaWYgKHJlZmVyZW5jZVJlY3RbbGVuXSA+IHBvcHBlclJlY3RbbGVuXSkge1xuICAgICAgbWFpblZhcmlhdGlvblNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XG4gICAgfVxuXG4gICAgdmFyIGFsdFZhcmlhdGlvblNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XG4gICAgdmFyIGNoZWNrcyA9IFtdO1xuXG4gICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W19iYXNlUGxhY2VtZW50XSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tBbHRBeGlzKSB7XG4gICAgICBjaGVja3MucHVzaChvdmVyZmxvd1ttYWluVmFyaWF0aW9uU2lkZV0gPD0gMCwgb3ZlcmZsb3dbYWx0VmFyaWF0aW9uU2lkZV0gPD0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrcy5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgIHJldHVybiBjaGVjaztcbiAgICB9KSkge1xuICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICAgICAgbWFrZUZhbGxiYWNrQ2hlY2tzID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjaGVja3NNYXAuc2V0KHBsYWNlbWVudCwgY2hlY2tzKTtcbiAgfVxuXG4gIGlmIChtYWtlRmFsbGJhY2tDaGVja3MpIHtcbiAgICAvLyBgMmAgbWF5IGJlIGRlc2lyZWQgaW4gc29tZSBjYXNlcyBcdTIwMTMgcmVzZWFyY2ggbGF0ZXJcbiAgICB2YXIgbnVtYmVyT2ZDaGVja3MgPSBmbGlwVmFyaWF0aW9ucyA/IDMgOiAxO1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoX2kpIHtcbiAgICAgIHZhciBmaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50cy5maW5kKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICAgICAgdmFyIGNoZWNrcyA9IGNoZWNrc01hcC5nZXQocGxhY2VtZW50KTtcblxuICAgICAgICBpZiAoY2hlY2tzKSB7XG4gICAgICAgICAgcmV0dXJuIGNoZWNrcy5zbGljZSgwLCBfaSkuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2s7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZml0dGluZ1BsYWNlbWVudCkge1xuICAgICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBmaXR0aW5nUGxhY2VtZW50O1xuICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBfaSA9IG51bWJlck9mQ2hlY2tzOyBfaSA+IDA7IF9pLS0pIHtcbiAgICAgIHZhciBfcmV0ID0gX2xvb3AoX2kpO1xuXG4gICAgICBpZiAoX3JldCA9PT0gXCJicmVha1wiKSBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUucGxhY2VtZW50ICE9PSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwID0gdHJ1ZTtcbiAgICBzdGF0ZS5wbGFjZW1lbnQgPSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgc3RhdGUucmVzZXQgPSB0cnVlO1xuICB9XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdmbGlwJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IGZsaXAsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J10sXG4gIGRhdGE6IHtcbiAgICBfc2tpcDogZmFsc2VcbiAgfVxufTsiLCAiaW1wb3J0IHsgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5cbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKSB7XG4gIGlmIChwcmV2ZW50ZWRPZmZzZXRzID09PSB2b2lkIDApIHtcbiAgICBwcmV2ZW50ZWRPZmZzZXRzID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0IC0gcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIHJpZ2h0OiBvdmVyZmxvdy5yaWdodCAtIHJlY3Qud2lkdGggKyBwcmV2ZW50ZWRPZmZzZXRzLngsXG4gICAgYm90dG9tOiBvdmVyZmxvdy5ib3R0b20gLSByZWN0LmhlaWdodCArIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aCAtIHByZXZlbnRlZE9mZnNldHMueFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcbiAgcmV0dXJuIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdLnNvbWUoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3dbc2lkZV0gPj0gMDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhpZGUoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgcHJldmVudGVkT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93O1xuICB2YXIgcmVmZXJlbmNlT3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICB9KTtcbiAgdmFyIHBvcHBlckFsdE92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICB9KTtcbiAgdmFyIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHJlZmVyZW5jZU92ZXJmbG93LCByZWZlcmVuY2VSZWN0KTtcbiAgdmFyIHBvcHBlckVzY2FwZU9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhwb3BwZXJBbHRPdmVyZmxvdywgcG9wcGVyUmVjdCwgcHJldmVudGVkT2Zmc2V0cyk7XG4gIHZhciBpc1JlZmVyZW5jZUhpZGRlbiA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMpO1xuICB2YXIgaGFzUG9wcGVyRXNjYXBlZCA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChwb3BwZXJFc2NhcGVPZmZzZXRzKTtcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IHtcbiAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHM6IHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyxcbiAgICBwb3BwZXJFc2NhcGVPZmZzZXRzOiBwb3BwZXJFc2NhcGVPZmZzZXRzLFxuICAgIGlzUmVmZXJlbmNlSGlkZGVuOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICBoYXNQb3BwZXJFc2NhcGVkOiBoYXNQb3BwZXJFc2NhcGVkXG4gIH07XG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAnZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlbic6IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgICdkYXRhLXBvcHBlci1lc2NhcGVkJzogaGFzUG9wcGVyRXNjYXBlZFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2hpZGUnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddLFxuICBmbjogaGlkZVxufTsiLCAiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIHBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCByZWN0cywgb2Zmc2V0KSB7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICB2YXIgaW52ZXJ0RGlzdGFuY2UgPSBbbGVmdCwgdG9wXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyAtMSA6IDE7XG5cbiAgdmFyIF9yZWYgPSB0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gb2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSkpIDogb2Zmc2V0LFxuICAgICAgc2tpZGRpbmcgPSBfcmVmWzBdLFxuICAgICAgZGlzdGFuY2UgPSBfcmVmWzFdO1xuXG4gIHNraWRkaW5nID0gc2tpZGRpbmcgfHwgMDtcbiAgZGlzdGFuY2UgPSAoZGlzdGFuY2UgfHwgMCkgKiBpbnZlcnREaXN0YW5jZTtcbiAgcmV0dXJuIFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8ge1xuICAgIHg6IGRpc3RhbmNlLFxuICAgIHk6IHNraWRkaW5nXG4gIH0gOiB7XG4gICAgeDogc2tpZGRpbmcsXG4gICAgeTogZGlzdGFuY2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gb2Zmc2V0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZjIubmFtZTtcbiAgdmFyIF9vcHRpb25zJG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0LFxuICAgICAgb2Zmc2V0ID0gX29wdGlvbnMkb2Zmc2V0ID09PSB2b2lkIDAgPyBbMCwgMF0gOiBfb3B0aW9ucyRvZmZzZXQ7XG4gIHZhciBkYXRhID0gcGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHN0YXRlLnJlY3RzLCBvZmZzZXQpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgdmFyIF9kYXRhJHN0YXRlJHBsYWNlbWVudCA9IGRhdGFbc3RhdGUucGxhY2VtZW50XSxcbiAgICAgIHggPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueCxcbiAgICAgIHkgPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueCArPSB4O1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy55ICs9IHk7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ29mZnNldCcsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgZm46IG9mZnNldFxufTsiLCAiaW1wb3J0IGNvbXB1dGVPZmZzZXRzIGZyb20gXCIuLi91dGlscy9jb21wdXRlT2Zmc2V0cy5qc1wiO1xuXG5mdW5jdGlvbiBwb3BwZXJPZmZzZXRzKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIC8vIE9mZnNldHMgYXJlIHRoZSBhY3R1YWwgcG9zaXRpb24gdGhlIHBvcHBlciBuZWVkcyB0byBoYXZlIHRvIGJlXG4gIC8vIHByb3Blcmx5IHBvc2l0aW9uZWQgbmVhciBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcbiAgLy8gVGhpcyBpcyB0aGUgbW9zdCBiYXNpYyBwbGFjZW1lbnQsIGFuZCB3aWxsIGJlIGFkanVzdGVkIGJ5XG4gIC8vIHRoZSBtb2RpZmllcnMgaW4gdGhlIG5leHQgc3RlcFxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogc3RhdGUucmVjdHMucmVmZXJlbmNlLFxuICAgIGVsZW1lbnQ6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ3BvcHBlck9mZnNldHMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3JlYWQnLFxuICBmbjogcG9wcGVyT2Zmc2V0cyxcbiAgZGF0YToge31cbn07IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEFsdEF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufSIsICJpbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHN0YXJ0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0QWx0QXhpcyBmcm9tIFwiLi4vdXRpbHMvZ2V0QWx0QXhpcy5qc1wiO1xuaW1wb3J0IHsgd2l0aGluLCB3aXRoaW5NYXhDbGFtcCB9IGZyb20gXCIuLi91dGlscy93aXRoaW4uanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgZ2V0RnJlc2hTaWRlT2JqZWN0IGZyb20gXCIuLi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanNcIjtcbmltcG9ydCB7IG1pbiBhcyBtYXRoTWluLCBtYXggYXMgbWF0aE1heCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIF9vcHRpb25zJHRldGhlciA9IG9wdGlvbnMudGV0aGVyLFxuICAgICAgdGV0aGVyID0gX29wdGlvbnMkdGV0aGVyID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkdGV0aGVyLFxuICAgICAgX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID0gb3B0aW9ucy50ZXRoZXJPZmZzZXQsXG4gICAgICB0ZXRoZXJPZmZzZXQgPSBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQ7XG4gIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5XG4gIH0pO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gIXZhcmlhdGlvbjtcbiAgdmFyIG1haW5BeGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgYWx0QXhpcyA9IGdldEFsdEF4aXMobWFpbkF4aXMpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgdGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gdGV0aGVyT2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSkpIDogdGV0aGVyT2Zmc2V0O1xuICB2YXIgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlID0gdHlwZW9mIHRldGhlck9mZnNldFZhbHVlID09PSAnbnVtYmVyJyA/IHtcbiAgICBtYWluQXhpczogdGV0aGVyT2Zmc2V0VmFsdWUsXG4gICAgYWx0QXhpczogdGV0aGVyT2Zmc2V0VmFsdWVcbiAgfSA6IE9iamVjdC5hc3NpZ24oe1xuICAgIG1haW5BeGlzOiAwLFxuICAgIGFsdEF4aXM6IDBcbiAgfSwgdGV0aGVyT2Zmc2V0VmFsdWUpO1xuICB2YXIgb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0ID8gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXRbc3RhdGUucGxhY2VtZW50XSA6IG51bGw7XG4gIHZhciBkYXRhID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmICghcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclN0YXRlJDtcblxuICAgIHZhciBtYWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICAgIHZhciBhbHRTaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBvZmZzZXQgPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXTtcbiAgICB2YXIgbWluID0gb2Zmc2V0ICsgb3ZlcmZsb3dbbWFpblNpZGVdO1xuICAgIHZhciBtYXggPSBvZmZzZXQgLSBvdmVyZmxvd1thbHRTaWRlXTtcbiAgICB2YXIgYWRkaXRpdmUgPSB0ZXRoZXIgPyAtcG9wcGVyUmVjdFtsZW5dIC8gMiA6IDA7XG4gICAgdmFyIG1pbkxlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gOiBwb3BwZXJSZWN0W2xlbl07XG4gICAgdmFyIG1heExlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyAtcG9wcGVyUmVjdFtsZW5dIDogLXJlZmVyZW5jZVJlY3RbbGVuXTsgLy8gV2UgbmVlZCB0byBpbmNsdWRlIHRoZSBhcnJvdyBpbiB0aGUgY2FsY3VsYXRpb24gc28gdGhlIGFycm93IGRvZXNuJ3QgZ29cbiAgICAvLyBvdXRzaWRlIHRoZSByZWZlcmVuY2UgYm91bmRzXG5cbiAgICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gICAgdmFyIGFycm93UmVjdCA9IHRldGhlciAmJiBhcnJvd0VsZW1lbnQgPyBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCkgOiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgdmFyIGFycm93UGFkZGluZ09iamVjdCA9IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXSA/IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXS5wYWRkaW5nIDogZ2V0RnJlc2hTaWRlT2JqZWN0KCk7XG4gICAgdmFyIGFycm93UGFkZGluZ01pbiA9IGFycm93UGFkZGluZ09iamVjdFttYWluU2lkZV07XG4gICAgdmFyIGFycm93UGFkZGluZ01heCA9IGFycm93UGFkZGluZ09iamVjdFthbHRTaWRlXTsgLy8gSWYgdGhlIHJlZmVyZW5jZSBsZW5ndGggaXMgc21hbGxlciB0aGFuIHRoZSBhcnJvdyBsZW5ndGgsIHdlIGRvbid0IHdhbnRcbiAgICAvLyB0byBpbmNsdWRlIGl0cyBmdWxsIHNpemUgaW4gdGhlIGNhbGN1bGF0aW9uLiBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsXG4gICAgLy8gYW5kIG5lYXIgdGhlIGVkZ2Ugb2YgYSBib3VuZGFyeSwgdGhlIHBvcHBlciBjYW4gb3ZlcmZsb3cgZXZlbiBpZiB0aGVcbiAgICAvLyByZWZlcmVuY2UgaXMgbm90IG92ZXJmbG93aW5nIGFzIHdlbGwgKGUuZy4gdmlydHVhbCBlbGVtZW50cyB3aXRoIG5vXG4gICAgLy8gd2lkdGggb3IgaGVpZ2h0KVxuXG4gICAgdmFyIGFycm93TGVuID0gd2l0aGluKDAsIHJlZmVyZW5jZVJlY3RbbGVuXSwgYXJyb3dSZWN0W2xlbl0pO1xuICAgIHZhciBtaW5PZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gLyAyIC0gYWRkaXRpdmUgLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcyA6IG1pbkxlbiAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzO1xuICAgIHZhciBtYXhPZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyAtcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiArIGFkZGl0aXZlICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXMgOiBtYXhMZW4gKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcbiAgICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdyAmJiBnZXRPZmZzZXRQYXJlbnQoc3RhdGUuZWxlbWVudHMuYXJyb3cpO1xuICAgIHZhciBjbGllbnRPZmZzZXQgPSBhcnJvd09mZnNldFBhcmVudCA/IG1haW5BeGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRUb3AgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudExlZnQgfHwgMCA6IDA7XG4gICAgdmFyIG9mZnNldE1vZGlmaWVyVmFsdWUgPSAoX29mZnNldE1vZGlmaWVyU3RhdGUkID0gb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogb2Zmc2V0TW9kaWZpZXJTdGF0ZVttYWluQXhpc10pICE9IG51bGwgPyBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQgOiAwO1xuICAgIHZhciB0ZXRoZXJNaW4gPSBvZmZzZXQgKyBtaW5PZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlIC0gY2xpZW50T2Zmc2V0O1xuICAgIHZhciB0ZXRoZXJNYXggPSBvZmZzZXQgKyBtYXhPZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlO1xuICAgIHZhciBwcmV2ZW50ZWRPZmZzZXQgPSB3aXRoaW4odGV0aGVyID8gbWF0aE1pbihtaW4sIHRldGhlck1pbikgOiBtaW4sIG9mZnNldCwgdGV0aGVyID8gbWF0aE1heChtYXgsIHRldGhlck1heCkgOiBtYXgpO1xuICAgIHBvcHBlck9mZnNldHNbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0O1xuICAgIGRhdGFbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0IC0gb2Zmc2V0O1xuICB9XG5cbiAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyO1xuXG4gICAgdmFyIF9tYWluU2lkZSA9IG1haW5BeGlzID09PSAneCcgPyB0b3AgOiBsZWZ0O1xuXG4gICAgdmFyIF9hbHRTaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IGJvdHRvbSA6IHJpZ2h0O1xuXG4gICAgdmFyIF9vZmZzZXQgPSBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdO1xuXG4gICAgdmFyIF9sZW4gPSBhbHRBeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICB2YXIgX21pbiA9IF9vZmZzZXQgKyBvdmVyZmxvd1tfbWFpblNpZGVdO1xuXG4gICAgdmFyIF9tYXggPSBfb2Zmc2V0IC0gb3ZlcmZsb3dbX2FsdFNpZGVdO1xuXG4gICAgdmFyIGlzT3JpZ2luU2lkZSA9IFt0b3AsIGxlZnRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJDIgPSBvZmZzZXRNb2RpZmllclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXRNb2RpZmllclN0YXRlW2FsdEF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkMiA6IDA7XG5cbiAgICB2YXIgX3RldGhlck1pbiA9IGlzT3JpZ2luU2lkZSA/IF9taW4gOiBfb2Zmc2V0IC0gcmVmZXJlbmNlUmVjdFtfbGVuXSAtIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzO1xuXG4gICAgdmFyIF90ZXRoZXJNYXggPSBpc09yaWdpblNpZGUgPyBfb2Zmc2V0ICsgcmVmZXJlbmNlUmVjdFtfbGVuXSArIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzIDogX21heDtcblxuICAgIHZhciBfcHJldmVudGVkT2Zmc2V0ID0gdGV0aGVyICYmIGlzT3JpZ2luU2lkZSA/IHdpdGhpbk1heENsYW1wKF90ZXRoZXJNaW4sIF9vZmZzZXQsIF90ZXRoZXJNYXgpIDogd2l0aGluKHRldGhlciA/IF90ZXRoZXJNaW4gOiBfbWluLCBfb2Zmc2V0LCB0ZXRoZXIgPyBfdGV0aGVyTWF4IDogX21heCk7XG5cbiAgICBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldDtcbiAgICBkYXRhW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldCAtIF9vZmZzZXQ7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBwcmV2ZW50T3ZlcmZsb3csXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J11cbn07IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEhUTUxFbGVtZW50U2Nyb2xsKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICB9O1xufSIsICJpbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0SFRNTEVsZW1lbnRTY3JvbGwgZnJvbSBcIi4vZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE5vZGVTY3JvbGwobm9kZSkge1xuICBpZiAobm9kZSA9PT0gZ2V0V2luZG93KG5vZGUpIHx8ICFpc0hUTUxFbGVtZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIGdldFdpbmRvd1Njcm9sbChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0SFRNTEVsZW1lbnRTY3JvbGwobm9kZSk7XG4gIH1cbn0iLCAiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXROb2RlU2Nyb2xsIGZyb20gXCIuL2dldE5vZGVTY3JvbGwuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcblxuZnVuY3Rpb24gaXNFbGVtZW50U2NhbGVkKGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc2NhbGVYID0gcm91bmQocmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDE7XG4gIHZhciBzY2FsZVkgPSByb3VuZChyZWN0LmhlaWdodCkgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxO1xuICByZXR1cm4gc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMTtcbn0gLy8gUmV0dXJucyB0aGUgY29tcG9zaXRlIHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LlxuLy8gQ29tcG9zaXRlIG1lYW5zIGl0IHRha2VzIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zIGFzIHdlbGwgYXMgbGF5b3V0LlxuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbXBvc2l0ZVJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudCwgaXNGaXhlZCkge1xuICBpZiAoaXNGaXhlZCA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgb2Zmc2V0UGFyZW50SXNTY2FsZWQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgaXNFbGVtZW50U2NhbGVkKG9mZnNldFBhcmVudCk7XG4gIHZhciBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudElzU2NhbGVkLCBpc0ZpeGVkKTtcbiAgdmFyIHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICB2YXIgb2Zmc2V0cyA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEwNzhcbiAgICBpc1Njcm9sbFBhcmVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgb2Zmc2V0cyA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQsIHRydWUpO1xuICAgICAgb2Zmc2V0cy54ICs9IG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ICs9IG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54LFxuICAgIHk6IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59IiwgImltcG9ydCB7IG1vZGlmaWVyUGhhc2VzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7IC8vIHNvdXJjZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk4NzUyNTVcblxuZnVuY3Rpb24gb3JkZXIobW9kaWZpZXJzKSB7XG4gIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIG1hcC5zZXQobW9kaWZpZXIubmFtZSwgbW9kaWZpZXIpO1xuICB9KTsgLy8gT24gdmlzaXRpbmcgb2JqZWN0LCBjaGVjayBmb3IgaXRzIGRlcGVuZGVuY2llcyBhbmQgdmlzaXQgdGhlbSByZWN1cnNpdmVseVxuXG4gIGZ1bmN0aW9uIHNvcnQobW9kaWZpZXIpIHtcbiAgICB2aXNpdGVkLmFkZChtb2RpZmllci5uYW1lKTtcbiAgICB2YXIgcmVxdWlyZXMgPSBbXS5jb25jYXQobW9kaWZpZXIucmVxdWlyZXMgfHwgW10sIG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMgfHwgW10pO1xuICAgIHJlcXVpcmVzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhkZXApKSB7XG4gICAgICAgIHZhciBkZXBNb2RpZmllciA9IG1hcC5nZXQoZGVwKTtcblxuICAgICAgICBpZiAoZGVwTW9kaWZpZXIpIHtcbiAgICAgICAgICBzb3J0KGRlcE1vZGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJlc3VsdC5wdXNoKG1vZGlmaWVyKTtcbiAgfVxuXG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmICghdmlzaXRlZC5oYXMobW9kaWZpZXIubmFtZSkpIHtcbiAgICAgIC8vIGNoZWNrIGZvciB2aXNpdGVkIG9iamVjdFxuICAgICAgc29ydChtb2RpZmllcik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb3JkZXJNb2RpZmllcnMobW9kaWZpZXJzKSB7XG4gIC8vIG9yZGVyIGJhc2VkIG9uIGRlcGVuZGVuY2llc1xuICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyKG1vZGlmaWVycyk7IC8vIG9yZGVyIGJhc2VkIG9uIHBoYXNlXG5cbiAgcmV0dXJuIG1vZGlmaWVyUGhhc2VzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwaGFzZSkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgcmV0dXJuIG1vZGlmaWVyLnBoYXNlID09PSBwaGFzZTtcbiAgICB9KSk7XG4gIH0sIFtdKTtcbn0iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVib3VuY2UoZm4pIHtcbiAgdmFyIHBlbmRpbmc7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcGVuZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXNvbHZlKGZuKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwZW5kaW5nO1xuICB9O1xufSIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZUJ5TmFtZShtb2RpZmllcnMpIHtcbiAgdmFyIG1lcmdlZCA9IG1vZGlmaWVycy5yZWR1Y2UoZnVuY3Rpb24gKG1lcmdlZCwgY3VycmVudCkge1xuICAgIHZhciBleGlzdGluZyA9IG1lcmdlZFtjdXJyZW50Lm5hbWVdO1xuICAgIG1lcmdlZFtjdXJyZW50Lm5hbWVdID0gZXhpc3RpbmcgPyBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZywgY3VycmVudCwge1xuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3Rpbmcub3B0aW9ucywgY3VycmVudC5vcHRpb25zKSxcbiAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLmRhdGEsIGN1cnJlbnQuZGF0YSlcbiAgICB9KSA6IGN1cnJlbnQ7XG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfSwge30pOyAvLyBJRTExIGRvZXMgbm90IHN1cHBvcnQgT2JqZWN0LnZhbHVlc1xuXG4gIHJldHVybiBPYmplY3Qua2V5cyhtZXJnZWQpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG1lcmdlZFtrZXldO1xuICB9KTtcbn0iLCAiaW1wb3J0IGdldENvbXBvc2l0ZVJlY3QgZnJvbSBcIi4vZG9tLXV0aWxzL2dldENvbXBvc2l0ZVJlY3QuanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgbGlzdFNjcm9sbFBhcmVudHMgZnJvbSBcIi4vZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBvcmRlck1vZGlmaWVycyBmcm9tIFwiLi91dGlscy9vcmRlck1vZGlmaWVycy5qc1wiO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gXCIuL3V0aWxzL2RlYm91bmNlLmpzXCI7XG5pbXBvcnQgbWVyZ2VCeU5hbWUgZnJvbSBcIi4vdXRpbHMvbWVyZ2VCeU5hbWUuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gIG1vZGlmaWVyczogW10sXG4gIHN0cmF0ZWd5OiAnYWJzb2x1dGUnXG59O1xuXG5mdW5jdGlvbiBhcmVWYWxpZEVsZW1lbnRzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuICFhcmdzLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gIShlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9PT0gJ2Z1bmN0aW9uJyk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9wcGVyR2VuZXJhdG9yKGdlbmVyYXRvck9wdGlvbnMpIHtcbiAgaWYgKGdlbmVyYXRvck9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIGdlbmVyYXRvck9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfZ2VuZXJhdG9yT3B0aW9ucyA9IGdlbmVyYXRvck9wdGlvbnMsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0TW9kaWZpZXJzLFxuICAgICAgZGVmYXVsdE1vZGlmaWVycyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9PT0gdm9pZCAwID8gW10gOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE9wdGlvbnMsXG4gICAgICBkZWZhdWx0T3B0aW9ucyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPT09IHZvaWQgMCA/IERFRkFVTFRfT1BUSU9OUyA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZjI7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgICAgIG9yZGVyZWRNb2RpZmllcnM6IFtdLFxuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBkZWZhdWx0T3B0aW9ucyksXG4gICAgICBtb2RpZmllcnNEYXRhOiB7fSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlLFxuICAgICAgICBwb3BwZXI6IHBvcHBlclxuICAgICAgfSxcbiAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH07XG4gICAgdmFyIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB2YXIgaXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB2YXIgaW5zdGFuY2UgPSB7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBzZXRPcHRpb25zOiBmdW5jdGlvbiBzZXRPcHRpb25zKHNldE9wdGlvbnNBY3Rpb24pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2V0T3B0aW9uc0FjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IHNldE9wdGlvbnNBY3Rpb24oc3RhdGUub3B0aW9ucykgOiBzZXRPcHRpb25zQWN0aW9uO1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHN0YXRlLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgc3RhdGUub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHN0YXRlLnNjcm9sbFBhcmVudHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBpc0VsZW1lbnQocmVmZXJlbmNlKSA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZSkgOiByZWZlcmVuY2UuY29udGV4dEVsZW1lbnQgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpIDogW10sXG4gICAgICAgICAgcG9wcGVyOiBsaXN0U2Nyb2xsUGFyZW50cyhwb3BwZXIpXG4gICAgICAgIH07IC8vIE9yZGVycyB0aGUgbW9kaWZpZXJzIGJhc2VkIG9uIHRoZWlyIGRlcGVuZGVuY2llcyBhbmQgYHBoYXNlYFxuICAgICAgICAvLyBwcm9wZXJ0aWVzXG5cbiAgICAgICAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlck1vZGlmaWVycyhtZXJnZUJ5TmFtZShbXS5jb25jYXQoZGVmYXVsdE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpKSk7IC8vIFN0cmlwIG91dCBkaXNhYmxlZCBtb2RpZmllcnNcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICByZXR1cm4gbS5lbmFibGVkO1xuICAgICAgICB9KTtcbiAgICAgICAgcnVuTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgIH0sXG4gICAgICAvLyBTeW5jIHVwZGF0ZSBcdTIwMTMgaXQgd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQsIGV2ZW4gaWYgbm90IG5lY2Vzc2FyeS4gVGhpc1xuICAgICAgLy8gaXMgdXNlZnVsIGZvciBsb3cgZnJlcXVlbmN5IHVwZGF0ZXMgd2hlcmUgc3luYyBiZWhhdmlvciBzaW1wbGlmaWVzIHRoZVxuICAgICAgLy8gbG9naWMuXG4gICAgICAvLyBGb3IgaGlnaCBmcmVxdWVuY3kgdXBkYXRlcyAoZS5nLiBgcmVzaXplYCBhbmQgYHNjcm9sbGAgZXZlbnRzKSwgYWx3YXlzXG4gICAgICAvLyBwcmVmZXIgdGhlIGFzeW5jIFBvcHBlciN1cGRhdGUgbWV0aG9kXG4gICAgICBmb3JjZVVwZGF0ZTogZnVuY3Rpb24gZm9yY2VVcGRhdGUoKSB7XG4gICAgICAgIGlmIChpc0Rlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfc3RhdGUkZWxlbWVudHMgPSBzdGF0ZS5lbGVtZW50cyxcbiAgICAgICAgICAgIHJlZmVyZW5jZSA9IF9zdGF0ZSRlbGVtZW50cy5yZWZlcmVuY2UsXG4gICAgICAgICAgICBwb3BwZXIgPSBfc3RhdGUkZWxlbWVudHMucG9wcGVyOyAvLyBEb24ndCBwcm9jZWVkIGlmIGByZWZlcmVuY2VgIG9yIGBwb3BwZXJgIGFyZSBub3QgdmFsaWQgZWxlbWVudHNcbiAgICAgICAgLy8gYW55bW9yZVxuXG4gICAgICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gU3RvcmUgdGhlIHJlZmVyZW5jZSBhbmQgcG9wcGVyIHJlY3RzIHRvIGJlIHJlYWQgYnkgbW9kaWZpZXJzXG5cblxuICAgICAgICBzdGF0ZS5yZWN0cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGdldENvbXBvc2l0ZVJlY3QocmVmZXJlbmNlLCBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKSwgc3RhdGUub3B0aW9ucy5zdHJhdGVneSA9PT0gJ2ZpeGVkJyksXG4gICAgICAgICAgcG9wcGVyOiBnZXRMYXlvdXRSZWN0KHBvcHBlcilcbiAgICAgICAgfTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gcmVzZXQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlLiBUaGVcbiAgICAgICAgLy8gbW9zdCBjb21tb24gdXNlIGNhc2UgZm9yIHRoaXMgaXMgdGhlIGBmbGlwYCBtb2RpZmllciBjaGFuZ2luZyB0aGVcbiAgICAgICAgLy8gcGxhY2VtZW50LCB3aGljaCB0aGVuIG5lZWRzIHRvIHJlLXJ1biBhbGwgdGhlIG1vZGlmaWVycywgYmVjYXVzZSB0aGVcbiAgICAgICAgLy8gbG9naWMgd2FzIHByZXZpb3VzbHkgcmFuIGZvciB0aGUgcHJldmlvdXMgcGxhY2VtZW50IGFuZCBpcyB0aGVyZWZvcmVcbiAgICAgICAgLy8gc3RhbGUvaW5jb3JyZWN0XG5cbiAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7IC8vIE9uIGVhY2ggdXBkYXRlIGN5Y2xlLCB0aGUgYG1vZGlmaWVyc0RhdGFgIHByb3BlcnR5IGZvciBlYWNoIG1vZGlmaWVyXG4gICAgICAgIC8vIGlzIGZpbGxlZCB3aXRoIHRoZSBpbml0aWFsIGRhdGEgc3BlY2lmaWVkIGJ5IHRoZSBtb2RpZmllci4gVGhpcyBtZWFuc1xuICAgICAgICAvLyBpdCBkb2Vzbid0IHBlcnNpc3QgYW5kIGlzIGZyZXNoIG9uIGVhY2ggdXBkYXRlLlxuICAgICAgICAvLyBUbyBlbnN1cmUgcGVyc2lzdGVudCBkYXRhLCB1c2UgYCR7bmFtZX0jcGVyc2lzdGVudGBcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLm1vZGlmaWVyc0RhdGFbbW9kaWZpZXIubmFtZV0gPSBPYmplY3QuYXNzaWduKHt9LCBtb2RpZmllci5kYXRhKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0YXRlLm9yZGVyZWRNb2RpZmllcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgaWYgKHN0YXRlLnJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfc3RhdGUkb3JkZXJlZE1vZGlmaWUgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzW2luZGV4XSxcbiAgICAgICAgICAgICAgZm4gPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUuZm4sXG4gICAgICAgICAgICAgIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUub3B0aW9ucyxcbiAgICAgICAgICAgICAgX29wdGlvbnMgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID09PSB2b2lkIDAgPyB7fSA6IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIsXG4gICAgICAgICAgICAgIG5hbWUgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUubmFtZTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN0YXRlID0gZm4oe1xuICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IF9vcHRpb25zLFxuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VcbiAgICAgICAgICAgIH0pIHx8IHN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFzeW5jIGFuZCBvcHRpbWlzdGljYWxseSBvcHRpbWl6ZWQgdXBkYXRlIFx1MjAxMyBpdCB3aWxsIG5vdCBiZSBleGVjdXRlZCBpZlxuICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXG4gICAgICB1cGRhdGU6IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICByZXNvbHZlKHN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgaWYgKCFpc0Rlc3Ryb3llZCAmJiBvcHRpb25zLm9uRmlyc3RVcGRhdGUpIHtcbiAgICAgICAgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSBiZWZvcmUgdGhlIGZpcnN0XG4gICAgLy8gdXBkYXRlIGN5Y2xlIHJ1bnMuIFRoZXkgd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgdXBkYXRlXG4gICAgLy8gY3ljbGUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBtb2RpZmllciBhZGRzIHNvbWUgcGVyc2lzdGVudCBkYXRhIHRoYXRcbiAgICAvLyBvdGhlciBtb2RpZmllcnMgbmVlZCB0byB1c2UsIGJ1dCB0aGUgbW9kaWZpZXIgaXMgcnVuIGFmdGVyIHRoZSBkZXBlbmRlbnRcbiAgICAvLyBvbmUuXG5cbiAgICBmdW5jdGlvbiBydW5Nb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgICAgICBfcmVmJG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zID0gX3JlZiRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkb3B0aW9ucyxcbiAgICAgICAgICAgIGVmZmVjdCA9IF9yZWYuZWZmZWN0O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZWZmZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIGNsZWFudXBGbiA9IGVmZmVjdCh7XG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIG5vb3BGbiA9IGZ1bmN0aW9uIG5vb3BGbigpIHt9O1xuXG4gICAgICAgICAgZWZmZWN0Q2xlYW51cEZucy5wdXNoKGNsZWFudXBGbiB8fCBub29wRm4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgZWZmZWN0Q2xlYW51cEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0pO1xuICAgICAgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcbn1cbmV4cG9ydCB2YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGRldGVjdE92ZXJmbG93IH07IiwgImltcG9ydCB7IHBvcHBlckdlbmVyYXRvciwgZGV0ZWN0T3ZlcmZsb3cgfSBmcm9tIFwiLi9jcmVhdGVQb3BwZXIuanNcIjtcbmltcG9ydCBldmVudExpc3RlbmVycyBmcm9tIFwiLi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanNcIjtcbmltcG9ydCBwb3BwZXJPZmZzZXRzIGZyb20gXCIuL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzLmpzXCI7XG5pbXBvcnQgY29tcHV0ZVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qc1wiO1xuaW1wb3J0IGFwcGx5U3R5bGVzIGZyb20gXCIuL21vZGlmaWVycy9hcHBseVN0eWxlcy5qc1wiO1xuaW1wb3J0IG9mZnNldCBmcm9tIFwiLi9tb2RpZmllcnMvb2Zmc2V0LmpzXCI7XG5pbXBvcnQgZmxpcCBmcm9tIFwiLi9tb2RpZmllcnMvZmxpcC5qc1wiO1xuaW1wb3J0IHByZXZlbnRPdmVyZmxvdyBmcm9tIFwiLi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgYXJyb3cgZnJvbSBcIi4vbW9kaWZpZXJzL2Fycm93LmpzXCI7XG5pbXBvcnQgaGlkZSBmcm9tIFwiLi9tb2RpZmllcnMvaGlkZS5qc1wiO1xudmFyIGRlZmF1bHRNb2RpZmllcnMgPSBbZXZlbnRMaXN0ZW5lcnMsIHBvcHBlck9mZnNldHMsIGNvbXB1dGVTdHlsZXMsIGFwcGx5U3R5bGVzLCBvZmZzZXQsIGZsaXAsIHByZXZlbnRPdmVyZmxvdywgYXJyb3csIGhpZGVdO1xudmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3Ioe1xuICBkZWZhdWx0TW9kaWZpZXJzOiBkZWZhdWx0TW9kaWZpZXJzXG59KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIsIHBvcHBlckdlbmVyYXRvciwgZGVmYXVsdE1vZGlmaWVycywgZGV0ZWN0T3ZlcmZsb3cgfTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIgYXMgY3JlYXRlUG9wcGVyTGl0ZSB9IGZyb20gXCIuL3BvcHBlci1saXRlLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0ICogZnJvbSBcIi4vbW9kaWZpZXJzL2luZGV4LmpzXCI7IiwgIi8vIENyZWRpdHMgZ28gdG8gTGlhbSdzIFBlcmlvZGljIE5vdGVzIFBsdWdpbjogaHR0cHM6Ly9naXRodWIuY29tL2xpYW1jYWluL29ic2lkaWFuLXBlcmlvZGljLW5vdGVzXG4vLyBhbmQgVGVtcGxhdGVyIHBsdWdpbjogaHR0cHM6Ly9naXRodWIuY29tL1NpbGVudFZvaWQxMy9UZW1wbGF0ZXIgd2hlcmUgSSBnb3QgdGhlIGNvZGUgZm9yIHRoZSBzdWdnZXN0ZXJzXG5cbmltcG9ydCB7IFRBYnN0cmFjdEZpbGUsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBUZXh0SW5wdXRTdWdnZXN0IH0gZnJvbSBcIi4vc3VnZ2VzdFwiO1xuaW1wb3J0IHsgZ2V0RmlsZXNGcm9tRm9sZGVyIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XG5pbXBvcnQgRm9sZGVyVGFnUGx1Z2luIGZyb20gXCIuLi8uLi9tYWluXCI7XG5pbXBvcnQgeyBlcnJvcldyYXBwZXJTeW5jIH0gZnJvbSBcIi4uL0Vycm9yXCI7XG5cbmV4cG9ydCBlbnVtIEZpbGVTdWdnZXN0TW9kZSB7XG4gICAgVGVtcGxhdGVGaWxlcyxcbiAgICBTY3JpcHRGaWxlcyxcbn1cblxuZXhwb3J0IGNsYXNzIEZpbGVTdWdnZXN0IGV4dGVuZHMgVGV4dElucHV0U3VnZ2VzdDxURmlsZT4ge1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHB1YmxpYyBpbnB1dEVsOiBIVE1MSW5wdXRFbGVtZW50LFxuICAgICAgICBwcml2YXRlIHBsdWdpbjogRm9sZGVyVGFnUGx1Z2luLFxuICAgICAgICBwcml2YXRlIGZvbGRlcjogc3RyaW5nXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKHBsdWdpbi5hcHAsIGlucHV0RWwpO1xuICAgIH1cblxuICAgIGdldF9lcnJvcl9tc2coKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGBGb2xkZXIgJHt0aGlzLmZvbGRlcn0gZG9lc24ndCBleGlzdGA7XG4gICAgfVxuXG4gICAgZ2V0U3VnZ2VzdGlvbnMoaW5wdXRfc3RyOiBzdHJpbmcpOiBURmlsZVtdIHtcbiAgICAgICAgY29uc3QgYWxsX2ZpbGVzID0gZXJyb3JXcmFwcGVyU3luYyhcbiAgICAgICAgICAgICgpID0+IGdldEZpbGVzRnJvbUZvbGRlcihcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uYXBwLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvbGRlclxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICB0aGlzLmdldF9lcnJvcl9tc2coKVxuICAgICAgICApO1xuICAgICAgICBpZiAoIWFsbF9maWxlcykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmlsZXM6IFRGaWxlW10gPSBbXTtcbiAgICAgICAgY29uc3QgbG93ZXJfaW5wdXRfc3RyID0gaW5wdXRfc3RyLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgYWxsX2ZpbGVzLmZvckVhY2goKGZpbGU6IFRBYnN0cmFjdEZpbGUpID0+IHtcbiAgICAgICAgICAgIGlmIChmaWxlIGluc3RhbmNlb2YgVEZpbGUgJiZcbiAgICAgICAgICAgICAgICBmaWxlLmV4dGVuc2lvbiA9PT0gXCJtZFwiICYmXG4gICAgICAgICAgICAgICAgZmlsZS5wYXRoLnRvTG93ZXJDYXNlKCkuY29udGFpbnMobG93ZXJfaW5wdXRfc3RyKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKGZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZmlsZXMuc2xpY2UoMCwgMTAwMCk7XG4gICAgfVxuXG4gICAgcmVuZGVyU3VnZ2VzdGlvbihmaWxlOiBURmlsZSwgZWw6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgICAgIGVsLnNldFRleHQoZmlsZS5wYXRoKTtcbiAgICB9XG5cbiAgICBzZWxlY3RTdWdnZXN0aW9uKGZpbGU6IFRGaWxlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaW5wdXRFbC52YWx1ZSA9IGZpbGUucGF0aDtcbiAgICAgICAgdGhpcy5pbnB1dEVsLnRyaWdnZXIoXCJpbnB1dFwiKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBSdWxlUHJvdG90eXBlLCBydWxlc01hbmFnZXIgfSBmcm9tIFwiLi9ydWxlc1wiO1xyXG5pbXBvcnQgeyBTY3JpcHRpbmdUb29scyB9IGZyb20gXCIuLi90b29sc1wiO1xyXG5pbXBvcnQgeyBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzIH0gZnJvbSBcIi4uL3R5cGVzXCI7XHJcbmltcG9ydCB7IEFwcCwgU2V0dGluZywgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHsgb3BlbkF1dG9jb21wbGV0ZU1vZGFsIH0gZnJvbSBcIi4uL2F1dG9jb21wbGV0ZU1vZGFsXCI7XHJcbmltcG9ydCB7IERFQlVHLCBFUlJPUiwgbG9nZ2VyIH0gZnJvbSBcIi4uL0xvZ1wiO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBSdWxlQnVpbGRJbkF1dG9Db21wbGV0ZU1vZGFsIGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaWQgPSAnYXV0b0NvbXBsZXRlTW9kYWwnO1xyXG4gICAgICAgIHRoaXMucnVsZVR5cGUgPSAnYXV0b2NvbXBsZXRlLm1vZGFsJztcclxuICAgICAgICB0aGlzLm5hbWUgPSAnQXV0by1Db21wbGV0ZSBNb2RhbCc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdEaXNwbGF5cyBhbiBhdXRvLWNvbXBsZXRlIG1vZGFsIGZvciB0aGUgZnJvbnRtYXR0ZXIgcGFyYW1ldGVyLic7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgY29uc3QgaW5wdXQgPSB0b29scy5nZXRDdXJyZW50Q29udGVudCgpOyAvLyBHZXQgdGhlIGN1cnJlbnQgY29udGVudCBvZiBwcm9wZXJ0eVxcbiAgcmV0dXJuIGlucHV0OyAvLyBSZXR1cm4gdGhlIGlucHV0IHVuYWx0ZXJlZFxcbn07XCI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAgICAgbG9nZ2VyLmxvZyhERUJVRyxgYXV0b2NvbXBsZXRlIG1vZGFsLCB3b3JrIGluIHByb2dyZXNzLi4uYCk7XHJcbiAgICAgICAgY29uc3QgY3VycmVudENvbnRlbnQgPSB0b29scy5nZXRDdXJyZW50Q29udGVudCgpO1xyXG4gICAgICAgIGNvbnN0IHJ1bGUgPSB0b29scy5nZXRSdWxlKCk7XHJcbiAgICAgICAgaWYgKCFydWxlKSByZXR1cm4gY3VycmVudENvbnRlbnQ7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRvb2xzLmdldE9wdGlvbkNvbmZpZyhydWxlLmlkKTtcclxuICAgICAgICBpZiAoIXJ1bGUpIHJldHVybiB0b29scy5nZXRDdXJyZW50Q29udGVudCgpIHx8ICdhdXRvY29tcGxldGUubW9kYWwnOyAvLyByZXR1cm4gY3VycmVudCBjb250ZW50IGlmIG5vdCBpbXBsZW1lbnRlZCB5ZXRcclxuICAgICAgICBjb25zdCBmcm9udG1hdHRlciA9IHRvb2xzLmdldEZyb250bWF0dGVyKCk7XHJcbiAgICAgICAgY29uc3QgaGFzQXV0b2NvbXBsZXRlUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKGZyb250bWF0dGVyKS5zb21lKGtleSA9PiBcclxuICAgICAgICAgICAga2V5LnN0YXJ0c1dpdGgocnVsZS5wcm9wZXJ0eSArIG9wdGlvbnMucHJvcGVydHlEZWxpbWl0ZXIpICYmXHJcbiAgICAgICAgICAgIChmcm9udG1hdHRlcltrZXldID09PSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgICAgZnJvbnRtYXR0ZXJba2V5XSA9PT0gbnVsbCB8fFxyXG4gICAgICAgICAgICBmcm9udG1hdHRlcltrZXldID09PSAnJylcclxuICAgICAgICApO1xyXG4gICAgICAgIGlmICghaGFzQXV0b2NvbXBsZXRlUHJvcGVydGllcykgcmV0dXJuIHRvb2xzLmdldEN1cnJlbnRDb250ZW50KCkgfHwgJ2F1dG9jb21wbGV0ZS5tb2RhbCc7IC8vIHJldHVybiBjdXJyZW50IGNvbnRlbnQgaWYgbm90IGltcGxlbWVudGVkIHlldFxyXG4gICAgICAgIG9wZW5BdXRvY29tcGxldGVNb2RhbChcclxuICAgICAgICAgICAgdG9vbHMuYXBwLFxyXG4gICAgICAgICAgICB0b29scy5wbHVnaW4sXHJcbiAgICAgICAgICAgIHJ1bGUsXHJcbiAgICAgICAgICAgIG9wdGlvbnMsXHJcbiAgICAgICAgICAgIHRvb2xzLmdldEFjdGl2ZUZpbGUoKSxcclxuICAgICAgICAgICAgdG9vbHMuZ2V0RnJvbnRtYXR0ZXIoKVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coREVCVUcsJ2F1dG9jb21wbGV0ZSBtb2RhbCByZXN1bHQnLCByZXN1bHQsIHRvb2xzLmdldEZyb250bWF0dGVyKCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdD8udmFsdWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0b29scy5hcHApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhFUlJPUiwnQXBwIGlzIG5vdCBkZWZpbmVkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b29scy5nZXRDdXJyZW50Q29udGVudCgpIHx8ICdhdXRvY29tcGxldGUubW9kYWwgRXJyb3IuIFNlZSBjb25zb2xlIGZvciBkZXRhaWxzLic7IC8vIHJldHVybiBjdXJyZW50IGNvbnRlbnQgaWYgbm90IGltcGxlbWVudGVkIHlldCAgXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRvb2xzLmFwcC5maWxlTWFuYWdlci5wcm9jZXNzRnJvbnRNYXR0ZXIoZmlsZSwgKGZyb250bWF0dGVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJlc3VsdC52YWx1ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9udG1hdHRlcltrZXldID0gdmFsdWU7IC8vIHNldCB0aGUgZnJvbnRtYXR0ZXIgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHsnbXRpbWUnOiBmaWxlLnN0YXQubXRpbWV9KTsgLy8gZG8gbm90IGNoYW5nZSB0aGUgbW9kaWZ5IHRpbWUuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbHMuZ2V0Q3VycmVudENvbnRlbnQoKTsgLy8gcmV0dXJuIGN1cnJlbnQgY29udGVudC4gRnJvbnRtYXR0ZXIgaXMgYWxyZWFkeSB1cGRhdGVkLlxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKEVSUk9SLCdFcnJvciBvcGVuaW5nIGF1dG9jb21wbGV0ZSBtb2RhbDonLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbHMuZ2V0Q3VycmVudENvbnRlbnQoKSB8fCAnYXV0b2NvbXBsZXRlLm1vZGFsIEVycm9yLiBTZWUgY29uc29sZSBmb3IgZGV0YWlscy4nOyAvLyByZXR1cm4gY3VycmVudCBjb250ZW50IGlmIG5vdCBpbXBsZW1lbnRlZCB5ZXRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbmZpZ1RhYiAob3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOkZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIHRoYXQ6YW55LCBwcmV2aWV3Q29tcG9uZW50OiBhbnkpIHtcclxuICAgICAgICBvcHRpb25FTC5lbXB0eSgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnRGVmYXVsdHMocnVsZS5pZCwge1xyXG4gICAgICAgICAgICBwcm9wZXJ0eURlbGltaXRlcjogJy4nLFxyXG4gICAgICAgIH0pXHJcbiAgICBcclxuICAgICAgICBuZXcgU2V0dGluZyhvcHRpb25FTClcclxuICAgICAgICAuc2V0TmFtZSgnRGVsaW1pdGVyJylcclxuICAgICAgICAuc2V0RGVzYygnQ2hhcmFjdGVyIHRvIGRldGVybWluZSB3aGljaCBwcm9wZXJ0eSBzaG91bGQgYXBwZWFyIGluIHRoZSBtb2RhbCcpXHJcbiAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGF0LmdldE9wdGlvbkNvbmZpZyhydWxlLmlkICwncHJvcGVydHlEZWxpbWl0ZXInKSB8fCAnLicpXHJcbiAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQsJ3Byb3BlcnR5RGVsaW1pdGVyJywgdmFsdWUpO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICB9O1xyXG59IiwgIlxyXG5pbXBvcnQgeyBBcHAsIE1vZGFsLCBTZXR0aW5nLCBUQWJzdHJhY3RGaWxlLCBURmlsZSwgVEZvbGRlciwgVmF1bHQsIHNldEljb24sQnV0dG9uQ29tcG9uZW50LCBUZXh0Q29tcG9uZW50LCBDb25zdHJ1Y3RvciB9IGZyb20gJ29ic2lkaWFuJzsgLy8gQWRkZWQgc2V0SWNvblxyXG5pbXBvcnQgeyBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCBPYnNpZGlhblByb3BlcnR5VHlwZXMsIFByb3BlcnR5SW5mbyB9IGZyb20gJy4vdHlwZXMnO1xyXG5pbXBvcnQgeyBTY3JpcHRpbmdUb29scyB9IGZyb20gJy4vdG9vbHMnO1xyXG5pbXBvcnQgeyByZW5kZXJWYWx1ZUlucHV0LCB1cGRhdGVQcm9wZXJ0eUljb24gfSBmcm9tICcuL3VpRWxlbWVudHMnOyAvLyBJbXBvcnQgdGhlIGZ1bmN0aW9uIHRvIHJlbmRlciB2YWx1ZSBpbnB1dFxyXG5pbXBvcnQgeyBERUJVRywgRVJST1IsIGxvZ2dlciB9IGZyb20gJy4vTG9nJztcclxuXHJcblxyXG4vLyBEZWZpbmUgdGhlIHJlc3VsdCBzdHJ1Y3R1cmUgcmV0dXJuZWQgYnkgdGhlIG1vZGFsXHJcbmV4cG9ydCBpbnRlcmZhY2UgYXV0b2NvbXBsZXRlTW9kYWxSZXN1bHQge1xyXG4gICAgdmFsdWVzOiB7fTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE9ic2lkaWFuIE1vZGFsIGZvciBzZWxlY3RpbmcgZGlyZWN0b3JpZXMgYW5kIGZpbGVzIGZyb20gdGhlIHZhdWx0IHN0cnVjdHVyZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBBdXRvY29tcGxldGVNb2RhbCBleHRlbmRzIE1vZGFsIHtcclxuXHJcbiAgICBcclxuICAgIHByaXZhdGUgcmVzb2x2ZVByb21pc2UhOiAocmVzdWx0OiBhdXRvY29tcGxldGVNb2RhbFJlc3VsdCB8IG51bGwpID0+IHZvaWQ7XHJcbiAgICBwcml2YXRlIHByb21pc2U6IFByb21pc2U8YXV0b2NvbXBsZXRlTW9kYWxSZXN1bHQgfCBudWxsPjtcclxuXHJcbiAgICAvLyBJbml0aWFsIHN0YXRlIHBhc3NlZCB0byB0aGUgbW9kYWwgKHN0b3JlZCBmb3IgcmVzZXQgZnVuY3Rpb25hbGl0eSlcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgb2tDYWxsYmFjayE6IChyZXN1bHQ6IGF1dG9jb21wbGV0ZU1vZGFsUmVzdWx0IHwgbnVsbCkgPT4gdm9pZDtcclxuICAgIHByaXZhdGUgcGx1Z2luOiBhbnk7XHJcbiAgICBwcml2YXRlIG9wdGlvbnM6IGFueTtcclxuICAgIHByaXZhdGUgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzO1xyXG4gICAgcHJpdmF0ZSBleHBlY3RlZFR5cGU6IE9ic2lkaWFuUHJvcGVydHlUeXBlcztcclxuICAgIHByaXZhdGUgcnVsZTogRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncztcclxuICAgIHByaXZhdGUga25vd25Qcm9wZXJ0aWVzOiBSZWNvcmQ8c3RyaW5nLCBQcm9wZXJ0eUluZm8+ID0ge307XHJcblxyXG4gICAgLy8gQ3VycmVudCBzdGF0ZSBiZWluZyBtb2RpZmllZCB3aXRoaW4gdGhlIG1vZGFsXHJcbiAgICBwcml2YXRlIGFjdGl2ZUZpbGU6IFRGaWxlIHwgVEZvbGRlciB8IHVuZGVmaW5lZFxyXG4gICAgcHJpdmF0ZSBmcm9udG1hdHRlcjogYW55OyAvLyBGcm9udG1hdHRlciBkYXRhIGZvciB0aGUgYWN0aXZlIGZpbGVcclxuXHJcbiAgICAvLyBVSSBFbGVtZW50c1xyXG4gICAgcHJpdmF0ZSBjb250ZW50Um9vdEVsZW1lbnQhOiBIVE1MRWxlbWVudDtcclxuICAgIHByaXZhdGUgZnVuY3Rpb25UZXN0QnV0dG9uITogQnV0dG9uQ29tcG9uZW50O1xyXG4gICAgcHJpdmF0ZSBmdW5jdGlvblJlc3VsdFRleHRDb21wb25lbnQhOiBUZXh0Q29tcG9uZW50IHwgdW5kZWZpbmVkO1xyXG4gICAgcHJpdmF0ZSByZXN1bHQ6IGFueSA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgRGlyZWN0b3J5U2VsZWN0aW9uTW9kYWwuXHJcbiAgICAgKiBAcGFyYW0gYXBwIC0gVGhlIE9ic2lkaWFuIEFwcCBpbnN0YW5jZS5cclxuICAgICAqIEBwYXJhbSBwbHVnaW4gLSBUaGUgcGx1Z2luIGluc3RhbmNlLlxyXG4gICAgICogQHBhcmFtIGV4cGVjdGVkVHlwZSAtIEV4cGVjdGVkIHJldHVybiB0eXBlLlxyXG4gICAgICogQHBhcmFtIGFjdGl2ZUZpbGUgLSBUaGUgY3VycmVudGx5IGFjdGl2ZSBmaWxlIG9yIGZvbGRlci5cclxuICAgICAqIEBwYXJhbSBmcm9udG1hdHRlciAtIEZyb250bWF0dGVyIGRhdGEgZm9yIHRoZSBhY3RpdmUgZmlsZS5cclxuICAgICAqIEBwYXJhbSBva0NhbGxiYWNrIC0gRnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBcIk9LXCIuIFJlY2VpdmVzIHRoZSBzZWxlY3Rpb24gcmVzdWx0LlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBhcHA6IEFwcCxcclxuICAgICAgICBwbHVnaW46IGFueSxcclxuICAgICAgICBydWxlOiBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLFxyXG4gICAgICAgIG9wdGlvbnM6IGFueSxcclxuICAgICAgICBhY3RpdmVGaWxlOiBURmlsZSB8IFRGb2xkZXIgfCB1bmRlZmluZWQsXHJcbiAgICAgICAgZnJvbnRtYXR0ZXI6IGFueSwgICBcclxuICAgICAgICBva0NhbGxiYWNrPzogKHJlc3VsdDogYXV0b2NvbXBsZXRlTW9kYWxSZXN1bHQgfCBudWxsKSA9PiB2b2lkXHJcbiAgICApIHtcclxuICAgICAgICBzdXBlcihhcHApO1xyXG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xyXG4gICAgICAgIC8vIFN0b3JlIGluaXRpYWwgc3RhdGUgZm9yIHJlc2V0XHJcbiAgICAgICAgdGhpcy50b29scz0gbmV3IFNjcmlwdGluZ1Rvb2xzKGFwcCwgdGhpcy5wbHVnaW4sIHRoaXMuZnJvbnRtYXR0ZXIpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRmlsZSA9IGFjdGl2ZUZpbGU7XHJcbiAgICAgICAgdGhpcy5mcm9udG1hdHRlciA9IGZyb250bWF0dGVyOyAvLyBTdG9yZSBmcm9udG1hdHRlciBkYXRhXHJcblxyXG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG4gICAgICAgIHRoaXMucnVsZSA9IHJ1bGU7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9uczsgLy8gU3RvcmUgb3B0aW9ucyBmb3IgdGhlIG1vZGFsXHJcbiAgICAgICAgdGhpcy5leHBlY3RlZFR5cGUgPSBydWxlLnR5cGU7IC8vIEV4cGVjdGVkIHR5cGUgZm9yIHRoZSBtb2RhbFxyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBwcm9taXNlXHJcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKG9rQ2FsbGJhY2spIHRoaXMub2tDYWxsYmFjayA9IG9rQ2FsbGJhY2s7XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgY3VycmVudCBzdGF0ZSBmcm9tIGluaXRpYWwgc3RhdGUgZm9yIGVkaXRpbmdcclxuICAgICAgICB0aGlzLnJlc2V0VG9Jbml0aWFsKCk7IC8vIFVzZSBhIG1ldGhvZCBmb3IgaW5pdGlhbGl6YXRpb24gYW5kIHJlc2V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHN0YXRlIHRvIHRoZSBpbml0aWFsIHN0YXRlIHByb3ZpZGVkIGF0IGNvbnN0cnVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZXNldFRvSW5pdGlhbCgpOiB2b2lkIHtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGUgY3VycmVudCBzZWxlY3Rpb24gc3RhdGUgdG8gZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVzZXRUb0VtcHR5KCk6IHZvaWQge1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIG1vZGFsIGlzIG9wZW5lZC4gQnVpbGRzIHRoZSBVSS5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgb25PcGVuKCkge1xyXG4gICAgICAgIHRoaXMua25vd25Qcm9wZXJ0aWVzID0gYXdhaXQgdGhpcy50b29scy5mZXRjaEtub3duUHJvcGVydGllcyh0aGlzLmFwcCk7IC8vIEluaXRpYWxpemUga25vd24gcHJvcGVydGllc1xyXG4gICAgICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xyXG4gICAgICAgIGlmIChjb250ZW50RWwucGFyZW50RWxlbWVudCkgY29udGVudEVsLnBhcmVudEVsZW1lbnQuc3R5bGUud2lkdGggPSAnOTAwcHgnO1xyXG4gICAgICAgIGNvbnRlbnRFbC5lbXB0eSgpOyAvLyBDbGVhciBwcmV2aW91cyBcclxuICAgICAgICBjb250ZW50RWwuYWRkQ2xhc3MoJ2NvZGVFZGl0b3ItbW9kYWwnKTsgXHJcblxyXG4gICAgICAgIC8vIC0tLSBNb2RhbCBUaXRsZSAtLS1cclxuICAgICAgICBjb250ZW50RWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnUGxlYXNlIGNvbXBsZXRlIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcycgfSk7ICAgIFxyXG4gICAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbCgnYm9keScsIHsgdGV4dDogYEZpbGU6ICR7dGhpcy5hY3RpdmVGaWxlPy5wYXRofWAgfSk7IFxyXG5cclxuICAgICAgICAvLyAtLS0gVHJlZSBDb250YWluZXIgLS0tXHJcbiAgICAgICAgdGhpcy5jb250ZW50Um9vdEVsZW1lbnQgPSBjb250ZW50RWwuY3JlYXRlRGl2KHsgY2xzOiAnY29kZUVkaXRvci1jb250YWluZXInIH0pO1xyXG4gICAgICAgIC8vIEJhc2ljIHN0eWxpbmcgZm9yIHRoZSBzY3JvbGxhYmxlIHRyZWUgYXJlYVxyXG4gICAgICAgIC8vIHRoaXMuZWRpdG9yUm9vdEVsZW1lbnQuc3R5bGUud2lkdGggPSAnNjAwcHgnO1xyXG4gICAgICAgIC8vIHRoaXMuY29udGVudFJvb3RFbGVtZW50LnN0eWxlLmhlaWdodCA9ICc2MDBweCc7XHJcbiAgICAgICAgdGhpcy5jb250ZW50Um9vdEVsZW1lbnQuc3R5bGUub3ZlcmZsb3dZID0gJ2F1dG8nO1xyXG4gICAgICAgIC8vdGhpcy5lZGl0b3JSb290RWxlbWVudC5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkIHZhcigtLWJhY2tncm91bmQtbW9kaWZpZXItYm9yZGVyKSc7XHJcbiAgICAgICAgdGhpcy5jb250ZW50Um9vdEVsZW1lbnQuc3R5bGUucGFkZGluZyA9ICcxMHB4JztcclxuICAgICAgICB0aGlzLmNvbnRlbnRSb290RWxlbWVudC5zdHlsZS5tYXJnaW5Ub3AgPSAnMTBweCc7XHJcbiAgICAgICAgdGhpcy5jb250ZW50Um9vdEVsZW1lbnQuc3R5bGUubWFyZ2luQm90dG9tID0gJzEwcHgnO1xyXG5cclxuXHJcbiAgICAgICAgY29uc3QgcHJvcGVydHlDb250YWluZXJFbCA9IGNvbnRlbnRFbC5jcmVhdGVEaXYoeyBjbHM6IFwiY29kZUVkaXRvci1vcHRpb25zXCIgfSk7XHJcbiAgICAgICAgcHJvcGVydHlDb250YWluZXJFbC5zdHlsZS5mbGV4RGlyZWN0aW9uID0gJ2NvbHVtbic7IC8vIFN0YWNrIGl0ZW1zIHZlcnRpY2FsbHlcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5mcm9udG1hdHRlcikpIHtcclxuICAgICAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKHRoaXMucnVsZS5wcm9wZXJ0eSArIHRoaXMub3B0aW9ucy5wcm9wZXJ0eURlbGltaXRlcikpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJvd0VsID0gcHJvcGVydHlDb250YWluZXJFbC5jcmVhdGVEaXYoeyBjbHM6ICdwcm9wZXJ0eS1zZXR0aW5nLXJvdyBzZXR0aW5nLWl0ZW0nIH0pO1xyXG4gICAgICAgICAgICAgICAgcm93RWwuc3R5bGUud2lkdGggPSAnMTAwJSc7IC8vIEZ1bGwgd2lkdGhcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb250cm9sRWwgPSByb3dFbC5jcmVhdGVEaXYoeyBjbHM6ICdzZXR0aW5nLWl0ZW0tY29udHJvbCcgfSk7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sRWwuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xFbC5zdHlsZS5hbGlnbkl0ZW1zID0gJ2NlbnRlcic7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sRWwuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSAnc3BhY2UtYmV0d2Vlbic7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sRWwuc3R5bGUud2lkdGggPSAnMTAwJSc7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sRWwuc3R5bGUuZ2FwID0gJzBweCc7IC8vIFByZXZlbnQgZ2FwIGZyb20gYmVpbmcgYWRkZWQgdG8gdGhlIGxlZnQgc2lkZVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRDb250YWluZXIgPSBjb250cm9sRWwuY3JlYXRlRGl2KHsgY2xzOiAncHJvcGVydHktbGVmdC1jb250YWluZXInIH0pO1xyXG4gICAgICAgICAgICAgICAgbGVmdENvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xyXG4gICAgICAgICAgICAgICAgbGVmdENvbnRhaW5lci5zdHlsZS5hbGlnbkl0ZW1zID0gJ2NlbnRlcic7XHJcbiAgICAgICAgICAgICAgICBsZWZ0Q29udGFpbmVyLnN0eWxlLm1pbldpZHRoID0gJzI1MHB4JzsgXHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgaWNvbkVsID0gbGVmdENvbnRhaW5lci5jcmVhdGVTcGFuKHsgY2xzOiAncHJvcGVydHktaWNvbiBzZXR0aW5nLWl0ZW0taWNvbicgfSk7XHJcbiAgICAgICAgICAgICAgICBpY29uRWwuc3R5bGUubWFyZ2luUmlnaHQgPSAnOHB4JztcclxuXHJcbiAgICAgICAgICAgICAgICB1cGRhdGVQcm9wZXJ0eUljb24oaWNvbkVsLCB0aGlzLmtub3duUHJvcGVydGllc1trZXldLnR5cGUpOyAvLyBVcGRhdGUgaWNvbiBiYXNlZCBvbiB0eXBlXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWFyY2hDb250YWluZXIgPSBsZWZ0Q29udGFpbmVyLmNyZWF0ZURpdih7IGNsczogJ3Byb3BlcnR5LXNlYXJjaC1jb250YWluZXInIH0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZUlucHV0ID0gbmV3IFRleHRDb21wb25lbnQoc2VhcmNoQ29udGFpbmVyKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShrZXkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdQcm9wZXJ0eSBuYW1lJylcclxuICAgICAgICAgICAgICAgICAgICAuc2V0RGlzYWJsZWQodHJ1ZSk7IC8vIERpc2FibGUgdGhlIGlucHV0IGZpZWxkXHJcbiAgICAgICAgICAgICAgICBuYW1lSW5wdXQuaW5wdXRFbC5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7IC8vIG1ha2UgYm9yZGVyIGludmlzaWJsZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbWlkZGxlQ29udGFpbmVyID0gY29udHJvbEVsLmNyZWF0ZURpdih7IGNsczogJ3Byb3BlcnR5LW1pZGRsZS1jb250YWluZXInIH0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVDb250YWluZXIgPSBtaWRkbGVDb250YWluZXIuY3JlYXRlRGl2KHsgY2xzOiAncHJvcGVydHktdmFsdWUtY29udGFpbmVyJyB9KTtcclxuICAgICAgICAgICAgICAgIHZhbHVlQ29udGFpbmVyLnN0eWxlLndpZHRoID0gJzEwMCUnOyAvLyBGdWxsIHdpZHRoIGZvciB2YWx1ZSBjb250YWluZXJcclxuICAgICAgICAgICAgICAgIGxldCBwcmV2aWV3Q29tcG9uZW50ID0gcmVuZGVyVmFsdWVJbnB1dCh2YWx1ZUNvbnRhaW5lciwgdGhpcy5rbm93blByb3BlcnRpZXNba2V5XSwgdGhpcy5mcm9udG1hdHRlcltrZXldLCB0aGlzLmNoYW5nZUNhbGxiYWNrKTtcclxuXHJcbiAgICAgICAgICAgICAgICBwcmV2aWV3Q29tcG9uZW50LmlucHV0RWwuc3R5bGUud2lkdGggPSAnMTAwJSc7IC8vIE1ha2UgdGhlIGlucHV0IGZpZWxkIHRha2UgZnVsbCB3aWR0aFxyXG4gICAgICAgICAgICAgICAgcHJldmlld0NvbXBvbmVudC5pbnB1dEVsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd0cmFuc3BhcmVudCc7IC8vIG1ha2UgaXQgaW52aXNpYmxlXHJcbiAgICAgICAgICAgICAgICAvLyAtLS0gcmlnaHQgcGFydCAtLS1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGV0ZUJ1dHRvbkNvbnRhaW5lciA9IGNvbnRyb2xFbC5jcmVhdGVEaXYoeyBjbHM6ICdwcm9wZXJ0eS1yaWdodC1jb250YWluZXInIH0pO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlQnV0dG9uQ29udGFpbmVyLnN0eWxlLm1hcmdpbkxlZnQgPSAnYXV0byc7IC8vIFB1c2ggdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIC0tLSBBY3Rpb24gQnV0dG9ucyAtLS1cclxuICAgICAgICB0aGlzLmNyZWF0ZUFjdGlvbkJ1dHRvbnMoY29udGVudEVsKTsgLy8gQ3JlYXRlIE9LIGFuZCBSZXNldCBidXR0b25zXHJcbiAgICB9XHJcblxyXG4gICAgY2hhbmdlQ2FsbGJhY2sgPSAocHJvcGVydHlJbmZvOiBQcm9wZXJ0eUluZm8gfCB1bmRlZmluZWQsIHZhbHVlOmFueSkgPT4ge1xyXG4gICAgICAgIC8vIFNhdmUgdGhlIHJlc3VsdCB0byB0aGUgY3VycmVudCBzdGF0ZVxyXG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcclxuICAgICAgICAgICAgdGhpcy5yZXN1bHRbcHJvcGVydHlJbmZvLm5hbWVdID0gdmFsdWU7IC8vIFVwZGF0ZSB0aGUgcmVzdWx0IHdpdGggdGhlIG5ldyB2YWx1ZVxyXG4gICAgICAgIH1cclxuICAgIH0gICBcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIFwiT0tcIiBhbmQgXCJSZXNldFwiIGJ1dHRvbnMuXHJcbiAgICAgKiBAcGFyYW0gY29udGFpbmVyRWwgLSBUaGUgSFRNTCBlbGVtZW50IHRvIGFwcGVuZCB0aGUgYnV0dG9ucyB0by5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjcmVhdGVBY3Rpb25CdXR0b25zKGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGJ1dHRvbnNFbCA9IGNvbnRhaW5lckVsLmNyZWF0ZURpdih7IGNsczogJ21vZGFsLWJ1dHRvbnMnIH0pO1xyXG4gICAgICAgIGJ1dHRvbnNFbC5zdHlsZS5tYXJnaW5Ub3AgPSAnMTVweCc7XHJcbiAgICAgICAgYnV0dG9uc0VsLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7IC8vIFVzZSBmbGV4IGZvciBhbGlnbm1lbnRcclxuICAgICAgICBidXR0b25zRWwuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSAnZmxleC1lbmQnOyAvLyBBbGlnbiBidXR0b25zIHRvIHRoZSByaWdodFxyXG4gICAgICAgIGJ1dHRvbnNFbC5zdHlsZS5nYXAgPSAnMTBweCc7IC8vIFNwYWNlIGJldHdlZW4gYnV0dG9uc1xyXG5cclxuICAgICAgICAvLyBSZXNldCBCdXR0b24gKFVuZG8gXHUyMUFBXHVGRTBGKVxyXG4gICAgICAgIGNvbnN0IHJlc2V0QnV0dG9uID0gYnV0dG9uc0VsLmNyZWF0ZUVsKCdidXR0b24nKTtcclxuICAgICAgICAvLyBVc2UgT2JzaWRpYW4ncyBzZXRJY29uIGZvciBjb25zaXN0ZW5jeSwgb3IgdXNlIHRleHRcclxuICAgICAgICBzZXRJY29uKHJlc2V0QnV0dG9uLCAncmVzZXQnKTsgLy8gVXNlIGEgc3VpdGFibGUgaWNvbiBsaWtlICdyZXNldCcgb3IgJ3VuZG8nXHJcbiAgICAgICAgcmVzZXRCdXR0b24uYXJpYUxhYmVsID0gJ1Jlc2V0IHNlbGVjdGlvbic7IC8vIEFjY2Vzc2liaWxpdHlcclxuICAgICAgICByZXNldEJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlc2V0VG9Jbml0aWFsKCk7IC8vIFJlc2V0IGludGVybmFsIHN0YXRlXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gQ2xlYXIgQnV0dG9uIChDbGVhciBcdUQ4M0RcdURFQUUpXHJcbiAgICAgICAgY29uc3QgZW1wdHlCdXR0b24gPSBidXR0b25zRWwuY3JlYXRlRWwoJ2J1dHRvbicpO1xyXG4gICAgICAgIC8vIFVzZSBPYnNpZGlhbidzIHNldEljb24gZm9yIGNvbnNpc3RlbmN5LCBvciB1c2UgdGV4dFxyXG4gICAgICAgIHNldEljb24oZW1wdHlCdXR0b24sICdlcmFzZXInKTsgLy8gVXNlIGEgc3VpdGFibGUgaWNvbiBsaWtlICdyZXNldCcgb3IgJ3VuZG8nXHJcbiAgICAgICAgZW1wdHlCdXR0b24uYXJpYUxhYmVsID0gJ0NsZWFyIHNlbGVjdGlvbic7IC8vIEFjY2Vzc2liaWxpdHlcclxuICAgICAgICBlbXB0eUJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlc2V0VG9FbXB0eSgpOyAvLyBDbGVhciBzdGF0ZVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIGNhbmNlbCBCdXR0b25cclxuICAgICAgICBjb25zdCBjYW5jZWxCdXR0b24gPSBidXR0b25zRWwuY3JlYXRlRWwoJ2J1dHRvbicsIHsgdGV4dDogJ0NhbmNlbCcgfSk7XHJcbiAgICAgICAgY2FuY2VsQnV0dG9uLmFyaWFMYWJlbCA9ICdjbG9zZSBhbmQgZGlzY2FyZCBjaGFuZ2VzJzsgLy8gQWNjZXNzaWJpbGl0eVxyXG4gICAgICAgIGNhbmNlbEJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBsb2dnZXIubG9nKERFQlVHLFwiQ2FuY2VsIENsaWNrZWQgLSBSZXR1cm5pbmdcIik7IC8vIERlYnVnIGxvZ1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVQcm9taXNlKG51bGwpOyAvLyBSZXNvbHZlIHRoZSBwcm9taXNlIHdpdGggbnVsbFxyXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gT0sgQnV0dG9uXHJcbiAgICAgICAgY29uc3Qgb2tCdXR0b24gPSBidXR0b25zRWwuY3JlYXRlRWwoJ2J1dHRvbicsIHsgdGV4dDogJ09LJywgY2xzOiAnbW9kLWN0YScgfSk7XHJcbiAgICAgICAgY2FuY2VsQnV0dG9uLmFyaWFMYWJlbCA9ICdjbG9zZSBhbmQgc2F2ZSBjaGFuZ2VzJzsgLy8gQWNjZXNzaWJpbGl0eVxyXG4gICAgICAgIG9rQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZVByb21pc2UoeyB2YWx1ZXM6IHRoaXMucmVzdWx0IH0pOyAvLyBSZXNvbHZlIHRoZSBwcm9taXNlIHdpdGggdGhlIHJlc3VsdFxyXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIG1vZGFsIGlzIGNsb3NlZC4gQ2xlYW5zIHVwIHJlc291cmNlcy5cclxuICAgICAqL1xyXG4gICAgb25DbG9zZSgpIHtcclxuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcclxuICAgICAgICBjb250ZW50RWwuZW1wdHkoKTsgLy8gQ2xlYXIgdGhlIG1vZGFsJ3MgY29udGVudFxyXG4gICAgfVxyXG5cclxuICAgIG9wZW5BbmRHZXRWYWx1ZXMoKTogUHJvbWlzZTxhdXRvY29tcGxldGVNb2RhbFJlc3VsdCB8IG51bGw+IHtcclxuICAgICAgICB0aGlzLm9wZW4oKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlOyAvLyBSZXR1cm4gdGhlIHByb21pc2VcclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBPcGVucyBhbiBhdXRvY29tcGxldGUgbW9kYWwgZm9yIHNlbGVjdGluZyBvciBlbnRlcmluZyB2YWx1ZXMgYmFzZWQgb24gdGhlIHByb3ZpZGVkIHBhcmFtZXRlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcHAgLSBUaGUgT2JzaWRpYW4gYXBwbGljYXRpb24gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBwbHVnaW4gLSBUaGUgcGx1Z2luIGluc3RhbmNlIHRoYXQgaXMgaW52b2tpbmcgdGhlIG1vZGFsLlxyXG4gKiBAcGFyYW0gcnVsZSAtIFRoZSBmb2xkZXItdG8tdGFnIHJ1bGUgZGVmaW5pdGlvbiB0byBiZSB1c2VkIGluIHRoZSBtb2RhbC5cclxuICogQHBhcmFtIGFjdGl2ZUZpbGUgLSBUaGUgY3VycmVudGx5IGFjdGl2ZSBmaWxlIG9yIGZvbGRlciwgaWYgYW55LlxyXG4gKiBAcGFyYW0gZnJvbnRtYXR0ZXIgLSBUaGUgZnJvbnRtYXR0ZXIgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGFjdGl2ZSBmaWxlLlxyXG4gKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcmVzdWx0IG9mIHRoZSBhdXRvY29tcGxldGUgbW9kYWwsIG9yIGBudWxsYCBpZiBubyBzZWxlY3Rpb24gd2FzIG1hZGUuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gb3BlbkF1dG9jb21wbGV0ZU1vZGFsKFxyXG4gICAgYXBwOiBBcHAgfCB1bmRlZmluZWQsXHJcbiAgICBwbHVnaW46IGFueSxcclxuICAgIHJ1bGU6IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsXHJcbiAgICBvcHRpb25zOiBhbnksXHJcbiAgICBhY3RpdmVGaWxlOiBURmlsZSB8IFRGb2xkZXIgfCB1bmRlZmluZWQsXHJcbiAgICBmcm9udG1hdHRlcjogYW55XHJcbik6IFByb21pc2U8YXV0b2NvbXBsZXRlTW9kYWxSZXN1bHQgfCBudWxsPiB7XHJcbiAgICAvLyBDcmVhdGUgYW5kIG9wZW4gdGhlIG1vZGFsIGluc3RhbmNlXHJcbiAgICBpZiAoIWFwcCkge1xyXG4gICAgICAgIGxvZ2dlci5sb2coRVJST1IsXCJBcHAgaXMgdW5kZWZpbmVkXCIpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbW9kYWwgPSBuZXcgQXV0b2NvbXBsZXRlTW9kYWwoYXBwLCBwbHVnaW4sIHJ1bGUsIG9wdGlvbnMsIGFjdGl2ZUZpbGUsIGZyb250bWF0dGVyKTtcclxuICAgIHJldHVybiBhd2FpdCBtb2RhbC5vcGVuQW5kR2V0VmFsdWVzKCk7IC8vIFdhaXQgZm9yIHRoZSBwcm9taXNlIHRvIHJlc29sdmVcclxufVxyXG4iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgUHJvcGVydHlUeXBlSW5mbyB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5pbXBvcnQgeyBBcHAsIEV4dHJhQnV0dG9uQ29tcG9uZW50LCBTZXR0aW5nLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgeyBkZWxpbWl0ZXIgfSBmcm9tIFwicGF0aFwiO1xyXG5pbXBvcnQgeyBNdWx0aVByb3BlcnR5U2V0dGluZyB9IGZyb20gXCIuLi91aU11bHRpUHJvcGVydHlTZXR0aW5nXCI7XHJcblxyXG4vKipcclxuICogUnVsZUJ1aWxkSW5Db25jYXRBcnJheXMgaXMgYSBidWlsdC1pbiBydWxlIGZvciBjb25jYXRlbmF0aW5nIG11bHRpcGxlIGZyb250bWF0dGVyIGFycmF5IHByb3BlcnRpZXNcclxuICogKHN1Y2ggYXMgdGV4dCwgdGFncywgYWxpYXNlcywgb3IgbXVsdGl0ZXh0KSBmcm9tIGEgZmlsZSBpbiBPYnNpZGlhbi4gSXQgYWxsb3dzIHVzZXJzIHRvIHNlbGVjdFxyXG4gKiB3aGljaCBwcm9wZXJ0aWVzIHRvIGNvbmNhdGVuYXRlIGFuZCBvcHRpb25hbGx5IHJlcXVpcmVzIHRoYXQgYWxsIHNlbGVjdGVkIHByb3BlcnRpZXMgZXhpc3QgYW5kIGFyZSBub24tZW1wdHkuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIC0gVGhlIHJ1bGUgY2FuIGJlIGNvbmZpZ3VyZWQgdmlhIGEgc2V0dGluZ3MgdGFiLCBhbGxvd2luZyB1c2VycyB0byBzZWxlY3QgaW5wdXQgcHJvcGVydGllcyBhbmQgdG9nZ2xlXHJcbiAqICAgd2hldGhlciBhbGwgcHJvcGVydGllcyBtdXN0IGV4aXN0IGZvciB0aGUgcnVsZSB0byByZXR1cm4gYSB2YWx1ZS5cclxuICogLSBUaGUgY29uY2F0ZW5hdGlvbiBjYW4gYmUgY3VzdG9taXplZCB3aXRoIGEgZGVsaW1pdGVyLlxyXG4gKiAtIFRoZSBydWxlIGlzIGRlc2lnbmVkIHRvIHdvcmsgd2l0aCBwcm9wZXJ0aWVzIG9mIHR5cGUgJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgb3IgJ211bHRpdGV4dCcuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIFVzYWdlIGluIGEgcnVsZSBjb25maWd1cmF0aW9uOlxyXG4gKiB7XHJcbiAqICAgaWQ6ICdjb25jYXRBcnJheXMnLFxyXG4gKiAgIGlucHV0UHJvcGVydGllczogWyd0YWdzJywgJ2FsaWFzZXMnXSxcclxuICogICBvbmx5V2hlbkFsbFByb3BlcnRpZXNFeGlzdDogdHJ1ZVxyXG4gKiB9XHJcbiAqXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVCdWlsZEluQ29uY2F0QXJyYXlzIGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5pZCA9ICdjb25jYXRBcnJheXMnO1xyXG4gICAgdGhpcy5ydWxlVHlwZSA9ICdidWlsZEluJztcclxuICAgIHRoaXMubmFtZSA9ICdDb25jYXQgQXJyYXlzJztcclxuICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnQ29uY2F0ZW5hdGVzIG11bHRpcGxlIExpc3RzIChNdWx0aXRleHQsIFRhZ3MsIEFsaWFzZXMpLic7XHJcbiAgICB0aGlzLnNvdXJjZSA9IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBjb25zdCBwcm9wZXJ0eUlkcyA9IHRvb2xzLmdldE9wdGlvbkNvbmZpZyh0b29scy5nZXRSdWxlKCk/LmlkLCdpbnB1dFByb3BlcnRpZXMnKTtcXG4gIGlmICghQXJyYXkuaXNBcnJheShwcm9wZXJ0eUlkcykgfHwgcHJvcGVydHlJZHMubGVuZ3RoID09PSAwKSB7XFxuICAgIHJldHVybiAnTm8gcHJvcGVydGllcyBzZWxlY3RlZCc7XFxuICB9XFxuICBjb25zdCBkZWxpbWl0ZXIgPSB0b29scy5nZXRPcHRpb25Db25maWcodG9vbHMuZ2V0UnVsZSgpPy5pZCwnZGVsaW1pdGVyJyk7XFxuICBjb25zdCBvbmx5V2hlbkFsbFByb3BlcnRpZXNFeGlzdCA9IHRvb2xzLmdldE9wdGlvbkNvbmZpZyh0b29scy5nZXRSdWxlKCk/LmlkLCAnb25seVdoZW5BbGxQcm9wZXJ0aWVzRXhpc3QnKSB8fCBmYWxzZTtcXG4gIGlmIChvbmx5V2hlbkFsbFByb3BlcnRpZXNFeGlzdCkge1xcbiAgICAvLyBDaGVjayBpZiBhbGwgcHJvcGVydGllcyBleGlzdFxcbiAgICBjb25zdCBhbGxFeGlzdCA9IHByb3BlcnR5SWRzLmV2ZXJ5KGlkID0+IHsgXFxuICAgICAgaWYgKGlkID09PSB1bmRlZmluZWQgfHwgaWQgPT09IG51bGwgfHwgaWQgPT09ICcnKSB7XFxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gU2tpcCBlbXB0eSBvciB1bmRlZmluZWQgcHJvcGVydHkgSURzXFxuICAgICAgfVxcbiAgICAgIGNvbnN0IHByb3BlcnR5VmFsdWUgPSB0b29scy5nZXRGcm9udG1hdHRlclByb3BlcnR5KGlkKTtcXG4gICAgICBjb25zdCByZXN1bHQgPSBwcm9wZXJ0eVZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcGVydHlWYWx1ZSAhPT0gbnVsbCAmJiBwcm9wZXJ0eVZhbHVlICE9PSAnJztcXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9KTtcXG4gICAgaWYgKCFhbGxFeGlzdCkge1xcbiAgICAgIHJldHVybiAnJztcXG4gICAgfVxcbiAgfVxcbiAgY29uc3QgcmVzdWx0ID0gcHJvcGVydHlJZHMubWFwKGlkID0+IHtcXG4gICAgbGV0IHZhbHVlID0gdG9vbHMuZ2V0RnJvbnRtYXR0ZXJQcm9wZXJ0eShpZCk7XFxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAnJykge1xcbiAgICAgIHJldHVybiAnJzsgLy8gU2tpcCBlbXB0eSBvciB1bmRlZmluZWQgcHJvcGVydGllc1xcbiAgICB9XFxuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xcbiAgfSkuZmlsdGVyKHJlcyA9PiByZXMgIT09IHVuZGVmaW5lZCkuam9pbihkZWxpbWl0ZXIpO1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1wiO1xyXG4gICAgdGhpcy50eXBlID0gWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXTtcclxuICAgIHRoaXMuY29uZmlnRWxlbWVudHMgPSB0aGlzLmRlZmF1bHRDb25maWdFbGVtZW50cyh7fSk7XHJcbiAgfVxyXG4gIFxyXG4gIGZ4IChhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogVEZpbGUsIHRvb2xzOiBTY3JpcHRpbmdUb29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgIGNvbnN0IHByb3BlcnR5SWRzID0gdG9vbHMuZ2V0T3B0aW9uQ29uZmlnKHRvb2xzLmdldFJ1bGUoKT8uaWQsJ2lucHV0UHJvcGVydGllcycpO1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BlcnR5SWRzKSB8fCBwcm9wZXJ0eUlkcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuICdObyBwcm9wZXJ0aWVzIHNlbGVjdGVkJztcclxuICAgIH1cclxuICAgIGNvbnN0IG9ubHlXaGVuQWxsUHJvcGVydGllc0V4aXN0ID0gdG9vbHMuZ2V0T3B0aW9uQ29uZmlnKHRvb2xzLmdldFJ1bGUoKT8uaWQsICdvbmx5V2hlbkFsbFByb3BlcnRpZXNFeGlzdCcpIHx8IGZhbHNlO1xyXG4gICAgaWYgKG9ubHlXaGVuQWxsUHJvcGVydGllc0V4aXN0KSB7XHJcbiAgICAgIC8vIENoZWNrIGlmIGFsbCBwcm9wZXJ0aWVzIGV4aXN0XHJcbiAgICAgIGNvbnN0IGFsbEV4aXN0ID0gcHJvcGVydHlJZHMuZXZlcnkoaWQgPT4geyBcclxuICAgICAgICBpZiAoaWQgPT09IHVuZGVmaW5lZCB8fCBpZCA9PT0gbnVsbCB8fCBpZCA9PT0gJycpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBTa2lwIGVtcHR5IG9yIHVuZGVmaW5lZCBwcm9wZXJ0eSBJRHNcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcHJvcGVydHlWYWx1ZSA9IHRvb2xzLmdldEZyb250bWF0dGVyUHJvcGVydHkoaWQpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHByb3BlcnR5VmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wZXJ0eVZhbHVlICE9PSBudWxsICYmIHByb3BlcnR5VmFsdWUgIT09ICcnO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoIWFsbEV4aXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHJlc3VsdEFycmF5OiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgcHJvcGVydHlJZHMuZm9yRWFjaChpZCA9PiB7XHJcbiAgICAgIGxldCB2YWx1ZSA9IHRvb2xzLmdldEZyb250bWF0dGVyUHJvcGVydHkoaWQpO1xyXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gJycpIHtcclxuICAgICAgICByZXR1cm47IC8vIFNraXAgZW1wdHkgb3IgdW5kZWZpbmVkIHByb3BlcnRpZXNcclxuICAgICAgfVxyXG4gICAgICByZXN1bHRBcnJheSA9IHJlc3VsdEFycmF5LmNvbmNhdChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlLnRvU3RyaW5nKCldKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdEFycmF5O1xyXG4gIH1cclxuXHJcbiAgY29uZmlnVGFiKG9wdGlvbkVMOiBIVE1MRWxlbWVudCwgcnVsZTogRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDogYW55LCBwcmV2aWV3Q29tcG9uZW50OiBhbnkpIHtcclxuICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnRGVmYXVsdHMocnVsZS5pZCwge1xyXG4gICAgICAgIGlucHV0UHJvcGVydGllczogW10sXHJcbiAgICAgICAgb25seVdoZW5BbGxQcm9wZXJ0aWVzRXhpc3Q6IGZhbHNlLCAvLyBEZWZhdWx0IHRvIGZhbHNlXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgY29uc3QgbXVsdGlQcm9wID0gbmV3IE11bHRpUHJvcGVydHlTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAuc2V0TmFtZShcIklucHV0IFByb3BlcnRpZXNcIilcclxuICAgICAgLnNldERlc2MoXCJTZWxlY3QgcHJvcGVydGllcyBhcyBpbnB1dC4gKHRleHQsIHRhZ3MsIGFsaWFzZXMgb3IgbXVsdGl0ZXh0KVwiKVxyXG4gICAgICAuc2V0T3B0aW9ucyhPYmplY3Qua2V5cyh0aGF0Lmtub3duUHJvcGVydGllcykubWFwKChrZXkpID0+IHtcclxuICAgICAgICBjb25zdCBwcm9wID0gdGhhdC5rbm93blByb3BlcnRpZXNba2V5XTtcclxuICAgICAgICBpZiAocHJvcC50eXBlID09PSAndGV4dCcgfHwgcHJvcC50eXBlID09PSAndGFncycgfHwgcHJvcC50eXBlID09PSAnYWxpYXNlcycgfHwgcHJvcC50eXBlID09PSAnbXVsdGl0ZXh0Jykge1xyXG4gICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIEZpbHRlciBvdXQgdW5zdXBwb3J0ZWQgdHlwZXNcclxuICAgICAgfSkuZmlsdGVyKChpdGVtKTogaXRlbSBpcyBzdHJpbmcgPT4gaXRlbSAhPT0gbnVsbCkpXHJcbiAgICAgIC5zZXRWYWx1ZSh0aGF0LmdldE9wdGlvbkNvbmZpZyhydWxlLmlkLCAnaW5wdXRQcm9wZXJ0aWVzJykgfHwgW10pXHJcbiAgICAgIC5vbkNoYW5nZSgoYXJyKSA9PiB7XHJcbiAgICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZyhydWxlLmlkLCAnaW5wdXRQcm9wZXJ0aWVzJywgYXJyKTtcclxuICAgICAgICAgIHRoYXQudXBkYXRlUHJldmlldyhydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgfSk7XHJcbiAgICBcclxuICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgIC5zZXROYW1lKCdPbmx5IHdoZW4gYWxsIHByb3BlcnRpZXMgZXhpc3QnKVxyXG4gICAgICAgIC5zZXREZXNjKCdJZiBlbmFibGVkLCB0aGUgcnVsZSB3aWxsIG9ubHkgcmV0dXJuIGEgdmFsdWUgaWYgYWxsIHNlbGVjdGVkIHByb3BlcnRpZXMgZXhpc3QgYW5kIG5vdCBlbXB0eS4nKVxyXG4gICAgICAgIC5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxyXG4gICAgICAgICAgICAuc2V0VmFsdWUodGhhdC5nZXRPcHRpb25Db25maWcocnVsZS5pZCwgJ29ubHlXaGVuQWxsUHJvcGVydGllc0V4aXN0JykpXHJcbiAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQsICdvbmx5V2hlbkFsbFByb3BlcnRpZXNFeGlzdCcsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHRoYXQudXBkYXRlUHJldmlldyhydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICApO1xyXG4gIH07XHJcbn0iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgUHJvcGVydHlUeXBlSW5mbyB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5pbXBvcnQgeyBBcHAsIEV4dHJhQnV0dG9uQ29tcG9uZW50LCBTZXR0aW5nLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgeyBkZWxpbWl0ZXIgfSBmcm9tIFwicGF0aFwiO1xyXG5pbXBvcnQgeyBNdWx0aVByb3BlcnR5U2V0dGluZyB9IGZyb20gXCIuLi91aU11bHRpUHJvcGVydHlTZXR0aW5nXCI7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGJ1aWx0LWluIHJ1bGUgZm9yIHJldHJpZXZpbmcgYSBwcm9wZXJ0eSB2YWx1ZSBmcm9tIHRoZSBmcm9udG1hdHRlciBvZiBhIGZpbGUuXHJcbiAqIFxyXG4gKiBUaGlzIHJ1bGUgYWxsb3dzIHVzZXJzIHRvIHNlbGVjdCBhIHByb3BlcnR5IChzdWNoIGFzIHRleHQsIHRhZ3MsIGFsaWFzZXMsIG9yIG11bHRpdGV4dCkgYW5kIHJldHJpZXZlIGl0cyB2YWx1ZVxyXG4gKiBmcm9tIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZmlsZSdzIGZyb250bWF0dGVyLiBUaGUgcnVsZSBwcm92aWRlcyBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHNlbGVjdGluZyB0aGUgcHJvcGVydHksXHJcbiAqIGFuZCBleHBvc2VzIGEgZnVuY3Rpb24gKGBmeGApIHRoYXQgcGVyZm9ybXMgdGhlIHJldHJpZXZhbC5cclxuICogXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICogXHJcbiAqIEByZW1hcmtzXHJcbiAqIC0gVGhlIHJ1bGUgaXMgaWRlbnRpZmllZCBieSB0aGUgSUQgJ2dldFByb3BlcnR5JyBhbmQgaXMgY2F0ZWdvcml6ZWQgYXMgYSBidWlsdC1pbiBydWxlLlxyXG4gKiAtIFRoZSBjb25maWd1cmF0aW9uIHRhYiBhbGxvd3MgdXNlcnMgdG8gc2VsZWN0IHdoaWNoIHByb3BlcnR5IHRvIHJldHJpZXZlLlxyXG4gKiAtIFRoZSBgZnhgIG1ldGhvZCBpcyB0aGUgbWFpbiBsb2dpYyBmb3IgZXh0cmFjdGluZyB0aGUgcHJvcGVydHkgdmFsdWUuXHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBVc2FnZSB3aXRoaW4gdGhlIHBsdWdpbidzIHJ1bGUgc3lzdGVtOlxyXG4gKiBjb25zdCBydWxlID0gbmV3IFJ1bGVCdWlsZEluR2V0UHJvcGVydHkoKTtcclxuICogY29uc3QgdmFsdWUgPSBydWxlLmZ4KGFwcCwgZmlsZSwgdG9vbHMpO1xyXG4gKiBcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcnVsZSAoJ2dldFByb3BlcnR5JykuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBydWxlVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBydWxlICgnYnVpbGRJbicpLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXNjcmlwdGlvbiAtIEEgYnJpZWYgZGVzY3JpcHRpb24gb2YgdGhlIHJ1bGUncyBwdXJwb3NlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSB0eXBlIC0gVGhlIHR5cGVzIG9mIHByb3BlcnRpZXMgdGhpcyBydWxlIGNhbiBoYW5kbGUuXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGZ4IC0gVGhlIGZ1bmN0aW9uIHRoYXQgcmV0cmlldmVzIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gY29uZmlnVGFiIC0gVGhlIGZ1bmN0aW9uIHRoYXQgcmVuZGVycyB0aGUgY29uZmlndXJhdGlvbiBVSSBmb3IgdGhlIHJ1bGUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZUJ1aWxkSW5Db25jYXRQcm9wZXJ0aWVzIGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5pZCA9ICdjb25jYXRQcm9wZXJ0aWVzJztcclxuICAgIHRoaXMucnVsZVR5cGUgPSAnYnVpbGRJbic7XHJcbiAgICB0aGlzLm5hbWUgPSAnQ29uY2F0IFByb3BlcnRpZXMnO1xyXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdDb25jYXRlbmF0ZXMgbXVsdGlwbGUgcHJvcGVydGllcyBmcm9tIHRoZSBmcm9udG1hdHRlci4nO1xyXG4gICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgY29uc3QgcHJvcGVydHlJZHMgPSB0b29scy5nZXRPcHRpb25Db25maWcodG9vbHMuZ2V0UnVsZSgpPy5pZCwnaW5wdXRQcm9wZXJ0aWVzJyk7XFxuICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcGVydHlJZHMpIHx8IHByb3BlcnR5SWRzLmxlbmd0aCA9PT0gMCkge1xcbiAgICByZXR1cm4gJ05vIHByb3BlcnRpZXMgc2VsZWN0ZWQnO1xcbiAgfVxcbiAgY29uc3QgZGVsaW1pdGVyID0gdG9vbHMuZ2V0T3B0aW9uQ29uZmlnKHRvb2xzLmdldFJ1bGUoKT8uaWQsJ2RlbGltaXRlcicpO1xcbiAgY29uc3Qgb25seVdoZW5BbGxQcm9wZXJ0aWVzRXhpc3QgPSB0b29scy5nZXRPcHRpb25Db25maWcodG9vbHMuZ2V0UnVsZSgpPy5pZCwgJ29ubHlXaGVuQWxsUHJvcGVydGllc0V4aXN0JykgfHwgZmFsc2U7XFxuICBpZiAob25seVdoZW5BbGxQcm9wZXJ0aWVzRXhpc3QpIHtcXG4gICAgLy8gQ2hlY2sgaWYgYWxsIHByb3BlcnRpZXMgZXhpc3RcXG4gICAgY29uc3QgYWxsRXhpc3QgPSBwcm9wZXJ0eUlkcy5ldmVyeShpZCA9PiB7IFxcbiAgICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkIHx8IGlkID09PSBudWxsIHx8IGlkID09PSAnJykge1xcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIFNraXAgZW1wdHkgb3IgdW5kZWZpbmVkIHByb3BlcnR5IElEc1xcbiAgICAgIH1cXG4gICAgICBjb25zdCBwcm9wZXJ0eVZhbHVlID0gdG9vbHMuZ2V0RnJvbnRtYXR0ZXJQcm9wZXJ0eShpZCk7XFxuICAgICAgY29uc3QgcmVzdWx0ID0gcHJvcGVydHlWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BlcnR5VmFsdWUgIT09IG51bGwgJiYgcHJvcGVydHlWYWx1ZSAhPT0gJyc7XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfSk7XFxuICAgIGlmICghYWxsRXhpc3QpIHtcXG4gICAgICByZXR1cm4gJyc7XFxuICAgIH1cXG4gIH1cXG4gIGNvbnN0IHJlc3VsdCA9IHByb3BlcnR5SWRzLm1hcChpZCA9PiB7XFxuICAgIGxldCB2YWx1ZSA9IHRvb2xzLmdldEZyb250bWF0dGVyUHJvcGVydHkoaWQpO1xcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gJycpIHtcXG4gICAgICByZXR1cm4gJyc7IC8vIFNraXAgZW1wdHkgb3IgdW5kZWZpbmVkIHByb3BlcnRpZXNcXG4gICAgfVxcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcXG4gIH0pLmZpbHRlcihyZXMgPT4gcmVzICE9PSB1bmRlZmluZWQpLmpvaW4oZGVsaW1pdGVyKTtcXG4gIHJldHVybiByZXN1bHQ7XFxufTtcIjtcclxuICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gIH1cclxuICBcclxuICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICBjb25zdCBwcm9wZXJ0eUlkcyA9IHRvb2xzLmdldE9wdGlvbkNvbmZpZyh0b29scy5nZXRSdWxlKCk/LmlkLCdpbnB1dFByb3BlcnRpZXMnKTtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wZXJ0eUlkcykgfHwgcHJvcGVydHlJZHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiAnTm8gcHJvcGVydGllcyBzZWxlY3RlZCc7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkZWxpbWl0ZXIgPSB0b29scy5nZXRPcHRpb25Db25maWcodG9vbHMuZ2V0UnVsZSgpPy5pZCwnZGVsaW1pdGVyJyk7XHJcbiAgICBjb25zdCBvbmx5V2hlbkFsbFByb3BlcnRpZXNFeGlzdCA9IHRvb2xzLmdldE9wdGlvbkNvbmZpZyh0b29scy5nZXRSdWxlKCk/LmlkLCAnb25seVdoZW5BbGxQcm9wZXJ0aWVzRXhpc3QnKSB8fCBmYWxzZTtcclxuICAgIGlmIChvbmx5V2hlbkFsbFByb3BlcnRpZXNFeGlzdCkge1xyXG4gICAgICAvLyBDaGVjayBpZiBhbGwgcHJvcGVydGllcyBleGlzdFxyXG4gICAgICBjb25zdCBhbGxFeGlzdCA9IHByb3BlcnR5SWRzLmV2ZXJ5KGlkID0+IHsgXHJcbiAgICAgICAgaWYgKGlkID09PSB1bmRlZmluZWQgfHwgaWQgPT09IG51bGwgfHwgaWQgPT09ICcnKSB7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gU2tpcCBlbXB0eSBvciB1bmRlZmluZWQgcHJvcGVydHkgSURzXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHByb3BlcnR5VmFsdWUgPSB0b29scy5nZXRGcm9udG1hdHRlclByb3BlcnR5KGlkKTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBwcm9wZXJ0eVZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcGVydHlWYWx1ZSAhPT0gbnVsbCAmJiBwcm9wZXJ0eVZhbHVlICE9PSAnJztcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9KTtcclxuICAgICAgaWYgKCFhbGxFeGlzdCkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgcmVzdWx0ID0gcHJvcGVydHlJZHMubWFwKGlkID0+IHtcclxuICAgICAgbGV0IHZhbHVlID0gdG9vbHMuZ2V0RnJvbnRtYXR0ZXJQcm9wZXJ0eShpZCk7XHJcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAnJykge1xyXG4gICAgICAgIHJldHVybiAnJzsgLy8gU2tpcCBlbXB0eSBvciB1bmRlZmluZWQgcHJvcGVydGllc1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xyXG4gICAgfSkuZmlsdGVyKHJlcyA9PiByZXMgIT09IHVuZGVmaW5lZCkuam9pbihkZWxpbWl0ZXIpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIGNvbmZpZ1RhYihvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIHRoYXQ6IGFueSwgcHJldmlld0NvbXBvbmVudDogYW55KSB7XHJcbiAgICB0aGF0LnNldE9wdGlvbkNvbmZpZ0RlZmF1bHRzKHJ1bGUuaWQsIHtcclxuICAgICAgICBkZWxpbWl0ZXI6ICcgJywgLy8gRGVmYXVsdCBkZWxpbWl0ZXIgZm9yIGNvbmNhdGVuYXRpb25cclxuICAgICAgICBpbnB1dFByb3BlcnRpZXM6IFtdLFxyXG4gICAgICAgIG9ubHlXaGVuQWxsUHJvcGVydGllc0V4aXN0OiB0cnVlLCAvLyBEZWZhdWx0IHRvIGZhbHNlXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgY29uc3QgbXVsdGlQcm9wID0gbmV3IE11bHRpUHJvcGVydHlTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAuc2V0TmFtZShcIklucHV0IFByb3BlcnRpZXNcIilcclxuICAgICAgLnNldERlc2MoXCJTZWxlY3QgcHJvcGVydGllcyBhcyBpbnB1dC4gVXNlICdTcGFjZSByZXBsYWNlbWVudCcgYXMgZGVsaW1pdGVyLlwiKVxyXG4gICAgICAuc2V0T3B0aW9ucyhPYmplY3Qua2V5cyh0aGF0Lmtub3duUHJvcGVydGllcykubWFwKChrZXkpID0+IGtleSkpXHJcbiAgICAgIC5zZXRWYWx1ZSh0aGF0LmdldE9wdGlvbkNvbmZpZyhydWxlLmlkLCAnaW5wdXRQcm9wZXJ0aWVzJykgfHwgW10pXHJcbiAgICAgIC5vbkNoYW5nZSgoYXJyKSA9PiB7XHJcbiAgICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZyhydWxlLmlkLCAnaW5wdXRQcm9wZXJ0aWVzJywgYXJyKTtcclxuICAgICAgICAgIHRoYXQudXBkYXRlUHJldmlldyhydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgfSk7XHJcbiAgICBcclxuICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgIC5zZXROYW1lKCdEZWxpbWl0ZXInKVxyXG4gICAgICAgIC5zZXREZXNjKCdTcGVjaWZ5IGEgZGVsaW1pdGVyIHRvIHVzZSB3aGVuIGNvbmNhdGVuYXRpbmcgcHJvcGVydGllcy4gRGVmYXVsdCBpcyBhIHNwYWNlLicpXHJcbiAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGF0LmdldE9wdGlvbkNvbmZpZyhydWxlLmlkICwnZGVsaW1pdGVyJykgfHwgJycpXHJcbiAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignRW50ZXIgZGVsaW1pdGVyJylcclxuICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWcocnVsZS5pZCwnZGVsaW1pdGVyJywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC51cGRhdGVQcmV2aWV3KHJ1bGUsIHByZXZpZXdDb21wb25lbnQpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICk7XHJcbiAgICBuZXcgU2V0dGluZyhvcHRpb25FTClcclxuICAgICAgICAuc2V0TmFtZSgnT25seSB3aGVuIGFsbCBwcm9wZXJ0aWVzIGV4aXN0JylcclxuICAgICAgICAuc2V0RGVzYygnSWYgZW5hYmxlZCwgdGhlIHJ1bGUgd2lsbCBvbmx5IHJldHVybiBhIHZhbHVlIGlmIGFsbCBzZWxlY3RlZCBwcm9wZXJ0aWVzIGV4aXN0IGFuZCBub3QgZW1wdHkuJylcclxuICAgICAgICAuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcclxuICAgICAgICAgICAgLnNldFZhbHVlKHRoYXQuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQsICdvbmx5V2hlbkFsbFByb3BlcnRpZXNFeGlzdCcpKVxyXG4gICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZyhydWxlLmlkLCAnb25seVdoZW5BbGxQcm9wZXJ0aWVzRXhpc3QnLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZVByZXZpZXcocnVsZSwgcHJldmlld0NvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgKTtcclxuICB9O1xyXG59IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MgfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuaW1wb3J0IHsgQXBwLCBTZXR0aW5nLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBidWlsdC1pbiBydWxlIHRoYXQgcmV0dXJucyBhIGNvbnN0YW50IHZhbHVlIGluc3RlYWQgb2YgZXh0cmFjdGluZyBhIHZhbHVlIGZyb20gdGhlIGZyb250bWF0dGVyLlxyXG4gKlxyXG4gKiBUaGlzIHJ1bGUgYWxsb3dzIHVzZXJzIHRvIHNwZWNpZnkgYSBjb25zdGFudCB2YWx1ZSB0aGF0IHdpbGwgYWx3YXlzIGJlIHJldHVybmVkIHdoZW4gdGhlIHJ1bGUgaXMgZXhlY3V0ZWQuXHJcbiAqIFRoZSB2YWx1ZSBjYW4gYmUgY29uZmlndXJlZCB2aWEgdGhlIHBsdWdpbidzIHNldHRpbmdzIFVJLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIC0gVGhlIHJ1bGUgdHlwZSBpcyBzZXQgdG8gYCdidWlsZEluJ2AuXHJcbiAqIC0gVGhlIGNvbnN0YW50IHZhbHVlIGlzIGNvbmZpZ3VyZWQgdXNpbmcgdGhlIGBjb25zdGFudFZhbHVlYCBvcHRpb24uXHJcbiAqIC0gVGhlIHJ1bGUgc3VwcG9ydHMgbXVsdGlwbGUgdHlwZXM6IGAndGV4dCdgLCBgJ3RhZ3MnYCwgYCdhbGlhc2VzJ2AsIGFuZCBgJ211bHRpdGV4dCdgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNvbnN0IHJ1bGUgPSBuZXcgUnVsZUJ1aWxkSW5Db25zdGFudCgpO1xyXG4gKiBjb25zdCB2YWx1ZSA9IHJ1bGUuZngoYXBwLCBmaWxlLCB0b29scyk7IC8vIFJldHVybnMgdGhlIGNvbmZpZ3VyZWQgY29uc3RhbnQgdmFsdWVcclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZUJ1aWxkSW5Db25zdGFudCBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlkID0gJ2NvbnN0YW50JztcclxuICAgICAgICB0aGlzLnJ1bGVUeXBlID0gJ2J1aWxkSW4nO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdDb25zdGFudCB2YWx1ZSc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdSZXR1cm5zIGEgY29uc3RhbnQgdmFsdWUgaW5zdGVhZCBvZiB0aGUgZnJvbnRtYXR0ZXIgcGFyYW1ldGVyLic7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgY29uc3QgcmVzdWx0ID0gdG9vbHMuZ2V0T3B0aW9uQ29uZmlnKHRvb2xzLmdldFJ1bGUoKT8uaWQsJ2NvbnN0YW50VmFsdWUnKTtcXG4gIHJldHVybiByZXN1bHQ7IC8vIFJldHVybiB0aGUgY29uc3RhbnQgdmFsdWVcXG59O1wiO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICAgICAgdGhpcy5jb25maWdFbGVtZW50cyA9IHRoaXMuZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KTtcclxuICAgIH1cclxuICAgIGZ4KGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBURmlsZSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRvb2xzLmdldE9wdGlvbkNvbmZpZyh0b29scy5nZXRSdWxlKCk/LmlkLCdjb25zdGFudFZhbHVlJyk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDsgLy8gUmV0dXJuIHRoZSBjb25zdGFudCB2YWx1ZVxyXG4gICAgfTtcclxuICAgIGNvbmZpZ1RhYihvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIHRoYXQ6IGFueSwgcHJldmlld0NvbXBvbmVudDogYW55KSB7XHJcbiAgICAgICAgb3B0aW9uRUwuZW1wdHkoKTtcclxuICAgICAgICAvLyBDcmVhdGUgYSBzZXR0aW5nIGZvciB0aGUgY29uc3RhbnQgdmFsdWVcclxuICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZ0RlZmF1bHRzKHJ1bGUuaWQsIHtcclxuICAgICAgICAgICAgY29uc3RhbnRWYWx1ZTogJycsXHJcbiAgICAgICAgfSlcclxuICAgICAgICAvLyBDcmVhdGUgYSBzZXR0aW5nIGZvciB0aGUgY29uc3RhbnQgdmFsdWVcclxuICAgICAgICBuZXcgU2V0dGluZyhvcHRpb25FTClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ0NvbnN0YW50IHZhbHVlJylcclxuICAgICAgICAgICAgLnNldERlc2MoJ0VudGVyIGEgY29uc3RhbnQgdmFsdWUgdG8gYmUgdXNlZCBpbiB0aGUgcnVsZScpXHJcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoYXQuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQgLCdjb25zdGFudFZhbHVlJykgfHwgJycpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWcocnVsZS5pZCwnY29uc3RhbnRWYWx1ZScsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZVByZXZpZXcocnVsZSwgcHJldmlld0NvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgfTtcclxufSIsICJpbXBvcnQgeyBSdWxlUHJvdG90eXBlLCBydWxlc01hbmFnZXIgfSBmcm9tIFwiLi9ydWxlc1wiO1xyXG5pbXBvcnQgeyBTY3JpcHRpbmdUb29scyB9IGZyb20gXCIuLi90b29sc1wiO1xyXG5pbXBvcnQgeyBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzIH0gZnJvbSBcIi4uL3R5cGVzXCI7XHJcbmltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGJ1aWx0LWluIHJ1bGUgdGhhdCByZXR1cm5zIHRoZSBkYXRlIGFuZCB0aW1lIHdoZW4gYSBmaWxlIHdhcyBjcmVhdGVkLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUaGlzIHJ1bGUgY2FsY3VsYXRlcyB0aGUgZmlsZSBjcmVhdGlvbiBkYXRlIGFuZCB0aW1lLCBhZGp1c3RlZCBmb3IgdGhlIGxvY2FsIHRpbWV6b25lLFxyXG4gKiBhbmQgcmV0dXJucyBpdCBhcyBhbiBJU08gc3RyaW5nIHdpdGhvdXQgdGhlIHRyYWlsaW5nICdaJyAoVVRDIHN5bWJvbCkuXHJcbiAqXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjb25zdCBydWxlID0gbmV3IFJ1bGVCdWlsZEluRGF0ZVRpbWVDcmVhdGVkKCk7XHJcbiAqIGNvbnN0IGNyZWF0ZWREYXRlID0gcnVsZS5meChhcHAsIGZpbGUsIHRvb2xzKTtcclxuICogLy8gY3JlYXRlZERhdGUgd2lsbCBiZSBhIHN0cmluZyBsaWtlIFwiMjAyNC0wNi0wMVQxMjozNDo1Ni43ODlcIlxyXG4gKiBgYGBcclxuICpcclxuICogQHByb3BlcnR5IGlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcnVsZSAoJ2RhdGVUaW1lQ3JlYXRlZCcpLlxyXG4gKiBAcHJvcGVydHkgcnVsZVR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgcnVsZSAoJ2J1aWxkSW4nKS5cclxuICogQHByb3BlcnR5IG5hbWUgLSBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkgZGVzY3JpcHRpb24gLSBBIGRlc2NyaXB0aW9uIG9mIHdoYXQgdGhlIHJ1bGUgZG9lcy5cclxuICogQHByb3BlcnR5IHNvdXJjZSAtIFRoZSBzb3VyY2UgY29kZSBvZiB0aGUgcnVsZSdzIG1haW4gZnVuY3Rpb24gYXMgYSBzdHJpbmcuXHJcbiAqIEBwcm9wZXJ0eSB0eXBlIC0gVGhlIHR5cGVzIG9mIGRhdGEgcmV0dXJuZWQgYnkgdGhlIHJ1bGUgKFsnZGF0ZScsICdkYXRldGltZSddKS5cclxuICogQHByb3BlcnR5IGNvbmZpZ0VsZW1lbnRzIC0gVGhlIGNvbmZpZ3VyYXRpb24gZWxlbWVudHMgZm9yIHRoZSBydWxlLlxyXG4gKlxyXG4gKiBAbWV0aG9kIGZ4IC0gUmV0dXJucyB0aGUgZmlsZSBjcmVhdGlvbiBkYXRlIGFuZCB0aW1lIGFzIGEgbG9jYWwgSVNPIHN0cmluZy5cclxuICogQG1ldGhvZCBjb25maWdUYWIgLSAoT3B0aW9uYWwpIEFkZHMgY29uZmlndXJhdGlvbiBVSSBlbGVtZW50cyBmb3IgdGhlIHJ1bGUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZUJ1aWxkSW5EYXRlVGltZUNyZWF0ZWQgZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9ICdkYXRlVGltZUNyZWF0ZWQnO1xyXG4gICAgICAgIHRoaXMucnVsZVR5cGUgPSAnYnVpbGRJbic7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ0RhdGUgKGFuZCBUaW1lKSBjcmVhdGVkJztcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gJ1RoaXMgcnVsZSByZXR1cm5zIHRoZSBkYXRlIGFuZCB0aW1lIHdoZW4gdGhlIGZpbGUgd2FzIGNyZWF0ZWQsIGFkanVzdGVkIGZvciBsb2NhbCB0aW1lem9uZS4nO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gXCJmdW5jdGlvbihhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogVEZpbGUsIHRvb2xzOiBTY3JpcHRpbmdUb29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSEgXFxuIGNvbnN0IHRpbWVPZmZzZXQgPSBuZXcgRGF0ZShEYXRlLm5vdygpKS5nZXRUaW1lem9uZU9mZnNldCgpKjYwMDAwOyAvLyBnZXQgbG9jYWwgdGltZSBvZmZzZXQgXFxuIGNvbnN0IHJlc3VsdCA9IG5ldyBEYXRlKGZpbGUuc3RhdC5jdGltZS10aW1lT2Zmc2V0KTsgXFxuIHJldHVybiByZXN1bHQudG9JU09TdHJpbmcoKS5zcGxpdCgnWicpWzBdOyAvLyByZW1vdmUgVVRDIHN5bWJvbCBcXG4gfVwiO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFsnZGF0ZScsICdkYXRldGltZSddO1xyXG4gICAgICAgIHRoaXMuY29uZmlnRWxlbWVudHMgPSB0aGlzLmRlZmF1bHRDb25maWdFbGVtZW50cyh7fSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ4IChhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogVEZpbGUsIHRvb2xzOiBTY3JpcHRpbmdUb29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgICAgICBjb25zdCB0aW1lT2Zmc2V0ID0gbmV3IERhdGUoRGF0ZS5ub3coKSkuZ2V0VGltZXpvbmVPZmZzZXQoKSo2MDAwMDsgLy8gZ2V0IGxvY2FsIHRpbWUgb2Zmc2V0XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IERhdGUoZmlsZS5zdGF0LmN0aW1lLXRpbWVPZmZzZXQpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQudG9JU09TdHJpbmcoKS5zcGxpdCgnWicpWzBdOyAvLyByZW1vdmUgVVRDIHN5bWJvbFxyXG4gICAgICB9XHJcblxyXG4gICAgY29uZmlnVGFiIChvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6RnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDphbnksIHByZXZpZXdDb21wb25lbnQ6IGFueSkge1xyXG4gICAgICAgIC8vIENvbmZpZ3VyYXRpb24gdGFiIGxvZ2ljIGNhbiBiZSBhZGRlZCBoZXJlIGlmIG5lZWRlZFxyXG4gICAgfTtcclxuICAgIFxyXG59IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MgfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgYnVpbHQtaW4gcnVsZSB0aGF0IHJldHVybnMgdGhlIGRhdGUgYW5kIHRpbWUgd2hlbiBhIGZpbGUgd2FzIGNyZWF0ZWQuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFRoaXMgcnVsZSBjYWxjdWxhdGVzIHRoZSBmaWxlIGNyZWF0aW9uIGRhdGUgYW5kIHRpbWUsIGFkanVzdGVkIGZvciB0aGUgbG9jYWwgdGltZXpvbmUsXHJcbiAqIGFuZCByZXR1cm5zIGl0IGFzIGFuIElTTyBzdHJpbmcgd2l0aG91dCB0aGUgdHJhaWxpbmcgJ1onIChVVEMgc3ltYm9sKS5cclxuICpcclxuICogQGV4dGVuZHMgUnVsZVByb3RvdHlwZVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNvbnN0IHJ1bGUgPSBuZXcgUnVsZUJ1aWxkSW5EYXRlVGltZUNyZWF0ZWQoKTtcclxuICogY29uc3QgY3JlYXRlZERhdGUgPSBydWxlLmZ4KGFwcCwgZmlsZSwgdG9vbHMpO1xyXG4gKiAvLyBjcmVhdGVkRGF0ZSB3aWxsIGJlIGEgc3RyaW5nIGxpa2UgXCIyMDI0LTA2LTAxVDEyOjM0OjU2Ljc4OVwiXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcHJvcGVydHkgaWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBydWxlICgnZGF0ZVRpbWVDcmVhdGVkJykuXHJcbiAqIEBwcm9wZXJ0eSBydWxlVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBydWxlICgnYnVpbGRJbicpLlxyXG4gKiBAcHJvcGVydHkgbmFtZSAtIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSBkZXNjcmlwdGlvbiAtIEEgZGVzY3JpcHRpb24gb2Ygd2hhdCB0aGUgcnVsZSBkb2VzLlxyXG4gKiBAcHJvcGVydHkgc291cmNlIC0gVGhlIHNvdXJjZSBjb2RlIG9mIHRoZSBydWxlJ3MgbWFpbiBmdW5jdGlvbiBhcyBhIHN0cmluZy5cclxuICogQHByb3BlcnR5IHR5cGUgLSBUaGUgdHlwZXMgb2YgZGF0YSByZXR1cm5lZCBieSB0aGUgcnVsZSAoWydkYXRlJywgJ2RhdGV0aW1lJ10pLlxyXG4gKiBAcHJvcGVydHkgY29uZmlnRWxlbWVudHMgLSBUaGUgY29uZmlndXJhdGlvbiBlbGVtZW50cyBmb3IgdGhlIHJ1bGUuXHJcbiAqXHJcbiAqIEBtZXRob2QgZnggLSBSZXR1cm5zIHRoZSBmaWxlIGNyZWF0aW9uIGRhdGUgYW5kIHRpbWUgYXMgYSBsb2NhbCBJU08gc3RyaW5nLlxyXG4gKiBAbWV0aG9kIGNvbmZpZ1RhYiAtIChPcHRpb25hbCkgQWRkcyBjb25maWd1cmF0aW9uIFVJIGVsZW1lbnRzIGZvciB0aGUgcnVsZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlQnVpbGRJbkRhdGVUaW1lTW9kaWZpZWQgZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9ICdkYXRlVGltZU1vZGlmaWVkJztcclxuICAgICAgICB0aGlzLnJ1bGVUeXBlID0gJ2J1aWxkSW4nO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdEYXRlIChhbmQgVGltZSkgbW9kaWZpZWQnO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnVGhpcyBydWxlIHJldHVybnMgdGhlIGRhdGUgYW5kIHRpbWUgd2hlbiB0aGUgZmlsZSB3YXMgbGFzdCBtb2RpZmllZCwgYWRqdXN0ZWQgZm9yIGxvY2FsIHRpbWV6b25lLic7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBURmlsZSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lISBcXG4gY29uc3QgdGltZU9mZnNldCA9IG5ldyBEYXRlKERhdGUubm93KCkpLmdldFRpbWV6b25lT2Zmc2V0KCkqNjAwMDA7IC8vIGdldCBsb2NhbCB0aW1lIG9mZnNldCBcXG4gY29uc3QgcmVzdWx0ID0gbmV3IERhdGUoZmlsZS5zdGF0Lm10aW1lLXRpbWVPZmZzZXQpOyBcXG4gcmV0dXJuIHJlc3VsdC50b0lTT1N0cmluZygpLnNwbGl0KCdaJylbMF07IC8vIHJlbW92ZSBVVEMgc3ltYm9sIFxcbiB9XCI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gWydkYXRlJywgJ2RhdGV0aW1lJ107XHJcbiAgICAgICAgdGhpcy5jb25maWdFbGVtZW50cyA9IHRoaXMuZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnggKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBURmlsZSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIGNvbnN0IHRpbWVPZmZzZXQgPSBuZXcgRGF0ZShEYXRlLm5vdygpKS5nZXRUaW1lem9uZU9mZnNldCgpKjYwMDAwOyAvLyBnZXQgbG9jYWwgdGltZSBvZmZzZXRcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRGF0ZShmaWxlLnN0YXQubXRpbWUtdGltZU9mZnNldCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC50b0lTT1N0cmluZygpLnNwbGl0KCdaJylbMF07IC8vIHJlbW92ZSBVVEMgc3ltYm9sXHJcbiAgICAgIH1cclxuXHJcbiAgICBjb25maWdUYWIgKG9wdGlvbkVMOiBIVE1MRWxlbWVudCwgcnVsZTpGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCB0aGF0OmFueSwgcHJldmlld0NvbXBvbmVudDogYW55KSB7XHJcbiAgICAgICAgLy8gQ29uZmlndXJhdGlvbiB0YWIgbG9naWMgY2FuIGJlIGFkZGVkIGhlcmUgaWYgbmVlZGVkXHJcbiAgICB9O1xyXG4gICAgXHJcbn0iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGJ1aWx0LWluIHJ1bGUgdGhhdCBwYXNzZXMgdGhlIGNvbnRlbnQgb2YgYSBmcm9udG1hdHRlciBwYXJhbWV0ZXIgdW5hbHRlcmVkLlxyXG4gKiBUaGlzIHJ1bGUgaXMgdXNlZCB0byByZXR1cm4gdGhlIGlucHV0IGNvbnRlbnQgd2l0aG91dCBhbnkgbW9kaWZpY2F0aW9ucy5cclxuICogXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICogXHJcbiAqIEByZW1hcmtzXHJcbiAqIC0gVGhlIGBmeGAgZnVuY3Rpb24gYW5kIGBzb3VyY2VgIHByb3BlcnR5IGFyZSBkZXNpZ25lZCB0byBwcm9jZXNzIHRoZSBpbnB1dCBjb250ZW50IGFuZCByZXR1cm4gaXQgYXMtaXMuXHJcbiAqIC0gVGhpcyBydWxlIHN1cHBvcnRzIG11bHRpcGxlIHR5cGVzIGluY2x1ZGluZyBgdGV4dGAsIGB0YWdzYCwgYGFsaWFzZXNgLCBhbmQgYG11bHRpdGV4dGAuXHJcbiAqIC0gVGhlIGBjb25maWdUYWJgIG1ldGhvZCBpcyBjdXJyZW50bHkgYSBwbGFjZWhvbGRlciBmb3IgY29uZmlndXJhdGlvbiBVSSBlbGVtZW50cy5cclxuICogXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHJ1bGUsIHNldCB0byBgJ2RlZmF1bHQnYC5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJ1bGVUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIHJ1bGUsIHNldCB0byBgJ2J1aWxkSW4nYC5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSBydWxlLCBzZXQgdG8gYCdQYXNzIHBhcmFtZXRlciB1bmFsdGVyZWQnYC5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uIC0gQSBicmllZiBkZXNjcmlwdGlvbiBvZiB0aGUgcnVsZSdzIGZ1bmN0aW9uYWxpdHkuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBUaGUgc291cmNlIGNvZGUgb2YgdGhlIHJ1bGUgYXMgYSBzdHJpbmcsIHVzZWQgZm9yIHNjcmlwdGluZyBwdXJwb3Nlcy5cclxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gdHlwZSAtIFRoZSBzdXBwb3J0ZWQgdHlwZXMgZm9yIHRoaXMgcnVsZSwgaW5jbHVkaW5nIGB0ZXh0YCwgYHRhZ3NgLCBgYWxpYXNlc2AsIGFuZCBgbXVsdGl0ZXh0YC5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZnggLSBUaGUgbWFpbiBmdW5jdGlvbiB0aGF0IHByb2Nlc3NlcyB0aGUgaW5wdXQgY29udGVudCBhbmQgcmV0dXJucyBpdCB1bmFsdGVyZWQuXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGNvbmZpZ1RhYiAtIEEgbWV0aG9kIGZvciByZW5kZXJpbmcgdGhlIGNvbmZpZ3VyYXRpb24gdGFiIGZvciB0aGUgcnVsZS5cclxuICogXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFJ1bGVCdWlsZEluRGVmYXVsdGAgY2xhc3MuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZUJ1aWxkSW5EZWZhdWx0IGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaWQgPSAnZGVmYXVsdCc7XHJcbiAgICAgICAgdGhpcy5ydWxlVHlwZSA9ICdidWlsZEluJztcclxuICAgICAgICB0aGlzLm5hbWUgPSAnUGFzcyBwYXJhbWV0ZXIgdW5hbHRlcmVkJztcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gJ1Bhc3MgdGhlIGNvbnRlbnQgb2YgdGhlIGZyb250bWF0dGVyIHBhcmFtZXRlciB1bmFsdGVyZWQuJztcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBjb25zdCBpbnB1dCA9IHRvb2xzLmdldEN1cnJlbnRDb250ZW50KCk7IC8vIEdldCB0aGUgY3VycmVudCBjb250ZW50IG9mIHByb3BlcnR5XFxuICByZXR1cm4gaW5wdXQ7IC8vIFJldHVybiB0aGUgaW5wdXQgdW5hbHRlcmVkXFxufTtcIjtcclxuICAgICAgICB0aGlzLnR5cGUgPSBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddO1xyXG4gICAgICAgIHRoaXMuY29uZmlnRWxlbWVudHMgPSB0aGlzLmRlZmF1bHRDb25maWdFbGVtZW50cyh7fSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ4IChhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogVEZpbGUsIHRvb2xzOiBTY3JpcHRpbmdUb29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgICAgICBjb25zdCBpbnB1dCA9IHRvb2xzLmdldEN1cnJlbnRDb250ZW50KCk7IC8vIEdldCB0aGUgY3VycmVudCBjb250ZW50IG9mIHByb3BlcnR5XHJcbiAgICAgICAgcmV0dXJuIGlucHV0OyAvLyBSZXR1cm4gdGhlIGlucHV0IHVuYWx0ZXJlZFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25maWdUYWIgKG9wdGlvbkVMOiBIVE1MRWxlbWVudCwgcnVsZTpGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCB0aGF0OmFueSwgcHJldmlld0NvbXBvbmVudDogYW55KSB7XHJcbiAgICAgICAgLy8gQ29uZmlndXJhdGlvbiB0YWIgbG9naWMgY2FuIGJlIGFkZGVkIGhlcmUgaWYgbmVlZGVkXHJcbiAgICB9O1xyXG4gICAgXHJcbn0iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBidWlsdC1pbiBydWxlIHRoYXQgcmV0cmlldmVzIHRoZSBzaXplIG9mIGEgZmlsZSBpbiBieXRlcy5cclxuICpcclxuICogQHJlbWFya3NcclxuICogVGhpcyBydWxlIGlzIGludGVuZGVkIGZvciB1c2Ugd2l0aGluIHRoZSBGb2xkZXIgdG8gVGFncyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKiBJdCBleHRlbmRzIHRoZSB7QGxpbmsgUnVsZVByb3RvdHlwZX0gY2xhc3MgYW5kIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgdG8gcmV0dXJuXHJcbiAqIHRoZSBmaWxlIHNpemUgaW4gYnl0ZXMgdXNpbmcgdGhlIGBmaWxlLnN0YXQuc2l6ZWAgcHJvcGVydHkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY29uc3QgcnVsZSA9IG5ldyBSdWxlQnVpbGRJbkZpbGVTaXplQnl0ZXMoKTtcclxuICogY29uc3Qgc2l6ZSA9IHJ1bGUuZngoYXBwLCBmaWxlLCB0b29scyk7IC8vIFJldHVybnMgdGhlIGZpbGUgc2l6ZSBpbiBieXRlc1xyXG4gKiBgYGBcclxuICpcclxuICogQGV4dGVuZHMgUnVsZVByb3RvdHlwZVxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZUJ1aWxkSW5GaWxlU2l6ZUJ5dGVzIGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaWQgPSAnZmlsZVNpemVCeXRlcyc7XHJcbiAgICAgICAgdGhpcy5ydWxlVHlwZSA9ICdidWlsZEluJztcclxuICAgICAgICB0aGlzLm5hbWUgPSAnRmlsZSBTaXplIGluIEJ5dGVzJztcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gJ1RoaXMgcnVsZSByZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBmaWxlIGluIGJ5dGVzLic7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBURmlsZSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lISBcXG4gY29uc3QgcmVzdWx0ID0gZmlsZS5zdGF0LnNpemU7IFxcbiByZXR1cm4gcmVzdWx0OyAvLyByZXR1cm4geW91IHJlc3VsdC4gXFxuIH1cIjtcclxuICAgICAgICB0aGlzLnR5cGUgPSBbJ251bWJlciddO1xyXG4gICAgICAgIHRoaXMuY29uZmlnRWxlbWVudHMgPSB0aGlzLmRlZmF1bHRDb25maWdFbGVtZW50cyh7fSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ4IChhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogVEZpbGUsIHRvb2xzOiBTY3JpcHRpbmdUb29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgICAgICAvLyBhY3F1aXJlIGZpbGUgc2l6ZVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGZpbGUuc3RhdC5zaXplO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7IC8vIHJldHVybiB5b3UgcmVzdWx0LlxyXG4gICAgfVxyXG5cclxuICAgIGNvbmZpZ1RhYiAob3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOkZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIHRoYXQ6YW55LCBwcmV2aWV3Q29tcG9uZW50OiBhbnkpIHtcclxuICAgICAgICAvLyBDb25maWd1cmF0aW9uIHRhYiBsb2dpYyBjYW4gYmUgYWRkZWQgaGVyZSBpZiBuZWVkZWRcclxuICAgIH07XHJcbiAgICBcclxufSIsICJpbXBvcnQgeyBSdWxlUHJvdG90eXBlLCBydWxlc01hbmFnZXIgfSBmcm9tIFwiLi9ydWxlc1wiO1xyXG5pbXBvcnQgeyBTY3JpcHRpbmdUb29scyB9IGZyb20gXCIuLi90b29sc1wiO1xyXG5pbXBvcnQgeyBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzIH0gZnJvbSBcIi4uL3R5cGVzXCI7XHJcbmltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgYnVpbHQtaW4gcnVsZSB0aGF0IHJldHVybnMgdGhlIHNpemUgb2YgYSBmaWxlIGFzIGEgaHVtYW4tcmVhZGFibGUgc3RyaW5nLlxyXG4gKlxyXG4gKiBUaGlzIHJ1bGUgY29udmVydHMgdGhlIGZpbGUgc2l6ZSBmcm9tIGJ5dGVzIHRvIEtCLCBNQiwgb3IgR0IgYXMgYXBwcm9wcmlhdGUsXHJcbiAqIGZvcm1hdHRpbmcgdGhlIHJlc3VsdCB3aXRoIGEgZml4ZWQgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiAtIFRoZSBydWxlIGlzIGlkZW50aWZpZWQgYnkgdGhlIElEIGAnZmlsZVNpemVTdHJpbmcnYC5cclxuICogLSBUaGUgYGZ4YCBtZXRob2QgcGVyZm9ybXMgdGhlIGZpbGUgc2l6ZSBjb252ZXJzaW9uIGFuZCBmb3JtYXR0aW5nLlxyXG4gKiAtIFRoZSBydWxlIGlzIGludGVuZGVkIGZvciB1c2Ugd2l0aGluIHRoZSBGb2xkZXIgdG8gVGFncyBwbHVnaW4gZm9yIE9ic2lkaWFuLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIFJldHVybnMgXCI1MTIgQnl0ZXNcIiBmb3IgYSA1MTItYnl0ZSBmaWxlXHJcbiAqIC8vIFJldHVybnMgXCIxLjIzIEtCXCIgZm9yIGEgZmlsZSBvZiBzaXplIDEyNTkgYnl0ZXNcclxuICogLy8gUmV0dXJucyBcIjIuMzQgTUJcIiBmb3IgYSBmaWxlIG9mIHNpemUgMiw0NTMsMTIzIGJ5dGVzXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlQnVpbGRJbkZpbGVTaXplU3RyaW5nIGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaWQgPSAnZmlsZVNpemVTdHJpbmcnO1xyXG4gICAgICAgIHRoaXMucnVsZVR5cGUgPSAnYnVpbGRJbic7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ0ZpbGUgU2l6ZSBhcyBTdHJpbmcnO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnQ29udmVydHMgdGhlIGZpbGUgc2l6ZSB0byBhIGh1bWFuLXJlYWRhYmxlIHN0cmluZyAoZS5nLiwgS0IsIE1CLCBHQikgd2l0aCAyIGRlY2ltYWwgcGxhY2VzIHByZWNpc2lvbi4nO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gXCJmdW5jdGlvbihhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogVEZpbGUsIHRvb2xzOiBTY3JpcHRpbmdUb29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSEgXFxuIGxldCBzaXplID1maWxlLnN0YXQuc2l6ZTsgXFxuIGNvbnN0IHByZWNpc2lvbiA9IDI7IC8vIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBcXG4gaWYgKHNpemUgPiAxMDI0KSB7IFxcbiAgIHNpemUgPSBzaXplIC8gMTAyNDsgXFxuICAgaWYgKHNpemUgPiAxMDI0KSB7IFxcbiAgICAgc2l6ZSA9IHNpemUgLyAxMDI0OyBcXG4gICAgIGlmIChzaXplID4gMTAyNCkgeyBcXG4gICAgICAgc2l6ZSA9IHNpemUgLyAxMDI0OyBcXG4gICAgICAgcmV0dXJuIHNpemUudG9GaXhlZChwcmVjaXNpb24pICsgJyBHQic7IFxcbiAgICAgfSBcXG4gICAgIHJldHVybiBzaXplLnRvRml4ZWQocHJlY2lzaW9uKSArICcgTUInOyBcXG4gICB9IFxcbiAgIHJldHVybiBzaXplLnRvRml4ZWQocHJlY2lzaW9uKSArICcgS0InOyBcXG4gfSAgIFxcbiByZXR1cm4gc2l6ZSArICcgQnl0ZXMnOyAvLyByZXR1cm4geW91IHJlc3VsdC4gXFxuIH1cIjtcclxuICAgICAgICB0aGlzLnR5cGUgPSBbJ3RleHQnXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAgICAvLyBhY3F1aXJlIGZpbGUgc2l6ZVxyXG4gICAgICAgIGxldCBzaXplID1maWxlLnN0YXQuc2l6ZTtcclxuICAgICAgICBjb25zdCBwcmVjaXNpb24gPSAyOyAvLyBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcclxuICAgICAgICBpZiAoc2l6ZSA+IDEwMjQpIHtcclxuICAgICAgICAgIHNpemUgPSBzaXplIC8gMTAyNDtcclxuICAgICAgICAgIGlmIChzaXplID4gMTAyNCkge1xyXG4gICAgICAgICAgICBzaXplID0gc2l6ZSAvIDEwMjQ7XHJcbiAgICAgICAgICAgIGlmIChzaXplID4gMTAyNCkge1xyXG4gICAgICAgICAgICAgIHNpemUgPSBzaXplIC8gMTAyNDtcclxuICAgICAgICAgICAgICByZXR1cm4gc2l6ZS50b0ZpeGVkKHByZWNpc2lvbikgKyAnIEdCJztcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgcmV0dXJuIHNpemUudG9GaXhlZChwcmVjaXNpb24pICsgJyBNQic7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gc2l6ZS50b0ZpeGVkKHByZWNpc2lvbikgKyAnIEtCJztcclxuICAgICAgICB9ICAgXHJcbiAgICAgICAgcmV0dXJuIHNpemUgKyAnIEJ5dGVzJzsgLy8gcmV0dXJuIHlvdSByZXN1bHQuXHJcbiAgICB9XHJcblxyXG4gICAgY29uZmlnVGFiIChvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6RnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDphbnksIHByZXZpZXdDb21wb25lbnQ6IGFueSkge1xyXG4gICAgICAgIC8vIENvbmZpZ3VyYXRpb24gdGFiIGxvZ2ljIGNhbiBiZSBhZGRlZCBoZXJlIGlmIG5lZWRlZFxyXG4gICAgfTtcclxuICAgIFxyXG59IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MgfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgYnVpbHQtaW4gcnVsZSB0aGF0IGV4dHJhY3RzIHRoZSBwYXJlbnQgZm9sZGVyIG9mIGEgZmlsZS5cclxuICogVGhpcyBydWxlIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBmb2xkZXIgbmFtZSB0aGF0IGRpcmVjdGx5IGNvbnRhaW5zIHRoZSBmaWxlLlxyXG4gKiBcclxuICogQGV4dGVuZHMgUnVsZVByb3RvdHlwZVxyXG4gKiBcclxuICogQHJlbWFya3NcclxuICogLSBUaGUgYGZ4YCBtZXRob2QgY2FsY3VsYXRlcyB0aGUgcGFyZW50IGZvbGRlciBieSBhbmFseXppbmcgdGhlIGZpbGUgcGF0aC5cclxuICogLSBUaGUgYHNvdXJjZWAgcHJvcGVydHkgY29udGFpbnMgYSBkZWZhdWx0IGZ1bmN0aW9uIHRlbXBsYXRlIGZvciBzY3JpcHRpbmcgcHVycG9zZXMuXHJcbiAqIC0gVGhlIGB0eXBlYCBwcm9wZXJ0eSBzcGVjaWZpZXMgdGhlIHN1cHBvcnRlZCBkYXRhIHR5cGVzIGZvciB0aGlzIHJ1bGUuXHJcbiAqIC0gVGhlIGBjb25maWdUYWJgIG1ldGhvZCBjYW4gYmUgdXNlZCB0byBkZWZpbmUgYSBjb25maWd1cmF0aW9uIFVJIGZvciB0aGUgcnVsZSwgaWYgbmVlZGVkLlxyXG4gKiBcclxuICogQGV4YW1wbGVcclxuICogLy8gRXhhbXBsZSB1c2FnZSBvZiB0aGUgYGZ4YCBtZXRob2Q6XHJcbiAqIGNvbnN0IHBhcmVudEZvbGRlciA9IHJ1bGUuZngoYXBwLCBmaWxlLCB0b29scyk7XHJcbiAqIGNvbnNvbGUubG9nKHBhcmVudEZvbGRlcik7IC8vIE91dHB1dHMgdGhlIG5hbWUgb2YgdGhlIHBhcmVudCBmb2xkZXJcclxuICogXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHJ1bGUsIHNldCB0byAnZm9sZGVyJy5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJ1bGVUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIHJ1bGUsIHNldCB0byAnYnVpbGRJbicuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgcnVsZSwgc2V0IHRvICdQYXJlbnQgZm9sZGVyJy5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uIC0gQSBicmllZiBkZXNjcmlwdGlvbiBvZiB0aGUgcnVsZSdzIGZ1bmN0aW9uYWxpdHkuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBBIGRlZmF1bHQgZnVuY3Rpb24gdGVtcGxhdGUgZm9yIHNjcmlwdGluZy5cclxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gdHlwZSAtIFRoZSBzdXBwb3J0ZWQgZGF0YSB0eXBlcyBmb3IgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGNvbmZpZ0VsZW1lbnRzIC0gQSBtZXRob2QgdG8gZGVmaW5lIGRlZmF1bHQgY29uZmlndXJhdGlvbiBlbGVtZW50cy5cclxuICogXHJcbiAqIEBtZXRob2QgZnhcclxuICogQHBhcmFtIHtBcHAgfCB1bmRlZmluZWR9IGFwcCAtIFRoZSBhcHBsaWNhdGlvbiBpbnN0YW5jZSAob3B0aW9uYWwpLlxyXG4gKiBAcGFyYW0ge1RGaWxlfSBmaWxlIC0gVGhlIGZpbGUgb2JqZWN0IGZvciB3aGljaCB0aGUgcGFyZW50IGZvbGRlciBpcyBkZXRlcm1pbmVkLlxyXG4gKiBAcGFyYW0ge1NjcmlwdGluZ1Rvb2xzfSB0b29scyAtIFV0aWxpdHkgdG9vbHMgZm9yIHNjcmlwdGluZy5cclxuICogQHJldHVybnMge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIHBhcmVudCBmb2xkZXIsIG9yIGFuIGVtcHR5IHN0cmluZyBpZiBubyBwYXJlbnQgZXhpc3RzLlxyXG4gKiBcclxuICogQG1ldGhvZCBjb25maWdUYWJcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gb3B0aW9uRUwgLSBUaGUgSFRNTCBlbGVtZW50IGZvciB0aGUgY29uZmlndXJhdGlvbiB0YWIuXHJcbiAqIEBwYXJhbSB7RnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5nc30gcnVsZSAtIFRoZSBydWxlIHNldHRpbmdzIG9iamVjdC5cclxuICogQHBhcmFtIHthbnl9IHRoYXQgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBjb250ZXh0LlxyXG4gKiBAcGFyYW0ge2FueX0gcHJldmlld0NvbXBvbmVudCAtIEEgY29tcG9uZW50IGZvciBwcmV2aWV3aW5nIGNoYW5nZXMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZUJ1aWxkSW5Gb2xkZXIgZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLmlkID0gJ2ZvbGRlcic7XHJcbiAgICB0aGlzLnJ1bGVUeXBlID0gJ2J1aWxkSW4nO1xyXG4gICAgdGhpcy5uYW1lID0gJ1BhcmVudCBmb2xkZXInO1xyXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdSZXR1cm5zIHRoZSBwYXJlbnQgZm9sZGVyIG9mIHRoZSBmaWxlLic7XHJcbiAgICB0aGlzLnNvdXJjZSA9IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBjb25zdCBpbnB1dCA9IHRvb2xzLmdldEN1cnJlbnRDb250ZW50KCk7IC8vIEdldCB0aGUgY3VycmVudCBjb250ZW50IG9mIHByb3BlcnR5XFxuICByZXR1cm4gaW5wdXQ7IC8vIFJldHVybiB0aGUgaW5wdXQgdW5hbHRlcmVkXFxufTtcIjtcclxuICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gIH1cclxuICBcclxuICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAvLyBhY3F1aXJlIGZpbGUgcGF0aFxyXG4gICAgY29uc3QgcGF0aCA9IGZpbGUucGF0aDtcclxuICAgIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLycpO1xyXG4gICAgbGV0IHJlc3VsdCA9ICcnO1xyXG4gICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgcmVzdWx0ID0gcGFydHNbcGFydHMubGVuZ3RoLTJdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIGNvbmZpZ1RhYiAob3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOkZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIHRoYXQ6YW55LCBwcmV2aWV3Q29tcG9uZW50OiBhbnkpIHtcclxuICAgIC8vIENvbmZpZ3VyYXRpb24gdGFiIGxvZ2ljIGNhbiBiZSBhZGRlZCBoZXJlIGlmIG5lZWRlZFxyXG4gIH07XHJcbiAgICBcclxufSIsICJpbXBvcnQgeyBSdWxlUHJvdG90eXBlLCBydWxlc01hbmFnZXIgfSBmcm9tIFwiLi9ydWxlc1wiO1xyXG5pbXBvcnQgeyBTY3JpcHRpbmdUb29scyB9IGZyb20gXCIuLi90b29sc1wiO1xyXG5pbXBvcnQgeyBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzIH0gZnJvbSBcIi4uL3R5cGVzXCI7XHJcbmltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgYnVpbHQtaW4gcnVsZSB0aGF0IHJldHVybnMgdGhlIHBhcmVudCBmb2xkZXIgb2YgYSBmaWxlLFxyXG4gKiBjb21wYXRpYmxlIHdpdGggdGhlIFwiRm9sZGVyIE5vdGVzXCIgY29udmVudGlvbiBpbiBPYnNpZGlhbi5cclxuICpcclxuICogVGhpcyBydWxlIGRldGVybWluZXMgdGhlIHBhcmVudCBmb2xkZXIgbmFtZSBmb3IgYSBnaXZlbiBmaWxlLCB0YWtpbmcgaW50byBhY2NvdW50XHJcbiAqIHRoZSBzcGVjaWFsIGNhc2Ugd2hlcmUgdGhlIGZpbGUgaXMgYSBmb2xkZXIgbm90ZSAoaS5lLiwgaXRzIG5hbWUgbWF0Y2hlcyBpdHMgcGFyZW50IGZvbGRlcikuXHJcbiAqIElmIHRoZSBmaWxlIGlzIGxvY2F0ZWQgaW4gdGhlIHJvb3QgZGlyZWN0b3J5LCB0aGUgdmF1bHQgbmFtZSBpcyByZXR1cm5lZCBpbnN0ZWFkLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIC0gVGhlIHJ1bGUgaXMgaWRlbnRpZmllZCBieSB0aGUgSUQgJ2ZvbGRlckZvbGRlck5vdGVzJy5cclxuICogLSBUaGUgcnVsZSB0eXBlIGlzICdidWlsZEluJy5cclxuICogLSBUaGUgYGZ4YCBtZXRob2Qgc2hvdWxkIG5vdCBoYXZlIGl0cyBzaWduYXR1cmUgY2hhbmdlZCwgYXMgaXQgaXMgdXNlZCBieSB0aGUgcnVsZSBlbmdpbmUuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIEZvciBhIGZpbGUgYXQgJ1Byb2plY3RzL05vdGVzL05vdGVzLm1kJyAod2hlcmUgJ05vdGVzJyBpcyBhIGZvbGRlciBub3RlKTpcclxuICogLy8gUmV0dXJucyAnUHJvamVjdHMnXHJcbiAqXHJcbiAqIC8vIEZvciBhIGZpbGUgYXQgJ1Byb2plY3RzL05vdGVzL01lZXRpbmcubWQnOlxyXG4gKiAvLyBSZXR1cm5zICdOb3RlcydcclxuICpcclxuICogLy8gRm9yIGEgZmlsZSBhdCB0aGUgdmF1bHQgcm9vdDpcclxuICogLy8gUmV0dXJucyB0aGUgdmF1bHQgbmFtZVxyXG4gKlxyXG4gKiBAcGFyYW0gYXBwIC0gVGhlIE9ic2lkaWFuIEFwcCBpbnN0YW5jZSAobWF5IGJlIHVuZGVmaW5lZCkuXHJcbiAqIEBwYXJhbSBmaWxlIC0gVGhlIHRhcmdldCBURmlsZSBmb3Igd2hpY2ggdGhlIHBhcmVudCBmb2xkZXIgaXMgZGV0ZXJtaW5lZC5cclxuICogQHBhcmFtIHRvb2xzIC0gVXRpbGl0eSB0b29scywgaW5jbHVkaW5nIGFjY2VzcyB0byB0aGUgdmF1bHQuXHJcbiAqIEByZXR1cm5zIFRoZSBuYW1lIG9mIHRoZSBwYXJlbnQgZm9sZGVyLCBvciB0aGUgdmF1bHQgbmFtZSBpZiB0aGUgZmlsZSBpcyBpbiB0aGUgcm9vdC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlQnVpbGRJbkZvbGRlckZvbGRlck5vdGVzIGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5pZCA9ICdmb2xkZXJGb2xkZXJOb3Rlcyc7XHJcbiAgICAgIHRoaXMucnVsZVR5cGUgPSAnYnVpbGRJbic7XHJcbiAgICAgIHRoaXMubmFtZSA9ICdQYXJlbnQgRm9sZGVyIChjb21wbGllcyB3aXRoIFwiZm9sZGVyIG5vdGVzXCIpJztcclxuICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdSZXR1cm5zIHRoZSBwYXJlbnQgZm9sZGVyIG9mIHRoZSBmaWxlIGNvbXBhdGlibGUgd2l0aCBGb2xkZXIgTm90ZXMuJztcclxuICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgLy8gYWNxdWlyZSBmaWxlIHBhdGhcXG4gIGNvbnN0IHBhdGggPSBmaWxlLnBhdGg7Y29uc3QgcGFydHMgPSBmaWxlLnBhdGguc3BsaXQoJy8nKTtcXG4gIGxldCBpbmRleCA9IHBhcnRzLmxlbmd0aC0yOyAvLyBpbmRleCBvZiBwYXJlbnQgZm9sZGVyXFxuICBpZiAocGFydHNbcGFydHMubGVuZ3RoLTJdPT09ZmlsZS5iYXNlbmFtZSkge1xcbiAgICAgIGluZGV4LS07IC8vIGZvbGRlciBub3RlIHBhcmVudCBpcyB0aGUgY2hpbGRcXG4gIH1cXG4gIGlmIChpbmRleCA+PSAwKSB7XFxuICAgIHJldHVybiBwYXJ0c1tpbmRleF07IC8vIGZpbGUgaW4gZm9sZGVyXFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gdG9vbHMuYXBwPy52YXVsdD8uZ2V0TmFtZSgpIHx8ICdWYXVsdCc7IC8vIGZpbGUgaW4gcm9vdCA9IHZhdWx0XFxuICB9XFxufVwiO1xyXG4gICAgICB0aGlzLnR5cGUgPSBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddO1xyXG4gICAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAgIC8vIGFjcXVpcmUgZmlsZSBwYXRoXHJcbiAgICAgIGNvbnN0IHBhdGggPSBmaWxlLnBhdGg7Y29uc3QgcGFydHMgPSBmaWxlLnBhdGguc3BsaXQoJy8nKTtcclxuICAgICAgbGV0IGluZGV4ID0gcGFydHMubGVuZ3RoLTI7IC8vIGluZGV4IG9mIHBhcmVudCBmb2xkZXJcclxuICAgICAgaWYgKHBhcnRzW3BhcnRzLmxlbmd0aC0yXT09PWZpbGUuYmFzZW5hbWUpIHtcclxuICAgICAgICAgIGluZGV4LS07IC8vIGZvbGRlciBub3RlIHBhcmVudCBpcyB0aGUgY2hpbGRcclxuICAgICAgfVxyXG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xyXG4gICAgICAgIHJldHVybiBwYXJ0c1tpbmRleF07IC8vIGZpbGUgaW4gZm9sZGVyXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRvb2xzLmFwcD8udmF1bHQ/LmdldE5hbWUoKSB8fCAnVmF1bHQnOyAvLyBmaWxlIGluIHJvb3QgPSB2YXVsdFxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uZmlnVGFiIChvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6RnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDphbnksIHByZXZpZXdDb21wb25lbnQ6IGFueSkge1xyXG4gICAgICAgIC8vIENvbmZpZ3VyYXRpb24gdGFiIGxvZ2ljIGNhbiBiZSBhZGRlZCBoZXJlIGlmIG5lZWRlZFxyXG4gICAgfTtcclxuICAgIFxyXG59IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MgfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuLyoqXHJcbiAqIEEgYnVpbHQtaW4gcnVsZSB0aGF0IGV4dHJhY3RzIGFsbCBmb2xkZXJzIGZyb20gdGhlIHBhdGggb2YgYSBnaXZlbiBmaWxlIGFuZCByZXR1cm5zIHRoZW0gYXMgYSBsaXN0LlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUaGlzIHJ1bGUgaXMgaW50ZW5kZWQgZm9yIHVzZSB3aXRoaW4gdGhlIEZvbGRlci10by1UYWdzIE9ic2lkaWFuIHBsdWdpbi5cclxuICogSXQgcHJvdmlkZXMgYSB3YXkgdG8gcmV0cmlldmUgYWxsIGZvbGRlciBuYW1lcyAoYXMgYSBzdHJpbmcgYXJyYXkpIHRoYXQgYSBmaWxlIGlzIHN0b3JlZCBpbixcclxuICogZXhjbHVkaW5nIHRoZSBmaWxlIG5hbWUgaXRzZWxmLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIElmIGZpbGUucGF0aCBpcyAnZm9sZGVyMS9mb2xkZXIyL215ZmlsZS5tZCcsIHRoZSByZXN1bHQgd2lsbCBiZSBbJ2ZvbGRlcjEnLCAnZm9sZGVyMiddXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHJ1bGUgKCdmb2xkZXJzJykuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBydWxlVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBydWxlICgnYnVpbGRJbicpLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXNjcmlwdGlvbiAtIEEgZGVzY3JpcHRpb24gb2Ygd2hhdCB0aGUgcnVsZSBkb2VzLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc291cmNlIC0gVGhlIHNvdXJjZSBvZiB0aGUgcnVsZSAoZW1wdHkgZm9yIGJ1aWx0LWluKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gdHlwZSAtIFRoZSB0eXBlcyB0aGlzIHJ1bGUgYXBwbGllcyB0byAoZS5nLiwgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnKS5cclxuICogQHByb3BlcnR5IHthbnlbXX0gY29uZmlnRWxlbWVudHMgLSBUaGUgY29uZmlndXJhdGlvbiBlbGVtZW50cyBmb3IgdGhpcyBydWxlLlxyXG4gKlxyXG4gKiBAbWV0aG9kIGZ4XHJcbiAqIFJldHVybnMgYWxsIGZvbGRlcnMgdGhlIGZpbGUgaXMgc3RvcmVkIGluIGFzIGEgbGlzdC5cclxuICogQHBhcmFtIGFwcCAtIFRoZSBPYnNpZGlhbiBhcHAgaW5zdGFuY2UgKG9wdGlvbmFsKS5cclxuICogQHBhcmFtIGZpbGUgLSBUaGUgZmlsZSB3aG9zZSBmb2xkZXJzIGFyZSB0byBiZSBleHRyYWN0ZWQuXHJcbiAqIEBwYXJhbSB0b29scyAtIFNjcmlwdGluZyB0b29scyBwcm92aWRlZCBieSB0aGUgcGx1Z2luLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IEFuIGFycmF5IG9mIGZvbGRlciBuYW1lcy5cclxuICpcclxuICogQG1ldGhvZCBjb25maWdUYWJcclxuICogT3B0aW9uYWwgY29uZmlndXJhdGlvbiB0YWIgbG9naWMgZm9yIHRoZSBydWxlLlxyXG4gKiBAcGFyYW0gb3B0aW9uRUwgLSBUaGUgSFRNTCBlbGVtZW50IGZvciB0aGUgY29uZmlndXJhdGlvbiB0YWIuXHJcbiAqIEBwYXJhbSBydWxlIC0gVGhlIHJ1bGUgc2V0dGluZ3MuXHJcbiAqIEBwYXJhbSB0aGF0IC0gVGhlIGNvbnRleHQgb2JqZWN0LlxyXG4gKiBAcGFyYW0gcHJldmlld0NvbXBvbmVudCAtIFRoZSBwcmV2aWV3IGNvbXBvbmVudCBmb3IgdGhlIGNvbmZpZ3VyYXRpb24gVUkuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZUJ1aWxkSW5Gb2xkZXJzIGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5pZCA9ICdmb2xkZXJzJztcclxuICAgICAgdGhpcy5ydWxlVHlwZSA9ICdidWlsZEluJztcclxuICAgICAgdGhpcy5uYW1lID0gJ0FsbCBmb2xkZXJzIG9mIHRoZSBmaWxlIGFzIGEgbGlzdCc7XHJcbiAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnUmV0dXJucyBhbGwgZm9sZGVycyB0aGUgZmlsZSBpcyBzdG9yZWQgaW4gYXMgYSBsaXN0Lic7XHJcbiAgICAgIHRoaXMuc291cmNlID0gXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIC8vIGFjcXVpcmUgZmlsZSBwYXRoXFxuICBjb25zdCBwYXRoID0gZmlsZS5wYXRoO1xcbiAgY29uc3QgcmVzdWx0ID0gcGF0aC5zcGxpdCgnLycpO1xcbiAgcmVzdWx0LnBvcCgpOyAvLyByZW1vdmUgdGhlIGZpbGUgbmFtZVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59XCI7XHJcbiAgICAgIHRoaXMudHlwZSA9IFsndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddO1xyXG4gICAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAgIC8vIGFjcXVpcmUgZmlsZSBwYXRoXHJcbiAgICAgIGNvbnN0IHBhdGggPSBmaWxlLnBhdGg7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhdGguc3BsaXQoJy8nKTtcclxuICAgICAgcmVzdWx0LnBvcCgpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbmZpZ1RhYiAob3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOkZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIHRoYXQ6YW55LCBwcmV2aWV3Q29tcG9uZW50OiBhbnkpIHtcclxuICAgICAgICAvLyBDb25maWd1cmF0aW9uIHRhYiBsb2dpYyBjYW4gYmUgYWRkZWQgaGVyZSBpZiBuZWVkZWRcclxuICAgIH07XHJcbiAgICBcclxufSIsICJpbXBvcnQgeyBSdWxlUHJvdG90eXBlLCBydWxlc01hbmFnZXIgfSBmcm9tIFwiLi9ydWxlc1wiO1xyXG5pbXBvcnQgeyBTY3JpcHRpbmdUb29scyB9IGZyb20gXCIuLi90b29sc1wiO1xyXG5pbXBvcnQgeyBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzIH0gZnJvbSBcIi4uL3R5cGVzXCI7XHJcbmltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIHJ1bGUgdGhhdCBnZW5lcmF0ZXMgdGhlIGZ1bGwgcGF0aCBvZiBhIGZpbGUsIGluY2x1ZGluZyBpdHMgZmlsZW5hbWUuXHJcbiAqIFRoaXMgcnVsZSBpcyBidWlsdC1pbiBhbmQgY2FuIGJlIHVzZWQgdG8gcmV0cmlldmUgdGhlIGNvbXBsZXRlIGZpbGUgcGF0aCBhcyBhIHN0cmluZy5cclxuICpcclxuICogQGV4dGVuZHMgUnVsZVByb3RvdHlwZVxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiAtIFRoZSBgZnhgIGZ1bmN0aW9uIHNwbGl0cyB0aGUgZmlsZSBwYXRoLCByZW1vdmVzIHRoZSBsYXN0IHBhcnQgKGFzc3VtZWQgdG8gYmUgdGhlIGZpbGVuYW1lKSxcclxuICogICBhcHBlbmRzIHRoZSBmaWxlJ3MgYmFzZW5hbWUsIGFuZCB0aGVuIGpvaW5zIHRoZSBwYXJ0cyBiYWNrIHRvZ2V0aGVyIHRvIGZvcm0gdGhlIGZ1bGwgcGF0aC5cclxuICogLSBUaGlzIHJ1bGUgY2FuIGJlIHVzZWQgZm9yIG11bHRpcGxlIHByb3BlcnR5IHR5cGVzOiBgdGV4dGAsIGB0YWdzYCwgYGFsaWFzZXNgLCBhbmQgYG11bHRpdGV4dGAuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHJ1bGUgKGAnZnVsbFBhdGgnYCkuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBydWxlVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBydWxlIChgJ2J1aWxkSW4nYCkuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgcnVsZSAoYCdGdWxsIHBhdGgsIGZpbGVuYW1lJ2ApLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGVzY3JpcHRpb24gLSBBIGJyaWVmIGRlc2NyaXB0aW9uIG9mIHRoZSBydWxlJ3MgZnVuY3Rpb25hbGl0eS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZSAtIFRoZSBzb3VyY2UgY29kZSBvZiB0aGUgcnVsZSdzIGZ1bmN0aW9uIGFzIGEgc3RyaW5nLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSB0eXBlIC0gVGhlIHByb3BlcnR5IHR5cGVzIHRoZSBydWxlIGNhbiBiZSB1c2VkIGZvci5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZnggLSBUaGUgZnVuY3Rpb24gdGhhdCBpbXBsZW1lbnRzIHRoZSBydWxlJ3MgbG9naWMuXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGNvbmZpZ1RhYiAtIEEgcGxhY2Vob2xkZXIgZnVuY3Rpb24gZm9yIGNvbmZpZ3VyaW5nIHRoZSBydWxlIGluIHRoZSBVSS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogLy8gRXhhbXBsZSB1c2FnZSBvZiB0aGUgYGZ4YCBmdW5jdGlvbjpcclxuICogY29uc3QgZnVsbFBhdGggPSBydWxlLmZ4KGFwcCwgZmlsZSwgdG9vbHMpO1xyXG4gKiBjb25zb2xlLmxvZyhmdWxsUGF0aCk7IC8vIE91dHB1dHMgdGhlIGZ1bGwgcGF0aCBvZiB0aGUgZmlsZSwgaW5jbHVkaW5nIGl0cyBmaWxlbmFtZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlQnVpbGRJbkZ1bGxQYXRoIGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaWQgPSAnZnVsbFBhdGgnO1xyXG4gICAgICAgIHRoaXMucnVsZVR5cGUgPSAnYnVpbGRJbic7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ0Z1bGwgcGF0aCwgZmlsZW5hbWUnO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnUmV0dXJucyB0aGUgZnVsbCBwYXRoIG9mIHRoZSBmaWxlLCBpbmNsdWRpbmcgdGhlIGZpbGVuYW1lLic7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgbGV0IHBhcnRzID0gZmlsZS5wYXRoLnNwbGl0KCcvJyk7XFxuICBwYXJ0cy5wb3AoKTtcXG4gIHBhcnRzLnB1c2goZmlsZS5iYXNlbmFtZSk7XFxuICByZXR1cm4gcGFydHMuam9pbignLycpO1xcbn07XCI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gICAgfTtcclxuXHJcbiAgICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMpe1xyXG4gICAgICAgIGxldCBwYXJ0cyA9IGZpbGUucGF0aC5zcGxpdCgnLycpO1xyXG4gICAgICAgIHBhcnRzLnBvcCgpO1xyXG4gICAgICAgIHBhcnRzLnB1c2goZmlsZS5iYXNlbmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJy8nKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uZmlnVGFiKG9wdGlvbkVMOiBIVE1MRWxlbWVudCwgcnVsZTogRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDogYW55LCBwcmV2aWV3Q29tcG9uZW50OiBhbnkpIHtcclxuICAgIH07XHJcblxyXG59IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MgfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgYnVpbHQtaW4gcnVsZSB0aGF0IHJldHVybnMgdGhlIGZ1bGwgcGF0aCBvZiBhIGZpbGUsIGluY2x1ZGluZyBpdHMgZmlsZW5hbWUgYW5kIGV4dGVuc2lvbi5cclxuICogXHJcbiAqIFRoaXMgcnVsZSBpcyBwYXJ0IG9mIHRoZSBcImZvbGRlci10by10YWdzLXBsdWdpblwiIGFuZCBpcyB1c2VkIHRvIGdlbmVyYXRlIG9yIG1hbmlwdWxhdGUgbWV0YWRhdGFcclxuICogYmFzZWQgb24gdGhlIGZ1bGwgcGF0aCBvZiBhIGZpbGUuIEl0IGV4dGVuZHMgdGhlIGBSdWxlUHJvdG90eXBlYCBjbGFzcyBhbmQgcHJvdmlkZXMgY29uZmlndXJhdGlvblxyXG4gKiBvcHRpb25zLCBhIGRlc2NyaXB0aW9uLCBhbmQgYSBmdW5jdGlvbiB0byBleGVjdXRlIHRoZSBydWxlIGxvZ2ljLlxyXG4gKiBcclxuICogQGNsYXNzIFJ1bGVCdWlsZEluRnVsbFBhdGhFeHRcclxuICogQGV4dGVuZHMgUnVsZVByb3RvdHlwZVxyXG4gKiBcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIHJ1bGUgKGBmdWxsUGF0aEV4dGApLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcnVsZVR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgcnVsZSAoYGJ1aWxkSW5gKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSBydWxlIChgRnVsbCBwYXRoLCBmaWxlbmFtZSBhbmQgZXh0ZW5zaW9uYCkuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXNjcmlwdGlvbiAtIEEgYnJpZWYgZGVzY3JpcHRpb24gb2YgdGhlIHJ1bGUncyBmdW5jdGlvbmFsaXR5LlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc291cmNlIC0gVGhlIHNvdXJjZSBjb2RlIG9mIHRoZSBydWxlJ3MgbG9naWMgYXMgYSBzdHJpbmcuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHR5cGUgLSBUaGUgdHlwZXMgb2YgbWV0YWRhdGEgdGhpcyBydWxlIGNhbiBiZSBhcHBsaWVkIHRvIChgdGV4dGAsIGB0YWdzYCwgYGFsaWFzZXNgLCBgbXVsdGl0ZXh0YCkuXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGZ4IC0gVGhlIGZ1bmN0aW9uIHRoYXQgaW1wbGVtZW50cyB0aGUgcnVsZSBsb2dpYywgcmV0dXJuaW5nIHRoZSBmdWxsIHBhdGggb2YgdGhlIGZpbGUuXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGNvbmZpZ1RhYiAtIEEgZnVuY3Rpb24gdG8gcmVuZGVyIHRoZSBjb25maWd1cmF0aW9uIHRhYiBmb3IgdGhpcyBydWxlLlxyXG4gKiBcclxuICogQG1ldGhvZCBkZWZhdWx0Q29uZmlnRWxlbWVudHMgLSBJbmhlcml0ZWQgZnJvbSBgUnVsZVByb3RvdHlwZWAsIHVzZWQgdG8gZGVmaW5lIGRlZmF1bHQgY29uZmlndXJhdGlvbiBlbGVtZW50cy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlQnVpbGRJbkZ1bGxQYXRoRXh0IGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaWQgPSAnZnVsbFBhdGhFeHQnO1xyXG4gICAgICAgIHRoaXMucnVsZVR5cGUgPSAnYnVpbGRJbic7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ0Z1bGwgcGF0aCwgZmlsZW5hbWUgYW5kIGV4dGVuc2lvbic7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdSZXR1cm5zIHRoZSBmdWxsIHBhdGggb2YgdGhlIGZpbGUsIGluY2x1ZGluZyBpdHMgZmlsZW5hbWUgYW5kIGV4dGVuc2lvbi4nO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIHJldHVybiBgJHtmaWxlLnBhdGh9YDtcXG59O1wiO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICAgICAgdGhpcy5jb25maWdFbGVtZW50cyA9IHRoaXMuZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KTtcclxuICAgIH07XHJcblxyXG4gICAgZngoYXBwOiBBcHAsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMpIHtcclxuICAgICAgICByZXR1cm4gYCR7ZmlsZS5wYXRofWA7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbmZpZ1RhYihvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIHRoYXQ6IGFueSwgcHJldmlld0NvbXBvbmVudDogYW55KSB7XHJcbiAgICAgICAgLy8gQ29uZmlndXJhdGlvbiB0YWIgbG9naWMgY2FuIGJlIGFkZGVkIGhlcmUgaWYgbmVlZGVkXHJcbiAgICAgICAgLy8gRm9yIGV4YW1wbGUsIHlvdSBjYW4gY3JlYXRlIHNldHRpbmdzIGZvciB0aGUgcnVsZSBoZXJlXHJcbiAgICB9O1xyXG4gICAgXHJcbn0iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIHJ1bGUgZm9yIGdlbmVyYXRpbmcgYSBmdWxsIHBhdGggd2l0aCBleHRlbnNpb25zIGNvbXBhdGlibGUgd2l0aCBcImZvbGRlciBub3Rlc1wiLlxyXG4gKiBUaGlzIHJ1bGUgbW9kaWZpZXMgdGhlIGZpbGUgcGF0aCB0byBlbnN1cmUgY29tcGF0aWJpbGl0eSB3aXRoIGZvbGRlciBub3RlcyBieSBhZGp1c3RpbmdcclxuICogdGhlIHBhdGggc3RydWN0dXJlIGJhc2VkIG9uIHRoZSBmaWxlJ3MgYmFzZW5hbWUgYW5kIHBhcmVudCBmb2xkZXIuXHJcbiAqIFxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqIFxyXG4gKiBAcmVtYXJrc1xyXG4gKiAtIFRoZSBgc291cmNlYCBwcm9wZXJ0eSBjb250YWlucyBhIHN0cmluZ2lmaWVkIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgdGhlIHBhdGggdHJhbnNmb3JtYXRpb24uXHJcbiAqIC0gVGhlIGBmeGAgbWV0aG9kIGltcGxlbWVudHMgdGhlIHNhbWUgbG9naWMgYXMgdGhlIGBzb3VyY2VgIGZ1bmN0aW9uIGJ1dCBpcyBkaXJlY3RseSBleGVjdXRhYmxlLlxyXG4gKiAtIFRoaXMgcnVsZSBpcyBjYXRlZ29yaXplZCBhcyBhIGJ1aWx0LWluIHJ1bGUgKGBydWxlVHlwZTogJ2J1aWxkSW4nYCkuXHJcbiAqIFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHJ1bGUgKGBmdWxsUGF0aEV4dEZvbGRlck5vdGVzYCkuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBydWxlVHlwZSAtIFR5cGUgb2YgdGhlIHJ1bGUgKGBidWlsZEluYCkuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gRGlzcGxheSBuYW1lIG9mIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGVzY3JpcHRpb24gLSBEZXNjcmlwdGlvbiBvZiB0aGUgcnVsZSdzIHB1cnBvc2UuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBTdHJpbmdpZmllZCBmdW5jdGlvbiBkZWZpbmluZyB0aGUgcnVsZSdzIGxvZ2ljLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSB0eXBlIC0gQXBwbGljYWJsZSB0eXBlcyBmb3IgdGhlIHJ1bGUgKGBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddYCkuXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGZ4IC0gRnVuY3Rpb24gaW1wbGVtZW50aW5nIHRoZSBydWxlJ3MgbG9naWMuXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGNvbmZpZ1RhYiAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gdGFiIGxvZ2ljIGZvciB0aGUgcnVsZS5cclxuICogXHJcbiAqIEBtZXRob2QgZnhcclxuICogQHBhcmFtIHtBcHAgfCB1bmRlZmluZWR9IGFwcCAtIFRoZSBhcHBsaWNhdGlvbiBpbnN0YW5jZSAob3B0aW9uYWwpLlxyXG4gKiBAcGFyYW0ge1RGaWxlfSBmaWxlIC0gVGhlIGZpbGUgb2JqZWN0IGNvbnRhaW5pbmcgcGF0aCBhbmQgYmFzZW5hbWUgaW5mb3JtYXRpb24uXHJcbiAqIEBwYXJhbSB7U2NyaXB0aW5nVG9vbHN9IHRvb2xzIC0gVXRpbGl0eSB0b29scyBmb3Igc2NyaXB0aW5nLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSB0cmFuc2Zvcm1lZCBmaWxlIHBhdGguXHJcbiAqIFxyXG4gKiBAbWV0aG9kIGNvbmZpZ1RhYlxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBvcHRpb25FTCAtIFRoZSBIVE1MIGVsZW1lbnQgZm9yIHRoZSBjb25maWd1cmF0aW9uIHRhYi5cclxuICogQHBhcmFtIHtGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzfSBydWxlIC0gVGhlIHJ1bGUgc2V0dGluZ3Mgb2JqZWN0LlxyXG4gKiBAcGFyYW0ge2FueX0gdGhhdCAtIFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBjb250ZXh0LlxyXG4gKiBAcGFyYW0ge2FueX0gcHJldmlld0NvbXBvbmVudCAtIENvbXBvbmVudCBmb3IgcHJldmlld2luZyBjaGFuZ2VzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVCdWlsZEluRnVsbFBhdGhFeHRGb2xkZXJOb3RlcyBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlkID0gJ2Z1bGxQYXRoRXh0Rm9sZGVyTm90ZXMnO1xyXG4gICAgICAgIHRoaXMucnVsZVR5cGUgPSAnYnVpbGRJbic7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ0Z1bGwgUGF0aCB3aXRoIEV4dGVuc2lvbiAoY29tcGx5IHdpdGggXCJmb2xkZXIgbm90ZXNcIiknO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnUGF0aCB3aXRoIEV4dGVuc2lvbnMgY29tcGF0aWJsZSB3aXRoIGZvbGRlciBub3Rlcy4nO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIGxldCBwYXJ0cyA9IGZpbGUucGF0aC5zcGxpdCgnLycpO1xcbiAgcGFydHMucG9wKCk7XFxuICBpZiAocGFydHNbcGFydHMubGVuZ3RoLTFdID09PSBmaWxlLmJhc2VuYW1lKSBwYXJ0cy5wb3AoKTtcXG4gIHBhcnRzLnB1c2goZmlsZS5iYXNlbmFtZSk7XFxuICByZXR1cm4gcGFydHMuam9pbignLycpO1xcbn07XCI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAgICAgbGV0IHBhcnRzID0gZmlsZS5wYXRoLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgcGFydHMucG9wKCk7IC8vIHJlbW92ZSBmaWxlIG5hbWVcclxuICAgICAgICBpZiAocGFydHNbcGFydHMubGVuZ3RoLTFdID09PSBmaWxlLmJhc2VuYW1lKSBwYXJ0cy5wb3AoKTsgLy8gcmVtb3ZlIHBhcmVudCBmb2xkZXIgaWYgc2FtZSBuYW1lIGFzIHRoZSBmaWxlXHJcbiAgICAgICAgcGFydHMucHVzaChmaWxlLm5hbWUpOyAvLyBhZGQgdGhlIGZpbGUgbmFtZSBiYWNrXHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJy8nKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25maWdUYWIgKG9wdGlvbkVMOiBIVE1MRWxlbWVudCwgcnVsZTpGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCB0aGF0OmFueSwgcHJldmlld0NvbXBvbmVudDogYW55KSB7XHJcbiAgICAgICAgLy8gQ29uZmlndXJhdGlvbiB0YWIgbG9naWMgY2FuIGJlIGFkZGVkIGhlcmUgaWYgbmVlZGVkXHJcbiAgICB9O1xyXG4gICAgXHJcbn0iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG4vKipcclxuICogQSBidWlsdC1pbiBydWxlIGZvciBnZW5lcmF0aW5nIGEgZnVsbCBwYXRoIGNvbXBhdGlibGUgd2l0aCBcImZvbGRlciBub3Rlc1wiIHBsdWdpbi5cclxuICogXHJcbiAqIFRoaXMgcnVsZSBwcm9jZXNzZXMgYSBmaWxlJ3MgcGF0aCBzdWNoIHRoYXQ6XHJcbiAqIC0gVGhlIGZpbGUgbmFtZSBpcyByZW1vdmVkIGZyb20gdGhlIHBhdGguXHJcbiAqIC0gSWYgdGhlIHBhcmVudCBmb2xkZXIgaGFzIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGZpbGUsIGl0IGlzIGFsc28gcmVtb3ZlZC5cclxuICogLSBUaGUgZmlsZSdzIGJhc2UgbmFtZSBpcyBhcHBlbmRlZCB0byB0aGUgcmVzdWx0aW5nIHBhdGguXHJcbiAqIFxyXG4gKiBUaGUgcmVzdWx0aW5nIHBhdGggaXMgc3VpdGFibGUgZm9yIHVzZSBjYXNlcyB3aGVyZSBmb2xkZXIgbm90ZXMgYXJlIHVzZWQsIGVuc3VyaW5nIGNvbXBhdGliaWxpdHkuXHJcbiAqIFxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqIFxyXG4gKiBAcmVtYXJrc1xyXG4gKiAtIFRoZSBgZnhgIG1ldGhvZCBpbXBsZW1lbnRzIHRoZSBjb3JlIGxvZ2ljIGZvciBwYXRoIHRyYW5zZm9ybWF0aW9uLlxyXG4gKiAtIFRoZSBgY29uZmlnVGFiYCBtZXRob2QgY2FuIGJlIGV4dGVuZGVkIHRvIHByb3ZpZGUgYSBjb25maWd1cmF0aW9uIFVJLlxyXG4gKiBcclxuICogQGV4YW1wbGVcclxuICogLy8gRm9yIGEgZmlsZSBhdCBcImZvbGRlcjEvZm9sZGVyMi9ub3RlL25vdGUubWRcIlxyXG4gKiAvLyBUaGUgcmVzdWx0aW5nIHBhdGggd2lsbCBiZSBcImZvbGRlcjEvZm9sZGVyMi9ub3RlXCJcclxuICogXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJ1bGVUeXBlIC0gVHlwZSBvZiB0aGUgcnVsZSwgc2V0IHRvICdidWlsZEluJy5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBIdW1hbi1yZWFkYWJsZSBuYW1lIGZvciB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uIC0gRGVzY3JpcHRpb24gb2YgdGhlIHJ1bGUncyBwdXJwb3NlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc291cmNlIC0gU3RyaW5naWZpZWQgZnVuY3Rpb24gc291cmNlIGZvciBzY3JpcHRpbmcuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHR5cGUgLSBTdXBwb3J0ZWQgdHlwZXMgZm9yIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge2FueVtdfSBjb25maWdFbGVtZW50cyAtIENvbmZpZ3VyYXRpb24gZWxlbWVudHMgZm9yIHRoZSBydWxlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVCdWlsZEluRnVsbFBhdGhGb2xkZXJOb3RlcyBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlkID0gJ2Z1bGxQYXRoRm9sZGVyTm90ZXMnO1xyXG4gICAgICAgIHRoaXMucnVsZVR5cGUgPSAnYnVpbGRJbic7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ0Z1bGwgUGF0aCAoY29tcGx5IHdpdGggXCJmb2xkZXIgbm90ZXNcIiknO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnUGF0aCBjb21wYXRpYmxlIGNvbXBhdGlibGUgd2l0aCBmb2xkZXIgbm90ZXMuJztcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBsZXQgcGFydHMgPSBmaWxlLnBhdGguc3BsaXQoJy8nKTtcXG4gIHBhcnRzLnBvcCgpO1xcbiAgaWYgKHBhcnRzW3BhcnRzLmxlbmd0aC0xXSA9PT0gZmlsZS5iYXNlbmFtZSkgcGFydHMucG9wKCk7XFxuICBwYXJ0cy5wdXNoKGZpbGUuYmFzZW5hbWUpO1xcbiAgcmV0dXJuIHBhcnRzLmpvaW4oJy8nKTtcXG59O1wiO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICAgICAgdGhpcy5jb25maWdFbGVtZW50cyA9IHRoaXMuZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnggKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBURmlsZSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIGxldCBwYXJ0cyA9IGZpbGUucGF0aC5zcGxpdCgnLycpO1xyXG4gICAgICAgIHBhcnRzLnBvcCgpOyAvLyByZW1vdmUgZmlsZSBuYW1lXHJcbiAgICAgICAgaWYgKHBhcnRzW3BhcnRzLmxlbmd0aC0xXSA9PT0gZmlsZS5iYXNlbmFtZSkgcGFydHMucG9wKCk7IC8vIHJlbW92ZSBwYXJlbnQgZm9sZGVyIGlmIHNhbWUgbmFtZSBhcyB0aGUgZmlsZVxyXG4gICAgICAgIHBhcnRzLnB1c2goZmlsZS5iYXNlbmFtZSk7IC8vIGFkZCB0aGUgZmlsZSBuYW1lIGJhY2tcclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbignLycpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbmZpZ1RhYiAob3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOkZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIHRoYXQ6YW55LCBwcmV2aWV3Q29tcG9uZW50OiBhbnkpIHtcclxuICAgICAgICAvLyBDb25maWd1cmF0aW9uIHRhYiBsb2dpYyBjYW4gYmUgYWRkZWQgaGVyZSBpZiBuZWVkZWRcclxuICAgIH07XHJcbiAgICBcclxufSIsICIgIGltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIFByb3BlcnR5VHlwZUluZm8gfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuaW1wb3J0IHsgQXBwLCBTZXR0aW5nLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBidWlsdC1pbiBydWxlIGZvciByZXRyaWV2aW5nIGEgcHJvcGVydHkgdmFsdWUgZnJvbSB0aGUgZnJvbnRtYXR0ZXIgb2YgYSBmaWxlLlxyXG4gKiBcclxuICogVGhpcyBydWxlIGFsbG93cyB1c2VycyB0byBzZWxlY3QgYSBwcm9wZXJ0eSAoc3VjaCBhcyB0ZXh0LCB0YWdzLCBhbGlhc2VzLCBvciBtdWx0aXRleHQpIGFuZCByZXRyaWV2ZSBpdHMgdmFsdWVcclxuICogZnJvbSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGZpbGUncyBmcm9udG1hdHRlci4gVGhlIHJ1bGUgcHJvdmlkZXMgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBzZWxlY3RpbmcgdGhlIHByb3BlcnR5LFxyXG4gKiBhbmQgZXhwb3NlcyBhIGZ1bmN0aW9uIChgZnhgKSB0aGF0IHBlcmZvcm1zIHRoZSByZXRyaWV2YWwuXHJcbiAqIFxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqIFxyXG4gKiBAcmVtYXJrc1xyXG4gKiAtIFRoZSBydWxlIGlzIGlkZW50aWZpZWQgYnkgdGhlIElEICdnZXRQcm9wZXJ0eScgYW5kIGlzIGNhdGVnb3JpemVkIGFzIGEgYnVpbHQtaW4gcnVsZS5cclxuICogLSBUaGUgY29uZmlndXJhdGlvbiB0YWIgYWxsb3dzIHVzZXJzIHRvIHNlbGVjdCB3aGljaCBwcm9wZXJ0eSB0byByZXRyaWV2ZS5cclxuICogLSBUaGUgYGZ4YCBtZXRob2QgaXMgdGhlIG1haW4gbG9naWMgZm9yIGV4dHJhY3RpbmcgdGhlIHByb3BlcnR5IHZhbHVlLlxyXG4gKiBcclxuICogQGV4YW1wbGVcclxuICogLy8gVXNhZ2Ugd2l0aGluIHRoZSBwbHVnaW4ncyBydWxlIHN5c3RlbTpcclxuICogY29uc3QgcnVsZSA9IG5ldyBSdWxlQnVpbGRJbkdldFByb3BlcnR5KCk7XHJcbiAqIGNvbnN0IHZhbHVlID0gcnVsZS5meChhcHAsIGZpbGUsIHRvb2xzKTtcclxuICogXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHJ1bGUgKCdnZXRQcm9wZXJ0eScpLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcnVsZVR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgcnVsZSAoJ2J1aWxkSW4nKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGVzY3JpcHRpb24gLSBBIGJyaWVmIGRlc2NyaXB0aW9uIG9mIHRoZSBydWxlJ3MgcHVycG9zZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gdHlwZSAtIFRoZSB0eXBlcyBvZiBwcm9wZXJ0aWVzIHRoaXMgcnVsZSBjYW4gaGFuZGxlLlxyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBmeCAtIFRoZSBmdW5jdGlvbiB0aGF0IHJldHJpZXZlcyB0aGUgcHJvcGVydHkgdmFsdWUuXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGNvbmZpZ1RhYiAtIFRoZSBmdW5jdGlvbiB0aGF0IHJlbmRlcnMgdGhlIGNvbmZpZ3VyYXRpb24gVUkgZm9yIHRoZSBydWxlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVCdWlsZEluR2V0UHJvcGVydHkgZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLmlkID0gJ2dldFByb3BlcnR5JztcclxuICAgIHRoaXMucnVsZVR5cGUgPSAnYnVpbGRJbic7XHJcbiAgICB0aGlzLm5hbWUgPSAnR2V0IHByb3BlcnR5JztcclxuICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnR2V0cyBhIHByb3BlcnR5IGZyb20gc2VsZWN0ZWQgcHJvcGVydHkuJztcclxuICAgIHRoaXMuc291cmNlID0gXCJmdW5jdGlvbihhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogVEZpbGUsIHRvb2xzOiBTY3JpcHRpbmdUb29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSEgXFxuIGNvbnN0IHByb3BlcnR5SWQgPSB0b29scy5nZXRPcHRpb25Db25maWcodG9vbHMuZ2V0UnVsZSgpPy5pZCwnaW5wdXRQcm9wZXJ0eScpOyBcXG4gaWYgKHByb3BlcnR5SWQgPT09IHVuZGVmaW5lZCB8fCBwcm9wZXJ0eUlkID09PSAnJykgeyBcXG4gcmV0dXJuICdQcm9wZXJ0eSBub3Qgc2V0JzsgXFxuIH0gXFxuIGNvbnN0IHJlc3VsdCA9IHRvb2xzLmdldEZyb250bWF0dGVyUHJvcGVydHkocHJvcGVydHlJZCk7IFxcbiBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHsgXFxuIHJldHVybiAnUHJvcGVydHkgbm90IGZvdW5kJzsgXFxuIH0gXFxuIHJldHVybiByZXN1bHQ7IFxcbiB9XCI7XHJcbiAgICB0aGlzLnR5cGUgPSBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddO1xyXG4gICAgdGhpcy5jb25maWdFbGVtZW50cyA9IHRoaXMuZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KTtcclxuICB9XHJcbiAgXHJcbiAgZnggKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBURmlsZSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgY29uc3QgcHJvcGVydHlJZCA9IHRvb2xzLmdldE9wdGlvbkNvbmZpZyh0b29scy5nZXRSdWxlKCk/LmlkLCdpbnB1dFByb3BlcnR5Jyk7XHJcbiAgICBpZiAocHJvcGVydHlJZCA9PT0gdW5kZWZpbmVkIHx8IHByb3BlcnR5SWQgPT09ICcnKSB7XHJcbiAgICAgIHJldHVybiAnUHJvcGVydHkgbm90IHNldCc7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXN1bHQgPSB0b29scy5nZXRGcm9udG1hdHRlclByb3BlcnR5KHByb3BlcnR5SWQpO1xyXG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiAnUHJvcGVydHkgbm90IGZvdW5kJztcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBjb25maWdUYWIgKG9wdGlvbkVMOiBIVE1MRWxlbWVudCwgcnVsZTpGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCB0aGF0OmFueSwgcHJldmlld0NvbXBvbmVudDogYW55KSB7XHJcbiAgICAvLyBDb25maWd1cmF0aW9uIHRhYiBsb2dpYyBjYW4gYmUgYWRkZWQgaGVyZSBpZiBuZWVkZWRcclxuICAgIC8vIENyZWF0ZSBhIHNldHRpbmcgZm9yIHRoZSBjb25zdGFudCB2YWx1ZVxyXG4gICAgdGhhdC5zZXRPcHRpb25Db25maWdEZWZhdWx0cyhydWxlLmlkLCB7XHJcbiAgICAgICAgaW5wdXRQcm9wZXJ0eTogJycsXHJcbiAgICB9KVxyXG4gICAgbGV0IGlucHV0UHJvcGVydGllc0Ryb3Bkb3duOmFueTtcclxuICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgIC5zZXROYW1lKCdJbnB1dCBQcm9wZXJ0eScpXHJcbiAgICAgICAgLnNldERlc2MoJ1NlbGVjdCBhIHByb3BlcnR5IGFzIGlucHV0JylcclxuICAgICAgICAuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4ge1xyXG4gICAgICAgICAgICBpbnB1dFByb3BlcnRpZXNEcm9wZG93biA9IGRyb3Bkb3duO1xyXG4gICAgICAgICAgICBkcm9wZG93blxyXG4gICAgICAgICAgICAuc2V0VmFsdWUodGhhdC5nZXRPcHRpb25Db25maWcocnVsZS5pZCAsJ2lucHV0UHJvcGVydHknKSB8fCAnJylcclxuICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQsJ2lucHV0UHJvcGVydHknLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZVByZXZpZXcocnVsZSwgcHJldmlld0NvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIE9iamVjdC5rZXlzKHRoYXQua25vd25Qcm9wZXJ0aWVzKS5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgICAgICAvL2lucHV0UHJvcGVydGllc0Ryb3Bkb3duLmFkZE9wdGlvbihpdGVtWzFdLm5hbWUsaXRlbVsxXS5uYW1lKTtcclxuICAgICAgICBjb25zdCBpdGVtID0gdGhhdC5rbm93blByb3BlcnRpZXNba2V5XSBhcyBQcm9wZXJ0eVR5cGVJbmZvO1xyXG4gICAgICAgIGlucHV0UHJvcGVydGllc0Ryb3Bkb3duLmFkZE9wdGlvbihpdGVtLm5hbWUsIGl0ZW0ubmFtZSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG59IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MgfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBSdWxlQnVpbGRJbklzUm9vdCBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlkID0gJ2lzUm9vdCc7XHJcbiAgICAgICAgdGhpcy5ydWxlVHlwZSA9ICdidWlsZEluJztcclxuICAgICAgICB0aGlzLm5hbWUgPSAnRmlsZSBpbiBSb290IGZvbGRlcic7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdDaGVjayBpZiB0aGUgZmlsZSBpcyBpbiB0aGUgcm9vdCBmb2xkZXIuJztcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBsZXQgcGFydHMgPSBmaWxlLnBhdGguc3BsaXQoJy8nKTtcXG4gIHJldHVybiBwYXJ0cy5sZW5ndGggPT09IDE7XFxufTtcIjtcclxuICAgICAgICB0aGlzLnR5cGUgPSBbJ2NoZWNrYm94J107XHJcbiAgICAgICAgdGhpcy5jb25maWdFbGVtZW50cyA9IHRoaXMuZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnggKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBURmlsZSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIGxldCBwYXJ0cyA9IGZpbGUucGF0aC5zcGxpdCgnLycpO1xyXG4gICAgICAgIHJldHVybiBwYXJ0cy5sZW5ndGggPT09IDE7XHJcbiAgICB9XHJcblxyXG4gICAgY29uZmlnVGFiIChvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6RnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDphbnksIHByZXZpZXdDb21wb25lbnQ6IGFueSkge1xyXG4gICAgICAgIC8vIENvbmZpZ3VyYXRpb24gdGFiIGxvZ2ljIGNhbiBiZSBhZGRlZCBoZXJlIGlmIG5lZWRlZFxyXG4gICAgfTtcclxuICAgIFxyXG59IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MgfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuaW1wb3J0IHsgQXBwLCBTZXR0aW5nLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBidWlsdC1pbiBydWxlIGZvciBjcmVhdGluZyBhIGxpbmsgdG8gYSBmaWxlIGluIHRoZSBjdXJyZW50IHZhdWx0LlxyXG4gKiBUaGlzIHJ1bGUgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gaW5jbHVkZSBvciBleGNsdWRlIHRoZSBmaWxlIGV4dGVuc2lvbiBpbiB0aGUgZ2VuZXJhdGVkIGxpbmsuXHJcbiAqXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICpcclxuICogQHJlbWFya3NcclxuICogLSBUaGUgcnVsZSBnZW5lcmF0ZXMgYSBsaW5rIGluIHRoZSBmb3JtYXQgYFtbcGF0aC90by9maWxlfGZpbGVOYW1lXV1gLlxyXG4gKiAtIFRoZSBgYWRkRXh0ZW5zaW9uYCBvcHRpb24gZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBmaWxlIGV4dGVuc2lvbiBpcyBpbmNsdWRlZCBpbiB0aGUgbGluay5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogLy8gRXhhbXBsZSBvdXRwdXQgd2l0aCBgYWRkRXh0ZW5zaW9uYCBzZXQgdG8gdHJ1ZTpcclxuICogW1twYXRoL3RvL2ZpbGUubWR8ZmlsZV1dXHJcbiAqXHJcbiAqIC8vIEV4YW1wbGUgb3V0cHV0IHdpdGggYGFkZEV4dGVuc2lvbmAgc2V0IHRvIGZhbHNlOlxyXG4gKiBbW3BhdGgvdG8vZmlsZXxmaWxlXV1cclxuICpcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcnVsZSAoYGxpbmtUb0ZpbGVgKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJ1bGVUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIHJ1bGUgKGBidWlsZEluYCkuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgcnVsZSAoYENyZWF0ZSBsaW5rIHRvIGZpbGVgKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uIC0gQSBicmllZiBkZXNjcmlwdGlvbiBvZiB0aGUgcnVsZSdzIGZ1bmN0aW9uYWxpdHkuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBUaGUgc291cmNlIGNvZGUgb2YgdGhlIHJ1bGUncyBtYWluIGZ1bmN0aW9uLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSB0eXBlIC0gVGhlIHR5cGVzIG9mIGNvbnRlbnQgdGhpcyBydWxlIGFwcGxpZXMgdG8gKGB0ZXh0YCwgYHRhZ3NgLCBgYWxpYXNlc2AsIGBtdWx0aXRleHRgKS5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZnggLSBUaGUgbWFpbiBmdW5jdGlvbiB0aGF0IGdlbmVyYXRlcyB0aGUgbGluayB0byB0aGUgZmlsZS5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gY29uZmlnVGFiIC0gVGhlIGNvbmZpZ3VyYXRpb24gVUkgZm9yIHRoZSBydWxlLCBhbGxvd2luZyB1c2VycyB0byB0b2dnbGUgdGhlIGBhZGRFeHRlbnNpb25gIG9wdGlvbi5cclxuICpcclxuICogQG1ldGhvZCBkZWZhdWx0Q29uZmlnRWxlbWVudHNcclxuICogUmV0dXJucyB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIGVsZW1lbnRzIGZvciB0aGUgcnVsZS5cclxuICpcclxuICogQHBhcmFtIHtBcHB9IGFwcCAtIFRoZSBPYnNpZGlhbiBhcHBsaWNhdGlvbiBpbnN0YW5jZS5cclxuICogQHBhcmFtIHtURmlsZX0gZmlsZSAtIFRoZSBmaWxlIGZvciB3aGljaCB0aGUgbGluayBpcyBiZWluZyBnZW5lcmF0ZWQuXHJcbiAqIEBwYXJhbSB7U2NyaXB0aW5nVG9vbHN9IHRvb2xzIC0gVXRpbGl0eSB0b29scyBmb3Igc2NyaXB0aW5nIGFuZCBydWxlIG1hbmFnZW1lbnQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZUJ1aWxkSW5MaW5rVG9GaWxlIGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaWQgPSAnbGlua1RvRmlsZSc7XHJcbiAgICAgICAgdGhpcy5ydWxlVHlwZSA9ICdidWlsZEluJztcclxuICAgICAgICB0aGlzLm5hbWUgPSAnQ3JlYXRlIGxpbmsgdG8gZmlsZSc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdDcmVhdGUgYSBsaW5rIHRvIHRoZSBmaWxlIGluIHRoZSBjdXJyZW50IHZhdWx0LiBDYW4gYmUgY29uZmlndXJlZCB0byBpbmNsdWRlIHRoZSBmaWxlIGV4dGVuc2lvbi4nO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIGNvbnN0IHBhcnRzID0gZmlsZS5wYXRoLnNwbGl0KCcvJyk7XFxuICBjb25zdCBydWxlID0gdG9vbHMuZ2V0UnVsZSgpO1xcbiAgaWYgKCFydWxlKSByZXR1cm4gdG9vbHMuZ2V0Q3VycmVudENvbnRlbnQoKTtcXG4gIGNvbnN0IGFkZEV4dGVuc2lvbiA9IHRvb2xzLmdldE9wdGlvbkNvbmZpZyhydWxlLmlkLCdhZGRFeHRlbnNpb24nKSBcXG4gIHBhcnRzLnBvcCgpO1xcbiAgaWYgKHBhcnRzW3BhcnRzLmxlbmd0aC0xXSA9PT0gZmlsZS5iYXNlbmFtZSkgcGFydHMucG9wKCk7XFxuICBsZXQgZmlsZU5hbWUgPSBhZGRFeHRlbnNpb24/IGZpbGUuYmFzZW5hbWUgKyAnLicgKyBmaWxlLmV4dGVuc2lvbiA6IGZpbGUuYmFzZW5hbWU7IFxcbiAgcmV0dXJuIGBbWyR7cGFydHMuam9pbignLycpfS8ke2ZpbGVOYW1lfXwke2ZpbGUuYmFzZW5hbWV9XV1gO1xcbn07XCI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gICAgfTtcclxuICAgIGZ4IChhcHA6IEFwcCwgZmlsZTpURmlsZSwgdG9vbHM6U2NyaXB0aW5nVG9vbHMpe1xyXG4gICAgICAgIGNvbnN0IHBhcnRzID0gZmlsZS5wYXRoLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgY29uc3QgcnVsZSA9IHRvb2xzLmdldFJ1bGUoKTtcclxuICAgICAgICBpZiAoIXJ1bGUpIHJldHVybiB0b29scy5nZXRDdXJyZW50Q29udGVudCgpO1xyXG4gICAgICAgIGNvbnN0IGFkZEV4dGVuc2lvbiA9IHRvb2xzLmdldE9wdGlvbkNvbmZpZyhydWxlLmlkLCdhZGRFeHRlbnNpb24nKSBcclxuICAgICAgICBwYXJ0cy5wb3AoKTtcclxuICAgICAgICBpZiAocGFydHNbcGFydHMubGVuZ3RoLTFdID09PSBmaWxlLmJhc2VuYW1lKSBwYXJ0cy5wb3AoKTtcclxuICAgICAgICBsZXQgZmlsZU5hbWUgPSBhZGRFeHRlbnNpb24/IGZpbGUuYmFzZW5hbWUgKyAnLicgKyBmaWxlLmV4dGVuc2lvbiA6IGZpbGUuYmFzZW5hbWU7IFxyXG4gICAgICAgIHJldHVybiBgW1ske3BhcnRzLmpvaW4oJy8nKX0vJHtmaWxlTmFtZX18JHtmaWxlLmJhc2VuYW1lfV1dYDtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGNvbmZpZ1RhYiAob3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOkZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIHRoYXQ6YW55LCBwcmV2aWV3Q29tcG9uZW50OiBhbnkpIHtcclxuICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZ0RlZmF1bHRzKHJ1bGUuaWQsIHtcclxuICAgICAgICAgICAgYWRkRXh0ZW5zaW9uOiB0cnVlXHJcbiAgICAgICAgfSlcclxuICAgIFxyXG4gICAgICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnSW5jbHVkZSBmaWxlIGV4dGVuc2lvbicpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdBZGQgZmlsZSBleHRlbnNpb24gdG8gcGF0aG5hbWUnKVxyXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGF0LmdldE9wdGlvbkNvbmZpZyhydWxlLmlkICwnYWRkRXh0ZW5zaW9uJykgfHwgZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWcocnVsZS5pZCwnYWRkRXh0ZW5zaW9uJywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudXBkYXRlUHJldmlldyhydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICk7XHJcbiAgICB9O1xyXG59IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MgfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBBIHJ1bGUgdGhhdCBleHRyYWN0cyB0aGUgZmlsZSBuYW1lIHdpdGhvdXQgaXRzIGV4dGVuc2lvbi5cclxuICpcclxuICogQHJlbWFya3NcclxuICogVGhpcyBydWxlIGlzIGludGVuZGVkIGZvciB1c2Ugd2l0aGluIHRoZSBGb2xkZXIgdG8gVGFncyBPYnNpZGlhbiBwbHVnaW4uXHJcbiAqIEl0IHByb3ZpZGVzIGEgd2F5IHRvIHJldHJpZXZlIHRoZSBiYXNlIG5hbWUgb2YgYSBmaWxlLCBleGNsdWRpbmcgYWxsIGV4dGVuc2lvbnMuXHJcbiAqXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICpcclxuICogQGV4YW1wbGVcclxuICogLy8gR2l2ZW4gYSBmaWxlIG5hbWVkIFwiZXhhbXBsZS5ub3RlLm1kXCIsIHRoZSBydWxlIHdpbGwgcmV0dXJuIFwiZXhhbXBsZVwiLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBydWxlIChcIm5hbWVcIikuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBydWxlVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBydWxlIChcImJ1aWxkSW5cIikuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uIC0gQSBicmllZiBkZXNjcmlwdGlvbiBvZiB0aGUgcnVsZSdzIHB1cnBvc2UuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBUaGUgc291cmNlIG9mIHRoZSBydWxlIChlbXB0eSBmb3IgYnVpbHQtaW4pLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSB0eXBlIC0gVGhlIHR5cGVzIHRoaXMgcnVsZSBhcHBsaWVzIHRvIChlLmcuLCB0ZXh0LCB0YWdzKS5cclxuICogQHByb3BlcnR5IHthbnlbXX0gY29uZmlnRWxlbWVudHMgLSBUaGUgY29uZmlndXJhdGlvbiBlbGVtZW50cyBmb3IgdGhlIHJ1bGUuXHJcbiAqXHJcbiAqIEBtZXRob2QgZnhcclxuICogUmV0dXJucyB0aGUgZmlsZSBuYW1lIHdpdGhvdXQgaXRzIGV4dGVuc2lvbiB1c2luZyB0aGUgcHJvdmlkZWQgc2NyaXB0aW5nIHRvb2xzLlxyXG4gKlxyXG4gKiBAbWV0aG9kIGNvbmZpZ1RhYlxyXG4gKiAoT3B0aW9uYWwpIFByb3ZpZGVzIGEgY29uZmlndXJhdGlvbiB0YWIgZm9yIHRoZSBydWxlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVCdWlsZEluTmFtZSBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuaWQgPSAnbmFtZSc7XHJcbiAgICB0aGlzLnJ1bGVUeXBlID0gJ2J1aWxkSW4nO1xyXG4gICAgdGhpcy5uYW1lID0gJ0ZpbGUgbmFtZSB3aXRob3V0IGV4dGVuc2lvbic7XHJcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gJ1JldHVybnMgdGhlIGZpbGUgbmFtZSB3aXRob3V0IGFsbCBleHRlbnNpb25zLiBJLmUuIGV4YW1wbGUubm90ZS5tZCA9PiBleGFtcGxlJztcclxuICAgIHRoaXMuc291cmNlID0gXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIC8vIGFjcXVpcmUgZmlsZSBuYW1lXFxuICBjb25zdCByZXN1bHQgPSB0b29scy5yZW1vdmVBbGxFeHRlbnNpb25zKGZpbGUubmFtZSk7XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIjtcclxuICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gIH1cclxuICBcclxuICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAvLyBhY3F1aXJlIGZpbGUgbmFtZVxyXG4gICAgY29uc3QgcmVzdWx0ID0gdG9vbHMucmVtb3ZlQWxsRXh0ZW5zaW9ucyhmaWxlLm5hbWUpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIGNvbmZpZ1RhYiAob3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOkZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIHRoYXQ6YW55LCBwcmV2aWV3Q29tcG9uZW50OiBhbnkpIHtcclxuICAgIC8vIENvbmZpZ3VyYXRpb24gdGFiIGxvZ2ljIGNhbiBiZSBhZGRlZCBoZXJlIGlmIG5lZWRlZFxyXG4gIH07XHJcbiAgICBcclxufSIsICIgIGltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MgfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuLyoqXHJcbiAqIEEgYnVpbHQtaW4gcnVsZSB0aGF0IHJldHVybnMgdGhlIGZpbGUgbmFtZSB3aXRoIGl0cyBleHRlbnNpb24uXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFRoaXMgcnVsZSBpcyBwYXJ0IG9mIHRoZSBmb2xkZXItdG8tdGFncy1wbHVnaW4gYW5kIGV4dGVuZHMgdGhlIHtAbGluayBSdWxlUHJvdG90eXBlfS5cclxuICogSXQgaXMgaWRlbnRpZmllZCBieSB0aGUgSUQgYCduYW1lRXh0J2AgYW5kIGlzIGNhdGVnb3JpemVkIGFzIGEgYnVpbHQtaW4gcnVsZS5cclxuICogVGhlIHJ1bGUgY2FuIGJlIHVzZWQgaW4gY29udGV4dHMgcmVxdWlyaW5nIHRoZSBmaWxlIG5hbWUgaW5jbHVkaW5nIGl0cyBleHRlbnNpb24sXHJcbiAqIHN1Y2ggYXMgdGV4dCwgdGFncywgYWxpYXNlcywgb3IgbXVsdGl0ZXh0IGZpZWxkcy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogLy8gUmV0dXJucyBcImV4YW1wbGUubWRcIiBmb3IgYSBmaWxlIG5hbWVkIFwiZXhhbXBsZS5tZFwiXHJcbiAqIGNvbnN0IGZpbGVOYW1lV2l0aEV4dCA9IHJ1bGUuZngoYXBwLCBmaWxlLCB0b29scyk7XHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlQnVpbGRJbk5hbWVFeHQgZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLmlkID0gJ25hbWVFeHQnO1xyXG4gICAgdGhpcy5ydWxlVHlwZSA9ICdidWlsZEluJztcclxuICAgIHRoaXMubmFtZSA9ICdGaWxlIG5hbWUgd2l0aCBleHRlbnNpb24nO1xyXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdSZXR1cm5zIHRoZSBmaWxlIG5hbWUgd2l0aCBleHRlbnNpb24uJztcclxuICAgIHRoaXMuc291cmNlID0gXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIC8vIGFjcXVpcmUgZmlsZSBuYW1lIHdpdGggZXh0ZW5zaW9uXFxuICBjb25zdCByZXN1bHQgPSBmaWxlLm5hbWU7XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIjtcclxuICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gIH1cclxuICBcclxuICBwdWJsaWMgZnggKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBURmlsZSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgLy8gYWNxdWlyZSBmaWxlIG5hbWVcclxuICAgIGNvbnN0IHJlc3VsdCA9IGZpbGUubmFtZTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgY29uZmlnVGFiIChvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6RnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDphbnksIHByZXZpZXdDb21wb25lbnQ6IGFueSkge1xyXG4gICAgLy8gQ29uZmlndXJhdGlvbiB0YWIgbG9naWMgY2FuIGJlIGFkZGVkIGhlcmUgaWYgbmVlZGVkXHJcbiAgfTtcclxuICAgIFxyXG59IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MgfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBydWxlIHRoYXQgZXh0cmFjdHMgdGhlIGZvbGRlciBwYXRoIG9mIGEgZmlsZSBpbiBPYnNpZGlhbi5cclxuICogVGhpcyBydWxlIGlzIGJ1aWx0LWluIGFuZCBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IHRvIHJldHJpZXZlIHRoZSBmdWxsIHBhdGhcclxuICogb2YgdGhlIGZvbGRlciB3aGVyZSBhIGZpbGUgaXMgc3RvcmVkLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIC0gVGhlIHJ1bGUgaXMgaWRlbnRpZmllZCBieSB0aGUgYGlkYCBcInBhdGhcIi5cclxuICogLSBJdCBpcyBjYXRlZ29yaXplZCBhcyBhIFwiYnVpbGRJblwiIHJ1bGUgdHlwZS5cclxuICogLSBUaGUgcnVsZSBzdXBwb3J0cyBtdWx0aXBsZSB0eXBlczogYHRleHRgLCBgdGFnc2AsIGBhbGlhc2VzYCwgYW5kIGBtdWx0aXRleHRgLlxyXG4gKiAtIFRoZSBgc291cmNlYCBwcm9wZXJ0eSBjb250YWlucyB0aGUgZnVuY3Rpb24gZGVmaW5pdGlvbiBhcyBhIHN0cmluZywgd2hpY2ggc2hvdWxkIG5vdCBiZSBtb2RpZmllZC5cclxuICogLSBUaGUgYGZ4YCBwcm9wZXJ0eSBpbXBsZW1lbnRzIHRoZSBsb2dpYyB0byBleHRyYWN0IHRoZSBmb2xkZXIgcGF0aCBmcm9tIHRoZSBmaWxlJ3MgcGF0aC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogLy8gRXhhbXBsZSB1c2FnZSBvZiB0aGUgcnVsZTpcclxuICogY29uc3QgcnVsZSA9IG5ldyBSdWxlQnVpbGRJblBhdGgoKTtcclxuICogY29uc3QgZm9sZGVyUGF0aCA9IHJ1bGUuZngoYXBwLCBmaWxlLCB0b29scyk7XHJcbiAqIGNvbnNvbGUubG9nKGZvbGRlclBhdGgpOyAvLyBPdXRwdXRzIHRoZSBmb2xkZXIgcGF0aCBvZiB0aGUgZmlsZVxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBydWxlIChcInBhdGhcIikuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBydWxlVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBydWxlIChcImJ1aWxkSW5cIikuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgcnVsZSAoXCJGdWxsIHBhdGhcIikuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXNjcmlwdGlvbiAtIEEgYnJpZWYgZGVzY3JpcHRpb24gb2YgdGhlIHJ1bGUncyBmdW5jdGlvbmFsaXR5LlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc291cmNlIC0gVGhlIHNvdXJjZSBjb2RlIG9mIHRoZSBydWxlJ3MgZnVuY3Rpb24gYXMgYSBzdHJpbmcuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHR5cGUgLSBUaGUgc3VwcG9ydGVkIHR5cGVzIGZvciB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZnggLSBUaGUgZnVuY3Rpb24gdGhhdCBpbXBsZW1lbnRzIHRoZSBydWxlJ3MgbG9naWMuXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGNvbmZpZ1RhYiAtIEEgcGxhY2Vob2xkZXIgZm9yIGNvbmZpZ3VyaW5nIHRoZSBydWxlIGluIHRoZSBVSS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlQnVpbGRJblBhdGggZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9ICdwYXRoJztcclxuICAgICAgICB0aGlzLnJ1bGVUeXBlID0gJ2J1aWxkSW4nO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdGdWxsIHBhdGgnO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnUmV0dXJucyB0aGUgZm9sZGVyIHBhdGggdGhlIGZpbGUgaXMgc3RvcmVkIGluLic7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgbGV0IHBhcnRzID0gZmlsZS5wYXRoLnNwbGl0KCcvJyk7XFxuICBwYXJ0cy5wb3AoKTtcXG4gIHJldHVybiBwYXJ0cy5qb2luKCcvJyk7XFxufTtcIjtcclxuICAgICAgICB0aGlzLnR5cGUgPSBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddO1xyXG4gICAgICAgIHRoaXMuY29uZmlnRWxlbWVudHMgPSB0aGlzLmRlZmF1bHRDb25maWdFbGVtZW50cyh7fSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ4IChhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogVEZpbGUsIHRvb2xzOiBTY3JpcHRpbmdUb29scykge1xyXG4gICAgICAgIGxldCBwYXJ0cyA9IGZpbGUucGF0aC5zcGxpdCgnLycpO1xyXG4gICAgICAgIHBhcnRzLnBvcCgpO1xyXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKCcvJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbmZpZ1RhYiAob3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOkZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIHRoYXQ6YW55LCBwcmV2aWV3Q29tcG9uZW50OiBhbnkpIHtcclxuICAgICAgICAvLyBDb25maWd1cmF0aW9uIHRhYiBsb2dpYyBjYW4gYmUgYWRkZWQgaGVyZSBpZiBuZWVkZWRcclxuICAgIH07XHJcbn0iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGJ1aWx0LWluIHJ1bGUgZm9yIGhhbmRsaW5nIGZvbGRlciBub3RlcyBpbiBhIHBhdGgtY29tcGF0aWJsZSBtYW5uZXIuXHJcbiAqIFRoaXMgcnVsZSBwcm9jZXNzZXMgZmlsZSBwYXRocyB0byBkZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIGZvbGRlciBzdHJ1Y3R1cmUsXHJcbiAqIHJlbW92aW5nIHBhcmVudCBmb2xkZXJzIGlmIHRoZXkgc2hhcmUgdGhlIHNhbWUgbmFtZSBhcyB0aGUgZmlsZS5cclxuICpcclxuICogQGV4dGVuZHMgUnVsZVByb3RvdHlwZVxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiAtIFRoZSBgZnhgIG1ldGhvZCBpbXBsZW1lbnRzIHRoZSBjb3JlIGxvZ2ljIGZvciBwYXRoIG1hbmlwdWxhdGlvbi5cclxuICogLSBUaGUgYHNvdXJjZWAgcHJvcGVydHkgY29udGFpbnMgdGhlIHNlcmlhbGl6ZWQgZnVuY3Rpb24gbG9naWMgZm9yIGV4dGVybmFsIHVzZS5cclxuICogLSBUaGlzIHJ1bGUgaXMgZGVzaWduZWQgdG8gd29yayB3aXRoIHRleHQsIHRhZ3MsIGFsaWFzZXMsIGFuZCBtdWx0aXRleHQgdHlwZXMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIEV4YW1wbGUgdXNhZ2Ugb2YgdGhlIGBmeGAgbWV0aG9kOlxyXG4gKiBjb25zdCByZXN1bHQgPSBydWxlLmZ4KGFwcCwgZmlsZSwgdG9vbHMpO1xyXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQpOyAvLyBPdXRwdXRzIHRoZSBwcm9jZXNzZWQgcGF0aFxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBydWxlIChgcGF0aEZvbGRlck5vdGVzYCkuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBydWxlVHlwZSAtIFRoZSB0eXBlIG9mIHJ1bGUgKGBidWlsZEluYCkuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgcnVsZSAoYFBhdGggKGZvbGRlciBub3RlcylgKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uIC0gQSBicmllZiBkZXNjcmlwdGlvbiBvZiB0aGUgcnVsZSdzIHB1cnBvc2UuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBUaGUgc2VyaWFsaXplZCBmdW5jdGlvbiBsb2dpYyBmb3IgZXh0ZXJuYWwgdXNlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSB0eXBlIC0gVGhlIHR5cGVzIG9mIGRhdGEgdGhpcyBydWxlIGFwcGxpZXMgdG8gKGB0ZXh0YCwgYHRhZ3NgLCBgYWxpYXNlc2AsIGBtdWx0aXRleHRgKS5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gY29uZmlnVGFiIC0gQSBwbGFjZWhvbGRlciBmb3IgY29uZmlndXJhdGlvbiB0YWIgbG9naWMuXHJcbiAqXHJcbiAqIEBtZXRob2QgZnhcclxuICogUHJvY2Vzc2VzIHRoZSBmaWxlIHBhdGggdG8gZGV0ZXJtaW5lIHRoZSBhcHByb3ByaWF0ZSBmb2xkZXIgc3RydWN0dXJlLlxyXG4gKiBSZW1vdmVzIHRoZSBwYXJlbnQgZm9sZGVyIGlmIGl0IHNoYXJlcyB0aGUgc2FtZSBuYW1lIGFzIHRoZSBmaWxlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FwcCB8IHVuZGVmaW5lZH0gYXBwIC0gVGhlIGFwcGxpY2F0aW9uIGluc3RhbmNlIChvcHRpb25hbCkuXHJcbiAqIEBwYXJhbSB7VEZpbGV9IGZpbGUgLSBUaGUgZmlsZSBvYmplY3QgY29udGFpbmluZyBwYXRoIGFuZCBiYXNlbmFtZSBpbmZvcm1hdGlvbi5cclxuICogQHBhcmFtIHtTY3JpcHRpbmdUb29sc30gdG9vbHMgLSBVdGlsaXR5IHRvb2xzIGZvciBzY3JpcHRpbmcgb3BlcmF0aW9ucy5cclxuICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgcHJvY2Vzc2VkIHBhdGggYWZ0ZXIgYXBwbHlpbmcgdGhlIHJ1bGUgbG9naWMuXHJcbiAqXHJcbiAqIEBtZXRob2QgY29uZmlnVGFiXHJcbiAqIFBsYWNlaG9sZGVyIG1ldGhvZCBmb3IgYWRkaW5nIGNvbmZpZ3VyYXRpb24gdGFiIGxvZ2ljLlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogSW5pdGlhbGl6ZXMgdGhlIHJ1bGUgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMgYW5kIGNvbmZpZ3VyYXRpb24gZWxlbWVudHMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZUJ1aWxkSW5QYXRoRm9sZGVyTm90ZXMgZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9ICdwYXRoRm9sZGVyTm90ZXMnO1xyXG4gICAgICAgIHRoaXMucnVsZVR5cGUgPSAnYnVpbGRJbic7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ1BhdGggKGZvbGRlciBub3RlcyknO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnUGF0aCBjb21wYXRpYmxlIHdpdGggZm9sZGVyIG5vdGVzLic7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgbGV0IHBhcnRzID0gZmlsZS5wYXRoLnNwbGl0KCcvJyk7XFxuICBwYXJ0cy5wb3AoKTtcXG4gIGlmIChwYXJ0c1twYXJ0cy5sZW5ndGgtMV0gPT09IGZpbGUuYmFzZW5hbWUpIHBhcnRzLnBvcCgpOyAvLyByZW1vdmUgcGFyZW50IGZvbGRlciBpZiBzYW1lIG5hbWUgYXMgdGhlIGZpbGVcXG4gIHJldHVybiBwYXJ0cy5qb2luKCcvJyk7XFxufTtcIjtcclxuICAgICAgICB0aGlzLnR5cGUgPSBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddO1xyXG4gICAgICAgIHRoaXMuY29uZmlnRWxlbWVudHMgPSB0aGlzLmRlZmF1bHRDb25maWdFbGVtZW50cyh7fSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ4IChhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogVEZpbGUsIHRvb2xzOiBTY3JpcHRpbmdUb29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgICAgICBsZXQgcGFydHMgPSBmaWxlLnBhdGguc3BsaXQoJy8nKTtcclxuICAgICAgICBwYXJ0cy5wb3AoKTtcclxuICAgICAgICBpZiAocGFydHNbcGFydHMubGVuZ3RoLTFdID09PSBmaWxlLmJhc2VuYW1lKSBwYXJ0cy5wb3AoKTsgLy8gcmVtb3ZlIHBhcmVudCBmb2xkZXIgaWYgc2FtZSBuYW1lIGFzIHRoZSBmaWxlXHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJy8nKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25maWdUYWIgKG9wdGlvbkVMOiBIVE1MRWxlbWVudCwgcnVsZTpGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCB0aGF0OmFueSwgcHJldmlld0NvbXBvbmVudDogYW55KSB7XHJcbiAgICAgICAgLy8gQ29uZmlndXJhdGlvbiB0YWIgbG9naWMgY2FuIGJlIGFkZGVkIGhlcmUgaWYgbmVlZGVkXHJcbiAgICB9O1xyXG4gICAgXHJcbn0iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG4vKipcclxuICogUnVsZUJ1aWxkSW5Sb290Rm9sZGVyIGlzIGEgcnVsZSBpbXBsZW1lbnRhdGlvbiB0aGF0IGV4dHJhY3RzIHRoZSByb290IGZvbGRlciBuYW1lXHJcbiAqIGZyb20gdGhlIHBhdGggb2YgYSBnaXZlbiBmaWxlIGluIGFuIE9ic2lkaWFuIHZhdWx0LlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIC0gVGhlIHJ1bGUgaWRlbnRpZmllcyB0aGUgdG9wLWxldmVsIGRpcmVjdG9yeSAocm9vdCBmb2xkZXIpIHdoZXJlIHRoZSBmaWxlIGlzIHN0b3JlZC5cclxuICogLSBJZiB0aGUgZmlsZSBpcyBhdCB0aGUgcm9vdCBvZiB0aGUgdmF1bHQgKGkuZS4sIG5vdCBpbnNpZGUgYW55IGZvbGRlciksIGFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZC5cclxuICogLSBUaGUgcnVsZSBpcyBjYXRlZ29yaXplZCBhcyBhICdidWlsZEluJyB0eXBlIGFuZCBzdXBwb3J0cyBtdWx0aXBsZSBvdXRwdXQgdHlwZXM6ICd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsIGFuZCAnbXVsdGl0ZXh0Jy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogLy8gSWYgZmlsZS5wYXRoIGlzICdQcm9qZWN0cy9Ob3Rlcy9tZWV0aW5nLm1kJywgdGhlIHJ1bGUgcmV0dXJucyAnUHJvamVjdHMnLlxyXG4gKiAvLyBJZiBmaWxlLnBhdGggaXMgJ3JlYWRtZS5tZCcsIHRoZSBydWxlIHJldHVybnMgJycgKGVtcHR5IHN0cmluZykuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcHAgLSBUaGUgY3VycmVudCBPYnNpZGlhbiBBcHAgaW5zdGFuY2UgKG1heSBiZSB1bmRlZmluZWQpLlxyXG4gKiBAcGFyYW0gZmlsZSAtIFRoZSBURmlsZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBmaWxlIHdob3NlIHJvb3QgZm9sZGVyIGlzIHRvIGJlIGRldGVybWluZWQuXHJcbiAqIEBwYXJhbSB0b29scyAtIFNjcmlwdGluZ1Rvb2xzIHV0aWxpdHkgb2JqZWN0IGZvciBhZGRpdGlvbmFsIG9wZXJhdGlvbnMgKG5vdCB1c2VkIGluIHRoaXMgcnVsZSkuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFRoZSBuYW1lIG9mIHRoZSByb290IGZvbGRlciBhcyBhIHN0cmluZywgb3IgYW4gZW1wdHkgc3RyaW5nIGlmIHRoZSBmaWxlIGlzIGluIHRoZSB2YXVsdCByb290LlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVCdWlsZEluUm9vdEZvbGRlciBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuaWQgPSAncm9vdEZvbGRlcic7XHJcbiAgICB0aGlzLnJ1bGVUeXBlID0gJ2J1aWxkSW4nO1xyXG4gICAgdGhpcy5uYW1lID0gJ1Jvb3QgZm9sZGVyJztcclxuICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnUmV0dXJucyB0aGUgcm9vdCBmb2xkZXIgd2hlcmUgdGhlIGZpbGUgaXMgc3RvcmVkLic7XHJcbiAgICB0aGlzLnNvdXJjZSA9IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICAvLyBhY3F1aXJlIGZpbGUgcGF0aFxcbiAgY29uc3QgcGF0aCA9IGZpbGUucGF0aDtcXG4gIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLycpO1xcbiAgcmV0dXJuIHBhcnRzLmxlbmd0aCA+IDEgPyBwYXJ0c1swXSA6ICcnOyAvLyByZXR1cm4gcm9vdCBmb2xkZXIgb3IgZW1wdHkgc3RyaW5nIGlmIGluIHJvb3RcXG59XCI7XHJcbiAgICB0aGlzLnR5cGUgPSBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddO1xyXG4gICAgdGhpcy5jb25maWdFbGVtZW50cyA9IHRoaXMuZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KTtcclxuICB9XHJcbiAgXHJcbiAgZnggKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBURmlsZSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgLy8gYWNxdWlyZSBmaWxlIHBhdGhcclxuICAgIGNvbnN0IHBhdGggPSBmaWxlLnBhdGg7XHJcbiAgICBjb25zdCBwYXJ0cyA9IHBhdGguc3BsaXQoJy8nKTtcclxuICAgIGxldCByZXN1bHQgPSAnJztcclxuICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgIHJlc3VsdCA9IHBhcnRzWzBdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIGNvbmZpZ1RhYiAob3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOkZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIHRoYXQ6YW55LCBwcmV2aWV3Q29tcG9uZW50OmFueSkge1xyXG4gICAgICAvLyBDb25maWd1cmF0aW9uIHRhYiBsb2dpYyBjYW4gYmUgYWRkZWQgaGVyZSBpZiBuZWVkZWRcclxuICB9O1xyXG4gICAgXHJcbn0iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGJ1aWx0LWluIHJ1bGUgdGhhdCBwYXNzZXMgdGhlIGNvbnRlbnQgb2YgYSBmcm9udG1hdHRlciBwYXJhbWV0ZXIgdW5hbHRlcmVkLlxyXG4gKiBUaGlzIHJ1bGUgaXMgdXNlZCB0byByZXR1cm4gdGhlIGlucHV0IGNvbnRlbnQgd2l0aG91dCBhbnkgbW9kaWZpY2F0aW9ucy5cclxuICogXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICogXHJcbiAqIEByZW1hcmtzXHJcbiAqIC0gVGhlIGBmeGAgZnVuY3Rpb24gYW5kIGBzb3VyY2VgIHByb3BlcnR5IGFyZSBkZXNpZ25lZCB0byBwcm9jZXNzIHRoZSBpbnB1dCBjb250ZW50IGFuZCByZXR1cm4gaXQgYXMtaXMuXHJcbiAqIC0gVGhpcyBydWxlIHN1cHBvcnRzIG11bHRpcGxlIHR5cGVzIGluY2x1ZGluZyBgdGV4dGAsIGB0YWdzYCwgYGFsaWFzZXNgLCBhbmQgYG11bHRpdGV4dGAuXHJcbiAqIC0gVGhlIGBjb25maWdUYWJgIG1ldGhvZCBpcyBjdXJyZW50bHkgYSBwbGFjZWhvbGRlciBmb3IgY29uZmlndXJhdGlvbiBVSSBlbGVtZW50cy5cclxuICogXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHJ1bGUsIHNldCB0byBgJ2RlZmF1bHQnYC5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJ1bGVUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIHJ1bGUsIHNldCB0byBgJ2J1aWxkSW4nYC5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSBydWxlLCBzZXQgdG8gYCdQYXNzIHBhcmFtZXRlciB1bmFsdGVyZWQnYC5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uIC0gQSBicmllZiBkZXNjcmlwdGlvbiBvZiB0aGUgcnVsZSdzIGZ1bmN0aW9uYWxpdHkuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBUaGUgc291cmNlIGNvZGUgb2YgdGhlIHJ1bGUgYXMgYSBzdHJpbmcsIHVzZWQgZm9yIHNjcmlwdGluZyBwdXJwb3Nlcy5cclxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gdHlwZSAtIFRoZSBzdXBwb3J0ZWQgdHlwZXMgZm9yIHRoaXMgcnVsZSwgaW5jbHVkaW5nIGB0ZXh0YCwgYHRhZ3NgLCBgYWxpYXNlc2AsIGFuZCBgbXVsdGl0ZXh0YC5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZnggLSBUaGUgbWFpbiBmdW5jdGlvbiB0aGF0IHByb2Nlc3NlcyB0aGUgaW5wdXQgY29udGVudCBhbmQgcmV0dXJucyBpdCB1bmFsdGVyZWQuXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGNvbmZpZ1RhYiAtIEEgbWV0aG9kIGZvciByZW5kZXJpbmcgdGhlIGNvbmZpZ3VyYXRpb24gdGFiIGZvciB0aGUgcnVsZS5cclxuICogXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFJ1bGVCdWlsZEluRGVmYXVsdGAgY2xhc3MuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZUJ1aWxkSW5TY3JpcHQgZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9ICdzY3JpcHQnO1xyXG4gICAgICAgIHRoaXMucnVsZVR5cGUgPSAnYnVpbGRJbic7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ0phdmFTY3JpcHQgZnVuY3Rpb24gKGFkdmFuY2VkKSc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdJbXBsZW1lbnQgYSBKYXZhU2NyaXB0IGZ1bmN0aW9uIHRvIHByb2Nlc3MgdGhlIGlucHV0IGNvbnRlbnQuIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIHRoZSBwcm9jZXNzZWQgY29udGVudC4nO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIGNvbnN0IGlucHV0ID0gdG9vbHMuZ2V0Q3VycmVudENvbnRlbnQoKTsgLy8gR2V0IHRoZSBjdXJyZW50IGNvbnRlbnQgb2YgcHJvcGVydHlcXG4gIHJldHVybiBpbnB1dDsgLy8gUmV0dXJuIHRoZSBpbnB1dCB1bmFsdGVyZWRcXG59O1wiO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICAgICAgdGhpcy5jb25maWdFbGVtZW50cyA9IHRoaXMuZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnggKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBURmlsZSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIGNvbnN0IGlucHV0ID0gdG9vbHMuZ2V0Q3VycmVudENvbnRlbnQoKTsgLy8gR2V0IHRoZSBjdXJyZW50IGNvbnRlbnQgb2YgcHJvcGVydHlcclxuICAgICAgICByZXR1cm4gaW5wdXQ7IC8vIFJldHVybiB0aGUgaW5wdXQgdW5hbHRlcmVkXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbmZpZ1RhYiAob3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOkZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIHRoYXQ6YW55LCBwcmV2aWV3Q29tcG9uZW50OmFueSkge1xyXG4gICAgICAgIC8vIENvbmZpZ3VyYXRpb24gdGFiIGxvZ2ljIGNhbiBiZSBhZGRlZCBoZXJlIGlmIG5lZWRlZFxyXG4gICAgfTtcclxuICAgIFxyXG59IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEFwcCwgU2V0dGluZywgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5pbXBvcnQgeyBFUlJPUiwgbG9nZ2VyLCBXQVJOSU5HIH0gZnJvbSBcIi4uL0xvZ1wiO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBBIHJ1bGUgY2xhc3MgZm9yIHJlcGxhY2luZyBjb25maWd1cmFibGUgY2hhcmFjdGVycyBpbiBhbiBpbnB1dCB2YWx1ZSB3aXRoIGEgc3BlY2lmaWVkIHRleHQgc3RyaW5nLlxyXG4gKiBTdXBwb3J0cyBib3RoIHBsYWluIHRleHQgYW5kIHJlZ3VsYXIgZXhwcmVzc2lvbiByZXBsYWNlbWVudHMuXHJcbiAqIFxyXG4gKiBAcmVtYXJrc1xyXG4gKiAtIFRoaXMgcnVsZSBpcyBpbnRlbmRlZCBmb3IgdXNlIGluIGZvcm1hdHRpbmcgb3BlcmF0aW9ucywgc3VjaCBhcyByZXBsYWNpbmcgc3BhY2VzIG9yIG90aGVyIGNoYXJhY3RlcnMgaW4gdGFncywgYWxpYXNlcywgb3IgdGV4dCBmaWVsZHMuXHJcbiAqIC0gVGhlIHJlcGxhY2VtZW50IGJlaGF2aW9yIGlzIGNvbmZpZ3VyYWJsZSB2aWEgdGhlIGByZXBsYWNlYCAoc2VhcmNoIHBhdHRlcm4pIGFuZCBgcmVwbGFjZUJ5YCAocmVwbGFjZW1lbnQgc3RyaW5nKSBvcHRpb25zLlxyXG4gKiAtIFRoZSBjb25maWd1cmF0aW9uIFVJIGFsbG93cyB1c2VycyB0byBzcGVjaWZ5IHRoZSBzZWFyY2ggcGF0dGVybiAoc3VwcG9ydHMgcmVnZXgpIGFuZCB0aGUgcmVwbGFjZW1lbnQgc3RyaW5nLlxyXG4gKiBcclxuICogQGV4dGVuZHMgUnVsZVByb3RvdHlwZVxyXG4gKiBcclxuICogQGV4YW1wbGVcclxuICogLy8gUmVwbGFjZSBhbGwgc3BhY2VzIHdpdGggdW5kZXJzY29yZXMgaW4gYSBzdHJpbmdcclxuICogY29uc3QgcnVsZSA9IG5ldyBSdWxlUmVwbGFjZVNwYWNlcygpO1xyXG4gKiBydWxlLmZ4KGFwcCwgZmlsZSwgdG9vbHMsIFwibXkgdGFnIG5hbWVcIik7IC8vIHJldHVybnMgXCJteV90YWdfbmFtZVwiIGlmIGNvbmZpZ3VyZWQgYXBwcm9wcmlhdGVseVxyXG4gKiBcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGVzY3JpcHRpb24gLSBBIGRlc2NyaXB0aW9uIG9mIHdoYXQgdGhlIHJ1bGUgZG9lcy5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJ1bGVUeXBlIC0gVGhlIHR5cGUgb2YgcnVsZSAoZS5nLiwgJ2Zvcm1hdHRlcicpLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc291cmNlIC0gVGhlIHNvdXJjZSBjb2RlIGZvciB0aGUgcnVsZSdzIGZ1bmN0aW9uLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSB0eXBlIC0gVGhlIHR5cGVzIG9mIGZpZWxkcyB0aGlzIHJ1bGUgY2FuIGJlIGFwcGxpZWQgdG8uXHJcbiAqIEBwcm9wZXJ0eSB7YW55fSBjb25maWdFbGVtZW50cyAtIFRoZSBjb25maWd1cmF0aW9uIGVsZW1lbnRzIGZvciB0aGUgcnVsZS5cclxuICogXHJcbiAqIEBtZXRob2QgZnhcclxuICogQXBwbGllcyB0aGUgcmVwbGFjZW1lbnQgcnVsZSB0byB0aGUgaW5wdXQgdmFsdWUgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgc2VhcmNoIHBhdHRlcm4gYW5kIHJlcGxhY2VtZW50IHN0cmluZy5cclxuICogXHJcbiAqIEBtZXRob2QgY29uZmlnVGFiXHJcbiAqIFJlbmRlcnMgdGhlIGNvbmZpZ3VyYXRpb24gdGFiIFVJIGZvciBzZXR0aW5nIHRoZSBzZWFyY2ggYW5kIHJlcGxhY2VtZW50IHN0cmluZ3MuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZVJlcGxhY2VDaGFycyBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlkID0gJ3JlcGxhY2VDaGFycyc7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ1JlcGxhY2UgQ2hhcmFjdGVycyc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdSZXBsYWNlcyBjb25maWd1cmFibGUgY2hhcmFjdGVycyBpbiB0aGUgaW5wdXQgdmFsdWUgd2l0aCBhIHNwZWNpZmllZCB0ZXh0IHN0cmluZy4gU3VwcG9ydHMgdGV4dCBhbmQgcmVnZXggcmVwbGFjZW1lbnRzLic7XHJcbiAgICAgICAgdGhpcy5ydWxlVHlwZSA9ICdmb3JtYXR0ZXInO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIGxldCByZXN1bHQgPSAnJztcXG4gIHJldHVybiByZXN1bHQ7XFxufVwiO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICAgICAgdGhpcy5jb25maWdFbGVtZW50cyA9IHRoaXMuZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGZ4IChhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogYW55LCB0b29sczogU2NyaXB0aW5nVG9vbHMsIGlucHV0PzphbnkpIHsgLy8gRGVmYXVsdCBmdW5jdGlvbiBzaWduYXR1cmVcclxuICAgICAgICBjb25zdCByZXBsYWNlID0gdG9vbHMuZ2V0T3B0aW9uQ29uZmlnKHRvb2xzLmdldFJ1bGUoKT8uaWQsICdyZXBsYWNlJyk7XHJcbiAgICAgICAgaWYgKCFyZXBsYWNlIHx8IHJlcGxhY2UgPT09ICcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVwbGFjZUJ5ID0gdG9vbHMuZ2V0T3B0aW9uQ29uZmlnKHRvb2xzLmdldFJ1bGUoKT8uaWQsICdyZXBsYWNlQnknKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAocmVwbGFjZSwgJ2cnKTtcclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UocmVnZXgsIHJlcGxhY2VCeSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBsb2dnZXIubG9nKEVSUk9SLGBFcnJvciBpbiBSdWxlUmVwbGFjZUNoYXJzOiBJbnZhbGlkIHJlZ2V4IHBhdHRlcm4gXCIke3JlcGxhY2V9XCJgLCBlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uZmlnVGFiKG9wdGlvbkVMOiBIVE1MRWxlbWVudCwgcnVsZTogRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDogYW55LCBwcmV2aWV3Q29tcG9uZW50OiBhbnkpIHtcclxuICAgICAgICBvcHRpb25FTC5lbXB0eSgpO1xyXG4gICAgICAgIC8vIENyZWF0ZSBhIHNldHRpbmcgZm9yIHRoZSBzbWFsbCB3b3Jkc1xyXG4gICAgICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnRGVmYXVsdHMocnVsZS5pZCwge1xyXG4gICAgICAgICAgICByZXBsYWNlOiAnJywgLy8gc2VhcmNoIGZvciB0aGlzIHN0cmluZ1xyXG4gICAgICAgICAgICByZXBsYWNlQnk6ICcnLCAvLyByZXBsYWNlIHdpdGggdGhpcyBzdHJpbmdcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBuZXcgU2V0dGluZyhvcHRpb25FTClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ3NlYXJjaCBmb3InKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnQ2hhcmFjdGVyIHRvIHNlYXJjaCBmb3IgaW4gdGhlIGlucHV0IHZhbHVlIChSZWdleCBzdXBwb3J0ZWQpJylcclxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ3NlYXJjaCBmb3InKVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoYXQuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQgLCdyZXBsYWNlJykgfHwgJycpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWcocnVsZS5pZCwncmVwbGFjZScsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZVByZXZpZXcocnVsZSwgcHJldmlld0NvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICBuZXcgU2V0dGluZyhvcHRpb25FTClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ3JlcGxhY2UgYnknKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnQ2hhcmFjdGVyIHRvIHJlcGxhY2UgbWF0Y2hlcycpXHJcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxyXG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdyZXBsYWNlIGJ5JylcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGF0LmdldE9wdGlvbkNvbmZpZyhydWxlLmlkICwncmVwbGFjZUJ5JykgfHwgJycpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWcocnVsZS5pZCwncmVwbGFjZUJ5JywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudXBkYXRlUHJldmlldyhydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICk7XHJcbiAgICB9O1xyXG59IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEFwcCwgU2V0dGluZywgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5cclxuLyoqXHJcbiAqIEEgcnVsZSBjbGFzcyB0aGF0IHJlcGxhY2VzIHNwYWNlcyBpbiBhIGdpdmVuIGlucHV0IHZhbHVlIHdpdGggYSBzcGVjaWZpZWQgY2hhcmFjdGVyLlxyXG4gKiBcclxuICogVGhpcyBydWxlIGlzIGludGVuZGVkIGZvciB1c2UgaW4gZm9ybWF0dGluZyB0ZXh0LCB0YWdzLCBhbGlhc2VzLCBvciBtdWx0aXRleHQgZmllbGRzLlxyXG4gKiBUaGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGNhbiBiZSBjb25maWd1cmVkIGJ5IHRoZSB1c2VyIHZpYSB0aGUgc2V0dGluZ3MgVUkuXHJcbiAqIFxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBJZiB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGlzIHNldCB0byBcIl9cIjpcclxuICogcnVsZS5meChhcHAsIGZpbGUsIHRvb2xzLCBcImhlbGxvIHdvcmxkXCIpIC8vIHJldHVybnMgXCJoZWxsb193b3JsZFwiXHJcbiAqIFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBydWxlIChcInJlcGxhY2VTcGFjZXNcIikuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIGRpc3BsYXkgbmFtZSBmb3IgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXNjcmlwdGlvbiAtIEEgZGVzY3JpcHRpb24gb2Ygd2hhdCB0aGUgcnVsZSBkb2VzLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcnVsZVR5cGUgLSBUaGUgdHlwZSBvZiBydWxlIChcImZvcm1hdHRlclwiKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gdHlwZSAtIFRoZSBhcHBsaWNhYmxlIGZpZWxkIHR5cGVzIGZvciB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHthbnl9IGNvbmZpZ0VsZW1lbnRzIC0gVGhlIGNvbmZpZ3VyYXRpb24gZWxlbWVudHMgZm9yIHRoZSBydWxlLlxyXG4gKiBcclxuICogQG1ldGhvZCBmeFxyXG4gKiBSZXBsYWNlcyBhbGwgc3BhY2VzIGluIHRoZSBpbnB1dCB2YWx1ZSB3aXRoIHRoZSBjb25maWd1cmVkIHJlcGxhY2VtZW50IGNoYXJhY3Rlci5cclxuICogXHJcbiAqIEBtZXRob2QgY29uZmlnVGFiXHJcbiAqIFJlbmRlcnMgdGhlIGNvbmZpZ3VyYXRpb24gVUkgZm9yIHNldHRpbmcgdGhlIHNwYWNlIHJlcGxhY2VtZW50IGNoYXJhY3Rlci5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlUmVwbGFjZVNwYWNlcyBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlkID0gJ3JlcGxhY2VTcGFjZXMnO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdSZXBsYWNlIFNwYWNlcyc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdSZXBsYWNlcyBzcGFjZXMgaW4gdGhlIGlucHV0IHZhbHVlIHdpdGggYSBzcGVjaWZpZWQgY2hhcmFjdGVyLic7XHJcbiAgICAgICAgdGhpcy5ydWxlVHlwZSA9ICdmb3JtYXR0ZXInO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIGxldCByZXN1bHQgPSAnJztcXG4gIHJldHVybiByZXN1bHQ7XFxufVwiO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICAgICAgdGhpcy5jb25maWdFbGVtZW50cyA9IHRoaXMuZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGZ4IChhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogYW55LCB0b29sczogU2NyaXB0aW5nVG9vbHMsIGlucHV0PzphbnkpIHsgLy8gRGVmYXVsdCBmdW5jdGlvbiBzaWduYXR1cmVcclxuICAgICAgICBjb25zdCBzcGFjZVJlcGxhY2VtZW50ID0gdG9vbHMuZ2V0T3B0aW9uQ29uZmlnKHRvb2xzLmdldFJ1bGUoKT8uaWQsICdzcGFjZVJlcGxhY2VtZW50Jyk7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xccysvZywgc3BhY2VSZXBsYWNlbWVudCk7IC8vIFJlcGxhY2UgYWxsIHNwYWNlcyB3aXRoIHRoZSBzcGVjaWZpZWQgY2hhcmFjdGVyXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbmZpZ1RhYihvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIHRoYXQ6IGFueSwgcHJldmlld0NvbXBvbmVudDogYW55KSB7XHJcbiAgICAgICAgb3B0aW9uRUwuZW1wdHkoKTtcclxuICAgICAgICAvLyBDcmVhdGUgYSBzZXR0aW5nIGZvciB0aGUgc21hbGwgd29yZHNcclxuICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZ0RlZmF1bHRzKHJ1bGUuaWQsIHtcclxuICAgICAgICAgICAgc3BhY2VSZXBsYWNlbWVudCA6ICcnLCAvLyBEZWZhdWx0IHN1ZmZpeFxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnU3BhY2UgcmVwbGFjZW1lbnQnKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnQ2hhcmFjdGVyIHRvIHJlcGxhY2Ugc3BhY2VzIChzdWdnZXN0ZWQ6IFwiX1wiKScpXHJcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxyXG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCd3aWxsIHJlbW92ZSBzcGFjZXMnKVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoYXQuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQgLCdzcGFjZVJlcGxhY2VtZW50JykgfHwgJycpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWcocnVsZS5pZCwnc3BhY2VSZXBsYWNlbWVudCcsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZVByZXZpZXcocnVsZSwgcHJldmlld0NvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgfTtcclxufSIsICJpbXBvcnQgeyBSdWxlUHJvdG90eXBlLCBydWxlc01hbmFnZXIgfSBmcm9tIFwiLi9ydWxlc1wiO1xyXG5pbXBvcnQgeyBTY3JpcHRpbmdUb29scyB9IGZyb20gXCIuLi90b29sc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFNldHRpbmcsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MgfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuXHJcblxyXG4vKipcclxuICogQSBydWxlIGNsYXNzIGZvciByZXBsYWNpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIHN0cmluZ3MsIHdoaWxlIHByZXNlcnZpbmcgbGV0dGVycyB3aXRoIGRpYWNyaXRpY3MuXHJcbiAqIFxyXG4gKiBUaGlzIHJ1bGUgaXMgaW50ZW5kZWQgZm9yIHVzZSBpbiBmb3JtYXR0aW5nIHRleHQsIHRhZ3MsIGFsaWFzZXMsIGFuZCBtdWx0aXRleHQgZmllbGRzLiBJdCBhbGxvd3NcclxuICogdGhlIHVzZXIgdG8gc3BlY2lmeSBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciAoc3VnZ2VzdGVkOiBcIi1cIikgZm9yIGFueSBjaGFyYWN0ZXIgdGhhdCBkb2VzIG5vdCBtYXRjaFxyXG4gKiB0aGUgYWxsb3dlZCBzZXQgKGxldHRlcnMsIG51bWJlcnMsIGRhc2hlcywgdW5kZXJzY29yZXMsIHNsYXNoZXMsIGFuZCBjb21tb24gZGlhY3JpdGljcykuXHJcbiAqIFxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqIFxyXG4gKiBAcmVtYXJrc1xyXG4gKiAtIFRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgY2FuIGJlIGNvbmZpZ3VyZWQgdmlhIHRoZSBzZXR0aW5ncyBVSS5cclxuICogLSBUaGUgcnVsZSBwcmVzZXJ2ZXMgbGV0dGVycyB3aXRoIGRpYWNyaXRpY3MgKGUuZy4sIFx1MDBFNCwgXHUwMEY2LCBcdTAwRkMsIFx1MDBFMSwgXHUwMEU5LCBldGMuKS5cclxuICogLSBUaGUgYGZ4YCBtZXRob2QgcGVyZm9ybXMgdGhlIHJlcGxhY2VtZW50IHVzaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxyXG4gKiBcclxuICogQGV4YW1wbGVcclxuICogLy8gUmVwbGFjZSBhbGwgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIGEgc3RyaW5nIHdpdGggJy0nXHJcbiAqIHJ1bGUuZngoYXBwLCBmaWxlLCB0b29scywgXCJoZWxsb0B3b3JsZCFcIikgLy8gcmV0dXJucyBcImhlbGxvLXdvcmxkLVwiXHJcbiAqIFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gRGlzcGxheSBuYW1lIGZvciB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uIC0gRGVzY3JpcHRpb24gb2YgdGhlIHJ1bGUncyBwdXJwb3NlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcnVsZVR5cGUgLSBUeXBlIG9mIHRoZSBydWxlIChlLmcuLCAnZm9ybWF0dGVyJykuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBTb3VyY2UgY29kZSBmb3IgdGhlIHJ1bGUncyBmdW5jdGlvbi5cclxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gdHlwZSAtIFR5cGVzIG9mIGZpZWxkcyB0aGUgcnVsZSBhcHBsaWVzIHRvLlxyXG4gKiBAcHJvcGVydHkge29iamVjdH0gY29uZmlnRWxlbWVudHMgLSBDb25maWd1cmF0aW9uIGVsZW1lbnRzIGZvciB0aGUgcnVsZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlUmVwbGFjZVNwZWNpYWxDaGFycyBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlkID0gJ3JlcGxhY2VTcGVjaWFsQ2hhcnMnO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdSZXBsYWNlIFNwZWNpYWwgQ2hhcmFjdGVycyc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdDaGFyYWN0ZXIgdG8gcmVwbGFjZSBzcGVjaWFsIGNoYXJhY3RlcnMgKHN1Z2dlc3RlZDogXCItXCIpIC0gcHJlc2VydmVzIGxldHRlcnMgd2l0aCBkaWFjcml0aWNzJztcclxuICAgICAgICB0aGlzLnJ1bGVUeXBlID0gJ2Zvcm1hdHRlcic7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgbGV0IHJlc3VsdCA9ICcnO1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59XCI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZnggKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBhbnksIHRvb2xzOiBTY3JpcHRpbmdUb29scywgaW5wdXQ/OmFueSkgeyAvLyBEZWZhdWx0IGZ1bmN0aW9uIHNpZ25hdHVyZVxyXG4gICAgICAgIGNvbnN0IHNwZWNpYWxDaGFyUmVwbGFjZW1lbnQgPSB0b29scy5nZXRPcHRpb25Db25maWcodG9vbHMuZ2V0UnVsZSgpPy5pZCwgJ3NwZWNpYWxDaGFyUmVwbGFjZW1lbnQnKTtcclxuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvW15hLXpBLVowLTlcXC1fXFwvXHUwMEU0XHUwMEY2XHUwMEZDXHUwMERGXHUwMEM0XHUwMEQ2XHUwMERDXHUwMEUxXHUwMEU5XHUwMEVEXHUwMEYzXHUwMEZBXHUwMEZEXHUwMEMxXHUwMEM5XHUwMENEXHUwMEQzXHUwMERBXHUwMEREXHUwMEUwXHUwMEU4XHUwMEVDXHUwMEYyXHUwMEY5XHUwMEMwXHUwMEM4XHUwMENDXHUwMEQyXHUwMEQ5XHUwMEUyXHUwMEVBXHUwMEVFXHUwMEY0XHUwMEZCXHUwMEMyXHUwMENBXHUwMENFXHUwMEQ0XHUwMERCXHUwMEUzXHUwMEYxXHUwMEY1XHUwMEMzXHUwMEQxXHUwMEQ1XS9nLCBzcGVjaWFsQ2hhclJlcGxhY2VtZW50KTtcclxuICAgIH07XHJcblxyXG4gICAgY29uZmlnVGFiKG9wdGlvbkVMOiBIVE1MRWxlbWVudCwgcnVsZTogRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDogYW55LCBwcmV2aWV3Q29tcG9uZW50OiBhbnkpIHtcclxuICAgICAgICBvcHRpb25FTC5lbXB0eSgpO1xyXG4gICAgICAgIC8vIENyZWF0ZSBhIHNldHRpbmcgZm9yIHRoZSBzbWFsbCB3b3Jkc1xyXG4gICAgICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnRGVmYXVsdHMocnVsZS5pZCwge1xyXG4gICAgICAgICAgICBzcGVjaWFsQ2hhclJlcGxhY2VtZW50IDogJycsIC8vIERlZmF1bHQgc3VmZml4XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgbmV3IFNldHRpbmcob3B0aW9uRUwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdSZXBsYWNlIFNwZWNpYWwgQ2hhcmFjdGVycycpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdDaGFyYWN0ZXIgdG8gcmVwbGFjZSBzcGVjaWFsIGNoYXJhY3RlcnMgKHN1Z2dlc3RlZDogXCItXCIpIC0gcHJlc2VydmVzIGxldHRlcnMgd2l0aCBkaWFjcml0aWNzJylcclxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ3dpbGwgcmVtb3ZlIHNwZWNpYWwgY2hhcmFjdGVycycpXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhhdC5nZXRPcHRpb25Db25maWcocnVsZS5pZCAsJ3NwZWNpYWxDaGFyUmVwbGFjZW1lbnQnKSB8fCAnJylcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZyhydWxlLmlkLCdzcGVjaWFsQ2hhclJlcGxhY2VtZW50JywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudXBkYXRlUHJldmlldyhydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICk7XHJcbiAgICB9O1xyXG59IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgcnVsZSB0aGF0IGNvbnZlcnRzIGlucHV0IHZhbHVlcyB0byBDYW1lbCBDYXNlLlxyXG4gKiBUaGlzIHJ1bGUgY2FuIGhhbmRsZSB2YXJpb3VzIGlucHV0IHR5cGVzIGluY2x1ZGluZyBzdHJpbmdzLCBhcnJheXMsIGRhdGVzLCBhbmQgb2JqZWN0cy5cclxuICogXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICogXHJcbiAqIEByZW1hcmtzXHJcbiAqIC0gRm9yIHN0cmluZ3MsIGl0IGNvbnZlcnRzIHRoZSBlbnRpcmUgc3RyaW5nIHRvIENhbWVsIENhc2UuXHJcbiAqIC0gRm9yIGFycmF5cywgaXQgbWFwcyBlYWNoIGVsZW1lbnQgdG8gaXRzIENhbWVsIENhc2Ugc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxyXG4gKiAtIEZvciBkYXRlcywgaXQgY29udmVydHMgdGhlIGRhdGUgdG8gYW4gSVNPIHN0cmluZyBhbmQgYXBwbGllcyBDYW1lbCBDYXNlLlxyXG4gKiAtIEZvciBvYmplY3RzLCBpdCBzZXJpYWxpemVzIHRoZSBvYmplY3QgdG8gYSBKU09OIHN0cmluZyBhbmQgYXBwbGllcyBDYW1lbCBDYXNlLlxyXG4gKiAtIElmIHRoZSBpbnB1dCB0eXBlIGlzIG5vdCByZWNvZ25pemVkLCBpdCByZXR1cm5zIHRoZSBpbnB1dCBhcyBpcy5cclxuICogXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY29uc3QgcnVsZSA9IG5ldyBSdWxlVG9DYW1lbENhc2UoKTtcclxuICogY29uc29sZS5sb2cocnVsZS5meChcImhlbGxvIHdvcmxkXCIsIHRvb2xzKSk7IC8vIE91dHB1dHM6IFwiaGVsbG9Xb3JsZFwiXHJcbiAqIGNvbnNvbGUubG9nKHJ1bGUuZngoW1wiaGVsbG8gd29ybGRcIiwgXCJ0ZXN0IGNhc2VcIl0sIHRvb2xzKSk7IC8vIE91dHB1dHM6IFtcImhlbGxvV29ybGRcIiwgXCJ0ZXN0Q2FzZVwiXVxyXG4gKiBjb25zb2xlLmxvZyhydWxlLmZ4KG5ldyBEYXRlKFwiMjAyMy0wMS0wMVwiKSwgdG9vbHMpKTsgLy8gT3V0cHV0czogXCIyMDIzLTAxLTAxdDAwOjAwOjAwLjAwMHpcIlxyXG4gKiBjb25zb2xlLmxvZyhydWxlLmZ4KHsga2V5OiBcInZhbHVlXCIgfSwgdG9vbHMpKTsgLy8gT3V0cHV0czogJ3tcImtleVwiOlwidmFsdWVcIn0nXHJcbiAqIGBgYFxyXG4gKiBcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGVzY3JpcHRpb24gLSBBIGJyaWVmIGRlc2NyaXB0aW9uIG9mIHRoZSBydWxlJ3MgZnVuY3Rpb25hbGl0eS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJ1bGVUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIHJ1bGUsIHdoaWNoIGlzIFwiZm9ybWF0dGVyXCIuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBUaGUgc291cmNlIGNvZGUgdGVtcGxhdGUgZm9yIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSB0eXBlIC0gVGhlIHR5cGVzIG9mIGlucHV0IHRoaXMgcnVsZSBhcHBsaWVzIHRvLCBlLmcuLCBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddLlxyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBmeCAtIFRoZSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIHRoZSBDYW1lbCBDYXNlIHRyYW5zZm9ybWF0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVUb0NhbWVsQ2FzZSBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlkID0gJ3RvQ2FtZWxDYXNlJztcclxuICAgICAgICB0aGlzLm5hbWUgPSAnVG8gQ2FtZWwgQ2FzZSc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdDb252ZXJ0IHRoZSB2YWx1ZSB0byBDYW1lbCBDYXNlLic7XHJcbiAgICAgICAgdGhpcy5ydWxlVHlwZSA9ICdmb3JtYXR0ZXInO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIGxldCByZXN1bHQgPSAnJztcXG4gIHJldHVybiByZXN1bHQ7XFxufVwiO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICAgICAgdGhpcy5jb25maWdFbGVtZW50cyA9IHRoaXMuZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KTtcclxuICAgIH07XHJcbiAgICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMsIGlucHV0OiBhbnkpIHsgXHJcbiAgICAgICAgY29uc3QgdG9DYW1lbENhc2UgPSAoc3RyOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgbGV0IHRleHRQYXJ0cyA9IHN0ci5zcGxpdCgnICcpO1xyXG4gICAgICAgICAgICBsZXQgY29udmVydGVkVGV4dFBhcnRzOnN0cmluZ1tdID0gW107XHJcbiAgICAgICAgICAgIHRleHRQYXJ0cy5mb3JFYWNoKCh0ZXh0LGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBuZXdUZXh0UGFydCA9IHRleHQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4PjApIG5ld1RleHRQYXJ0ID0gbmV3VGV4dFBhcnQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuZXdUZXh0UGFydC5zbGljZSgxKTtcclxuICAgICAgICAgICAgY29udmVydGVkVGV4dFBhcnRzLnB1c2gobmV3VGV4dFBhcnQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRlZFRleHRQYXJ0cy5qb2luKCcnKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdG9DYW1lbENhc2UoaW5wdXQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0Lm1hcCgoaXRlbSkgPT4gdG9DYW1lbENhc2UoU3RyaW5nKGl0ZW0pKSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dCBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRvQ2FtZWxDYXNlKGlucHV0LnRvSVNPU3RyaW5nKCkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gdG9DYW1lbENhc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlucHV0O1xyXG4gICAgfTtcclxufVxyXG5cclxuLy9ydWxlc01hbmFnZXIucmVnaXN0ZXJSdWxlKG5ldyBSdWxlVG9DYW1lbENhc2UoKSk7IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUgfSBmcm9tIFwiLi9ydWxlc1wiO1xyXG5pbXBvcnQgeyBTY3JpcHRpbmdUb29scyB9IGZyb20gXCIuLi90b29sc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIHJ1bGUgZm9yIGZvcm1hdHRpbmcgaW5wdXQgYXMgYSBtYXJrZG93biBsaW5rLlxyXG4gKiBUaGlzIGNsYXNzIGV4dGVuZHMgdGhlIGBSdWxlUHJvdG90eXBlYCBhbmQgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eVxyXG4gKiB0byBjb252ZXJ0IGlucHV0IGludG8gYSBtYXJrZG93biBsaW5rIGZvcm1hdCB1c2luZyB0aGUgcHJvdmlkZWQgdG9vbHMuXHJcbiAqXHJcbiAqIEBjbGFzcyBSdWxlVG9MaW5rTWFya2Rvd25cclxuICogQGV4dGVuZHMgUnVsZVByb3RvdHlwZVxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogSW5pdGlhbGl6ZXMgdGhlIHJ1bGUgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMgc3VjaCBhcyBgaWRgLCBgbmFtZWAsXHJcbiAqIGBkZXNjcmlwdGlvbmAsIGBydWxlVHlwZWAsIGBzb3VyY2VgLCBgdHlwZWAsIGFuZCBgY29uZmlnRWxlbWVudHNgLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXNjcmlwdGlvbiAtIEEgYnJpZWYgZGVzY3JpcHRpb24gb2YgdGhlIHJ1bGUncyBwdXJwb3NlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcnVsZVR5cGUgLSBUaGUgdHlwZSBvZiBydWxlLCBpbiB0aGlzIGNhc2UsIGEgbGluayBmb3JtYXR0ZXIuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBUaGUgc291cmNlIGNvZGUgb2YgdGhlIHJ1bGUgYXMgYSBzdHJpbmcsIHVzZWQgZm9yIHNjcmlwdGluZyBwdXJwb3Nlcy5cclxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gdHlwZSAtIFRoZSBhcHBsaWNhYmxlIGlucHV0IHR5cGVzIGZvciB0aGUgcnVsZSwgc3VjaCBhcyAndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCBhbmQgJ211bHRpdGV4dCcuXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGZ4IC0gVGhlIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgdGhlIG1hcmtkb3duIGxpbmsgZm9ybWF0dGluZy5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gY29uZmlnRWxlbWVudHMgLSBBIG1ldGhvZCB0byByZXRyaWV2ZSB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIGVsZW1lbnRzIGZvciB0aGUgcnVsZS5cclxuICpcclxuICogQG1ldGhvZCBmeFxyXG4gKiBDb252ZXJ0cyB0aGUgaW5wdXQgaW50byBhIG1hcmtkb3duIGxpbmsgZm9ybWF0IHVzaW5nIHRoZSBgdG9vbHMudG9NYXJrZG93bkxpbmtgIG1ldGhvZC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogY29uc3QgcnVsZSA9IG5ldyBSdWxlVG9MaW5rTWFya2Rvd24oKTtcclxuICogY29uc3QgZm9ybWF0dGVkID0gcnVsZS5meChcImV4YW1wbGVcIiwgdG9vbHMpO1xyXG4gKiBjb25zb2xlLmxvZyhmb3JtYXR0ZWQpOyAvLyBPdXRwdXRzIHRoZSBpbnB1dCBmb3JtYXR0ZWQgYXMgYSBtYXJrZG93biBsaW5rLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVUb0xpbmtNYXJrZG93biBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlkID0gJ3RvTWFya2Rvd25MaW5rJztcclxuICAgICAgICB0aGlzLm5hbWUgPSAndG8gbWFya2Rvd24gbGluayc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdGb3JtYXQgYXMgYSBtYXJrZG93biBsaW5rLic7XHJcbiAgICAgICAgdGhpcy5ydWxlVHlwZSA9ICdsaW5rRm9ybWF0dGVyJztcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IFwiZnVuY3Rpb24gKGlucHV0OiBhbnksIHRvb2xzOiBTY3JpcHRpbmdUb29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIGlucHV0ID0gdG9vbHMudG9NYXJrZG93bkxpbmsoaW5wdXQpOyAvLyBDb252ZXJ0IHRvIG1hcmtkb3duIGxpbmsgZm9ybWF0XFxuICByZXR1cm4gaW5wdXQ7XFxufVwiO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICAgICAgdGhpcy5jb25maWdFbGVtZW50cyA9IHRoaXMuZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KTtcclxuICAgIH07XHJcbiAgICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMsIGlucHV0OiBhbnkpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAgICAgaW5wdXQgPSB0b29scy50b01hcmtkb3duTGluayhpbnB1dCk7IC8vIENvbnZlcnQgdG8gbWFya2Rvd24gbGluayBmb3JtYXRcclxuICAgICAgICByZXR1cm4gaW5wdXQ7XHJcbiAgICB9O1xyXG59IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgcnVsZSB0aGF0IHBhc3NlcyBpbnB1dCB2YWx1ZXMgdW5hbHRlcmVkLlxyXG4gKiBUaGlzIHJ1bGUgc2ltcGx5IHJldHVybnMgdGhlIGlucHV0IGFzIGlzLCB3aXRob3V0IGFueSB0cmFuc2Zvcm1hdGlvbi5cclxuICogXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICogXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY29uc3QgcnVsZSA9IG5ldyBSdWxlVG9PcmlnaW5hbCgpO1xyXG4gKiBjb25zb2xlLmxvZyhydWxlLmZ4KFwiaGVsbG8gd29ybGRcIiwgdG9vbHMpKTsgLy8gT3V0cHV0czogXCJoZWxsbyB3b3JsZFwiXHJcbiAqIGNvbnNvbGUubG9nKHJ1bGUuZngoW1wiaGVsbG9cIiwgXCJ3b3JsZFwiXSwgdG9vbHMpKTsgLy8gT3V0cHV0czogW1wiaGVsbG9cIiwgXCJ3b3JsZFwiXVxyXG4gKiBjb25zb2xlLmxvZyhydWxlLmZ4KG5ldyBEYXRlKFwiMjAyMy0wMS0wMVwiKSwgdG9vbHMpKTsgLy8gT3V0cHV0czogRGF0ZSBvYmplY3RcclxuICogY29uc29sZS5sb2cocnVsZS5meCh7IGtleTogXCJ2YWx1ZVwiIH0sIHRvb2xzKSk7IC8vIE91dHB1dHM6IHsga2V5OiBcInZhbHVlXCIgfVxyXG4gKiBgYGBcclxuICogXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uIC0gQSBicmllZiBkZXNjcmlwdGlvbiBvZiB0aGUgcnVsZSdzIGZ1bmN0aW9uYWxpdHkuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBydWxlVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBydWxlLCB3aGljaCBpcyBcImZvcm1hdHRlclwiLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc291cmNlIC0gVGhlIHNvdXJjZSBjb2RlIHRlbXBsYXRlIGZvciB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gdHlwZSAtIFRoZSB0eXBlcyBvZiBpbnB1dCB0aGlzIHJ1bGUgYXBwbGllcyB0bywgZS5nLiwgWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXS5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZnggLSBUaGUgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBpbnB1dCB1bmFsdGVyZWQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZVRvTGlua09yaWdpbmFsIGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaWQgPSAndG9PcmlnaW5hbExpbmsnO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdubyBjaGFuZ2UnO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnUGFzcyB0aGUgaW5wdXQgdW5hbHRlcmVkLic7XHJcbiAgICAgICAgdGhpcy5ydWxlVHlwZSA9ICdsaW5rRm9ybWF0dGVyJztcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBsZXQgcmVzdWx0ID0gJyc7XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIjtcclxuICAgICAgICB0aGlzLnR5cGUgPSBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddO1xyXG4gICAgICAgIHRoaXMuY29uZmlnRWxlbWVudHMgPSB0aGlzLmRlZmF1bHRDb25maWdFbGVtZW50cyh7fSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMsIGlucHV0OiBhbnkpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAgICAgcmV0dXJuIGlucHV0OyAvLyBSZXR1cm4gdGhlIGlucHV0IHVuYWx0ZXJlZFxyXG4gICAgfTtcclxufSIsICJpbXBvcnQgeyBSdWxlUHJvdG90eXBlfSBmcm9tIFwiLi9ydWxlc1wiO1xyXG5pbXBvcnQgeyBTY3JpcHRpbmdUb29scyB9IGZyb20gXCIuLi90b29sc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG4vKipcclxuICogQSBydWxlIHRoYXQgZm9ybWF0cyBhIGdpdmVuIGlucHV0IGFzIGEgc2ltcGxlIE9ic2lkaWFuIGxpbmsgYnkgd3JhcHBpbmcgaXQgaW4gZG91YmxlIHNxdWFyZSBicmFja2V0cyAoW1suLi5dXSkuXHJcbiAqIFJldHVybnMgYW4gZW1wdHkgc3RyaW5nIGlmIHRoZSBpbnB1dCBpcyBgdW5kZWZpbmVkYCwgYG51bGxgLCBvciBhbiBlbXB0eSBzdHJpbmcuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIC0gUmV0dXJucyBhbiBlbXB0eSBzdHJpbmcgaWYgdGhlIGlucHV0IGlzIGB1bmRlZmluZWRgLCBgbnVsbGAsIG9yIGFuIGVtcHR5IHN0cmluZy5cclxuICogLSBJbnRlbmRlZCBmb3IgdXNlIGFzIGEgbGluayBmb3JtYXR0ZXIgd2l0aGluIHRoZSBwbHVnaW4ncyBydWxlIHN5c3RlbS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjb25zdCBydWxlID0gbmV3IFJ1bGVUb0xpbmtTaW1wbGUoKTtcclxuICogcnVsZS5meChhcHAsIGZpbGUsIHRvb2xzLCBcIk15Tm90ZVwiKTsgLy8gcmV0dXJucyAnW1tNeU5vdGVdXSdcclxuICogcnVsZS5meChhcHAsIGZpbGUsIHRvb2xzLCBcIlwiKTsgLy8gcmV0dXJucyAnJ1xyXG4gKiBgYGBcclxuICpcclxuICogQGV4dGVuZHMgUnVsZVByb3RvdHlwZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVUb0xpbmtTaW1wbGUgZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9ICd0b1NpbXBsZUxpbmsnO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICd0byBzaW1wbGUgbGluayc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdGb3JtYXQgYXMgYSBzaW1wbGUgbGluayBieSBhZGRpbmcgW1tdXS4nO1xyXG4gICAgICAgIHRoaXMucnVsZVR5cGUgPSAnbGlua0Zvcm1hdHRlcic7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzLCBpbnB1dCkgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkIHx8IGlucHV0ID09PSBudWxsIHx8IGlucHV0ID09PSAnJykge1xcbiAgICByZXR1cm4gJyc7IC8vIFJldHVybiBlbXB0eSBzdHJpbmcgaWYgaW5wdXQgaXMgdW5kZWZpbmVkLCBudWxsLCBvciBlbXB0eVxcbiAgfVxcbiAgICAgICAgIGlucHV0ID0gYFtbJHtpbnB1dH1dXWA7IC8vIENvbnZlcnQgdG8gc2ltcGxlIExpbmtcXG4gIHJldHVybiBpbnB1dDtcXG59O1wiOyAvLyBTb3VyY2UgY29kZSB0ZW1wbGF0ZVxyXG4gICAgICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICAgICAgdGhpcy5jb25maWdFbGVtZW50cyA9IHRoaXMuZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGZ4IChhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogVEZpbGUsIHRvb2xzOiBTY3JpcHRpbmdUb29scywgaW5wdXQ6IGFueSkgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgICAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCB8fCBpbnB1dCA9PT0gbnVsbCB8fCBpbnB1dCA9PT0gJycpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnOyAvLyBSZXR1cm4gZW1wdHkgc3RyaW5nIGlmIGlucHV0IGlzIHVuZGVmaW5lZCwgbnVsbCwgb3IgZW1wdHkgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlucHV0ID0gYFtbJHtpbnB1dH1dXWA7IC8vIENvbnZlcnQgdG8gc2ltcGxlIExpbmtcclxuICAgICAgICByZXR1cm4gaW5wdXQ7XHJcbiAgICB9O1xyXG59IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGV9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgcnVsZSBmb3IgZm9ybWF0dGluZyBpbnB1dCBhcyBhIHdpa2kgbGluay5cclxuICogXHJcbiAqIFRoaXMgY2xhc3MgZXh0ZW5kcyB0aGUgYFJ1bGVQcm90b3R5cGVgIGFuZCBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IHRvXHJcbiAqIGNvbnZlcnQgaW5wdXQgaW50byBhIHdpa2kgbGluayBmb3JtYXQgdXNpbmcgdGhlIHByb3ZpZGVkIHNjcmlwdGluZyB0b29scy5cclxuICogXHJcbiAqIEBjbGFzcyBSdWxlVG9MaW5rV2lraVxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqIFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogSW5pdGlhbGl6ZXMgdGhlIHJ1bGUgd2l0aCBwcmVkZWZpbmVkIHByb3BlcnRpZXMgc3VjaCBhcyBJRCwgbmFtZSwgZGVzY3JpcHRpb24sXHJcbiAqIHJ1bGUgdHlwZSwgc291cmNlIGNvZGUgdGVtcGxhdGUsIGFwcGxpY2FibGUgdHlwZXMsIGFuZCBjb25maWd1cmF0aW9uIGVsZW1lbnRzLlxyXG4gKiBcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcnVsZSAoYHRvV2lraUxpbmtgKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSBydWxlIChgd2lraSBsaW5rYCkuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXNjcmlwdGlvbiAtIEEgYnJpZWYgZGVzY3JpcHRpb24gb2YgdGhlIHJ1bGUncyBwdXJwb3NlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcnVsZVR5cGUgLSBUaGUgdHlwZSBvZiBydWxlIChgbGlua0Zvcm1hdHRlcmApLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc291cmNlIC0gVGhlIHNvdXJjZSBjb2RlIHRlbXBsYXRlIGZvciB0aGUgcnVsZSdzIGZ1bmN0aW9uYWxpdHkuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHR5cGUgLSBUaGUgYXBwbGljYWJsZSBpbnB1dCB0eXBlcyBmb3IgdGhlIHJ1bGUgXHJcbiAqIChgWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXWApLlxyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBmeCAtIFRoZSBmdW5jdGlvbiB0aGF0IGFwcGxpZXMgdGhlIHJ1bGUgbG9naWMsIGNvbnZlcnRpbmdcclxuICogaW5wdXQgdG8gYSB3aWtpIGxpbmsgZm9ybWF0IHVzaW5nIHRoZSBwcm92aWRlZCBgU2NyaXB0aW5nVG9vbHNgLlxyXG4gKiBcclxuICogQG1ldGhvZCBkZWZhdWx0Q29uZmlnRWxlbWVudHNcclxuICogR2VuZXJhdGVzIHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gZWxlbWVudHMgZm9yIHRoZSBydWxlLlxyXG4gKiBcclxuICogQGV4YW1wbGVcclxuICogY29uc3QgcnVsZSA9IG5ldyBSdWxlVG9MaW5rV2lraSgpO1xyXG4gKiBjb25zdCBmb3JtYXR0ZWRJbnB1dCA9IHJ1bGUuZngoXCJleGFtcGxlXCIsIHRvb2xzKTtcclxuICogY29uc29sZS5sb2coZm9ybWF0dGVkSW5wdXQpOyAvLyBPdXRwdXRzIHRoZSBpbnB1dCBmb3JtYXR0ZWQgYXMgYSB3aWtpIGxpbmsuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZVRvTGlua1dpa2kgZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9ICd0b1dpa2lMaW5rJztcclxuICAgICAgICB0aGlzLm5hbWUgPSAndG8gd2lraSBsaW5rJztcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gJ0Zvcm1hdCBhcyBhIHdpa2kgbGluay4nO1xyXG4gICAgICAgIHRoaXMucnVsZVR5cGUgPSAnbGlua0Zvcm1hdHRlcic7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChpbnB1dDogYW55LCB0b29sczogU2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBpbnB1dCA9IHRvb2xzLnRvV2lraUxpbmsoaW5wdXQpOyAvLyBDb252ZXJ0IHRvIHdpa2kgbGluayBmb3JtYXRcXG4gIHJldHVybiBpbnB1dDtcXG59XCI7IC8vIFNvdXJjZSBjb2RlIHRlbXBsYXRlXHJcbiAgICAgICAgdGhpcy50eXBlID0gWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZnggKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBURmlsZSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzLCBpbnB1dDogYW55KSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIGlucHV0ID0gdG9vbHMudG9XaWtpTGluayhpbnB1dCk7IC8vIENvbnZlcnQgdG8gd2lraSBsaW5rIGZvcm1hdFxyXG4gICAgICAgIHJldHVybiBpbnB1dDtcclxuICAgIH07XHJcbn0iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBydWxlIHRoYXQgY29udmVydHMgaW5wdXQgdmFsdWVzIHRvIGxvd2VyIGNhc2UuXHJcbiAqIFRoaXMgcnVsZSBjYW4gaGFuZGxlIHZhcmlvdXMgaW5wdXQgdHlwZXMgaW5jbHVkaW5nIHN0cmluZ3MsIGFycmF5cywgZGF0ZXMsIGFuZCBvYmplY3RzLlxyXG4gKiBcclxuICogQGV4dGVuZHMgUnVsZVByb3RvdHlwZVxyXG4gKiBcclxuICogQHJlbWFya3NcclxuICogLSBGb3Igc3RyaW5ncywgaXQgY29udmVydHMgdGhlIGVudGlyZSBzdHJpbmcgdG8gbG93ZXIgY2FzZS5cclxuICogLSBGb3IgYXJyYXlzLCBpdCBtYXBzIGVhY2ggZWxlbWVudCB0byBpdHMgbG93ZXIgY2FzZSBzdHJpbmcgcmVwcmVzZW50YXRpb24uXHJcbiAqIC0gRm9yIGRhdGVzLCBpdCBjb252ZXJ0cyB0aGUgZGF0ZSB0byBhbiBJU08gc3RyaW5nIGluIGxvd2VyIGNhc2UuXHJcbiAqIC0gRm9yIG9iamVjdHMsIGl0IHNlcmlhbGl6ZXMgdGhlIG9iamVjdCB0byBhIEpTT04gc3RyaW5nIGFuZCBjb252ZXJ0cyBpdCB0byBsb3dlciBjYXNlLlxyXG4gKiAtIElmIHRoZSBpbnB1dCB0eXBlIGlzIG5vdCByZWNvZ25pemVkLCBpdCByZXR1cm5zIHRoZSBpbnB1dCBhcyBpcy5cclxuICogXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY29uc3QgcnVsZSA9IG5ldyBSdWxlVG9Mb3dlckNhc2UoKTtcclxuICogY29uc29sZS5sb2cocnVsZS5meChcIkhFTExPXCIsIHRvb2xzKSk7IC8vIE91dHB1dHM6IFwiaGVsbG9cIlxyXG4gKiBjb25zb2xlLmxvZyhydWxlLmZ4KFtcIkhFTExPXCIsIFwiV09STERcIl0sIHRvb2xzKSk7IC8vIE91dHB1dHM6IFtcImhlbGxvXCIsIFwid29ybGRcIl1cclxuICogY29uc29sZS5sb2cocnVsZS5meChuZXcgRGF0ZShcIjIwMjMtMDEtMDFcIiksIHRvb2xzKSk7IC8vIE91dHB1dHM6IFwiMjAyMy0wMS0wMXQwMDowMDowMC4wMDB6XCJcclxuICogY29uc29sZS5sb2cocnVsZS5meCh7IEtFWTogXCJWQUxVRVwiIH0sIHRvb2xzKSk7IC8vIE91dHB1dHM6ICd7XCJrZXlcIjpcInZhbHVlXCJ9J1xyXG4gKiBgYGBcclxuICogXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uIC0gQSBicmllZiBkZXNjcmlwdGlvbiBvZiB0aGUgcnVsZSdzIGZ1bmN0aW9uYWxpdHkuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBydWxlVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBydWxlLCB3aGljaCBpcyBcImZvcm1hdHRlclwiLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc291cmNlIC0gVGhlIHNvdXJjZSBjb2RlIHRlbXBsYXRlIGZvciB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gdHlwZSAtIFRoZSB0eXBlcyBvZiBpbnB1dCB0aGlzIHJ1bGUgYXBwbGllcyB0bywgZS5nLiwgWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXS5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZnggLSBUaGUgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyB0aGUgbG93ZXIgY2FzZSB0cmFuc2Zvcm1hdGlvbi5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlVG9Mb3dlckNhc2UgZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9ICd0b0xvd2VyQ2FzZSc7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ1RvIExvd2VyIENhc2UnO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnQ29udmVydCB0aGUgdmFsdWUgdG8gbG93ZXIgY2FzZS4nO1xyXG4gICAgICAgIHRoaXMucnVsZVR5cGUgPSAnZm9ybWF0dGVyJztcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBsZXQgcmVzdWx0ID0gJyc7XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIjtcclxuICAgICAgICB0aGlzLnR5cGUgPSBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddO1xyXG4gICAgICAgIHRoaXMuY29uZmlnRWxlbWVudHMgPSB0aGlzLmRlZmF1bHRDb25maWdFbGVtZW50cyh7fSk7XHJcbiAgICB9O1xyXG4gICAgZnggKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBURmlsZSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzLCBpbnB1dDogYW55KSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIGlmIChTdHJpbmcuaXNTdHJpbmcoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIH0gZWxzZSBpZihBcnJheS5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQubWFwKChpdGVtKSA9PiBTdHJpbmcoaXRlbSkudG9Mb3dlckNhc2UoKSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dCBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnRvSVNPU3RyaW5nKCkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGlucHV0KS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW5wdXQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vcnVsZXNNYW5hZ2VyLnJlZ2lzdGVyUnVsZShuZXcgUnVsZVRvTG93ZXJDYXNlKCkpOyIsICJpbXBvcnQgeyBSdWxlUHJvdG90eXBlLCBydWxlc01hbmFnZXIgfSBmcm9tIFwiLi9ydWxlc1wiO1xyXG5pbXBvcnQgeyBTY3JpcHRpbmdUb29scyB9IGZyb20gXCIuLi90b29sc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIHJ1bGUgdGhhdCBwYXNzZXMgaW5wdXQgdmFsdWVzIHVuYWx0ZXJlZC5cclxuICogVGhpcyBydWxlIHNpbXBseSByZXR1cm5zIHRoZSBpbnB1dCBhcyBpcywgd2l0aG91dCBhbnkgdHJhbnNmb3JtYXRpb24uXHJcbiAqIFxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNvbnN0IHJ1bGUgPSBuZXcgUnVsZVRvT3JpZ2luYWwoKTtcclxuICogY29uc29sZS5sb2cocnVsZS5meChcImhlbGxvIHdvcmxkXCIsIHRvb2xzKSk7IC8vIE91dHB1dHM6IFwiaGVsbG8gd29ybGRcIlxyXG4gKiBjb25zb2xlLmxvZyhydWxlLmZ4KFtcImhlbGxvXCIsIFwid29ybGRcIl0sIHRvb2xzKSk7IC8vIE91dHB1dHM6IFtcImhlbGxvXCIsIFwid29ybGRcIl1cclxuICogY29uc29sZS5sb2cocnVsZS5meChuZXcgRGF0ZShcIjIwMjMtMDEtMDFcIiksIHRvb2xzKSk7IC8vIE91dHB1dHM6IERhdGUgb2JqZWN0XHJcbiAqIGNvbnNvbGUubG9nKHJ1bGUuZngoeyBrZXk6IFwidmFsdWVcIiB9LCB0b29scykpOyAvLyBPdXRwdXRzOiB7IGtleTogXCJ2YWx1ZVwiIH1cclxuICogYGBgXHJcbiAqIFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXNjcmlwdGlvbiAtIEEgYnJpZWYgZGVzY3JpcHRpb24gb2YgdGhlIHJ1bGUncyBmdW5jdGlvbmFsaXR5LlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcnVsZVR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgcnVsZSwgd2hpY2ggaXMgXCJmb3JtYXR0ZXJcIi5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZSAtIFRoZSBzb3VyY2UgY29kZSB0ZW1wbGF0ZSBmb3IgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHR5cGUgLSBUaGUgdHlwZXMgb2YgaW5wdXQgdGhpcyBydWxlIGFwcGxpZXMgdG8sIGUuZy4sIFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J10uXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGZ4IC0gVGhlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgaW5wdXQgdW5hbHRlcmVkLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVUb09yaWdpbmFsIGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaWQgPSAndG9PcmlnaW5hbCc7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ25vIGNoYW5nZSc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdQYXNzIHRoZSBpbnB1dCB1bmFsdGVyZWQuJztcclxuICAgICAgICB0aGlzLnJ1bGVUeXBlID0gJ2Zvcm1hdHRlcic7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgbGV0IHJlc3VsdCA9ICcnO1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59XCI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZnggKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBhbnksIHRvb2xzOiBTY3JpcHRpbmdUb29scywgaW5wdXQ/OmFueSkgeyAvLyBEZWZhdWx0IGZ1bmN0aW9uIHNpZ25hdHVyZVxyXG4gICAgICAgIHJldHVybiBpbnB1dDsgLy8gUmV0dXJuIHRoZSBpbnB1dCB1bmFsdGVyZWRcclxuICAgIH07XHJcbn0iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBydWxlIHRoYXQgY29udmVydHMgaW5wdXQgdmFsdWVzIHRvIFBhc2NhbCBDYXNlIChVcHBlciBDYW1lbCBDYXNlKS5cclxuICogVGhpcyBydWxlIGNhbiBoYW5kbGUgdmFyaW91cyBpbnB1dCB0eXBlcyBpbmNsdWRpbmcgc3RyaW5ncywgYXJyYXlzLCBkYXRlcywgYW5kIG9iamVjdHMuXHJcbiAqIFxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqIFxyXG4gKiBAcmVtYXJrc1xyXG4gKiAtIEZvciBzdHJpbmdzLCBpdCBjb252ZXJ0cyB0aGUgZW50aXJlIHN0cmluZyB0byBQYXNjYWwgQ2FzZS5cclxuICogLSBGb3IgYXJyYXlzLCBpdCBtYXBzIGVhY2ggZWxlbWVudCB0byBpdHMgUGFzY2FsIENhc2Ugc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxyXG4gKiAtIEZvciBkYXRlcywgaXQgY29udmVydHMgdGhlIGRhdGUgdG8gYW4gSVNPIHN0cmluZyBhbmQgYXBwbGllcyBQYXNjYWwgQ2FzZS5cclxuICogLSBGb3Igb2JqZWN0cywgaXQgc2VyaWFsaXplcyB0aGUgb2JqZWN0IHRvIGEgSlNPTiBzdHJpbmcgYW5kIGFwcGxpZXMgUGFzY2FsIENhc2UuXHJcbiAqIC0gSWYgdGhlIGlucHV0IHR5cGUgaXMgbm90IHJlY29nbml6ZWQsIGl0IHJldHVybnMgdGhlIGlucHV0IGFzIGlzLlxyXG4gKiBcclxuICogQGV4YW1wbGVcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjb25zdCBydWxlID0gbmV3IFJ1bGVUb1Bhc2NhbENhc2UoKTtcclxuICogY29uc29sZS5sb2cocnVsZS5meChcImhlbGxvIHdvcmxkXCIsIHRvb2xzKSk7IC8vIE91dHB1dHM6IFwiSGVsbG9Xb3JsZFwiXHJcbiAqIGNvbnNvbGUubG9nKHJ1bGUuZngoW1wiaGVsbG8gd29ybGRcIiwgXCJ0ZXN0IGNhc2VcIl0sIHRvb2xzKSk7IC8vIE91dHB1dHM6IFtcIkhlbGxvV29ybGRcIiwgXCJUZXN0Q2FzZVwiXVxyXG4gKiBjb25zb2xlLmxvZyhydWxlLmZ4KG5ldyBEYXRlKFwiMjAyMy0wMS0wMVwiKSwgdG9vbHMpKTsgLy8gT3V0cHV0czogXCIyMDIzLTAxLTAxVDAwOjAwOjAwLjAwMFpcIlxyXG4gKiBjb25zb2xlLmxvZyhydWxlLmZ4KHsga2V5OiBcInZhbHVlXCIgfSwgdG9vbHMpKTsgLy8gT3V0cHV0czogJ3tcIktleVwiOlwiVmFsdWVcIn0nXHJcbiAqIGBgYFxyXG4gKiBcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGVzY3JpcHRpb24gLSBBIGJyaWVmIGRlc2NyaXB0aW9uIG9mIHRoZSBydWxlJ3MgZnVuY3Rpb25hbGl0eS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJ1bGVUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIHJ1bGUsIHdoaWNoIGlzIFwiZm9ybWF0dGVyXCIuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBUaGUgc291cmNlIGNvZGUgdGVtcGxhdGUgZm9yIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSB0eXBlIC0gVGhlIHR5cGVzIG9mIGlucHV0IHRoaXMgcnVsZSBhcHBsaWVzIHRvLCBlLmcuLCBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddLlxyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBmeCAtIFRoZSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIHRoZSBQYXNjYWwgQ2FzZSB0cmFuc2Zvcm1hdGlvbi5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlVG9QYXNjYWxDYXNlIGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaWQgPSAndG9QYXNjYWxDYXNlJztcclxuICAgICAgICB0aGlzLm5hbWUgPSAnVG8gUGFzY2FsIENhc2UnO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnQ29udmVydCB0aGUgdmFsdWUgdG8gUGFzY2FsIENhc2UgKFVwcGVyIENhbWVsIENhc2UpLic7XHJcbiAgICAgICAgdGhpcy5ydWxlVHlwZSA9ICdmb3JtYXR0ZXInO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIGxldCByZXN1bHQgPSAnJztcXG4gIHJldHVybiByZXN1bHQ7XFxufVwiO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICAgICAgdGhpcy5jb25maWdFbGVtZW50cyA9IHRoaXMuZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KTtcclxuICAgIH07XHJcbiAgICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMsIGlucHV0OiBhbnkpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAgICAgY29uc3QgdG9QYXNjYWxDYXNlID0gKHN0cjogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHJcclxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oPzpeXFx3fFtBLVpdfFxcYlxcd3xcXHMrKS9nLCAobWF0Y2gpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2gudG9VcHBlckNhc2UoKVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xccysvZywgJycpXHJcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvW15hLXpBLVowLTldL2csICcnKTsgLy8gUmVtb3ZlIHNwZWNpYWwgY2hhcmFjdGVyc1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0b1Bhc2NhbENhc2UoaW5wdXQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0Lm1hcCgoaXRlbSkgPT4gdG9QYXNjYWxDYXNlKFN0cmluZyhpdGVtKSkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0b1Bhc2NhbENhc2UoaW5wdXQudG9JU09TdHJpbmcoKSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0b1Bhc2NhbENhc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlucHV0O1xyXG4gICAgfTtcclxufVxyXG5cclxuLy9ydWxlcy5yZWdpc3RlclJ1bGUobmV3IFJ1bGVUb1Bhc2NhbENhc2UoKSk7IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgcnVsZSB0aGF0IGNvbnZlcnRzIGlucHV0IHZhbHVlcyB0byBUaXRsZSBDYXNlLlxyXG4gKiBUaGlzIHJ1bGUgY2FuIGhhbmRsZSB2YXJpb3VzIGlucHV0IHR5cGVzIGluY2x1ZGluZyBzdHJpbmdzLCBhcnJheXMsIGRhdGVzLCBhbmQgb2JqZWN0cy5cclxuICogXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICogXHJcbiAqIEByZW1hcmtzXHJcbiAqIC0gRm9yIHN0cmluZ3MsIGl0IGNvbnZlcnRzIHRoZSBlbnRpcmUgc3RyaW5nIHRvIFRpdGxlIENhc2UuXHJcbiAqIC0gRm9yIGFycmF5cywgaXQgbWFwcyBlYWNoIGVsZW1lbnQgdG8gaXRzIFRpdGxlIENhc2Ugc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxyXG4gKiAtIEZvciBkYXRlcywgaXQgY29udmVydHMgdGhlIGRhdGUgdG8gYW4gSVNPIHN0cmluZyBhbmQgYXBwbGllcyBUaXRsZSBDYXNlLlxyXG4gKiAtIEZvciBvYmplY3RzLCBpdCBzZXJpYWxpemVzIHRoZSBvYmplY3QgdG8gYSBKU09OIHN0cmluZyBhbmQgYXBwbGllcyBUaXRsZSBDYXNlLlxyXG4gKiAtIElmIHRoZSBpbnB1dCB0eXBlIGlzIG5vdCByZWNvZ25pemVkLCBpdCByZXR1cm5zIHRoZSBpbnB1dCBhcyBpcy5cclxuICogXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY29uc3QgcnVsZSA9IG5ldyBSdWxlVG9UaXRsZUNhc2UoKTtcclxuICogY29uc29sZS5sb2cocnVsZS5meChcImhlbGxvIHdvcmxkXCIsIHRvb2xzKSk7IC8vIE91dHB1dHM6IFwiSGVsbG8gV29ybGRcIlxyXG4gKiBjb25zb2xlLmxvZyhydWxlLmZ4KFtcImhlbGxvXCIsIFwid29ybGRcIl0sIHRvb2xzKSk7IC8vIE91dHB1dHM6IFtcIkhlbGxvXCIsIFwiV29ybGRcIl1cclxuICogY29uc29sZS5sb2cocnVsZS5meChuZXcgRGF0ZShcIjIwMjMtMDEtMDFcIiksIHRvb2xzKSk7IC8vIE91dHB1dHM6IFwiMjAyMy0wMS0wMVQwMDowMDowMC4wMDBaXCJcclxuICogY29uc29sZS5sb2cocnVsZS5meCh7IGtleTogXCJ2YWx1ZVwiIH0sIHRvb2xzKSk7IC8vIE91dHB1dHM6ICd7XCJLZXlcIjpcIlZhbHVlXCJ9J1xyXG4gKiBgYGBcclxuICogXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uIC0gQSBicmllZiBkZXNjcmlwdGlvbiBvZiB0aGUgcnVsZSdzIGZ1bmN0aW9uYWxpdHkuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBydWxlVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBydWxlLCB3aGljaCBpcyBcImZvcm1hdHRlclwiLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc291cmNlIC0gVGhlIHNvdXJjZSBjb2RlIHRlbXBsYXRlIGZvciB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gdHlwZSAtIFRoZSB0eXBlcyBvZiBpbnB1dCB0aGlzIHJ1bGUgYXBwbGllcyB0bywgZS5nLiwgWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXS5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZnggLSBUaGUgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyB0aGUgVGl0bGUgQ2FzZSB0cmFuc2Zvcm1hdGlvbi5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlVG9UaXRsZUNhc2UgZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9ICd0b1RpdGxlQ2FzZSc7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ1RvIFRpdGxlIENhc2UgKFNpbXBsZSknO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnQ29udmVydCB0aGUgdmFsdWUgdG8gVGl0bGUgQ2FzZS4nO1xyXG4gICAgICAgIHRoaXMucnVsZVR5cGUgPSAnZm9ybWF0dGVyJztcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBsZXQgcmVzdWx0ID0gJyc7XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIjtcclxuICAgICAgICB0aGlzLnR5cGUgPSBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddO1xyXG4gICAgICAgIHRoaXMuY29uZmlnRWxlbWVudHMgPSB0aGlzLmRlZmF1bHRDb25maWdFbGVtZW50cyh7fSk7XHJcbiAgICB9O1xyXG4gICAgZnggKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBURmlsZSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzLCBpbnB1dDogYW55KSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIGNvbnN0IHRvVGl0bGVDYXNlID0gKHN0cjogc3RyaW5nKSA9PiB7ICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGxldCB0ZXh0UGFydHMgPSBzdHIuc3BsaXQoJyAnKTtcclxuICAgICAgICAgICAgbGV0IGNvbnZlcnRlZFRleHRQYXJ0czpzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgICAgICB0ZXh0UGFydHMuZm9yRWFjaCgodGV4dCxpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IG5ld1RleHRQYXJ0ID0gdGV4dC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgbmV3VGV4dFBhcnQgPSBuZXdUZXh0UGFydC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5ld1RleHRQYXJ0LnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgY29udmVydGVkVGV4dFBhcnRzLnB1c2gobmV3VGV4dFBhcnQpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gY29udmVydGVkVGV4dFBhcnRzLmpvaW4oJyAnKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdG9UaXRsZUNhc2UoaW5wdXQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0Lm1hcCgoaXRlbSkgPT4gdG9UaXRsZUNhc2UoU3RyaW5nKGl0ZW0pKSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dCBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRvVGl0bGVDYXNlKGlucHV0LnRvSVNPU3RyaW5nKCkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gdG9UaXRsZUNhc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlucHV0O1xyXG4gICAgfTtcclxufVxyXG5cclxuLy8gcnVsZXMucmVnaXN0ZXJSdWxlKG5ldyBSdWxlVG9UaXRsZUNhc2UoKSk7IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEFwcCwgU2V0dGluZywgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5pbXBvcnQgeyBERUJVRywgbG9nZ2VyLCBUUkFDRSB9IGZyb20gXCIuLi9Mb2dcIjtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgcnVsZSB0aGF0IGNvbnZlcnRzIGlucHV0IHZhbHVlcyB0byBUaXRsZSBDYXNlIHdpdGggR2VybWFuIFwic21hbGxcIiBXb3Jkcy5cclxuICogVGhpcyBydWxlIGNhbiBoYW5kbGUgdmFyaW91cyBpbnB1dCB0eXBlcyBpbmNsdWRpbmcgc3RyaW5ncywgYXJyYXlzLCBkYXRlcywgYW5kIG9iamVjdHMuXHJcbiAqIGdlcm1hbiBkZWZpbml0aW9uIG9mIHNtYWxsIHdvcmRzOiBodHRwczovL2NvcHltYXRlLmFwcC9kZS9ibG9nL211bHRpL3RpdGVsLWthcGl0YWxpc2llcmVyXHJcbiAqIGxpc3Qgb2YgbW9zdCBnZXJtYW4gc21hbGwgd29yZHM6IEdlbWluaSBBSVxyXG4gKiBcclxuICogQGV4dGVuZHMgUnVsZVByb3RvdHlwZVxyXG4gKiBcclxuICogQHJlbWFya3NcclxuICogLSBGb3Igc3RyaW5ncywgaXQgY29udmVydHMgdGhlIGVudGlyZSBzdHJpbmcgdG8gVGl0bGUgQ2FzZS5cclxuICogLSBGb3IgYXJyYXlzLCBpdCBtYXBzIGVhY2ggZWxlbWVudCB0byBpdHMgVGl0bGUgQ2FzZSBzdHJpbmcgcmVwcmVzZW50YXRpb24uXHJcbiAqIC0gRm9yIGRhdGVzLCBpdCBjb252ZXJ0cyB0aGUgZGF0ZSB0byBhbiBJU08gc3RyaW5nIGFuZCBhcHBsaWVzIFRpdGxlIENhc2UuXHJcbiAqIC0gRm9yIG9iamVjdHMsIGl0IHNlcmlhbGl6ZXMgdGhlIG9iamVjdCB0byBhIEpTT04gc3RyaW5nIGFuZCBhcHBsaWVzIFRpdGxlIENhc2UuXHJcbiAqIC0gSWYgdGhlIGlucHV0IHR5cGUgaXMgbm90IHJlY29nbml6ZWQsIGl0IHJldHVybnMgdGhlIGlucHV0IGFzIGlzLlxyXG4gKiBcclxuICogQGV4YW1wbGVcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjb25zdCBydWxlID0gbmV3IFJ1bGVUb1RpdGxlQ2FzZSgpO1xyXG4gKiBjb25zb2xlLmxvZyhydWxlLmZ4KFwiaGVsbG8gd29ybGRcIiwgdG9vbHMpKTsgLy8gT3V0cHV0czogXCJIZWxsbyBXb3JsZFwiXHJcbiAqIGNvbnNvbGUubG9nKHJ1bGUuZngoW1wiaGVsbG9cIiwgXCJ3b3JsZFwiXSwgdG9vbHMpKTsgLy8gT3V0cHV0czogW1wiSGVsbG9cIiwgXCJXb3JsZFwiXVxyXG4gKiBjb25zb2xlLmxvZyhydWxlLmZ4KG5ldyBEYXRlKFwiMjAyMy0wMS0wMVwiKSwgdG9vbHMpKTsgLy8gT3V0cHV0czogXCIyMDIzLTAxLTAxVDAwOjAwOjAwLjAwMFpcIlxyXG4gKiBjb25zb2xlLmxvZyhydWxlLmZ4KHsga2V5OiBcInZhbHVlXCIgfSwgdG9vbHMpKTsgLy8gT3V0cHV0czogJ3tcIktleVwiOlwiVmFsdWVcIn0nXHJcbiAqIGBgYFxyXG4gKiBcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGVzY3JpcHRpb24gLSBBIGJyaWVmIGRlc2NyaXB0aW9uIG9mIHRoZSBydWxlJ3MgZnVuY3Rpb25hbGl0eS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJ1bGVUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIHJ1bGUsIHdoaWNoIGlzIFwiZm9ybWF0dGVyXCIuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBUaGUgc291cmNlIGNvZGUgdGVtcGxhdGUgZm9yIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSB0eXBlIC0gVGhlIHR5cGVzIG9mIGlucHV0IHRoaXMgcnVsZSBhcHBsaWVzIHRvLCBlLmcuLCBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddLlxyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBmeCAtIFRoZSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIHRoZSBUaXRsZSBDYXNlIHRyYW5zZm9ybWF0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVUb1RpdGxlQ2FzZURFIGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgICBwcml2YXRlIHZlcmJvc2VMb2dnaW5nID0gZmFsc2U7IC8vIFNldCB0byB0cnVlIGZvciB2ZXJib3NlIGxvZ2dpbmdcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9ICd0b1RpdGxlQ2FzZURlJztcclxuICAgICAgICB0aGlzLm5hbWUgPSAnVG8gVGl0bGUgQ2FzZSAoR2VybWFuIHNtYWxsIHdvcmRzKSc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdDb252ZXJ0IEdlcm1hbiB2YWx1ZSB0byBUaXRsZSBDYXNlLic7XHJcbiAgICAgICAgdGhpcy5ydWxlVHlwZSA9ICdmb3JtYXR0ZXInO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIGxldCByZXN1bHQgPSAnJztcXG4gIHJldHVybiByZXN1bHQ7XFxufVwiO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICAgICAgdGhpcy5jb25maWdFbGVtZW50cyA9IHRoaXMuZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGZ4IChhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogVEZpbGUsIHRvb2xzOiBTY3JpcHRpbmdUb29scywgaW5wdXQ6IGFueSkgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgICAgICBjb25zdCB0b1RpdGxlQ2FzZSA9IChzdHI6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlSWQgPSB0b29scy5nZXRSdWxlKCk/LmlkO1xyXG4gICAgICAgICAgICBjb25zdCBkb05vdENhcGl0YWxpemVTbWFsbFdvcmRzID0gdG9vbHMuZ2V0T3B0aW9uQ29uZmlnKHJ1bGVJZCwgJ2RvTm90Q2FwaXRhbGl6ZVNtYWxsV29yZHMnKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGl0bGVDYXBzKHN0ciwgZG9Ob3RDYXBpdGFsaXplU21hbGxXb3JkcyA/IHRvb2xzLmdldE9wdGlvbkNvbmZpZyhydWxlSWQsJ3NtYWxsV29yZHMnKSA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgcmVzdWx0OiBhbnkgPSBpbnB1dDtcclxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB0b1RpdGxlQ2FzZShpbnB1dCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBpbnB1dC5tYXAoKGl0ZW0pID0+IHRvVGl0bGVDYXNlKFN0cmluZyhpdGVtKSkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHRvVGl0bGVDYXNlKGlucHV0LnRvSVNPU3RyaW5nKCkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB0b1RpdGxlQ2FzZShKU09OLnN0cmluZ2lmeShpbnB1dCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsb2dnZXIubG9nKERFQlVHLCBgUnVsZVRvVGl0bGVDYXNlREUuZnggLSBpbnB1dDonJHtpbnB1dH0nIHJlc3VsdDonJHsgcmVzdWx0fSdgKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25maWdUYWIob3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOiBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCB0aGF0OiBhbnksIHByZXZpZXdDb21wb25lbnQ6IGFueSkge1xyXG4gICAgICAgIG9wdGlvbkVMLmVtcHR5KCk7XHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgc2V0dGluZyBmb3IgdGhlIHNtYWxsIHdvcmRzXHJcbiAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWdEZWZhdWx0cyhydWxlLmlkLCB7XHJcbiAgICAgICAgICAgIHNtYWxsV29yZHM6ICdkZXJ8ZGllfGRhc3xkZW58ZGVtfGRlc3xlaW5lcnxlaW5lc3xkZXJlbnxlaW58ZWluZXxlaW5lbXxlaW5lcnxlaW5lc3xlaW5lcnx1bmR8b2RlcnxhYmVyfGRlbm58c29uZGVybnxzb3dpZXx3ZWRlcnxub2NofGVudHdlZGVyfG9kZXJ8ZGFzc3x3ZWlsfG9id29obHx3ZW5ufGFsc3xuYWNoZGVtfGJldm9yfHdcdTAwRTRocmVuZHxiaXN8ZGFtaXR8dW18enV8c29iYWxkfHNvbGFuZ2V8ZGF8aW5kZW18c298ZGFzc3xvaG5lfHp1fGR1cmNofGZcdTAwRkNyfGdlZ2VufG9obmV8dW18YmlzfGF1c3xhdVx1MDBERmVyfGJlaXxnZWdlblx1MDBGQ2JlcnxtaXR8bmFjaHxzZWl0fHZvbnx6dXxhbnN0YXR0fGF1ZmdydW5kfGF1XHUwMERGZXJoYWxifGlubmVyaGFsYnx0cm90enx3XHUwMEU0aHJlbmR8d2VnZW58YW58YXVmfGhpbnRlcnxpbnxuZWJlbnxcdTAwRkNiZXJ8dW50ZXJ8dm9yfHp3aXNjaGVuJyxcclxuICAgICAgICAgICAgZG9Ob3RDYXBpdGFsaXplU21hbGxXb3JkczogdHJ1ZSxcclxuICAgICAgICB9KVxyXG4gICAgICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnRG8gbm90IGNhcGl0YWxpemUgc21hbGwgd29yZHMnKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnSWYgZW5hYmxlZCwgc21hbGwgd29yZHMgd2lsbCBub3QgYmUgY2FwaXRhbGl6ZWQuIElmIGRpc2FibGVkLCBhbGwgd29yZHMgd2lsbCBiZSBjYXBpdGFsaXplZC4nKVxyXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGF0LmdldE9wdGlvbkNvbmZpZyhydWxlLmlkICwnZG9Ob3RDYXBpdGFsaXplU21hbGxXb3JkcycpIHx8IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQsJ2RvTm90Q2FwaXRhbGl6ZVNtYWxsV29yZHMnLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC51cGRhdGVQcmV2aWV3KHJ1bGUsIHByZXZpZXdDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAvLyBDcmVhdGUgYSBzZXR0aW5nIGZvciB0aGUgc21hbGwgd29yZHNcclxuICAgICAgICBuZXcgU2V0dGluZyhvcHRpb25FTClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ0xpc3Qgb2Ygc21hbGwgd29yZHMnKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnRW50ZXIgYSBsaXN0IG9mIHNtYWxsIHdvcmRzIHRvIGJlIGV4Y2x1ZGVkIGZyb20gY2FwaXRhbGl6YXRpb24uIFVzZSBcInxcIiBhcyBzZXBhcmF0b3IuJylcclxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhhdC5nZXRPcHRpb25Db25maWcocnVsZS5pZCAsJ3NtYWxsV29yZHMnKSB8fCAnJylcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZyhydWxlLmlkLCdzbWFsbFdvcmRzJywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudXBkYXRlUHJldmlldyhydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICk7XHJcbiAgICB9O1xyXG5cdFxyXG5cdHByaXZhdGUgc21hbGwgPSBcIihkZXJ8ZGllfGRhc3xkZW58ZGVtfGRlc3xlaW5lcnxlaW5lc3xkZXJlbnxlaW58ZWluZXxlaW5lbXxlaW5lcnxlaW5lc3xlaW5lcnx1bmR8b2RlcnxhYmVyfGRlbm58c29uZGVybnxzb3dpZXx3ZWRlcnxub2NofGVudHdlZGVyfG9kZXJ8ZGFzc3x3ZWlsfG9id29obHx3ZW5ufGFsc3xuYWNoZGVtfGJldm9yfHdcdTAwRTRocmVuZHxiaXN8ZGFtaXR8dW18enV8c29iYWxkfHNvbGFuZ2V8ZGF8aW5kZW18c298ZGFzc3xvaG5lfHp1fGR1cmNofGZcdTAwRkNyfGdlZ2VufG9obmV8dW18YmlzfGF1c3xhdVx1MDBERmVyfGJlaXxnZWdlblx1MDBGQ2JlcnxtaXR8bmFjaHxzZWl0fHZvbnx6dXxhbnN0YXR0fGF1ZmdydW5kfGF1XHUwMERGZXJoYWxifGlubmVyaGFsYnx0cm90enx3XHUwMEU0aHJlbmR8d2VnZW58YW58YXVmfGhpbnRlcnxpbnxuZWJlbnxcdTAwRkNiZXJ8dW50ZXJ8dm9yfHp3aXNjaGVuKVwiO1xyXG4gICAgcHJpdmF0ZSBwdW5jdHVhdGlvbiA9IFwiXFxcXChbIVxcXCIjJCUmJygpKissLi86Ozw9Pj9AW1xcXFxcXFxcXFxcXF1eX2B7fH1+XFxcXC1dKlxcXFwpXCI7XHJcblxyXG4gICAgdGl0bGVDYXBzKHRpdGxlOiBzdHJpbmcsIHNtYWxsV29yZHM6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGNvbnN0IHBhcnRzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHNwbGl0ID0gbmV3IFJlZ0V4cChgWzouOz8hXSB8KD86IHxeKVtcIiR7dGhpcy5wdW5jdHVhdGlvbn1dYCwgXCJnXCIpO1xyXG4gICAgICAgIGxldCBpbmRleCA9IDA7XHJcblxyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG0gPSBzcGxpdC5leGVjKHRpdGxlKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHN1YnN0cmluZyA9IHRpdGxlLnN1YnN0cmluZyhpbmRleCwgbSA/IG0uaW5kZXggOiB0aXRsZS5sZW5ndGgpO1xyXG4gICAgICAgICAgICBsb2dnZXIubG9nKFRSQUNFLFwiUHJvY2Vzc2luZyBzdWJzdHJpbmc6XCIsIHN1YnN0cmluZyk7XHJcblxyXG4gICAgICAgICAgICBsZXQgaXNGaXJzdFdvcmQgPSB0cnVlO1xyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgc3Vic3RyaW5nLnJlcGxhY2UoLyhbXFxwe0x9XFxwe019XSsoPzpcXC5bXFxwe0x9XFxwe019XSspKikvZ3UsIChhbGwpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFRSQUNFLFwiTWF0Y2hlZCB3b3JkOlwiLCBhbGwpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBFeGNsdWRlIHdvcmRzIHdpdGggbWl4ZWQgY2FwaXRhbGl6YXRpb24gKGUuZy4sIFwiaVBob25lXCIsIFwiaU1hY1wiKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgvW2Etel1bQS1aXXxbQS1aXVthLXpdLy50ZXN0KGFsbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhUUkFDRSxcIkV4Y2x1ZGluZyBtaXhlZCBjYXBpdGFsaXphdGlvbiB3b3JkOlwiLCBhbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpcnN0V29yZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhjbHVkZSBmdWxseSBjYXBpdGFsaXplZCB3b3JkcyAoZS5nLiwgXCJJQk1cIiwgXCJERUxMXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKC9eW0EtWlx1MDBDNFx1MDBENlx1MDBEQ1x1MDBERl0rJC8udGVzdChhbGwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coVFJBQ0UsXCJFeGNsdWRpbmcgZnVsbHkgY2FwaXRhbGl6ZWQgd29yZDpcIiwgYWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXJzdFdvcmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4Y2x1ZGUgd29yZHMgd2l0aCBwdW5jdHVhdGlvbiB3aXRob3V0IHNwYWNlcyAoZS5nLiwgXCJnb29nbGUuY29tXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKC9bXlxcc10rXFwuW15cXHNdKy8udGVzdChhbGwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coVFJBQ0UsXCJFeGNsdWRpbmcgd29yZCB3aXRoIHB1bmN0dWF0aW9uOlwiLCBhbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpcnN0V29yZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc21hbGxSZWdleCA9IG5ldyBSZWdFeHAoYF4oJHtzbWFsbFdvcmRzfSkkYCwgXCJpdVwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGaXJzdFdvcmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhUUkFDRSxcIkNhcGl0YWxpemluZyBmaXJzdCB3b3JkIG9mIHNlbnRlbmNlOlwiLCBhbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpcnN0V29yZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51cHBlckRFKGFsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzbWFsbFJlZ2V4LnRlc3QoYWxsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFRSQUNFLFwiU2tpcHBpbmcgY2FwaXRhbGl6YXRpb24gZm9yIHNtYWxsIHdvcmQ6XCIsIGFsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvd2VyREUoYWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlzRmlyc3RXb3JkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBwZXJERShhbGwpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGluZGV4ID0gc3BsaXQubGFzdEluZGV4O1xyXG5cclxuICAgICAgICAgICAgaWYgKG0pIHBhcnRzLnB1c2gobVswXSk7XHJcbiAgICAgICAgICAgIGVsc2UgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBsb3dlckRFKHdvcmQ6IHN0cmluZykge1xyXG4gICAgICAgIGxvZ2dlci5sb2coVFJBQ0UsXCJMb3dlcmluZzpcIiwgd29yZCk7XHJcbiAgICAgICAgcmV0dXJuIHdvcmQudG9Mb2NhbGVMb3dlckNhc2UoXCJkZVwiKTtcclxuICAgIH1cclxuXHJcbiAgICB1cHBlckRFKHdvcmQ6IHN0cmluZykge1xyXG4gICAgICAgIGxvZ2dlci5sb2coVFJBQ0UsXCJVcHBlcmluZzpcIiwgd29yZCk7XHJcbiAgICAgICAgLy8gQ2FwaXRhbGl6ZSB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCBsZWF2ZSB0aGUgcmVzdCBvZiB0aGUgd29yZCB1bmNoYW5nZWRcclxuICAgICAgICByZXR1cm4gd29yZC5jaGFyQXQoMCkudG9Mb2NhbGVVcHBlckNhc2UoXCJkZVwiKSArIHdvcmQuc2xpY2UoMSkudG9Mb2NhbGVMb3dlckNhc2UoXCJkZVwiKTtcclxuICAgIH1cclxufSIsICJpbXBvcnQgeyBSdWxlUHJvdG90eXBlLCBydWxlc01hbmFnZXIgfSBmcm9tIFwiLi9ydWxlc1wiO1xyXG5pbXBvcnQgeyBTY3JpcHRpbmdUb29scyB9IGZyb20gXCIuLi90b29sc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIHJ1bGUgdGhhdCBjb252ZXJ0cyBpbnB1dCB2YWx1ZXMgdG8gVGl0bGUgQ2FzZSB3aXRoIEVuZ2xpc2ggXCJzbWFsbFwiIFdvcmRzLlxyXG4gKiBUaGlzIHJ1bGUgY2FuIGhhbmRsZSB2YXJpb3VzIGlucHV0IHR5cGVzIGluY2x1ZGluZyBzdHJpbmdzLCBhcnJheXMsIGRhdGVzLCBhbmQgb2JqZWN0cy5cclxuICogY3JlZGl0IGh0dHBzOi8vam9obnJlc2lnLmNvbS9ibG9nL3RpdGxlLWNhcGl0YWxpemF0aW9uLWluLWphdmFzY3JpcHQvXHJcbiAqIFxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqIFxyXG4gKiBAcmVtYXJrc1xyXG4gKiAtIEZvciBzdHJpbmdzLCBpdCBjb252ZXJ0cyB0aGUgZW50aXJlIHN0cmluZyB0byBUaXRsZSBDYXNlLlxyXG4gKiAtIEZvciBhcnJheXMsIGl0IG1hcHMgZWFjaCBlbGVtZW50IHRvIGl0cyBUaXRsZSBDYXNlIHN0cmluZyByZXByZXNlbnRhdGlvbi5cclxuICogLSBGb3IgZGF0ZXMsIGl0IGNvbnZlcnRzIHRoZSBkYXRlIHRvIGFuIElTTyBzdHJpbmcgYW5kIGFwcGxpZXMgVGl0bGUgQ2FzZS5cclxuICogLSBGb3Igb2JqZWN0cywgaXQgc2VyaWFsaXplcyB0aGUgb2JqZWN0IHRvIGEgSlNPTiBzdHJpbmcgYW5kIGFwcGxpZXMgVGl0bGUgQ2FzZS5cclxuICogLSBJZiB0aGUgaW5wdXQgdHlwZSBpcyBub3QgcmVjb2duaXplZCwgaXQgcmV0dXJucyB0aGUgaW5wdXQgYXMgaXMuXHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNvbnN0IHJ1bGUgPSBuZXcgUnVsZVRvVGl0bGVDYXNlKCk7XHJcbiAqIGNvbnNvbGUubG9nKHJ1bGUuZngoXCJoZWxsbyB3b3JsZFwiLCB0b29scykpOyAvLyBPdXRwdXRzOiBcIkhlbGxvIFdvcmxkXCJcclxuICogY29uc29sZS5sb2cocnVsZS5meChbXCJoZWxsb1wiLCBcIndvcmxkXCJdLCB0b29scykpOyAvLyBPdXRwdXRzOiBbXCJIZWxsb1wiLCBcIldvcmxkXCJdXHJcbiAqIGNvbnNvbGUubG9nKHJ1bGUuZngobmV3IERhdGUoXCIyMDIzLTAxLTAxXCIpLCB0b29scykpOyAvLyBPdXRwdXRzOiBcIjIwMjMtMDEtMDFUMDA6MDA6MDAuMDAwWlwiXHJcbiAqIGNvbnNvbGUubG9nKHJ1bGUuZngoeyBrZXk6IFwidmFsdWVcIiB9LCB0b29scykpOyAvLyBPdXRwdXRzOiAne1wiS2V5XCI6XCJWYWx1ZVwifSdcclxuICogYGBgXHJcbiAqIFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXNjcmlwdGlvbiAtIEEgYnJpZWYgZGVzY3JpcHRpb24gb2YgdGhlIHJ1bGUncyBmdW5jdGlvbmFsaXR5LlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcnVsZVR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgcnVsZSwgd2hpY2ggaXMgXCJmb3JtYXR0ZXJcIi5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZSAtIFRoZSBzb3VyY2UgY29kZSB0ZW1wbGF0ZSBmb3IgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHR5cGUgLSBUaGUgdHlwZXMgb2YgaW5wdXQgdGhpcyBydWxlIGFwcGxpZXMgdG8sIGUuZy4sIFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J10uXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGZ4IC0gVGhlIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgdGhlIFRpdGxlIENhc2UgdHJhbnNmb3JtYXRpb24uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZVRvVGl0bGVDYXNlRU4gZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9ICd0b1RpdGxlQ2FzZUVuJztcclxuICAgICAgICB0aGlzLm5hbWUgPSAnVG8gVGl0bGUgQ2FzZSAoRW5nbGlzaCBzbWFsbCB3b3JkcyknO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnQ29udmVydCB0aGUgdmFsdWUgdG8gVGl0bGUgQ2FzZS4nO1xyXG4gICAgICAgIHRoaXMucnVsZVR5cGUgPSAnZm9ybWF0dGVyJztcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBsZXQgcmVzdWx0ID0gJyc7XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIjtcclxuICAgICAgICB0aGlzLnR5cGUgPSBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddO1xyXG4gICAgICAgIHRoaXMuY29uZmlnRWxlbWVudHMgPSB0aGlzLmRlZmF1bHRDb25maWdFbGVtZW50cyh7fSk7XHJcblx0fTtcclxuXHRcclxuXHRmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMsIGlucHV0OiBhbnkpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcblx0XHRjb25zdCB0b1RpdGxlQ2FzZSA9IChzdHI6IHN0cmluZykgPT4ge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50aXRsZUNhcHMoc3RyKTtcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0cmV0dXJuIHRvVGl0bGVDYXNlKGlucHV0KTtcclxuXHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcclxuXHRcdFx0cmV0dXJuIGlucHV0Lm1hcCgoaXRlbSkgPT4gdG9UaXRsZUNhc2UoU3RyaW5nKGl0ZW0pKSk7XHJcblx0XHR9IGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgRGF0ZSkge1xyXG5cdFx0XHRyZXR1cm4gdG9UaXRsZUNhc2UoaW5wdXQudG9JU09TdHJpbmcoKSk7XHJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0cmV0dXJuIHRvVGl0bGVDYXNlKEpTT04uc3RyaW5naWZ5KGlucHV0KSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gaW5wdXQ7XHJcblx0fTtcclxuXHJcblx0cHJpdmF0ZSBzbWFsbCA9IFwiKGF8YW58YW5kfGFzfGF0fGJ1dHxieXxlbnxmb3J8aWZ8aW58b2Z8b258b3J8dGhlfHRvfHZbLl0/fHZpYXx2c1suXT8pXCI7XHJcblx0cHJpdmF0ZSBwdW5jdHVhdGlvbiA9IFwiKFshXFxcIiMkJSYnKCkqKywuLzo7PD0+P0BbXFxcXFxcXFxcXFxcXV5fYHt8fX4tXSopXCI7XHJcbiAgXHJcblx0dGl0bGVDYXBzICh0aXRsZTpzdHJpbmcpe1xyXG5cdFx0dmFyIHBhcnRzOiBzdHJpbmdbXSA9IFtdLCBzcGxpdCA9IC9bOi47PyFdIHwoPzogfF4pW1wiXHUwMEQyXS9nLCBpbmRleCA9IDA7XHJcblx0XHRcclxuXHRcdHdoaWxlICh0cnVlKSB7XHJcblx0XHRcdHZhciBtID0gc3BsaXQuZXhlYyh0aXRsZSk7XHJcblxyXG5cdFx0XHRwYXJ0cy5wdXNoKCB0aXRsZS5zdWJzdHJpbmcoaW5kZXgsIG0gPyBtLmluZGV4IDogdGl0bGUubGVuZ3RoKVxyXG5cdFx0XHRcdC5yZXBsYWNlKC9cXGIoW0EtWmEtel1bYS16LidcdTAwRDVdKilcXGIvZywgKGFsbDpzdHJpbmcpID0+e1xyXG5cdFx0XHRcdFx0cmV0dXJuIC9bQS1aYS16XVxcLltBLVphLXpdLy50ZXN0KGFsbCkgPyBhbGwgOiB0aGlzLnVwcGVyKGFsbCk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQucmVwbGFjZShSZWdFeHAoXCJcXFxcYlwiICsgdGhpcy5zbWFsbCArIFwiXFxcXGJcIiwgXCJpZ1wiKSwgdGhpcy5sb3dlcilcclxuXHRcdFx0XHQucmVwbGFjZShSZWdFeHAoXCJeXCIgKyB0aGlzLnB1bmN0dWF0aW9uICsgdGhpcy5zbWFsbCArIFwiXFxcXGJcIiwgXCJpZ1wiKSwgKGFsbDpzdHJpbmcsIHB1bmN0OnN0cmluZywgd29yZDpzdHJpbmcpID0+e1xyXG5cdFx0XHRcdFx0cmV0dXJuIHB1bmN0ICsgdGhpcy51cHBlcih3b3JkKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5yZXBsYWNlKFJlZ0V4cChcIlxcXFxiXCIgKyB0aGlzLnNtYWxsICsgdGhpcy5wdW5jdHVhdGlvbiArIFwiJFwiLCBcImlnXCIpLCB0aGlzLnVwcGVyKSk7XHJcblx0XHRcdFxyXG5cdFx0XHRpbmRleCA9IHNwbGl0Lmxhc3RJbmRleDtcclxuXHRcdFx0XHJcblx0XHRcdGlmICggbSApIHBhcnRzLnB1c2goIG1bMF0gKTtcclxuXHRcdFx0ZWxzZSBicmVhaztcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0cmV0dXJuIHBhcnRzLmpvaW4oXCJcIikucmVwbGFjZSgvIFYocz8pXFwuIC9pZywgXCIgdiQxLiBcIilcclxuXHRcdFx0LnJlcGxhY2UoLyhbJ1x1MDBENV0pU1xcYi9pZywgXCIkMXNcIilcclxuXHRcdFx0LnJlcGxhY2UoL1xcYihBVCZUfFEmQSlcXGIvaWcsIGZ1bmN0aW9uKGFsbCl7XHJcblx0XHRcdFx0cmV0dXJuIGFsbC50b1VwcGVyQ2FzZSgpO1xyXG5cdFx0XHR9KTtcclxuXHR9O1xyXG4gICAgXHJcblx0bG93ZXIod29yZDpzdHJpbmcpe1xyXG5cdFx0cmV0dXJuIHdvcmQudG9Mb3dlckNhc2UoKTtcclxuXHR9XHJcbiAgICBcclxuXHR1cHBlcih3b3JkOnN0cmluZyl7XHJcblx0ICByZXR1cm4gd29yZC5zdWJzdHIoMCwxKS50b1VwcGVyQ2FzZSgpICsgd29yZC5zdWJzdHIoMSk7XHJcblx0fVxyXG59IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgcnVsZSB0aGF0IGNvbnZlcnRzIGlucHV0IHZhbHVlcyB0byB1cHBlciBjYXNlLlxyXG4gKiBUaGlzIHJ1bGUgY2FuIGhhbmRsZSB2YXJpb3VzIGlucHV0IHR5cGVzIGluY2x1ZGluZyBzdHJpbmdzLCBhcnJheXMsIGRhdGVzLCBhbmQgb2JqZWN0cy5cclxuICogXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICogXHJcbiAqIEByZW1hcmtzXHJcbiAqIC0gRm9yIHN0cmluZ3MsIGl0IGNvbnZlcnRzIHRoZSBlbnRpcmUgc3RyaW5nIHRvIHVwcGVyIGNhc2UuXHJcbiAqIC0gRm9yIGFycmF5cywgaXQgbWFwcyBlYWNoIGVsZW1lbnQgdG8gaXRzIHVwcGVyIGNhc2Ugc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxyXG4gKiAtIEZvciBkYXRlcywgaXQgY29udmVydHMgdGhlIGRhdGUgdG8gYW4gSVNPIHN0cmluZyBpbiB1cHBlciBjYXNlLlxyXG4gKiAtIEZvciBvYmplY3RzLCBpdCBzZXJpYWxpemVzIHRoZSBvYmplY3QgdG8gYSBKU09OIHN0cmluZyBhbmQgY29udmVydHMgaXQgdG8gdXBwZXIgY2FzZS5cclxuICogLSBJZiB0aGUgaW5wdXQgdHlwZSBpcyBub3QgcmVjb2duaXplZCwgaXQgcmV0dXJucyB0aGUgaW5wdXQgYXMgaXMuXHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNvbnN0IHJ1bGUgPSBuZXcgUnVsZVRvVXBwZXJDYXNlKCk7XHJcbiAqIGNvbnNvbGUubG9nKHJ1bGUuZngoXCJoZWxsb1wiLCB0b29scykpOyAvLyBPdXRwdXRzOiBcIkhFTExPXCJcclxuICogY29uc29sZS5sb2cocnVsZS5meChbXCJoZWxsb1wiLCBcIndvcmxkXCJdLCB0b29scykpOyAvLyBPdXRwdXRzOiBbXCJIRUxMT1wiLCBcIldPUkxEXCJdXHJcbiAqIGNvbnNvbGUubG9nKHJ1bGUuZngobmV3IERhdGUoXCIyMDIzLTAxLTAxXCIpLCB0b29scykpOyAvLyBPdXRwdXRzOiBcIjIwMjMtMDEtMDFUMDA6MDA6MDAuMDAwWlwiXHJcbiAqIGNvbnNvbGUubG9nKHJ1bGUuZngoeyBrZXk6IFwidmFsdWVcIiB9LCB0b29scykpOyAvLyBPdXRwdXRzOiAne1wiS0VZXCI6XCJWQUxVRVwifSdcclxuICogYGBgXHJcbiAqIFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXNjcmlwdGlvbiAtIEEgYnJpZWYgZGVzY3JpcHRpb24gb2YgdGhlIHJ1bGUncyBmdW5jdGlvbmFsaXR5LlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcnVsZVR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgcnVsZSwgd2hpY2ggaXMgXCJmb3JtYXR0ZXJcIi5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZSAtIFRoZSBzb3VyY2UgY29kZSB0ZW1wbGF0ZSBmb3IgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHR5cGUgLSBUaGUgdHlwZXMgb2YgaW5wdXQgdGhpcyBydWxlIGFwcGxpZXMgdG8sIGUuZy4sIFsndGV4dCddLlxyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBmeCAtIFRoZSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIHRoZSB1cHBlciBjYXNlIHRyYW5zZm9ybWF0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVUb1VwcGVyQ2FzZSBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlkID0gJ3RvVXBwZXJDYXNlJztcclxuICAgICAgICB0aGlzLm5hbWUgPSAnVG8gVXBwZXIgQ2FzZSc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdDb252ZXJ0IHRoZSB2YWx1ZSB0byB1cHBlciBjYXNlLic7XHJcbiAgICAgICAgdGhpcy5ydWxlVHlwZSA9ICdmb3JtYXR0ZXInO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIGxldCByZXN1bHQgPSAnJztcXG4gIHJldHVybiByZXN1bHQ7XFxufVwiO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICAgICAgdGhpcy5jb25maWdFbGVtZW50cyA9IHRoaXMuZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KTtcclxuICAgIH07XHJcbiAgICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMsIGlucHV0OiBhbnkpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAgICAgaWYgKFN0cmluZy5pc1N0cmluZyhpbnB1dCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5tYXAoKGl0ZW0pID0+IFN0cmluZyhpdGVtKS50b1VwcGVyQ2FzZSgpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQudG9JU09TdHJpbmcoKS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaW5wdXQpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnB1dDtcclxuICAgIH1cclxufVxyXG5cclxuLy9ydWxlc01hbmFnZXIucmVnaXN0ZXJSdWxlKG5ldyBSdWxlVG9VcHBlckNhc2UoKSk7IiwgIi8vIFRoaXMgZmlsZSBpcyBhdXRvLWdlbmVyYXRlZC4gRG8gbm90IGVkaXQgbWFudWFsbHkuXG4vLyBHZW5lcmF0ZWQgYnkgYnVpbGQtcnVsZXMtaW5kZXguanNcbmltcG9ydCB7IHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XG5pbXBvcnQgeyBSdWxlQWRkUHJlZml4IH0gZnJvbSBcIi4vYWRkUHJlZml4XCI7XG5pbXBvcnQgeyBSdWxlQWRkU3VmZml4IH0gZnJvbSBcIi4vYWRkU3VmZml4XCI7XG5pbXBvcnQgeyBSdWxlQXV0b21hdGlvbkF1dG9MaW5rIH0gZnJvbSBcIi4vYXV0b21hdGlvbkF1dG9MaW5rXCI7XG5pbXBvcnQgeyBSdWxlQnVpbGRJbkF1dG9Db21wbGV0ZU1vZGFsIH0gZnJvbSBcIi4vYnVpbGRJbkF1dG9Db21wbGV0ZU1vZGFsXCI7XG5pbXBvcnQgeyBSdWxlQnVpbGRJbkNvbmNhdEFycmF5cyB9IGZyb20gXCIuL2J1aWxkSW5Db25jYXRBcnJheXNcIjtcbmltcG9ydCB7IFJ1bGVCdWlsZEluQ29uY2F0UHJvcGVydGllcyB9IGZyb20gXCIuL2J1aWxkSW5Db25jYXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBSdWxlQnVpbGRJbkNvbnN0YW50IH0gZnJvbSBcIi4vYnVpbGRJbkNvbnN0YW50XCI7XG5pbXBvcnQgeyBSdWxlQnVpbGRJbkRhdGVUaW1lQ3JlYXRlZCB9IGZyb20gXCIuL2J1aWxkSW5EYXRlVGltZUNyZWF0ZWRcIjtcbmltcG9ydCB7IFJ1bGVCdWlsZEluRGF0ZVRpbWVNb2RpZmllZCB9IGZyb20gXCIuL2J1aWxkSW5EYXRlVGltZU1vZGlmaWVkXCI7XG5pbXBvcnQgeyBSdWxlQnVpbGRJbkRlZmF1bHQgfSBmcm9tIFwiLi9idWlsZEluRGVmYXVsdFwiO1xuaW1wb3J0IHsgUnVsZUJ1aWxkSW5GaWxlU2l6ZUJ5dGVzIH0gZnJvbSBcIi4vYnVpbGRJbkZpbGVTaXplQnl0ZXNcIjtcbmltcG9ydCB7IFJ1bGVCdWlsZEluRmlsZVNpemVTdHJpbmcgfSBmcm9tIFwiLi9idWlsZEluRmlsZVNpemVTdHJpbmdcIjtcbmltcG9ydCB7IFJ1bGVCdWlsZEluRm9sZGVyIH0gZnJvbSBcIi4vYnVpbGRJbkZvbGRlclwiO1xuaW1wb3J0IHsgUnVsZUJ1aWxkSW5Gb2xkZXJGb2xkZXJOb3RlcyB9IGZyb20gXCIuL2J1aWxkSW5Gb2xkZXJGb2xkZXJOb3Rlc1wiO1xuaW1wb3J0IHsgUnVsZUJ1aWxkSW5Gb2xkZXJzIH0gZnJvbSBcIi4vYnVpbGRJbkZvbGRlcnNcIjtcbmltcG9ydCB7IFJ1bGVCdWlsZEluRnVsbFBhdGggfSBmcm9tIFwiLi9idWlsZEluRnVsbFBhdGhcIjtcbmltcG9ydCB7IFJ1bGVCdWlsZEluRnVsbFBhdGhFeHQgfSBmcm9tIFwiLi9idWlsZEluRnVsbFBhdGhFeHRcIjtcbmltcG9ydCB7IFJ1bGVCdWlsZEluRnVsbFBhdGhFeHRGb2xkZXJOb3RlcyB9IGZyb20gXCIuL2J1aWxkSW5GdWxsUGF0aEV4dEZvbGRlck5vdGVzXCI7XG5pbXBvcnQgeyBSdWxlQnVpbGRJbkZ1bGxQYXRoRm9sZGVyTm90ZXMgfSBmcm9tIFwiLi9idWlsZEluRnVsbFBhdGhGb2xkZXJOb3Rlc1wiO1xuaW1wb3J0IHsgUnVsZUJ1aWxkSW5HZXRQcm9wZXJ0eSB9IGZyb20gXCIuL2J1aWxkSW5HZXRQcm9wZXJ0eVwiO1xuaW1wb3J0IHsgUnVsZUJ1aWxkSW5Jc1Jvb3QgfSBmcm9tIFwiLi9idWlsZEluSXNSb290XCI7XG5pbXBvcnQgeyBSdWxlQnVpbGRJbkxpbmtUb0ZpbGUgfSBmcm9tIFwiLi9idWlsZEluTGlua1RvRmlsZVwiO1xuaW1wb3J0IHsgUnVsZUJ1aWxkSW5OYW1lIH0gZnJvbSBcIi4vYnVpbGRJbk5hbWVcIjtcbmltcG9ydCB7IFJ1bGVCdWlsZEluTmFtZUV4dCB9IGZyb20gXCIuL2J1aWxkSW5OYW1lRXh0XCI7XG5pbXBvcnQgeyBSdWxlQnVpbGRJblBhdGggfSBmcm9tIFwiLi9idWlsZEluUGF0aFwiO1xuaW1wb3J0IHsgUnVsZUJ1aWxkSW5QYXRoRm9sZGVyTm90ZXMgfSBmcm9tIFwiLi9idWlsZEluUGF0aEZvbGRlck5vdGVzXCI7XG5pbXBvcnQgeyBSdWxlQnVpbGRJblJvb3RGb2xkZXIgfSBmcm9tIFwiLi9idWlsZEluUm9vdEZvbGRlclwiO1xuaW1wb3J0IHsgUnVsZUJ1aWxkSW5TY3JpcHQgfSBmcm9tIFwiLi9idWlsZEluU2NyaXB0XCI7XG5pbXBvcnQgeyBSdWxlUmVwbGFjZUNoYXJzIH0gZnJvbSBcIi4vcmVwbGFjZUNoYXJzXCI7XG5pbXBvcnQgeyBSdWxlUmVwbGFjZVNwYWNlcyB9IGZyb20gXCIuL3JlcGxhY2VTcGFjZXNcIjtcbmltcG9ydCB7IFJ1bGVSZXBsYWNlU3BlY2lhbENoYXJzIH0gZnJvbSBcIi4vcmVwbGFjZVNwZWNpYWxDaGFyc1wiO1xuaW1wb3J0IHsgUnVsZVRvQ2FtZWxDYXNlIH0gZnJvbSBcIi4vdG9DYW1lbENhc2VcIjtcbmltcG9ydCB7IFJ1bGVUb0xpbmtNYXJrZG93biB9IGZyb20gXCIuL3RvTGlua01hcmtkb3duXCI7XG5pbXBvcnQgeyBSdWxlVG9MaW5rT3JpZ2luYWwgfSBmcm9tIFwiLi90b0xpbmtPcmlnaW5hbFwiO1xuaW1wb3J0IHsgUnVsZVRvTGlua1NpbXBsZSB9IGZyb20gXCIuL3RvTGlua1NpbXBsZVwiO1xuaW1wb3J0IHsgUnVsZVRvTGlua1dpa2kgfSBmcm9tIFwiLi90b0xpbmtXaWtpXCI7XG5pbXBvcnQgeyBSdWxlVG9Mb3dlckNhc2UgfSBmcm9tIFwiLi90b0xvd2VyQ2FzZVwiO1xuaW1wb3J0IHsgUnVsZVRvT3JpZ2luYWwgfSBmcm9tIFwiLi90b09yaWdpbmFsXCI7XG5pbXBvcnQgeyBSdWxlVG9QYXNjYWxDYXNlIH0gZnJvbSBcIi4vdG9QYXNjYWxDYXNlXCI7XG5pbXBvcnQgeyBSdWxlVG9UaXRsZUNhc2UgfSBmcm9tIFwiLi90b1RpdGxlQ2FzZVwiO1xuaW1wb3J0IHsgUnVsZVRvVGl0bGVDYXNlREUgfSBmcm9tIFwiLi90b1RpdGxlQ2FzZURFXCI7XG5pbXBvcnQgeyBSdWxlVG9UaXRsZUNhc2VFTiB9IGZyb20gXCIuL3RvVGl0bGVDYXNlRU5cIjtcbmltcG9ydCB7IFJ1bGVUb1VwcGVyQ2FzZSB9IGZyb20gXCIuL3RvVXBwZXJDYXNlXCI7XG5cbi8vIExpc3Qgb2YgYWxsIHJ1bGUgY2xhc3Nlc1xuY29uc3QgcnVsZUNsYXNzZXMgPSBbUnVsZUFkZFByZWZpeCwgUnVsZUFkZFN1ZmZpeCwgUnVsZUF1dG9tYXRpb25BdXRvTGluaywgUnVsZUJ1aWxkSW5BdXRvQ29tcGxldGVNb2RhbCwgUnVsZUJ1aWxkSW5Db25jYXRBcnJheXMsIFJ1bGVCdWlsZEluQ29uY2F0UHJvcGVydGllcywgUnVsZUJ1aWxkSW5Db25zdGFudCwgUnVsZUJ1aWxkSW5EYXRlVGltZUNyZWF0ZWQsIFJ1bGVCdWlsZEluRGF0ZVRpbWVNb2RpZmllZCwgUnVsZUJ1aWxkSW5EZWZhdWx0LCBSdWxlQnVpbGRJbkZpbGVTaXplQnl0ZXMsIFJ1bGVCdWlsZEluRmlsZVNpemVTdHJpbmcsIFJ1bGVCdWlsZEluRm9sZGVyLCBSdWxlQnVpbGRJbkZvbGRlckZvbGRlck5vdGVzLCBSdWxlQnVpbGRJbkZvbGRlcnMsIFJ1bGVCdWlsZEluRnVsbFBhdGgsIFJ1bGVCdWlsZEluRnVsbFBhdGhFeHQsIFJ1bGVCdWlsZEluRnVsbFBhdGhFeHRGb2xkZXJOb3RlcywgUnVsZUJ1aWxkSW5GdWxsUGF0aEZvbGRlck5vdGVzLCBSdWxlQnVpbGRJbkdldFByb3BlcnR5LCBSdWxlQnVpbGRJbklzUm9vdCwgUnVsZUJ1aWxkSW5MaW5rVG9GaWxlLCBSdWxlQnVpbGRJbk5hbWUsIFJ1bGVCdWlsZEluTmFtZUV4dCwgUnVsZUJ1aWxkSW5QYXRoLCBSdWxlQnVpbGRJblBhdGhGb2xkZXJOb3RlcywgUnVsZUJ1aWxkSW5Sb290Rm9sZGVyLCBSdWxlQnVpbGRJblNjcmlwdCwgUnVsZVJlcGxhY2VDaGFycywgUnVsZVJlcGxhY2VTcGFjZXMsIFJ1bGVSZXBsYWNlU3BlY2lhbENoYXJzLCBSdWxlVG9DYW1lbENhc2UsIFJ1bGVUb0xpbmtNYXJrZG93biwgUnVsZVRvTGlua09yaWdpbmFsLCBSdWxlVG9MaW5rU2ltcGxlLCBSdWxlVG9MaW5rV2lraSwgUnVsZVRvTG93ZXJDYXNlLCBSdWxlVG9PcmlnaW5hbCwgUnVsZVRvUGFzY2FsQ2FzZSwgUnVsZVRvVGl0bGVDYXNlLCBSdWxlVG9UaXRsZUNhc2VERSwgUnVsZVRvVGl0bGVDYXNlRU4sIFJ1bGVUb1VwcGVyQ2FzZV07XG5cbi8vIFJlZ2lzdGVyIGVhY2ggcnVsZSBjbGFzc1xucnVsZUNsYXNzZXMuZm9yRWFjaCgoUnVsZUNsYXNzKSA9PiB7XG4gICAgY29uc3QgcnVsZUluc3RhbmNlID0gbmV3IFJ1bGVDbGFzcygpO1xuICAgIHJ1bGVzTWFuYWdlci5yZWdpc3RlclJ1bGUocnVsZUluc3RhbmNlKTtcbn0pOyJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUEsb0JBQTZJOzs7QUNBN0ksSUFBQUMsb0JBQWlIOzs7QUNBakgsSUFBQUMsbUJBQWlEOzs7QUNBakQsc0JBQXVCOzs7QUNFaEIsSUFBTSxlQUFOLGNBQTJCLE1BQU07QUFBQSxFQUNwQyxZQUFZLEtBQW9CLGFBQXNCO0FBQ2xELFVBQU0sR0FBRztBQURtQjtBQUU1QixTQUFLLE9BQU8sS0FBSyxZQUFZO0FBQzdCLFFBQUksTUFBTSxtQkFBbUI7QUFDekIsWUFBTSxrQkFBa0IsTUFBTSxLQUFLLFdBQVc7QUFBQSxJQUNsRDtBQUFBLEVBQ0o7QUFDSjtBQW1CTyxTQUFTLGlCQUFvQkMsS0FBYSxLQUFnQjtBQUM3RCxNQUFJO0FBQ0EsV0FBT0EsSUFBRztBQUFBLEVBQ2QsU0FBUyxHQUFQO0FBQ0UsUUFBSSxhQUFhLE9BQU87QUFDcEIsZUFBUyxJQUFJLGFBQWEsS0FBSyxFQUFFLE9BQU8sQ0FBQztBQUFBLElBQzdDLE9BQU87QUFDSCxlQUFTLElBQUksYUFBYSxLQUFLLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFBQSxJQUM3QztBQUNBLFdBQU87QUFBQSxFQUNYO0FBQ0o7OztBRHBDTyxJQUFNLE1BQU07QUFDWixJQUFNLFFBQVE7QUFDZCxJQUFNLFFBQVE7QUFD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TSxRQUFRLEtBQUssMEJBQTBCLEtBQUssWUFBWSxLQUFLLG1CQUFtQjtBQUNqRyxpQkFBTyxTQUFTO0FBQ2hCO0FBQUEsUUFDSjtBQUNBLFlBQUksS0FBSyxjQUFjLENBQUMsWUFBWSxlQUFlLEtBQUssUUFBUSxHQUFHO0FBQy9ELGlCQUFPLElBQUksT0FBTSxTQUFTLEtBQUssa0JBQWtCLEtBQUssa0JBQWtCLEtBQUssa0NBQWtDO0FBQy9HLGlCQUFPLFNBQVM7QUFDaEI7QUFBQSxRQUNKO0FBQ0EsaUJBQVFBLE1BQUEsYUFBYSxZQUFZLEtBQUssT0FBTyxNQUFyQyxnQkFBQUEsSUFBd0MsVUFBVTtBQUFBLFVBQ3RELEtBQUs7QUFBQSxVQUNMLEtBQUs7QUFDRCxxQkFBUyxrQkFBa0IsV0FBVyxLQUFLLEtBQUssTUFBTSxLQUFLLFVBQVUsTUFBTSxZQUFZLEtBQUssUUFBUSxHQUFHLE1BQU0sYUFBYSxrQkFBa0I7QUFDNUk7QUFBQSxVQUNKO0FBQUEsUUFDSjtBQUNBLG9CQUFZLEtBQUssUUFBUSxJQUFJO0FBQzdCLGVBQU8sU0FBUztBQUFBLE1BQ3BCO0FBQ0EsYUFBTyxJQUFJLE9BQU0sdUJBQXNCLFdBQVc7QUFDbEQsYUFBTyxTQUFTO0FBQUEsSUFDcEIsR0FBRSxFQUFDLFNBQVEsS0FBSyxLQUFLLE1BQUssQ0FBQztBQUFBLEVBQy9CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUF1Qko7IiwKICAibmFtZXMiOiBbImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImZuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAicnVsZSIsICJ2YWx1ZSIsICJqc0NvZGUiLCAicnVsZSIsICJ0ZXh0IiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJqc0NvZGUiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAicnVsZSIsICJfYSIsICJfYiIsICJfYyIsICJfZCIsICJfZSIsICJfZiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgIm5hbWUiLCAic3R5bGUiLCAid2luZG93IiwgIm1pbiIsICJtYXgiLCAidG9QYWRkaW5nT2JqZWN0IiwgInBvcHBlck9mZnNldHMiLCAibWluIiwgIm1heCIsICJvZmZzZXQiLCAiZWZmZWN0IiwgInBvcHBlciIsICJlZmZlY3QiLCAid2luZG93IiwgImhhc2giLCAiY2xpcHBpbmdQYXJlbnRzIiwgInJlZmVyZW5jZSIsICJwb3BwZXJPZmZzZXRzIiwgIm9mZnNldCIsICJwbGFjZW1lbnRzIiwgInBsYWNlbWVudCIsICJwbGFjZW1lbnRzIiwgInBsYWNlbWVudCIsICJfbG9vcCIsICJfaSIsICJjaGVja3MiLCAib2Zmc2V0IiwgInBvcHBlck9mZnNldHMiLCAib2Zmc2V0IiwgIm1pbiIsICJtYXgiLCAiZm4iLCAibWVyZ2VkIiwgImRlZmF1bHRNb2RpZmllcnMiLCAiY3JlYXRlUG9wcGVyIiwgInJlZmVyZW5jZSIsICJwb3BwZXIiLCAib3B0aW9ucyIsICJmbiIsICJzdGF0ZSIsICJlZmZlY3QiLCAibm9vcEZuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImZyb250bWF0dGVyIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAicmVzdWx0IiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJmb2xkZXIiLCAiX2EiXQp9Cg==
