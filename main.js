/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FolderTagPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian15 = require("obsidian");

// src/settings.ts
var import_obsidian14 = require("obsidian");

// src/frontmatter-tools.ts
var import_obsidian = require("obsidian");
function getPropertiesFromMetadataManager(app) {
  try {
    const metadataManager = app.metadataTypeManager;
    console.log("get properties:", metadataManager);
    return Object.values(metadataManager.properties).map((value) => ({
      name: value.name,
      type: value.type,
      count: value.count,
      source: "registered"
    })).sort((a, b) => a.name.localeCompare(b.name));
  } catch (e) {
    console.error("Couldn't access properties from Metadata Manager", e);
    return [];
  }
}
function getTypesFromMetadataManager(app) {
  try {
    const metadataManager = app.metadataTypeManager;
    console.log("get types:", metadataManager);
    return Object.values(metadataManager.registeredTypeWidgets).map((value, index, array) => ({
      type: value.type,
      icon: value.icon,
      jsType: ""
    })).sort((a, b) => a.type.localeCompare(b.type));
  } catch (e) {
    console.error("Couldn't access properties from Metadata Manager", e);
    return [];
  }
}

// src/tools.ts
var import_obsidian11 = require("obsidian");

// src/Log.ts
var import_obsidian2 = require("obsidian");
function logError(e) {
  const notice = new import_obsidian2.Notice("", 8e3);
  if (e instanceof ErrorManager && e.console_msg) {
    notice.messageEl.innerHTML = `<b>Frontmatter Automate Error</b>:<br/>${e.message}<br/>Check console for more information`;
    console.error(`Frontmatter Error:`, e.message, "\n", e.console_msg);
  } else {
    notice.messageEl.innerHTML = `<b>Frontmatter Automate Error</b>:<br/>${e.message}`;
  }
}

// src/Error.ts
var ErrorManager = class extends Error {
  constructor(msg, console_msg) {
    super(msg);
    this.console_msg = console_msg;
    this.name = this.constructor.name;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
function errorWrapperSync(fn2, msg) {
  try {
    return fn2();
  } catch (e) {
    logError(new ErrorManager(msg, e.message));
    return null;
  }
}

// src/alertBox.ts
var import_obsidian3 = require("obsidian");
var AlertModal = class extends import_obsidian3.Modal {
  constructor(app, title, description, btn1, btn2, askAgainLabel) {
    super(app);
    this.title = title;
    this.description = description;
    this.btn1Text = btn1;
    this.btn2Text = btn2;
    this.askAgainLabel = askAgainLabel;
    this.promise = new Promise((resolve) => {
      this.resolvePromise = resolve;
    });
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: this.title });
    contentEl.createEl("p", { text: this.description });
    const settings = new import_obsidian3.Setting(contentEl);
    if (this.askAgainLabel) {
      const itemInfoDiv = settings.settingEl.getElementsByClassName("setting-item-info")[0];
      if (itemInfoDiv) {
        this.checkboxEl = itemInfoDiv.createEl("input", { type: "checkbox" });
        const label = itemInfoDiv.createEl("label", { text: this.askAgainLabel });
        label.style.marginLeft = "8px";
      }
    }
    settings.addButton((btn) => {
      btn.setButtonText(this.btn1Text).setCta().onClick(() => {
        var _a;
        this.close();
        this.resolvePromise({ proceed: true, data: { askConfirmation: (_a = this.checkboxEl) == null ? void 0 : _a.checked } });
      });
    });
    settings.addButton((btn) => {
      btn.setButtonText(this.btn2Text).onClick(() => {
        var _a;
        this.close();
        this.resolvePromise({ proceed: false, data: { askConfirmation: (_a = this.checkboxEl) == null ? void 0 : _a.checked } });
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  async openAndGetValue() {
    this.open();
    return this.promise;
  }
};

// src/rules.ts
var import_obsidian10 = require("obsidian");

// src/autocompleteModal.ts
var import_obsidian5 = require("obsidian");

// src/uiElements.ts
var import_obsidian4 = require("obsidian");
function renderValueInput(containerEl, propertyInfo, currentValue, changeCallback) {
  let returnComponent;
  containerEl.empty();
  if (!propertyInfo) {
    containerEl.setText("");
    containerEl.addClass("text-muted");
    return;
  }
  const type = propertyInfo.type;
  switch (type) {
    case "number":
      returnComponent = new import_obsidian4.TextComponent(containerEl).setPlaceholder("Numeric Value").setValue(currentValue !== void 0 && currentValue !== null ? String(currentValue) : "").onChange(async (value) => {
        const numValue = value === "" ? void 0 : parseFloat(value);
        changeCallback(propertyInfo, isNaN(numValue) ? void 0 : numValue);
      });
      returnComponent.inputEl.type = "number";
      break;
    case "checkbox":
      returnComponent = containerEl.createDiv({ cls: "tri-state-checkbox clickable-icon" });
      returnComponent.setAttribute("aria-label", "Checkbox change state");
      returnComponent.setAttribute("role", "checkbox");
      const updateCheckboxVisual = (state) => {
        let iconName;
        let ariaState;
        if (state === true) {
          iconName = "check-square";
          ariaState = "true";
        } else if (state === false) {
          iconName = "square";
          ariaState = "false";
        } else {
          iconName = "minus-square";
          ariaState = "mixed";
        }
        (0, import_obsidian4.setIcon)(returnComponent, iconName);
        returnComponent.setAttribute("aria-checked", ariaState);
        returnComponent.dataset.state = String(state);
      };
      updateCheckboxVisual(currentValue);
      returnComponent.addEventListener("click", async () => {
        let currentState = returnComponent.dataset.state;
        let nextState;
        if (currentState === "false") {
          nextState = true;
        } else if (currentState === "true") {
          nextState = void 0;
        } else {
          nextState = false;
        }
        changeCallback(propertyInfo, nextState);
        updateCheckboxVisual(nextState);
      });
      break;
    case "date":
      returnComponent = new import_obsidian4.TextComponent(containerEl).setPlaceholder("YYYY-MM-DD").setValue(currentValue || "").onChange(async (value) => {
        changeCallback(propertyInfo, value || void 0);
      });
      returnComponent.inputEl.type = "date";
      break;
    case "datetime":
      returnComponent = new import_obsidian4.TextComponent(containerEl).setPlaceholder("YYYY-MM-DDTHH:mm").setValue(currentValue || "").onChange(async (value) => {
        changeCallback(propertyInfo, value || void 0);
      });
      returnComponent.inputEl.type = "datetime-local";
      break;
    case "aliases":
    case "tags":
    case "multitext":
      returnComponent = new import_obsidian4.TextComponent(containerEl).setPlaceholder("values (divided by comma)").setValue(Array.isArray(currentValue) ? currentValue.join(", ") : currentValue || "").onChange(async (value) => {
        const arrayValue = value.split(",").map((s) => s.trim()).filter((s) => s);
        changeCallback(propertyInfo, arrayValue.length > 0 ? arrayValue : void 0);
      });
      break;
    case "text":
    default:
      returnComponent = new import_obsidian4.TextComponent(containerEl).setPlaceholder("value").setValue(currentValue || "").onChange(async (value) => {
        changeCallback(propertyInfo, value || void 0);
      });
      break;
  }
  if (type !== "checkbox") {
    returnComponent.inputEl.style.backgroundColor = "transparent";
    returnComponent.inputEl.style.width = "100%";
    returnComponent.inputEl.style.border = "none";
  }
  return returnComponent;
}
function updatePropertyIcon(iconEl, type) {
  let iconName = "hash";
  switch (type) {
    case "text":
      iconName = "align-left";
      break;
    case "number":
      iconName = "binary";
      break;
    case "multitext":
      iconName = "list";
      break;
    case "date":
      iconName = "calendar";
      break;
    case "datetime":
      iconName = "clock";
      break;
    case "checkbox":
      iconName = "check-square";
      break;
    case "tags":
      iconName = "tags";
      break;
    case "aliases":
      iconName = "forward";
      break;
    default:
      iconName = "help-circle";
  }
  (0, import_obsidian4.setIcon)(iconEl, iconName);
}

// src/autocompleteModal.ts
var AutocompleteModal = class extends import_obsidian5.Modal {
  /**
   * Creates an instance of the DirectorySelectionModal.
   * @param app - The Obsidian App instance.
   * @param plugin - The plugin instance.
   * @param expectedType - Expected return type.
   * @param activeFile - The currently active file or folder.
   * @param frontmatter - Frontmatter data for the active file.
   * @param okCallback - Function to call when the user clicks "OK". Receives the selection result.
   */
  constructor(app, plugin, rule, options, activeFile, frontmatter, okCallback) {
    super(app);
    this.knownProperties = {};
    this.result = {};
    this.changeCallback = (propertyInfo, value) => {
      if (propertyInfo) {
        this.result[propertyInfo.name] = value;
      }
    };
    this.app = app;
    this.tools = new ScriptingTools(app, this.plugin, this.frontmatter);
    this.activeFile = activeFile;
    this.frontmatter = frontmatter;
    this.plugin = plugin;
    this.rule = rule;
    this.options = options;
    this.expectedType = rule.type;
    this.promise = new Promise((resolve) => {
      this.resolvePromise = resolve;
    });
    if (okCallback)
      this.okCallback = okCallback;
    this.resetToInitial();
  }
  /**
   * Resets the current selection state to the initial state provided at construction.
   */
  resetToInitial() {
  }
  /**
   * Resets the current selection state to empty.
   */
  resetToEmpty() {
  }
  /**
   * Called when the modal is opened. Builds the UI.
   */
  async onOpen() {
    var _a;
    this.knownProperties = await this.tools.fetchKnownProperties(this.app);
    const { contentEl } = this;
    if (contentEl.parentElement)
      contentEl.parentElement.style.width = "900px";
    contentEl.empty();
    contentEl.addClass("codeEditor-modal");
    contentEl.createEl("h2", { text: "Please complete the following properties" });
    contentEl.createEl("body", { text: `File: ${(_a = this.activeFile) == null ? void 0 : _a.path}` });
    this.contentRootElement = contentEl.createDiv({ cls: "codeEditor-container" });
    this.contentRootElement.style.overflowY = "auto";
    this.contentRootElement.style.padding = "10px";
    this.contentRootElement.style.marginTop = "10px";
    this.contentRootElement.style.marginBottom = "10px";
    const propertyContainerEl = contentEl.createDiv({ cls: "codeEditor-options" });
    propertyContainerEl.style.flexDirection = "column";
    for (const [key, value] of Object.entries(this.frontmatter)) {
      if (key.startsWith(this.rule.property + this.options.propertyDelimiter)) {
        const rowEl = propertyContainerEl.createDiv({ cls: "property-setting-row setting-item" });
        rowEl.style.width = "100%";
        const controlEl = rowEl.createDiv({ cls: "setting-item-control" });
        controlEl.style.display = "flex";
        controlEl.style.alignItems = "center";
        controlEl.style.justifyContent = "space-between";
        controlEl.style.width = "100%";
        controlEl.style.gap = "0px";
        const leftContainer = controlEl.createDiv({ cls: "property-left-container" });
        leftContainer.style.display = "flex";
        leftContainer.style.alignItems = "center";
        leftContainer.style.minWidth = "250px";
        const iconEl = leftContainer.createSpan({ cls: "property-icon setting-item-icon" });
        iconEl.style.marginRight = "8px";
        updatePropertyIcon(iconEl, this.knownProperties[key].type);
        const searchContainer = leftContainer.createDiv({ cls: "property-search-container" });
        const nameInput = new import_obsidian5.TextComponent(searchContainer).setValue(key).setPlaceholder("Property name").setDisabled(true);
        nameInput.inputEl.style.border = "none";
        const middleContainer = controlEl.createDiv({ cls: "property-middle-container" });
        const valueContainer = middleContainer.createDiv({ cls: "property-value-container" });
        valueContainer.style.width = "100%";
        let previewComponent = renderValueInput(valueContainer, this.knownProperties[key], this.frontmatter[key], this.changeCallback);
        previewComponent.inputEl.style.width = "100%";
        previewComponent.inputEl.style.backgroundColor = "transparent";
        const deleteButtonContainer = controlEl.createDiv({ cls: "property-right-container" });
        deleteButtonContainer.style.marginLeft = "auto";
      }
    }
    this.createActionButtons(contentEl);
  }
  /**
   * Creates the "OK" and "Reset" buttons.
   * @param containerEl - The HTML element to append the buttons to.
   */
  createActionButtons(containerEl) {
    const buttonsEl = containerEl.createDiv({ cls: "modal-buttons" });
    buttonsEl.style.marginTop = "15px";
    buttonsEl.style.display = "flex";
    buttonsEl.style.justifyContent = "flex-end";
    buttonsEl.style.gap = "10px";
    const resetButton = buttonsEl.createEl("button");
    (0, import_obsidian5.setIcon)(resetButton, "reset");
    resetButton.ariaLabel = "Reset selection";
    resetButton.onclick = () => {
      this.resetToInitial();
    };
    const emptyButton = buttonsEl.createEl("button");
    (0, import_obsidian5.setIcon)(emptyButton, "eraser");
    emptyButton.ariaLabel = "Clear selection";
    emptyButton.onclick = () => {
      this.resetToEmpty();
    };
    const cancelButton = buttonsEl.createEl("button", { text: "Cancel" });
    cancelButton.ariaLabel = "close and discard changes";
    cancelButton.onclick = () => {
      console.log("Cancel Clicked - Returning");
      this.resolvePromise(null);
      this.close();
    };
    const okButton = buttonsEl.createEl("button", { text: "OK", cls: "mod-cta" });
    cancelButton.ariaLabel = "close and save changes";
    okButton.onclick = () => {
      this.resolvePromise({ values: this.result });
      this.close();
    };
  }
  /**
   * Called when the modal is closed. Cleans up resources.
   */
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  openAndGetValues() {
    this.open();
    return this.promise;
  }
};
async function openAutocompleteModal(app, plugin, rule, options, activeFile, frontmatter) {
  const modal = new AutocompleteModal(app, plugin, rule, options, activeFile, frontmatter);
  return await modal.openAndGetValues();
}

// src/suggesters/FolderSuggester.ts
var import_obsidian7 = require("obsidian");

// src/suggesters/suggest.ts
var import_obsidian6 = require("obsidian");

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect4 = _ref.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});

// src/suggesters/suggest.ts
var wrapAround = (value, size) => {
  return (value % size + size) % size;
};
var Suggest = class {
  constructor(owner, containerEl, scope) {
    this.owner = owner;
    this.containerEl = containerEl;
    containerEl.on(
      "click",
      ".suggestion-item",
      this.onSuggestionClick.bind(this)
    );
    containerEl.on(
      "mousemove",
      ".suggestion-item",
      this.onSuggestionMouseover.bind(this)
    );
    scope.register([], "ArrowUp", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem - 1, true);
        return false;
      }
    });
    scope.register([], "ArrowDown", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem + 1, true);
        return false;
      }
    });
    scope.register([], "Enter", (event) => {
      if (!event.isComposing) {
        this.useSelectedItem(event);
        return false;
      }
    });
  }
  onSuggestionClick(event, el) {
    event.preventDefault();
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
    this.useSelectedItem(event);
  }
  onSuggestionMouseover(_event, el) {
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
  }
  setSuggestions(values) {
    this.containerEl.empty();
    const suggestionEls = [];
    values.forEach((value) => {
      const suggestionEl = this.containerEl.createDiv("suggestion-item");
      this.owner.renderSuggestion(value, suggestionEl);
      suggestionEls.push(suggestionEl);
    });
    this.values = values;
    this.suggestions = suggestionEls;
    this.setSelectedItem(0, false);
  }
  useSelectedItem(event) {
    const currentValue = this.values[this.selectedItem];
    if (currentValue) {
      this.owner.selectSuggestion(currentValue, event);
    }
  }
  setSelectedItem(selectedIndex, scrollIntoView) {
    const normalizedIndex = wrapAround(
      selectedIndex,
      this.suggestions.length
    );
    const prevSelectedSuggestion = this.suggestions[this.selectedItem];
    const selectedSuggestion = this.suggestions[normalizedIndex];
    prevSelectedSuggestion == null ? void 0 : prevSelectedSuggestion.removeClass("is-selected");
    selectedSuggestion == null ? void 0 : selectedSuggestion.addClass("is-selected");
    this.selectedItem = normalizedIndex;
    if (scrollIntoView) {
      selectedSuggestion.scrollIntoView(false);
    }
  }
};
var TextInputSuggest = class {
  constructor(app, inputEl) {
    this.app = app;
    this.inputEl = inputEl;
    this.scope = new import_obsidian6.Scope();
    this.suggestEl = createDiv("suggestion-container");
    const suggestion = this.suggestEl.createDiv("suggestion");
    this.suggest = new Suggest(this, suggestion, this.scope);
    this.scope.register([], "Escape", this.close.bind(this));
    this.inputEl.addEventListener("input", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("focus", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("blur", this.close.bind(this));
    this.suggestEl.on(
      "mousedown",
      ".suggestion-container",
      (event) => {
        event.preventDefault();
      }
    );
  }
  onInputChanged() {
    const inputStr = this.inputEl.value;
    const suggestions = this.getSuggestions(inputStr);
    if (!suggestions) {
      this.close();
      return;
    }
    if (suggestions.length > 0) {
      this.suggest.setSuggestions(suggestions);
      this.open(this.app.dom.appContainerEl, this.inputEl);
    } else {
      this.close();
    }
  }
  open(container, inputEl) {
    this.app.keymap.pushScope(this.scope);
    container.appendChild(this.suggestEl);
    this.popper = createPopper(inputEl, this.suggestEl, {
      placement: "bottom-start",
      modifiers: [
        {
          name: "sameWidth",
          enabled: true,
          fn: ({ state, instance }) => {
            const targetWidth = `${state.rects.reference.width}px`;
            if (state.styles.popper.width === targetWidth) {
              return;
            }
            state.styles.popper.width = targetWidth;
            instance.update();
          },
          phase: "beforeWrite",
          requires: ["computeStyles"]
        }
      ]
    });
  }
  close() {
    this.app.keymap.popScope(this.scope);
    this.suggest.setSuggestions([]);
    if (this.popper)
      this.popper.destroy();
    this.suggestEl.detach();
  }
};

// src/suggesters/FolderSuggester.ts
var FolderSuggest = class extends TextInputSuggest {
  constructor(app, inputEl) {
    super(app, inputEl);
  }
  getSuggestions(inputStr) {
    const abstractFiles = this.app.vault.getAllLoadedFiles();
    const folders = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    abstractFiles.forEach((folder) => {
      if (folder instanceof import_obsidian7.TFolder && folder.path.toLowerCase().contains(lowerCaseInputStr)) {
        folders.push(folder);
      }
    });
    return folders.slice(0, 1e3);
  }
  renderSuggestion(file, el) {
    el.setText(file.path.replace(/^(?!\/)/, "/"));
  }
  selectSuggestion(file) {
    this.inputEl.value = file.path.replace(/^(?!\/)/, "/");
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/suggesters/FileSuggester.ts
var import_obsidian8 = require("obsidian");
var FileSuggest = class extends TextInputSuggest {
  constructor(inputEl, plugin, folder) {
    super(plugin.app, inputEl);
    this.inputEl = inputEl;
    this.plugin = plugin;
    this.folder = folder;
  }
  get_error_msg() {
    return `Folder ${this.folder} doesn't exist`;
  }
  getSuggestions(input_str) {
    const all_files = errorWrapperSync(
      () => getFilesFromFolder(
        this.plugin.app,
        this.folder
      ),
      this.get_error_msg()
    );
    if (!all_files) {
      return [];
    }
    const files = [];
    const lower_input_str = input_str.toLowerCase();
    all_files.forEach((file) => {
      if (file instanceof import_obsidian8.TFile && file.extension === "md" && file.path.toLowerCase().contains(lower_input_str)) {
        files.push(file);
      }
    });
    return files.slice(0, 1e3);
  }
  renderSuggestion(file, el) {
    el.setText(file.path);
  }
  selectSuggestion(file) {
    this.inputEl.value = file.path;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/directorySelectionModal.ts
var import_obsidian9 = require("obsidian");
var DirectorySelectionModal = class extends import_obsidian9.Modal {
  // Reference to update dropdown on reset
  /**
   * Creates an instance of the DirectorySelectionModal.
   * @param app - The Obsidian App instance.
   * @param initialFolders - Array of initially selected folder paths.
   * @param initialFiles - Array of initially selected file paths.
   * @param initialMode - The initial selection mode ('include' or 'exclude').
   * @param okCallback - Function to call when the user clicks "OK". Receives the selection result.
   */
  constructor(app, initialFolders, initialFiles, initialOptions, okCallback) {
    super(app);
    this.showFiles = false;
    // Container for the tree view
    this.treeNodes = /* @__PURE__ */ new Map();
    // Map path to node info for quick access
    this.modeDropdown = null;
    this.initialFoldersSnapshot = new Set(initialFolders);
    this.initialFilesSnapshot = new Set(initialFiles);
    this.initialModeSnapshot = initialOptions.selectionMode;
    this.initialDisplaySnapshot = initialOptions.displayMode;
    this.showFiles = initialOptions.displayMode === "files" || initialOptions.displayMode === "file" || initialFiles.length > 0;
    this.options = initialOptions;
    this.okCallback = okCallback;
    this.resetSelectionToInitial();
  }
  /**
   * Resets the current selection state to the initial state provided at construction.
   */
  resetSelectionToInitial() {
    this.currentFolders = new Set(this.initialFoldersSnapshot);
    this.currentFiles = new Set(this.initialFilesSnapshot);
    this.currentMode = this.initialModeSnapshot;
  }
  /**
   * Resets the current selection state to empty.
   */
  resetSelectionToEmpty() {
    this.currentFolders = /* @__PURE__ */ new Set([]);
    this.currentFiles = /* @__PURE__ */ new Set([]);
    this.currentMode = this.initialModeSnapshot;
  }
  /**
   * Called when the modal is opened. Builds the UI.
   */
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("directory-selection-modal");
    if (this.includeExcludeSelectable) {
      contentEl.createEl("h2", { text: this.options.title || "Include or Exclude Folders and Files" });
    } else {
      contentEl.createEl("h2", { text: this.options.title || `${this.currentMode === "exclude" ? "Exclude" : "Include"} Folders and Files` });
    }
    const controlsEl = contentEl.createDiv({ cls: "modal-controls" });
    this.createModeSetting(controlsEl);
    this.createShowFilesSetting(controlsEl);
    this.treeRootElement = contentEl.createDiv({ cls: "tree-view-container" });
    this.treeRootElement.style.maxHeight = "600px";
    this.treeRootElement.style.overflowY = "auto";
    this.treeRootElement.style.border = "1px solid var(--background-modifier-border)";
    this.treeRootElement.style.padding = "10px";
    this.treeRootElement.style.marginTop = "10px";
    this.treeRootElement.style.marginBottom = "10px";
    if (!this.treeNodes.size) {
      this.buildAndRenderTree();
    }
    this.createActionButtons(contentEl);
  }
  /**
   * Creates the dropdown setting for choosing the selection mode.
   * @param containerEl - The HTML element to append the setting to.
   */
  createModeSetting(containerEl) {
    if (this.includeExcludeSelectable) {
      this.modeDropdown = new import_obsidian9.Setting(containerEl).setName("Selection Mode").setDesc("Choose if the selected files and folders should be excluded or included.").addDropdown((dropdown) => {
        dropdown.addOption("exclude", "exclude").addOption("include", "include").setValue(this.currentMode).onChange((value) => {
          this.currentMode = value;
          this.updateTreeAppearance();
        });
      });
    }
  }
  /**
   * Updates the mode dropdown UI element to reflect the currentMode state.
   */
  updateModeDropdown() {
    var _a;
    const dropdownComponent = (_a = this.modeDropdown) == null ? void 0 : _a.components[0];
    if (dropdownComponent && typeof dropdownComponent.setValue === "function") {
      dropdownComponent.setValue(this.currentMode);
    }
  }
  /**
   * Creates the toggle setting for showing/hiding files in the tree.
   * @param containerEl - The HTML element to append the setting to.
   */
  createShowFilesSetting(containerEl) {
    if (this.options.optionShowFiles) {
      new import_obsidian9.Setting(containerEl).setName("Show Files").setDesc("Show Files within the directory tree.").addToggle((toggle) => {
        toggle.setValue(this.showFiles).onChange((value) => {
          this.showFiles = value;
          this.buildAndRenderTree();
        });
      });
    }
  }
  /**
   * Creates the "OK" and "Reset" buttons.
   * @param containerEl - The HTML element to append the buttons to.
   */
  createActionButtons(containerEl) {
    const buttonsEl = containerEl.createDiv({ cls: "modal-buttons" });
    buttonsEl.style.marginTop = "15px";
    buttonsEl.style.display = "flex";
    buttonsEl.style.justifyContent = "flex-end";
    buttonsEl.style.gap = "10px";
    const resetButton = buttonsEl.createEl("button");
    (0, import_obsidian9.setIcon)(resetButton, "reset");
    resetButton.ariaLabel = "Reset selection";
    resetButton.onclick = () => {
      this.resetSelectionToInitial();
      this.updateModeDropdown();
      this.buildAndRenderTree();
    };
    const emptyButton = buttonsEl.createEl("button");
    (0, import_obsidian9.setIcon)(emptyButton, "eraser");
    emptyButton.ariaLabel = "Clear selection";
    emptyButton.onclick = () => {
      this.resetSelectionToEmpty();
      this.updateModeDropdown();
      this.buildAndRenderTree();
    };
    const cancelButton = buttonsEl.createEl("button", { text: "Cancel" });
    cancelButton.ariaLabel = "close and discard changes";
    cancelButton.onclick = () => {
      this.okCallback(null);
      this.close();
    };
    const okButton = buttonsEl.createEl("button", { text: "OK", cls: "mod-cta" });
    okButton.ariaLabel = "close and save changes";
    okButton.onclick = () => {
      this.close();
    };
  }
  /**
   * Builds the logical tree structure data from the vault's files and folders.
   * @returns The root node of the tree structure.
   */
  buildTreeData() {
    const vaultRootNode = {
      path: "/",
      // Root folder path
      name: this.app.vault.getName() || "Vault",
      // Use vault name or default
      type: "folder",
      children: [],
      // Placeholder elements, will be assigned during rendering
      element: null,
      checkbox: null,
      label: null,
      container: null
    };
    const folderNodes = /* @__PURE__ */ new Map();
    folderNodes.set("/", vaultRootNode);
    const allFiles = this.app.vault.getFiles();
    allFiles.forEach((file) => {
      const parentFolder = file.parent;
      if (!parentFolder)
        return;
      let currentPath = "";
      const pathParts = parentFolder.path.split("/").filter((p) => p.length > 0);
      let parentNode = vaultRootNode;
      pathParts.forEach((part) => {
        currentPath = currentPath === "/" ? part : `${currentPath}/${part}`;
        if (!folderNodes.has(currentPath)) {
          const newFolderNode = {
            path: currentPath,
            name: part,
            type: "folder",
            children: [],
            element: null,
            checkbox: null,
            label: null,
            container: null
          };
          folderNodes.set(currentPath, newFolderNode);
          if (!parentNode.children) {
            parentNode.children = [];
          }
          parentNode.children.push(newFolderNode);
          parentNode = newFolderNode;
        } else {
          parentNode = folderNodes.get(currentPath);
        }
      });
    });
    if (this.showFiles) {
      allFiles.forEach((file) => {
        const parentFolder = file.parent;
        if (!parentFolder)
          return;
        const parentPath = "/" + parentFolder.path;
        const parentNode = folderNodes.get(parentPath);
        const fileNode = {
          path: file.path,
          name: file.name,
          type: "file",
          element: null,
          checkbox: null,
          label: null,
          container: null
        };
        if (parentNode) {
          if (!parentNode.children) {
            parentNode.children = [];
          }
          parentNode.children.push(fileNode);
        }
      });
    }
    const sortNodes = (a, b) => {
      if (a.type === "folder" && b.type === "file")
        return -1;
      if (a.type === "file" && b.type === "folder")
        return 1;
      return a.name.localeCompare(b.name);
    };
    folderNodes.forEach((node) => {
      var _a;
      return (_a = node.children) == null ? void 0 : _a.sort(sortNodes);
    });
    return vaultRootNode;
  }
  /**
   * Renders the entire tree structure in the DOM based on the tree data.
   */
  renderTree() {
    var _a;
    this.treeRootElement.empty();
    this.treeNodes.clear();
    const treeData = this.buildTreeData();
    const rootUl = this.treeRootElement.createEl("ul");
    rootUl.addClass("tree-root-ul");
    rootUl.style.listStyle = "none";
    rootUl.style.paddingLeft = "0";
    this.renderTreeNode(treeData, rootUl, 0, this.currentFolders, this.currentFiles);
    (_a = treeData.children) == null ? void 0 : _a.forEach((childNode) => {
    });
  }
  /**
   * Recursively renders a single tree node and its children in the DOM.
   * @param node - The TreeNode data to render.
   * @param parentElement - The HTML `ul` element to append this node's `li` to.
   * @param level - The current indentation level.
   */
  renderTreeNode(node, parentElement, level, selectedPaths, selectedfiles) {
    const li = parentElement.createEl("li");
    li.style.marginLeft = `${level * 20}px`;
    li.addClass(`tree-node-${node.type}`);
    const container = li.createDiv({ cls: "tree-node-container" });
    container.style.display = "flex";
    container.style.alignItems = "center";
    container.style.padding = "2px 0";
    let toggleButton = null;
    let isCollapsed = true;
    if (node.type === "folder") {
      toggleButton = container.createSpan({ cls: "tree-toggle-button" });
      toggleButton.textContent = "\u25B6";
      toggleButton.style.cursor = "pointer";
      toggleButton.style.marginRight = "5px";
      const shouldExpand = this.shouldExpandFolder(node, selectedPaths, selectedfiles);
      if (shouldExpand) {
        isCollapsed = false;
      }
      toggleButton.onclick = () => {
        isCollapsed = !isCollapsed;
        if (toggleButton)
          toggleButton.textContent = isCollapsed ? "\u25B6" : "\u25BC";
        if (childrenUl)
          childrenUl.style.display = isCollapsed ? "none" : "block";
      };
    }
    const checkbox = container.createEl("input", { type: "checkbox" });
    checkbox.id = `tree-cb-${node.path.replace(/[^a-zA-Z0-9]/g, "-")}`;
    checkbox.dataset.path = node.path;
    checkbox.dataset.type = node.type;
    const label = container.createEl("label");
    label.textContent = `${node.type === "folder" ? "\u{1F4C1}" : "\u{1F4C4}"} ${node.name}`;
    label.htmlFor = checkbox.id;
    label.style.marginLeft = "5px";
    label.style.cursor = "pointer";
    label.title = node.path;
    node.element = li;
    node.checkbox = checkbox;
    node.label = label;
    node.container = container;
    this.treeNodes.set(node.path, node);
    if (node.type === "folder") {
      checkbox.checked = this.currentFolders.has(node.path);
    } else {
      checkbox.checked = this.currentFiles.has(node.path);
    }
    checkbox.onchange = (event) => {
      const target = event.target;
      const path = target.dataset.path;
      const type = target.dataset.type;
      if (target.checked) {
        if (type === "folder") {
          if (this.options.displayMode === "folder") {
            this.currentFolders.clear();
          }
          this.currentFolders.add(path);
        } else {
          if (this.options.displayMode === "file") {
            this.currentFiles.clear();
          }
          this.currentFiles.add(path);
        }
      } else {
        if (type === "folder")
          this.currentFolders.delete(path);
        else
          this.currentFiles.delete(path);
      }
      this.updateTreeAppearance();
    };
    let childrenUl = null;
    if (node.type === "folder" && node.children && node.children.length > 0) {
      childrenUl = li.createEl("ul");
      childrenUl.style.listStyle = "none";
      childrenUl.style.paddingLeft = "0";
      childrenUl.style.marginLeft = "0";
      childrenUl.style.display = isCollapsed ? "none" : "block";
      node.children.forEach((child) => this.renderTreeNode(child, childrenUl, level + 1, selectedPaths, selectedfiles));
    }
  }
  // Helper method to determine if a folder should be expanded
  shouldExpandFolder(node, selectedPaths, selectedFiles) {
    if (selectedPaths.has(node.path) || selectedFiles.has(node.path)) {
      return true;
    }
    if (node.children) {
      for (const child of node.children) {
        if (this.shouldExpandFolder(child, selectedPaths, selectedFiles)) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Updates the visual appearance (enabled/disabled/styling) of all nodes
   * in the tree based on the current mode and selections.
   */
  updateTreeAppearance() {
    this.treeNodes.forEach((node) => {
      let isDisabled = false;
      let isEffectivelyIncluded = false;
      let isEffectivelyExcluded = false;
      let ancestorFolderSelected = false;
      let currentPath = node.path;
      while (currentPath !== "/") {
        const parentPath = currentPath.substring(0, currentPath.lastIndexOf("/")) || "/";
        if (this.currentFolders.has(parentPath)) {
          ancestorFolderSelected = true;
          break;
        }
        if (parentPath === currentPath)
          break;
        currentPath = parentPath;
      }
      const nodeSelected = node.type === "folder" ? this.currentFolders.has(node.path) : this.currentFiles.has(node.path);
      if (this.currentMode === "exclude") {
        isEffectivelyExcluded = nodeSelected || ancestorFolderSelected;
        isDisabled = isEffectivelyExcluded;
      } else {
        if (node.type === "folder") {
          isEffectivelyIncluded = nodeSelected || ancestorFolderSelected;
        } else {
          const parentPath = node.path.substring(0, node.path.lastIndexOf("/")) || "/";
          const parentEffectivelyIncluded = this.isPathEffectivelyIncluded(parentPath);
          isEffectivelyIncluded = nodeSelected || parentEffectivelyIncluded;
        }
        isDisabled = !isEffectivelyIncluded;
      }
      node.checkbox.disabled = false;
      node.checkbox.checked = nodeSelected;
      if (isDisabled) {
        node.container.style.opacity = "0.5";
        node.label.style.textDecoration = "line-through";
        node.element.addClass("is-disabled");
      } else {
        node.container.style.opacity = "1";
        node.label.style.textDecoration = "none";
        node.element.removeClass("is-disabled");
      }
      node.element.classList.remove("is-included", "is-excluded");
      if (this.currentMode === "include" && isEffectivelyIncluded) {
        node.element.addClass("is-included");
      } else if (this.currentMode === "exclude" && isEffectivelyExcluded) {
        node.element.addClass("is-excluded");
      }
    });
  }
  /**
   * Helper function to determine if a given path is effectively included
   * in the current selection under 'include' mode.
   * A path is included if it (file or folder) is selected, or if any of its ancestor FOLDERS are selected.
   * @param path - The folder or file path to check.
   * @returns True if the path should be considered included, false otherwise.
   */
  isPathEffectivelyIncluded(path) {
    if (this.currentMode !== "include") {
      return !this.isPathEffectivelyExcluded(path);
    }
    if (this.currentFiles.has(path) || this.currentFolders.has(path)) {
      return true;
    }
    let current = path;
    while (current !== "/") {
      const parentPath = current.substring(0, current.lastIndexOf("/")) || "/";
      if (this.currentFolders.has(parentPath)) {
        return true;
      }
      if (parentPath === current)
        break;
      current = parentPath;
    }
    return false;
  }
  /**
  * Helper function to determine if a given path is effectively excluded
  * in the current selection under 'exclude' mode.
  * A path is excluded if it (file or folder) is selected, or if any of its ancestor FOLDERS are selected.
  * @param path - The folder or file path to check.
  * @returns True if the path should be considered excluded, false otherwise.
  */
  isPathEffectivelyExcluded(path) {
    if (this.currentMode !== "exclude") {
      return false;
    }
    if (this.currentFiles.has(path) || this.currentFolders.has(path)) {
      return true;
    }
    let current = path;
    while (current !== "/") {
      const parentPath = current.substring(0, current.lastIndexOf("/")) || "/";
      if (this.currentFolders.has(parentPath)) {
        return true;
      }
      if (parentPath === current)
        break;
      current = parentPath;
    }
    return false;
  }
  /**
   * Combines building the tree data, rendering the DOM, and applying initial appearance.
   */
  buildAndRenderTree() {
    this.renderTree();
    this.updateTreeAppearance();
  }
  /**
   * Called when the modal is closed. Cleans up resources.
   */
  onClose() {
    const result = {
      folders: Array.from(this.currentFolders),
      files: Array.from(this.currentFiles),
      mode: this.currentMode,
      display: this.currentDisplay
    };
    this.okCallback(result);
    const { contentEl } = this;
    contentEl.empty();
    this.treeNodes.clear();
    this.modeDropdown = null;
  }
};
function openDirectorySelectionModal(app, initialFolders, initialFiles, options, okCallback) {
  new DirectorySelectionModal(
    app,
    initialFolders,
    initialFiles,
    options,
    okCallback
  ).open();
}

// src/rules.ts
var ruleFunctions = [];
function getRuleFunctionById(id) {
  return ruleFunctions.find((rule) => rule.id === id);
}
function applyFormatOptions(value, rule) {
  if (rule.type === "date" || rule.type === "datetime")
    return value;
  switch (typeof value) {
    case "boolean":
    case "number":
      return value;
    case "string":
      if (rule.spaceReplacement && rule.spaceReplacement !== "")
        value = value.replace(/\s+/g, rule.spaceReplacement);
      if (rule.specialCharReplacement && rule.specialCharReplacement !== "")
        value = value.replace(/[^a-zA-Z0-9\-_\/]/g, rule.specialCharReplacement);
      if (rule.lowercaseTags)
        value = value.toLowerCase();
      if (rule.prefix && rule.prefix !== "")
        value = rule.prefix + value;
      if (rule.asLink)
        value = `[[${value}]]`;
      return value;
    case "object":
      if (Array.isArray(value)) {
        return value.map((value2) => applyFormatOptions(value2, rule));
      }
      return value;
  }
  return;
}
function getRuleResult(ruleFx, app, rule, ruleFunction, currentFile, tools, frontMatter) {
  let result = void 0;
  switch (ruleFunction.ruleType) {
    case "script":
    case "buildIn":
      result = applyFormatOptions(ruleFx(app, currentFile, tools), rule);
      break;
    case "buildIn.inputProperty":
      result = applyFormatOptions(ruleFx(app, currentFile, tools, frontMatter[rule.inputProperty]), rule);
      break;
    case "autocomplete.modal":
      ruleFx(app, currentFile, tools);
      result = null;
      break;
    case "automation":
      result = applyFormatOptions(ruleFx(app, currentFile, tools), rule);
      break;
  }
  return result;
}
function executeRule(event, app, settings, currentFile, returnResult, rule, frontMatter, oldPath) {
  if (!rule.active || !currentFile)
    return returnResult;
  const tools = new ScriptingTools(app, this, settings, rule, frontMatter, currentFile);
  let fxResult = returnResult;
  let oldResult;
  let oldFile = void 0;
  if (oldPath) {
    let oldFileParts = oldPath.split("/");
    oldFile = {
      path: oldPath,
      extension: oldFileParts[oldFileParts.length - 1].split(".")[1],
      name: oldFileParts[oldFileParts.length - 1].split(".")[0],
      stat: currentFile.stat,
      basename: currentFile.basename,
      vault: currentFile.vault,
      parent: currentFile.parent
    };
  }
  try {
    const functionIndex = ruleFunctions.findIndex((fx) => fx.id === rule.content);
    if (functionIndex === -1) {
      console.error(`Rule function ${rule.content} not found!`);
      return returnResult;
    }
    const ruleFunctionConfig = ruleFunctions[functionIndex];
    tools.setCurrentContent(frontMatter[rule.property]);
    tools.setRule(rule);
    tools.setFrontmatter(frontMatter);
    switch (ruleFunctionConfig.ruleType) {
      case "script":
        const customRuleFunction = parseJSCode(rule.jsCode);
        if (typeof customRuleFunction !== "function") {
          console.error(`Could not parse custom function for ${rule.content}!`);
          return;
        }
        fxResult = applyFormatOptions(customRuleFunction(app, currentFile, tools), rule);
        if (oldFile) {
          oldResult = applyFormatOptions(customRuleFunction(app, oldFile, tools), rule);
        }
        break;
      case "buildIn.inputProperty":
      case "buildIn":
        const ruleFunction = rule.useCustomCode ? parseJSCode(rule.buildInCode) : ruleFunctionConfig.fx;
        if (typeof ruleFunction !== "function") {
          console.error(`Could not parse custom function for ${rule.content}!`);
          break;
        }
        fxResult = getRuleResult(ruleFunction, app, rule, ruleFunctionConfig, currentFile, tools, frontMatter);
        if (oldFile) {
          oldResult = getRuleResult(ruleFunction, app, rule, ruleFunctionConfig, oldFile, tools, frontMatter);
        }
        console.log(`executeRule: ${rule.content} ${rule.property} [${rule.type}]= '${fxResult}'`);
        break;
      case "autocomplete.modal":
        fxResult = getRuleResult(ruleFunctionConfig.fx, app, rule, ruleFunctionConfig, currentFile, tools, frontMatter);
        break;
      case "automation":
        fxResult = getRuleResult(ruleFunctionConfig.fx, app, rule, ruleFunctionConfig, currentFile, tools, frontMatter);
        break;
      default:
        break;
    }
  } catch (error) {
    console.error(`Error executing rule ${rule.property}|${rule.content} for file ${currentFile.path}: ${error}`);
    return returnResult;
  }
  if (rule.type === "number" || rule.type === "checkbox" || rule.type === "date" || rule.type === "datetime") {
    return fxResult;
  }
  switch (rule.addContent) {
    case "overwrite":
      returnResult = fxResult;
      break;
    case "end":
      if (rule.type === "multitext" || rule.type === "tags" || rule.type === "aliases") {
        if (!fxResult)
          fxResult = [];
        if (typeof fxResult === "string")
          fxResult = [fxResult];
        if (!Array.isArray(returnResult))
          returnResult = [returnResult];
        if (!Array.isArray(oldResult))
          oldResult = [oldResult];
        let filtered = returnResult.filter((value) => !oldResult.includes(value));
        returnResult = tools.removeDuplicateStrings(filtered.concat(fxResult));
      } else {
        if (!returnResult)
          returnResult = "";
        returnResult = returnResult.replaceAll(returnResult, oldResult);
        returnResult = returnResult + fxResult;
      }
      break;
    case "start":
      if (rule.type === "multitext" || rule.type === "tags" || rule.type === "aliases") {
        if (!fxResult)
          fxResult = [];
        if (typeof fxResult === "string")
          fxResult = [fxResult];
        if (!Array.isArray(returnResult))
          returnResult = [returnResult];
        if (!Array.isArray(oldResult))
          oldResult = [oldResult];
        let filtered = returnResult.filter((value) => !oldResult.includes(value));
        returnResult = tools.removeDuplicateStrings(fxResult.concat(filtered));
      } else {
        if (!returnResult)
          returnResult = "";
        returnResult = returnResult.replaceAll(returnResult, oldResult);
        returnResult = fxResult + returnResult;
      }
      break;
  }
  return returnResult;
}
function removeRule(app, settings, currentFile, returnResult, rule, frontMatter) {
  const tools = new ScriptingTools(app, settings, frontMatter);
  let fxResult;
  if (rule.content === "script") {
    const ruleFunction = parseJSCode(rule.jsCode);
    if (typeof ruleFunction !== "function")
      return;
    fxResult = ruleFunction(app, currentFile, tools);
  } else {
    const functionIndex = ruleFunctions.findIndex((fx) => fx.id === rule.content);
    if (functionIndex !== -1) {
      const ruleFunction = rule.useCustomCode ? parseJSCode(rule.buildInCode) : ruleFunctions[functionIndex].fx;
      if (typeof ruleFunction !== "function") {
        console.error(`Could not parse custom function for ${rule.content}!`);
        return;
      }
      if (ruleFunctions[functionIndex].inputProperty) {
        fxResult = applyFormatOptions(ruleFunction(app, currentFile, tools, frontMatter[rule.inputProperty]), rule);
      } else {
        fxResult = applyFormatOptions(ruleFunction(app, currentFile, tools), rule);
      }
    }
  }
  switch (rule.addContent) {
    case "overwrite":
      returnResult = fxResult;
      break;
    case "end":
      if (rule.type === "multitext" || rule.type === "tags" || rule.type === "aliases") {
        if (!fxResult)
          fxResult = [];
        if (typeof fxResult === "string")
          fxResult = [fxResult];
        if (!Array.isArray(returnResult))
          returnResult = [returnResult];
        if (!Array.isArray(fxResult))
          fxResult = [fxResult];
        let filtered = returnResult.filter((value) => !fxResult.includes(value));
        returnResult = tools.removeDuplicateStrings(filtered);
      } else {
        if (!returnResult)
          returnResult = "";
        returnResult = returnResult.replaceAll(returnResult, fxResult);
      }
      break;
    case "start":
      if (rule.type === "multitext" || rule.type === "tags" || rule.type === "aliases") {
        if (!fxResult)
          fxResult = [];
        if (typeof fxResult === "string")
          fxResult = [fxResult];
        if (!Array.isArray(returnResult))
          returnResult = [returnResult];
        if (!Array.isArray(fxResult))
          fxResult = [fxResult];
        let filtered = returnResult.filter((value) => !fxResult.includes(value));
        returnResult = tools.removeDuplicateStrings(filtered);
      } else {
        if (!returnResult)
          returnResult = "";
        returnResult = returnResult.replaceAll(returnResult, fxResult);
      }
      break;
  }
  return returnResult;
}
function filterFile(file, fileList, filterMode, type) {
  let result = false;
  const filterArray = type === "folders" ? fileList[filterMode].selectedFolders : fileList[filterMode].selectedFiles;
  if (filterArray.length === 0)
    return filterMode === "include" ? false : true;
  const filePath = file.path;
  const fileFolder = getFolderFromPath(file.path);
  const fileName = file.basename + "." + file.extension;
  if (type === "files") {
    result = filterArray.includes(filePath);
  }
  if (type === "folders") {
    for (let path of filterArray) {
      result = (fileFolder == null ? void 0 : fileFolder.startsWith(path.slice(1))) || false;
      if (result === true)
        return filterMode === "exclude" ? !result : result;
      ;
    }
    ;
  }
  ;
  return filterMode === "exclude" ? !result : result;
}
function checkIfFileAllowed(file, settings, rule) {
  let result = true;
  if (!file)
    return false;
  if (settings && !rule) {
    try {
      if (settings.exclude.selectedFiles.length > 0) {
        result = filterFile(file, settings, "exclude", "files");
      }
      if (settings.exclude.selectedFolders.length > 0) {
        result = filterFile(file, settings, "exclude", "folders");
      }
      if (settings.include.selectedFiles.length > 0) {
        result = filterFile(file, settings, "include", "files");
      }
      if (settings.include.selectedFolders.length > 0) {
        result = filterFile(file, settings, "include", "folders");
      }
    } catch (error) {
      console.error(`Error filtering file ${file.path} globally: ${error}`);
      return false;
    }
  }
  if (rule) {
    try {
      if (rule.exclude.selectedFiles.length > 0) {
        result = filterFile(file, rule, "exclude", "files");
      }
      if (rule.exclude.selectedFolders.length > 0) {
        result = filterFile(file, rule, "exclude", "folders");
      }
      if (rule.include.selectedFiles.length > 0) {
        result = filterFile(file, rule, "include", "files");
      }
      if (rule.include.selectedFolders.length > 0) {
        result = filterFile(file, rule, "include", "folders");
      }
    } catch (error) {
      console.error(`Error filtering file ${file.path} by rule ${rule.property}|${rule.content}: ${error}`);
      return false;
    }
  }
  return result;
}
function defaultConfigElements(modifiers) {
  const configElements = {
    removeContent: true,
    ruleActive: true,
    modifyOnly: true,
    inputProperty: false,
    addPrefix: true,
    spaceReplacement: true,
    specialCharacterReplacement: true,
    convertToLowerCase: true,
    resultAsLink: true,
    addContent: true,
    excludeFolders: true,
    includeFolders: true,
    script: true
  };
  return Object.assign({}, configElements, modifiers);
}
function useRuleOption(ruleFn, option) {
  if ((ruleFn == null ? void 0 : ruleFn.configElements[option]) === void 0)
    return true;
  return ruleFn.configElements[option];
}
ruleFunctions.push({
  id: "default",
  ruleType: "buildIn",
  description: "Pass parameter",
  source: "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}",
  type: ["text"],
  configElements: defaultConfigElements({}),
  fx: function(app, file, tools) {
    let result = "";
    return result;
  }
});
ruleFunctions.push({
  id: "constant",
  ruleType: "buildIn",
  description: "Constant value",
  source: "function (app, file, tools) { // do not change this line!\n  // acquire file path\n  const path = file.path;\n  const parts = path.split('/');\n  let result = '';\n  if (parts.length > 1) {\n    parts.pop(); // remove file name\n    result = result + parts.join('/');\n  }\n  return result;\n}",
  type: ["text", "tags", "aliases", "multitext"],
  configElements: defaultConfigElements({
    addPrefix: false,
    spaceReplacement: false,
    specialCharacterReplacement: false,
    convertToLowerCase: false,
    resultAsLink: false
  }),
  fx: function(app, file, tools) {
    var _a;
    const result = tools.getOptionConfig((_a = tools.getRule()) == null ? void 0 : _a.id, "constantValue");
    return result;
  },
  configTab: function(optionEL, rule, that, previewComponent) {
    that.setOptionConfigDefaults(rule.id, {
      constantValue: ""
    });
    new import_obsidian10.Setting(optionEL).setName("Constant value").setDesc("Enter a constant value to be used in the rule").addText((text) => text.setValue(that.getOptionConfig(rule.id, "constantValue") || "").onChange(async (value) => {
      that.setOptionConfig(rule.id, "constantValue", value);
      that.updatePreview(rule, previewComponent);
    }));
  }
});
ruleFunctions.push({
  id: "fullPath",
  ruleType: "buildIn",
  description: "Full path, filename",
  source: "function (app, file, tools) { // do not change this line!\n  // acquire file path\n  const path = file.path;\n  const parts = path.split('/');\n  let result = '';\n  if (parts.length > 1) {\n    parts.pop(); // remove file name\n    result = result + parts.join('/');\n  }\n  return result;\n}",
  type: ["text", "tags", "aliases", "multitext"],
  configElements: defaultConfigElements({}),
  fx: function(app, file, tools) {
    let parts = file.path.split("/");
    parts.pop();
    parts.push(file.basename);
    return parts.join("/");
  }
});
ruleFunctions.push({
  id: "fullPathExt",
  ruleType: "buildIn",
  description: "Full path, filename and Extension",
  source: "function (app, file, tools) { // do not change this line!\n  // acquire file path\n  const result = file.path;\n  return result;\n}",
  type: ["text", "tags", "aliases"],
  configElements: defaultConfigElements({}),
  fx: function(app, file, tools) {
    return `${file.path}`;
  }
});
ruleFunctions.push({
  id: "path",
  ruleType: "buildIn",
  description: "Full Path",
  source: "function (app, file, tools) { // do not change this line!\n  // acquire file path\n  const path = file.path;\n  const parts = path.split('/');\n  let result = '';\n  if (parts.length > 1) {\n    parts.pop(); // remove file name\n    result = result + parts.join('/');\n  }\n  return result;\n}",
  type: ["text", "tags", "aliases"],
  configElements: defaultConfigElements({}),
  fx: function(app, file, tools) {
    let parts = file.path.split("/");
    parts.pop();
    return parts.join("/");
  }
});
ruleFunctions.push({
  id: "linkToFile",
  ruleType: "buildIn",
  description: "Link to file",
  source: "function (app, file, tools) { // do not change this line!\n  // acquire file path\n  const path = file.path;\n  const parts = path.split('/');\n  let result = '';\n  if (parts.length > 1) {\n    parts.pop(); // remove file name\n    result = result + parts.join('/');\n  }\n  return result;\n}",
  type: ["text", "tags", "aliases", "multitext"],
  configElements: defaultConfigElements({ resultAsLink: false }),
  fx: function(app, file, tools) {
    const parts = file.path.split("/");
    const rule = tools.getRule();
    if (!rule)
      return tools.getCurrentContent();
    const addExtension = tools.getOptionConfig(rule.id, "addExtension");
    parts.pop();
    if (parts[parts.length - 1] === file.basename)
      parts.pop();
    let fileName = addExtension ? file.basename + "." + file.extension : file.basename;
    return `[[${parts.join("/")}/${fileName}|${file.basename}]]`;
  },
  configTab: function(optionEL, rule, that, previewComponent) {
    that.setOptionConfigDefaults(rule.id, {
      addExtension: true
    });
    new import_obsidian10.Setting(optionEL).setName("Include file extension").setDesc("Add file extension to pathname").addToggle(
      (toggle) => toggle.setValue(that.getOptionConfig(rule.id, "addExtension") || false).onChange(async (value) => {
        that.setOptionConfig(rule.id, "addExtension", value);
        that.updatePreview(rule, previewComponent);
      })
    );
  }
});
ruleFunctions.push({
  id: "pathFolderNotes",
  ruleType: "buildIn",
  description: "Path (folder notes)",
  source: "function (app, file, tools) { // do not change this line!\n  // acquire file path\n  const path = file.path;\n  const parts = path.split('/');\n  let result = '';\n  if (parts.length > 1) {\n    parts.pop(); // remove file name\n    result = result + parts.join('/');\n  }\n  return result;\n}",
  type: ["text", "tags", "aliases", "multitext"],
  configElements: defaultConfigElements({}),
  fx: function(app, file, tools) {
    let parts = file.path.split("/");
    parts.pop();
    if (parts[parts.length - 1] === file.basename)
      parts.pop();
    return parts.join("/");
  }
});
ruleFunctions.push({
  id: "fullPathFolderNotes",
  ruleType: "buildIn",
  description: 'Full Path (comply with "folder notes")',
  source: "function (app, file, tools) { // do not change this line!\n  // acquire file path\n  const path = file.path;\n  const parts = path.split('/');\n  let result = '';\n  if (parts.length > 1) {\n    parts.pop(); // remove file name\n    result = result + parts.join('/');\n  }\n  return result;\n}",
  type: ["text", "tags", "aliases"],
  configElements: defaultConfigElements({}),
  fx: function(app, file, tools) {
    let parts = file.path.split("/");
    parts.pop();
    if (parts[parts.length - 1] === file.basename)
      parts.pop();
    parts.push(file.basename);
    return parts.join("/");
  }
});
ruleFunctions.push({
  id: "fullPathExtFolderNotes",
  ruleType: "buildIn",
  description: 'Full Path with Extension (comply with "folder notes")',
  source: "function (app, file, tools) { // do not change this line!\n  // acquire file path\n  const path = file.path;\n  const parts = path.split('/');\n  let result = '';\n  if (parts.length > 1) {\n    parts.pop(); // remove file name\n    result = result + parts.join('/');\n  }\n  return result;\n}",
  type: ["text", "tags", "aliases"],
  configElements: defaultConfigElements({}),
  fx: function(app, file, tools) {
    let parts = file.path.split("/");
    parts.pop();
    if (parts[parts.length - 1] === file.basename)
      parts.pop();
    parts.push(file.name);
    return parts.join("/");
  }
});
ruleFunctions.push({
  id: "isRoot",
  ruleType: "buildIn",
  description: "File in Root folder",
  source: "function (app, file, tools) { // do not change this line!\n  let parts = file.path.split('/');\n  return parts.length === 1;\n}",
  type: ["checkbox"],
  configElements: defaultConfigElements({}),
  fx: function(app, file, tools) {
    let parts = file.path.split("/");
    return parts.length === 1;
  }
});
ruleFunctions.push({
  id: "folder",
  ruleType: "buildIn",
  description: "Parent Folder",
  source: "function (app, file, tools) { // do not change this line!\n  // acquire file path\n  const path = file.path;\n  const parts = path.split('/');\n  let result = '';\n  if (parts.length > 1) {\n    result = parts[parts.length-2];\n  }\n  return result;\n}",
  type: ["text", "tags"],
  configElements: defaultConfigElements({}),
  fx: function(app, file, tools) {
    const path = file.path;
    const parts = path.split("/");
    let result = "";
    if (parts.length > 1) {
      result = parts[parts.length - 2];
    }
    return result;
  }
});
ruleFunctions.push({
  id: "folderFolderNotes",
  ruleType: "buildIn",
  description: 'Parent Folder (complies with "folder notes")',
  source: "function (app, file, tools) { // do not change this line!\n  const parts = file.path.split('/');\n  let index = parts.length-2; // index of parent folder\n  if (parts[parts.length-2]===file.basename) {\n      index--; // folder note parent is the child\n  }\n  if (index >= 0) {\n    return parts[index]; // file in folder\n  } else {\n    return tools.app?.vault?.getName() || 'Vault'; // file in root = vault\n  }\n}",
  type: ["text", "tags"],
  configElements: defaultConfigElements({}),
  fx: function(app, file, tools) {
    var _a, _b;
    const parts = file.path.split("/");
    let index = parts.length - 2;
    if (parts[parts.length - 2] === file.basename) {
      index--;
    }
    if (index >= 0) {
      return parts[index];
    } else {
      return ((_b = (_a = tools.app) == null ? void 0 : _a.vault) == null ? void 0 : _b.getName()) || "Vault";
    }
  }
});
ruleFunctions.push({
  id: "folders",
  ruleType: "buildIn",
  description: "All folders of the file as a list",
  source: "function (app, file, tools) { // do not change this line!\n  const path = file.path; // acquire file path\n  const result = path.split('/');\n  result.pop(); // remove file name\n  return result;\n}",
  type: ["multitext", "tags", "aliases"],
  configElements: defaultConfigElements({}),
  fx: function(app, file, tools) {
    const path = file.path;
    const result = path.split("/");
    result.pop();
    return result;
  }
});
ruleFunctions.push({
  id: "rootFolder",
  ruleType: "buildIn",
  description: "Root folder",
  source: "function (app, file, tools) { // do not change this line!\n  // acquire file path\n  const path = file.path;\n  const parts = path.split('/');\n  let result = '';\n  if (parts.length > 1) {\n    result = parts[0];\n  }\n  return result;\n}",
  type: ["text", "multitext", "tags", "aliases"],
  configElements: defaultConfigElements({}),
  fx: function(app, file, tools) {
    const path = file.path;
    const parts = path.split("/");
    let result = "";
    if (parts.length > 1) {
      result = parts[0];
    }
    return result;
  }
});
ruleFunctions.push({
  id: "name",
  ruleType: "buildIn",
  description: "File name without extension",
  source: "function (app, file, tools) { // do not change this line!\n  // acquire file name\n  const result = file.name.split('.');\n  result.pop(); // remove extension\n  result.join('.'); // reconstruct the file name\n  return result;\n}",
  type: ["text", "multitext", "tags", "aliases"],
  configElements: defaultConfigElements({}),
  fx: function(app, file, tools) {
    const result = file.name.split(".");
    result.pop();
    result.join(".");
    return result;
  }
});
ruleFunctions.push({
  id: "nameExt",
  ruleType: "buildIn",
  description: "File name with extension",
  source: "function (app, file, tools) { // do not change this line!\n  // acquire file name\n  const result = file.name;\n  return result;\n}",
  type: ["text", "multitext", "tags", "aliases"],
  configElements: defaultConfigElements({}),
  fx: function(app, file, tools) {
    const result = file.name;
    return result;
  }
});
ruleFunctions.push({
  id: "getProperty",
  ruleType: "buildIn.inputProperty",
  description: "Get a property",
  isLiveRule: true,
  inputProperty: true,
  source: "function (app, file, tools) { // do not change this line!\n  const result = input;\n  return result;\n}",
  type: ["text", "multitext", "tags", "aliases"],
  configElements: defaultConfigElements({ inputProperty: true }),
  fx: function(app, file, tools, input) {
    const result = input;
    return result;
  }
});
ruleFunctions.push({
  id: "dateTimeCreated",
  ruleType: "buildIn",
  description: "Date (and Time) created",
  source: "function (app, file, tools) { // do not change this line!\n  const timeOffset = new Date(Date.now()).getTimezoneOffset()*60000; // get local time offset\n  const result = new Date(file.stat.ctime-timeOffset);\n  return result.toISOString().split('Z')[0]; // remove UTC symbol\n}",
  type: ["date", "datetime"],
  configElements: defaultConfigElements({}),
  fx: function(app, file, tools) {
    const timeOffset = new Date(Date.now()).getTimezoneOffset() * 6e4;
    const result = new Date(file.stat.ctime - timeOffset);
    return result.toISOString().split("Z")[0];
  }
});
ruleFunctions.push({
  id: "dateTimeModified",
  ruleType: "buildIn",
  description: "Date (and Time) modified",
  source: "function (app, file, tools) { // do not change this line!\n  const timeOffset = new Date(Date.now()).getTimezoneOffset()*60000;\n  const result = new Date(file.stat.mtime-timeOffset); // Apply offset to GMT Timestamp\n  return result.toISOString().split('Z')[0]; // remove UTC symbol\n}",
  type: ["date", "datetime"],
  configElements: defaultConfigElements({}),
  fx: function(app, file, tools) {
    const timeOffset = new Date(Date.now()).getTimezoneOffset() * 6e4;
    const result = new Date(file.stat.mtime - timeOffset);
    return result.toISOString().split("Z")[0];
  }
});
ruleFunctions.push({
  id: "fileSizeBytes",
  ruleType: "buildIn",
  description: "File size in bytes",
  source: "function (app, file, tools) { // do not change this line!\n  // acquire file size\n  const result = file.stat.size;\n  return result; // return you result.\n}",
  type: ["number"],
  configElements: defaultConfigElements({}),
  fx: function(app, file, tools) {
    const result = file.stat.size;
    return result;
  }
});
ruleFunctions.push({
  id: "fileSizeString",
  ruleType: "buildIn",
  description: "File size formatted as text",
  source: "function (app, file, tools) { // do not change this line!\n  // acquire file size\n  let size =file.stat.size;\n  const precision = 2; // number of decimal places\n  if (size > 1024) {\n    size = size / 1024;\n    if (size > 1024) {\n      size = size / 1024;\n      if (size > 1024) {\n        size = size / 1024;\n        return Number.parseFloat(size).toFixed(precision) + ' GB';\n      } \n      return Number.parseFloat(size).toFixed(precision) + ' MB';\n    }\n    return Number.parseFloat(size).toFixed(precision) + ' KB';\n  }   \n  return size + ' Bytes'; // return you result.\n}",
  type: ["text"],
  configElements: defaultConfigElements({}),
  fx: function(app, file, tools) {
    let size = file.stat.size;
    const precision = 2;
    if (size > 1024) {
      size = size / 1024;
      if (size > 1024) {
        size = size / 1024;
        if (size > 1024) {
          size = size / 1024;
          return size.toFixed(precision) + " GB";
        }
        return size.toFixed(precision) + " MB";
      }
      return size.toFixed(precision) + " KB";
    }
    return size + " Bytes";
  }
});
ruleFunctions.push({
  id: "autocomplete.modal",
  ruleType: "autocomplete.modal",
  description: "Autocomplete Modal (advanced)",
  isLiveRule: true,
  source: "",
  type: ["text", "tags", "aliases", "multitext"],
  configElements: defaultConfigElements({ removeContent: false, inputProperty: false, addPrefix: false, spaceReplacement: false, specialCharacterReplacement: false, convertToLowerCase: false, resultAsLink: false, addContent: false, script: false }),
  fx: async function(app, file, tools) {
    console.log(`autocomplete modal, work in progress...`);
    const currentContent = tools.getCurrentContent();
    const rule = tools.getRule();
    if (!rule)
      return currentContent;
    const options = tools.getOptionConfig(rule.id);
    if (!rule)
      return tools.getCurrentContent() || "autocomplete.modal";
    const frontmatter = tools.getFrontmatter();
    const hasAutocompleteProperties = Object.keys(frontmatter).some(
      (key) => key.startsWith(rule.property + options.propertyDelimiter) && (frontmatter[key] === void 0 || frontmatter[key] === null || frontmatter[key] === "")
    );
    if (!hasAutocompleteProperties)
      return tools.getCurrentContent() || "autocomplete.modal";
    const result = await openAutocompleteModal(
      this.app,
      this.plugin,
      rule,
      options,
      tools.getActiveFile(),
      tools.getFrontmatter()
    );
    console.log("autocomplete modal result", result, tools.getFrontmatter());
    if (result == null ? void 0 : result.values) {
      this.app.fileManager.processFrontMatter(file, (frontmatter2) => {
        for (const [key, value] of Object.entries(result.values)) {
          frontmatter2[key] = value;
        }
      }, { "mtime": file.stat.mtime });
    }
    return tools.getCurrentContent() || "autocomplete.modal";
  },
  configTab: function(optionEL, rule, that, previewComponent) {
    that.setOptionConfigDefaults(rule.id, {
      propertyDelimiter: "."
    });
    new import_obsidian10.Setting(optionEL).setName("Delimiter").setDesc("Character to determine which property should appear in the modal").addText((text) => text.setValue(that.getOptionConfig(rule.id, "propertyDelimiter") || ".").onChange(async (value) => {
      that.setOptionConfig(rule.id, "propertyDelimiter", value);
    }));
  }
});
ruleFunctions.push({
  id: "autoLink",
  ruleType: "automation",
  description: "Auto Link (advanced)",
  isLiveRule: true,
  source: "",
  type: ["text", "multitext"],
  configElements: defaultConfigElements({ removeContent: false, inputProperty: false, addPrefix: false, spaceReplacement: false, specialCharacterReplacement: false, convertToLowerCase: false, resultAsLink: false, script: false }),
  fx: async function(app, file, tools) {
    const currentContent = tools.getCurrentContent();
    let newContent = new Array();
    const rule = tools.getRule();
    if (!rule) {
      console.error(`autoLink: rule not found, returning current content ${currentContent}`);
      return currentContent;
    }
    const options = tools.getOptionConfig(rule.id);
    const filesToCheck = tools.getFilesInVault(options.destinationFolder);
    let links = currentContent || [];
    if (typeof links === "object" && !Array.isArray(links)) {
      links = [];
    } else if (typeof links === "string") {
      links = [links];
    }
    for (const part of links) {
      let link = tools.extractLinkParts(part);
      let linkFile = tools.getFileFromPath(link.path, filesToCheck);
      if (!linkFile) {
        if (options.askConfirmation) {
          const result = await new AlertModal(app, "Create new file", `File ${link.path} does not exist. Do you want to create it?`, "Create", "Cancel", "Don't ask again.").openAndGetValue();
          if (!result.proceed)
            return;
          options.askConfirmation = !result.data.askConfirmation;
        }
        link.path = options.destinationFolder + "/" + link.title + ".md";
        linkFile = await tools.createFileFromPath(link.path, options.addTemplate ? options.templateFile : void 0);
        tools.updateFrontmatter(rule.property, [`[[${tools.removeLeadingSlash(link.path)}|${link.title}]]`], linkFile);
      } else {
      }
      if (linkFile) {
        link.path = linkFile.path;
        newContent.push(`[[${tools.removeLeadingSlash(link.path)}|${link.title}]]`);
      }
    }
    tools.updateFrontmatter(rule.property, newContent);
    return newContent;
  },
  configTab: function(optionEL, rule, that, previewComponent) {
    that.setOptionConfigDefaults(rule.id, {
      addTemplate: true,
      askConfirmation: true,
      destinationFolder: "/",
      templateFile: ""
    });
    new import_obsidian10.Setting(optionEL).setName("Add template to new files").setDesc("Automatically add template to new files").addToggle((toggle) => toggle.setValue(that.getOptionConfig(rule.id, "addTemplate") || false).onChange(async (value) => {
      that.setOptionConfig(rule.id, "addTemplate", value);
    }));
    new import_obsidian10.Setting(optionEL).setName("Ask for confirmation").setDesc("Ask for confirmation before creating new files").addToggle((toggle) => toggle.setValue(that.getOptionConfig(rule.id, "askConfirmation") || false).onChange(async (value) => {
      that.setOptionConfig(rule.id, "askConfirmation", value);
    }));
    let destinationFolderEl;
    new import_obsidian10.Setting(optionEL).setName("Destination Folder").setDesc("Folder to place new files").addSearch((cb) => {
      destinationFolderEl = cb;
      new FolderSuggest(that.app, cb.inputEl);
      cb.setPlaceholder("enter folder or browse ...").setValue(that.getOptionConfig(rule.id, "destinationFolder") || "").onChange((newFolder) => {
        newFolder = newFolder.trim();
        newFolder = newFolder.replace(/\/$/, "");
        that.setOptionConfig(rule.id, "destinationFolder", newFolder);
      });
      cb.containerEl.addClass("frontmatter-automate-search");
    }).addExtraButton(
      (button) => button.setIcon("folder-tree").setTooltip("Select template folder").onClick(async () => {
        openDirectorySelectionModal(
          that.app,
          [that.getOptionConfig(rule.id, "destinationFolder")],
          [],
          {
            title: "Select folder to place new files",
            selectionMode: "include",
            displayMode: "folder",
            optionSelectionMode: false,
            optionShowFiles: false
          },
          (result) => {
            if (!result)
              return;
            if (result.folders.length === 0 || !result.folders[0] || typeof result.folders[0] !== "string")
              return;
            let selectedFolder = result.folders[0].trim().replace(/\/$/, "");
            if (selectedFolder === "")
              selectedFolder = "/";
            if (!selectedFolder)
              return;
            destinationFolderEl.setValue(selectedFolder);
            that.setOptionConfig(rule.id, "destinationFolder", selectedFolder);
          }
        );
      })
    );
    let destinationFileEl;
    new import_obsidian10.Setting(optionEL).setName("Template File").setDesc("Select a template file to add to new files").addSearch((cb) => {
      destinationFileEl = cb;
      new FileSuggest(cb.inputEl, that.plugin, "");
      cb.setPlaceholder("enter folder or browse ...").setValue(that.getOptionConfig(rule.id, "templateFile") || "").onChange((newFile) => {
        newFile = newFile.trim();
        newFile = newFile.replace(/\/$/, "");
        that.setOptionConfig(rule.id, "templateFile", newFile);
      });
      cb.containerEl.addClass("frontmatter-automate-search");
    }).addExtraButton(
      (button) => button.setIcon("folder-tree").setTooltip("Select template file").onClick(async () => {
        openDirectorySelectionModal(
          that.app,
          [],
          [that.getOptionConfig(rule.id, "templateFile")],
          {
            title: "Select template for new files",
            selectionMode: "include",
            displayMode: "file",
            optionSelectionMode: false,
            optionShowFiles: true
          },
          (result) => {
            if (!result)
              return;
            if (result.files.length === 0 || !result.files[0] || typeof result.files[0] !== "string")
              return;
            let selectedFile = result.files[0].trim().replace(/\/$/, "");
            if (!selectedFile)
              return;
            destinationFileEl.setValue(selectedFile);
            that.setOptionConfig(rule.id, "templateFile", selectedFile);
          }
        );
      })
    );
  }
});

// src/tools.ts
function parseJSCode(jsCode) {
  function parseFunction(jsCode2) {
    try {
      jsCode2 = cleanCodeString(jsCode2);
      var funcReg = /function *\(([^()]*)\)[ \n\t]*{(.*)}/gmi;
      var match = funcReg.exec(jsCode2.replace(/\n/g, " "));
      if (!match)
        return void 0;
      var args = match[1].split(",");
      args.push(match[2]);
      return new Function(...args);
    } catch (error) {
      console.error("error parsing JS function!", error);
      return error.message;
    }
  }
  ;
  return parseFunction(jsCode);
}
function cleanCodeString(codeString) {
  if (typeof codeString !== "string") {
    throw new TypeError("Input must be a string.");
  }
  let inMultiLineComment = false;
  let inSingleLineComment = false;
  let inString = null;
  let inRegExp = false;
  let cleanedCode = "";
  let i = 0;
  while (i < codeString.length) {
    const char = codeString[i];
    const nextChar = codeString[i + 1];
    if (inMultiLineComment) {
      if (char === "*" && nextChar === "/") {
        inMultiLineComment = false;
        i += 2;
        continue;
      } else {
        i++;
        continue;
      }
    }
    if (inSingleLineComment) {
      if (char === "\n" || char === "\r") {
        inSingleLineComment = false;
        cleanedCode += char;
        i++;
        continue;
      } else {
        i++;
        continue;
      }
    }
    if (inString) {
      if (char === inString) {
        inString = null;
      } else if (char === "\\") {
        cleanedCode += char;
        i++;
        if (i < codeString.length) {
          cleanedCode += codeString[i];
        }
        i++;
        continue;
      }
      cleanedCode += char;
      i++;
      continue;
    }
    if (inRegExp) {
      if (char === "/") {
        inRegExp = false;
      } else if (char === "\\") {
        cleanedCode += char;
        i++;
        if (i < codeString.length) {
          cleanedCode += codeString[i];
        }
        i++;
        continue;
      }
      cleanedCode += char;
      i++;
      continue;
    }
    if (char === "/" && nextChar === "*") {
      inMultiLineComment = true;
      i += 2;
      continue;
    }
    if (char === "/" && nextChar === "/") {
      inSingleLineComment = true;
      i += 2;
      continue;
    }
    if (char === '"' || char === "'") {
      inString = char;
      cleanedCode += char;
      i++;
      continue;
    }
    if (char === "/") {
      const prevMeaningfulChar = cleanedCode.trim().slice(-1);
      if (prevMeaningfulChar === "" || ["(", ",", "=", ":", "[", "!", "&", "|", "?", "{", ";", "\n", "\r"].includes(prevMeaningfulChar)) {
        inRegExp = true;
        cleanedCode += char;
        i++;
        continue;
      }
    }
    cleanedCode += char;
    i++;
  }
  return cleanedCode;
}
function resolveFolder(app, folder_str) {
  folder_str = (0, import_obsidian11.normalizePath)(folder_str);
  const folder = app.vault.getAbstractFileByPath(folder_str);
  if (!folder) {
    throw new ErrorManager(`Folder "${folder_str}" doesn't exist`);
  }
  if (!(folder instanceof import_obsidian11.TFolder)) {
    throw new ErrorManager(`${folder_str} is a file, not a folder`);
  }
  return folder;
}
function getFilesFromFolder(app, folder_str) {
  const folder = resolveFolder(app, folder_str);
  const files = [];
  import_obsidian11.Vault.recurseChildren(folder, (file) => {
    if (file instanceof import_obsidian11.TFile) {
      files.push(file);
    }
  });
  files.sort((a, b) => {
    return a.path.localeCompare(b.path);
  });
  return files;
}
var ScriptingTools = class {
  constructor(app, plugin, settings, rule, frontmatter, activeFile) {
    this.app = app;
    this.plugin = plugin;
    this.settings = settings;
    this.rule = rule;
    this.frontmatter = frontmatter;
    this.activeFile = activeFile;
  }
  getFrontmatter() {
    return this.frontmatter;
  }
  setFrontmatter(frontmatter) {
    this.frontmatter = frontmatter;
  }
  setFrontmatterProperty(key, value) {
    if (!this.frontmatter)
      this.frontmatter = {};
    this.frontmatter[key] = value;
  }
  getFrontmatterProperty(key) {
    return this.frontmatter[key];
  }
  setActiveFile(file) {
    this.activeFile = file;
  }
  getActiveFile() {
    return this.activeFile;
  }
  setRule(rule) {
    this.rule = rule;
  }
  getRule() {
    return this.rule;
  }
  getRuleFunction(rule) {
    if (!rule)
      rule = this.rule;
    if (rule) {
      const functionIndex = ruleFunctions.findIndex((fx) => fx.id === rule.content);
      if (functionIndex !== -1) {
        return ruleFunctions[functionIndex];
      }
    }
  }
  setCurrentContent(content) {
    this.currentContent = content;
  }
  getCurrentContent() {
    return this.currentContent;
  }
  updateFrontmatter(property, newContent, file) {
    if (!this.app)
      return;
    if (!file)
      file = this.activeFile;
    if (!file)
      return;
    this.app.fileManager.processFrontMatter(file, (frontmatter) => {
      console.log(`updateFrontmatter '${file.path}' frontmatter '${property}' to '${newContent.toString()}'`);
      if (typeof newContent === "object" && !Array.isArray(newContent)) {
        console.warn(`updateFrontmatter '${file.path}'|'${property}' object not supported!`);
      } else {
        frontmatter[property] = newContent;
      }
    }, { "mtime": file.stat.mtime });
  }
  async showConfirmDialog(message, title = "Confirm", button1 = "Yes", button2 = "No") {
    const result = await new AlertModal(this.app, title, message, button1, button2).openAndGetValue();
    return result.proceed;
  }
  /**
   * * Get the option config for a specific rule. Optional the specific parameter by providing an option ID.
   *
   * @param {string} ruleId
   * @param {string} [optionId]
   * @return {*} 
   * @memberof ScriptingTools
   */
  getOptionConfig(ruleId, optionId) {
    if (!ruleId || ruleId === void 0 || !this.settings)
      return void 0;
    const rule = this.settings.rules.find((rule2) => rule2.id === ruleId);
    if (rule && rule.hasOwnProperty("optionsConfig")) {
      const optionConfig = rule.optionsConfig[ruleId];
      if (optionConfig) {
        if (optionId) {
          return optionConfig[optionId];
        } else {
          return optionConfig;
        }
      }
    }
    return void 0;
  }
  getFilesInVault(matching) {
    matching = matching.replace(/^\/|\/$/g, "") + "/";
    const files = this.app.vault.getMarkdownFiles();
    const matchingFiles = files.filter((file) => file instanceof import_obsidian11.TFile && file.path.includes(matching));
    return matchingFiles;
  }
  getFileFromPath(path, filesCheck) {
    const files = filesCheck ? filesCheck : this.app.vault.getMarkdownFiles();
    const matchingFiles = files.filter(
      (file) => file instanceof import_obsidian11.TFile && file.path.toLocaleLowerCase().includes(path.toLocaleLowerCase())
    );
    return matchingFiles.length > 0 ? matchingFiles[0] : void 0;
  }
  async createFileFromPath(fileNameWithPath, templateFileWithPath) {
    const fileName = fileNameWithPath.replace(/^\/|\/$/g, "");
    const templateFile = templateFileWithPath.replace(/^\/|\/$/g, "");
    const folderPath = this.getFolderFromPath(fileName);
    const fileNameOnly = fileName.split("/").pop() || fileName;
    if (!folderPath) {
      throw new ErrorManager(`Invalid folder path: "${folderPath}"`);
    }
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!folder) {
      throw new ErrorManager(`Folder "${folderPath}" doesn't exist`);
    }
    if (!(folder instanceof import_obsidian11.TFolder)) {
      throw new ErrorManager(`${folderPath} is a file, not a folder`);
    }
    const templateContent = await this.app.vault.read(this.app.vault.getAbstractFileByPath(templateFile));
    const fileExists = this.app.vault.getAbstractFileByPath(fileNameWithPath);
    if (!fileExists) {
      return await this.app.vault.create(folder.path + "/" + fileNameOnly, templateContent);
    }
    return fileExists;
  }
  // create the file if it does not exist
  /**
   * * Fetches custom property information from all markdown files in the vault.
   *
   * @return {*} 
   */
  fetchCustomPropertyInfos(app) {
    const propertyInfos = {};
    const files = app.vault.getMarkdownFiles();
    files.forEach((file) => {
      const metadata = app.metadataCache.getFileCache(file);
      if (metadata == null ? void 0 : metadata.frontmatter) {
        Object.keys(metadata.frontmatter).forEach((key) => {
          if (!propertyInfos[key]) {
            propertyInfos[key] = { name: key, type: "text" };
          }
        });
      }
    });
    return propertyInfos;
  }
  /**
   * Fetches known properties from the metadata cache.
   * If the method getAllPropertyInfos is not available, it falls back to fetchCustomPropertyInfos.
   * @param app The Obsidian app instance.
   */
  async fetchKnownProperties(app) {
    let propertyInfos = {};
    if (typeof app.metadataCache.getAllPropertyInfos === "function") {
      propertyInfos = app.metadataCache.getAllPropertyInfos();
    } else {
      propertyInfos = this.fetchCustomPropertyInfos(app);
    }
    propertyInfos = Object.fromEntries(
      Object.entries(propertyInfos).sort(([keyA], [keyB]) => keyA.localeCompare(keyB))
    );
    this.knownProperties = {};
    Object.keys(propertyInfos).forEach((key) => {
      this.knownProperties[propertyInfos[key].name] = propertyInfos[key];
    });
    console.log(this.knownProperties);
    return this.knownProperties;
  }
  getKnownProperties() {
    if (!this.knownProperties) {
      this.knownProperties = this.fetchCustomPropertyInfos(this.app);
    }
    return this.knownProperties;
  }
  extractLinkParts(link) {
    const cleanedLink = link.replace(/[\[\]]/g, "");
    const parts = cleanedLink.split("|");
    const path = parts[0].trim();
    const title = parts.length > 1 ? parts[1].trim() : path;
    return { path, title };
  }
  removeLeadingSlash(path) {
    return path.replace(/^\/+/, "");
  }
  addLeadingSlash(path) {
    return path.replace(/^(?!\/)/, "/");
  }
  /**
   * Check if a string complies with ISO Standard
   * 
   * @param str Any string
   * @param options Options to look for
   * @returns 
   */
  isISOString(str, options = {}) {
    const {
      withMilliseconds = false,
      withTimezone = false,
      withTime = true,
      withDate = true
    } = options;
    let dateRegexStr = "^(?:\\d{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[12]\\d|3[01]))";
    let timeRegexStr = "(?:T(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
    if (withMilliseconds) {
      timeRegexStr += "\\.\\d{3}";
    }
    if (withTimezone) {
      timeRegexStr += "(?:Z|[+-](?:[01]\\d|2[0-3]):[0-5]\\d)?)?";
    } else {
      timeRegexStr += ")?";
    }
    let regexStr = "";
    if (withDate && withTime) {
      regexStr = `${dateRegexStr}${timeRegexStr}$`;
    } else if (withDate) {
      regexStr = `${dateRegexStr}$`;
    } else if (withTime) {
      regexStr = `^${timeRegexStr.slice(4)}$`;
    } else {
      return false;
    }
    const regex = new RegExp(regexStr);
    return regex.test(str);
  }
  /**
   * Try to convert Any Types to a specific Type
   * @param input 
   * @param typeString 'string' | 'number' | 'boolean' | 'string[]'
   * @returns 
   */
  tryConvert(input, typeString) {
    switch (typeString) {
      case "string":
        if (typeof input === "string") {
          return input;
        }
        return void 0;
      case "number":
        const num = Number(input);
        if (!isNaN(num)) {
          return num;
        }
        return void 0;
      case "boolean":
        if (typeof input === "boolean") {
          return input;
        }
        if (typeof input === "string") {
          const lowerValue = input.toLowerCase();
          if (lowerValue === "true") {
            return true;
          }
          if (lowerValue === "false") {
            return false;
          }
        }
        if (typeof input === "number") {
          if (input === 1) {
            return true;
          }
          if (input === 0) {
            return false;
          }
        }
        return void 0;
      case "string[]":
        if (Array.isArray(input) && input.every((item) => typeof item === "string")) {
          return input;
        }
        return void 0;
      default:
        return void 0;
    }
  }
  formatToYAMLSaveString(text, replaceBy = void 0) {
    let replaceString = "-";
    if (!replaceBy && this.settings) {
      replaceString = this.settings.specialCharReplacement || "-";
    } else {
      if (replaceBy)
        replaceString = replaceBy;
    }
    return text.replace(/[^a-zA-Z0-9\-_\/]/g, replaceString);
  }
  /**
   * Converts a string to a YAML-safe format by adding quotes when necessary.
   * @param input The string, boolean, number or array to make YAML-safe
   * @returns The safely quoted string when needed, or the original string if safe
   */
  toYamlSafeString(input) {
    if (Array.isArray(input)) {
      input.forEach((item, index) => {
        input[index] = this.toYamlSafeString(item).toString();
      });
      return input;
    }
    switch (typeof input) {
      case "number":
        return input;
      case "boolean":
        return input ? "true" : "false";
      case "string":
        const trimmed = input.trim();
        if (trimmed === "")
          return '""';
        const needsQuotes = /[:{}\[\],&*#?|<>=!%@`"'\\]|^[-?\n]|[\s\n]|^[yYnN]|^[0-9]|^[+-]|^(true|false|yes|no|on|off)$/i.test(trimmed);
        const isAlreadyQuoted = trimmed.startsWith('"') && trimmed.endsWith('"') || trimmed.startsWith("'") && trimmed.endsWith("'");
        if (!needsQuotes && !isAlreadyQuoted) {
          return trimmed;
        }
        if (!isAlreadyQuoted) {
          return `"${trimmed.replace(/"/g, '\\"')}"`;
        }
        return trimmed;
      default:
        console.error(`toYamlSafeString(${input}) if of type '${typeof input}'`);
        return input;
    }
  }
  replaceSpaces(text, replaceBy = void 0) {
    let replaceString = "_";
    if (!replaceBy && this.settings) {
      replaceString = this.settings.spaceReplacement || "_";
    } else {
      if (replaceBy)
        replaceString = replaceBy;
    }
    return text.replace(/\s+/g, replaceString);
  }
  formatCamelCase(text) {
    let textParts = text.split(" ");
    let convertedTextParts = [];
    textParts.forEach((text2, index) => {
      let newTextPart = text2.toLowerCase();
      if (index > 0)
        newTextPart = newTextPart.charAt(0).toUpperCase() + newTextPart.slice(1);
      convertedTextParts.push(newTextPart);
    });
    return convertedTextParts.join("");
  }
  formatUpperCamelCase(text) {
    let textParts = text.split(" ");
    let convertedTextParts = [];
    textParts.forEach((text2, index) => {
      let newTextPart = text2.toLowerCase();
      newTextPart = newTextPart.charAt(0).toUpperCase() + newTextPart.slice(1);
      convertedTextParts.push(newTextPart);
    });
    return convertedTextParts.join("");
  }
  /**
   * get the path to a file from a string containing the full parh/name string
   * @param path string
   * @param separator string defaults to '/'
   * @returns string
   */
  getFolderFromPath(path, separator = "/") {
    if (path === null)
      return null;
    if (path === void 0)
      return void 0;
    const currentPathParts = path.split("/");
    currentPathParts.pop();
    return currentPathParts.join(separator);
  }
  /**
   * removes duplicate strings in an array and deletes empty strings
   * @param stringArray 
   * @returns 
   */
  removeDuplicateStrings(stringArray) {
    if (!stringArray)
      return [];
    const uniqueStringsSet = new Set(stringArray);
    uniqueStringsSet.delete("");
    return [...uniqueStringsSet];
  }
};
function getFolderFromPath(path, separator = "/") {
  if (path === null)
    return null;
  if (path === void 0)
    return void 0;
  const currentPathParts = path.split("/");
  currentPathParts.pop();
  return currentPathParts.join(separator);
}

// src/types.ts
var versionString = "0.0.18";
var DEFAULT_FILTER_FILES_AND_FOLDERS = {
  selectedFolders: [],
  selectedFiles: [],
  mode: "exclude",
  display: "folders"
};
var DEFAULT_SETTINGS = {
  tagPrefix: "",
  excludeRootFolder: false,
  tagsPropertyName: "tags",
  spaceReplacement: "_",
  specialCharReplacement: "_",
  lowercaseTags: false,
  knownProperties: [],
  rules: [],
  liveRules: [],
  useTextArea: false,
  exclude: {
    selectedFolders: [],
    selectedFiles: [],
    mode: "exclude",
    display: "folders"
  },
  include: {
    selectedFolders: [],
    selectedFiles: [],
    mode: "include",
    display: "folders"
  },
  configuredProperties: []
};
var DEFAULT_RULE_DEFINITION = {
  id: "",
  active: true,
  asLink: false,
  addContent: "overwrite",
  property: "",
  value: "",
  customProperty: "",
  type: "text",
  typeProperty: { name: "", type: "text", source: "registered" },
  content: "",
  buildInCode: "",
  jsCode: "",
  showContent: false,
  exclude: {
    selectedFolders: [],
    selectedFiles: [],
    mode: "exclude",
    display: "folders"
  },
  include: {
    selectedFolders: [],
    selectedFiles: [],
    mode: "include",
    display: "folders"
  },
  prefix: "",
  spaceReplacement: "",
  specialCharReplacement: "",
  lowercaseTags: false,
  inputProperty: "",
  onlyModify: true,
  useCustomCode: false
};

// src/settings-properties.ts
var import_obsidian13 = require("obsidian");
var import_crypto = require("crypto");

// src/editorModal.ts
var import_obsidian12 = require("obsidian");
var codeEditorModal = class extends import_obsidian12.Modal {
  /**
   * Creates an instance of the DirectorySelectionModal.
   * @param app - The Obsidian App instance.
   * @param plugin - The plugin instance.
   * @param initialCode - String with the initial code.
   * @param expectedType - Expected return type.
   * @param activeFile - The currently active file or folder.
   * @param frontmatter - Frontmatter data for the active file.
   * @param okCallback - Function to call when the user clicks "OK". Receives the selection result.
   */
  constructor(app, plugin, initialCode, expectedType, activeFile, frontmatter, okCallback) {
    super(app);
    this.initialCode = initialCode;
    this.expectedType = expectedType;
    this.useTextArea = false;
    this.checkedSuccessfully = false;
    this.activeFile = activeFile;
    this.frontmatter = frontmatter;
    this.currentType = expectedType;
    this.currentCode = initialCode;
    this.plugin = plugin;
    this.scriptingTools = new ScriptingTools(app, this.plugin, this.frontmatter);
    this.okCallback = okCallback;
    this.resetSelectionToInitial();
  }
  /**
   * Resets the current selection state to the initial state provided at construction.
   */
  resetSelectionToInitial() {
    var _a;
    this.currentCode = this.initialCode;
    (_a = this.cmEditor) == null ? void 0 : _a.setValue(this.currentCode);
    if (this.functionResultTextComponent)
      this.functionResultTextComponent.setValue("");
  }
  /**
   * Resets the current selection state to empty.
   */
  resetSelectionToEmpty() {
    var _a;
    this.currentCode = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    (_a = this.cmEditor) == null ? void 0 : _a.setValue(this.currentCode);
    if (this.functionResultTextComponent)
      this.functionResultTextComponent.setValue("");
  }
  loadCodeMirrorMode(mode) {
    try {
      require(`obsidian/lib/codemirror/mode/${mode}/${mode}.js`);
      console.log(`CodeMirror mode '${mode}' loaded successfully (using require).`);
    } catch (error) {
      console.error(`Failed to load CodeMirror mode '${mode}' (using require):`, error);
    }
  }
  /**
   * Called when the modal is opened. Builds the UI.
   */
  async onOpen() {
    const { contentEl } = this;
    if (contentEl.parentElement)
      contentEl.parentElement.style.width = "900px";
    contentEl.empty();
    contentEl.addClass("codeEditor-modal");
    contentEl.createEl("h2", { text: "JavaScript Editor" });
    contentEl.createEl("body", { text: `Make sure your code results: ${this.expectedType}` });
    this.editorRootElement = contentEl.createDiv({ cls: "codeEditor-container" });
    this.editorRootElement.style.height = "600px";
    this.editorRootElement.style.overflowY = "auto";
    this.editorRootElement.style.padding = "10px";
    this.editorRootElement.style.marginTop = "10px";
    this.editorRootElement.style.marginBottom = "10px";
    this.cmEditor = null;
    const ruleOptionsDiv = contentEl.createDiv({ cls: "codeEditor-options" });
    if (this.useTextArea) {
      const ruleOptionsSettings = new import_obsidian12.Setting(this.editorRootElement).addTextArea((textArea) => {
        textArea.setPlaceholder("ender valid JS Code");
        textArea.inputEl.setAttribute("style", `height:190px; width:80%;`);
        textArea.onChange(async (value) => {
          if (this.functionTestButton)
            this.functionTestButton.buttonEl.addClass("mod-warning");
          this.currentCode = value;
        });
      });
    } else {
      const CodeMirror = window.CodeMirror;
      if (CodeMirror) {
        if (!CodeMirror.modes.javascript) {
          await this.loadCodeMirrorMode("javascript");
          console.log("javaScript support loaded");
        }
      }
      let jsCode = this.currentCode;
      this.cmEditor = CodeMirror(this.editorRootElement, {
        value: jsCode || "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result; // return you result.\n}",
        mode: "javascript",
        lineNumbers: true,
        theme: "obsidian",
        indentUnit: 4,
        lineWrapping: false,
        readOnly: false,
        outerHeight: "600px"
      });
      if (this.cmEditor) {
        this.cmEditor.on("change", (cmEditor) => {
          if (this.functionTestButton)
            this.functionTestButton.buttonEl.addClass("mod-warning");
        });
        this.cmEditor.on("blur", (cmEditor) => {
          this.currentCode = cmEditor.getValue();
        });
      }
      ;
      new import_obsidian12.Setting(ruleOptionsDiv).addButton((button) => {
        this.functionTestButton = button;
        button.setWarning().setButtonText("Run Code").setTooltip("Run the code and check for errors").onClick(async () => {
          if (this.cmEditor) {
            let jsCode2 = this.cmEditor.getValue();
            let userFunction = parseJSCode(jsCode2);
            if (typeof userFunction === "string") {
              let errorHint = "See console for details!";
              if (userFunction.contains("Unexpected token")) {
                errorHint = "Did you missed a semicolon (;)?";
              }
              if (this.functionResultTextComponent)
                this.functionResultTextComponent.setValue(`Syntax error: ${userFunction}! ${errorHint}`);
              this.checkedSuccessfully = false;
              button.buttonEl.addClass("mod-warning");
            } else {
              if (userFunction) {
                try {
                  const result = userFunction(this.app, this.activeFile, this.scriptingTools);
                  if (this.functionResultTextComponent)
                    this.functionResultTextComponent.setValue(`'${result.toString()}' (${typeof result})`);
                  this.updateTypeIcons(result, typesContainer, this.expectedType, this.currentType, this.plugin.settings);
                  button.buttonEl.removeClass("mod-warning");
                  this.checkedSuccessfully = true;
                } catch (e) {
                  if (this.functionResultTextComponent) {
                    this.functionResultTextComponent.setValue(`Syntax error: ${e.message}! See console for details!`);
                  }
                  console.error("Syntax error. ", e, jsCode2, userFunction);
                  this.checkedSuccessfully = false;
                  button.buttonEl.addClass("mod-warning");
                }
              } else {
                console.error("syntax error");
                this.checkedSuccessfully = false;
              }
            }
          }
        });
      }).addText((text) => {
        this.functionResultTextComponent = text;
        text.setPlaceholder("function result").setDisabled(true);
        this.functionResultTextComponent.inputEl.style.width = "580px";
      });
      const typesContainer = ruleOptionsDiv.createDiv({ cls: "property-icons-container" });
    }
    this.createActionButtons(contentEl);
  }
  updateTypeIcons(value, container, expectedType, currentType, settings) {
    const newType = typeof value;
    const typeIcons = {
      "string": ["text", "tags", "aliases", "multitext", "date", "datetime"],
      "number": ["number"],
      "boolean": ["checkbox"],
      "object": ["tags", "aliases", "multitext"]
    };
    if (newType === "string") {
      if (!this.scriptingTools.isISOString(value, { withDate: true })) {
        typeIcons[newType].splice(typeIcons[newType].indexOf("date"), 1);
        console.error("Invalid date format:", value);
      }
      if (!this.scriptingTools.isISOString(value, { withDate: true, withTime: true })) {
        typeIcons[newType].splice(typeIcons[newType].indexOf("datetime"), 1);
        console.error("Invalid date format:", value);
      }
    }
    container.empty();
    for (let obsidianType of typeIcons[newType]) {
      if (obsidianType) {
        const iconEl = container.createSpan({ cls: "property-icon setting-item-icon" });
        updatePropertyIcon(iconEl, obsidianType);
      }
    }
  }
  /**
   * Creates the "OK" and "Reset" buttons.
   * @param containerEl - The HTML element to append the buttons to.
   */
  createActionButtons(containerEl) {
    const buttonsEl = containerEl.createDiv({ cls: "modal-buttons" });
    buttonsEl.style.marginTop = "15px";
    buttonsEl.style.display = "flex";
    buttonsEl.style.justifyContent = "flex-end";
    buttonsEl.style.gap = "10px";
    const resetButton = buttonsEl.createEl("button");
    (0, import_obsidian12.setIcon)(resetButton, "reset");
    resetButton.ariaLabel = "Reset selection";
    resetButton.onclick = () => {
      this.resetSelectionToInitial();
    };
    const emptyButton = buttonsEl.createEl("button");
    (0, import_obsidian12.setIcon)(emptyButton, "eraser");
    emptyButton.ariaLabel = "Clear selection";
    emptyButton.onclick = () => {
      this.resetSelectionToEmpty();
    };
    const cancelButton = buttonsEl.createEl("button", { text: "Cancel" });
    cancelButton.ariaLabel = "close and discard changes";
    cancelButton.onclick = () => {
      console.log("Cancel Clicked - Returning");
      this.okCallback(null);
      this.close();
    };
    const okButton = buttonsEl.createEl("button", { text: "OK", cls: "mod-cta" });
    cancelButton.ariaLabel = "close and save changes";
    okButton.onclick = () => {
      this.close();
    };
  }
  /**
   * Called when the modal is closed. Cleans up resources.
   */
  onClose() {
    const result = {
      code: this.currentCode,
      checked: this.checkedSuccessfully,
      type: "text"
    };
    console.log("OK Clicked - Returning Result:", result);
    this.okCallback(result);
    const { contentEl } = this;
    contentEl.empty();
  }
};
function openCodeEditorModal(app, plugin, initialCode, expectedType, activeFile, frontmatter, okCallback) {
  new codeEditorModal(
    app,
    plugin,
    initialCode,
    expectedType,
    activeFile,
    frontmatter,
    okCallback
  ).open();
}

// src/settings-properties.ts
var RulesTable = class extends import_obsidian13.PluginSettingTab {
  constructor(app, plugin, container, settingsParameter) {
    super(app, plugin);
    this.knownProperties = {};
    this.activeFile = null;
    this.plugin = plugin;
    this.container = container;
    this.settingsParameter = settingsParameter;
    this.tools = new ScriptingTools(app, plugin);
    this.activeFile = this.app.workspace.getActiveFile();
  }
  // Helper to render one rule
  renderPropertyRow(containerEl, rule, index) {
    const ruleFn = getRuleFunctionById(rule.content);
    const rowEl = containerEl.createDiv({ cls: "property-setting-row setting-item" });
    rowEl.id = rule.id;
    const controlEl = rowEl.createDiv({ cls: "setting-item-control" });
    controlEl.style.gap = "0px";
    const leftContainer = controlEl.createDiv({ cls: "property-left-container" });
    const iconEl = leftContainer.createSpan({ cls: "property-icon setting-item-icon" });
    (0, import_obsidian13.setIcon)(iconEl, "hash");
    const searchContainer = leftContainer.createDiv({ cls: "property-search-container" });
    const nameInput = new import_obsidian13.TextComponent(searchContainer).setPlaceholder("Select property...").setValue(rule.property || "").onChange(async (value) => {
      this.renderSearchResults(searchContainer, value, index);
    });
    nameInput.inputEl.style.border = "none";
    nameInput.inputEl.addEventListener("focus", () => {
      this.renderSearchResults(searchContainer, nameInput.getValue(), index);
    });
    nameInput.inputEl.addEventListener("input", () => {
      this.renderSearchResults(searchContainer, nameInput.getValue(), index);
    });
    nameInput.inputEl.addEventListener("blur", (event) => {
      setTimeout(() => {
        const relatedTarget = event.relatedTarget;
        const resultsEl = searchContainer.querySelector(".property-search-results");
        if (!resultsEl || !resultsEl.contains(relatedTarget)) {
          this.clearSearchResults(searchContainer);
        }
      }, 100);
    });
    const currentPropertyInfo = this.knownProperties[rule.property];
    if (currentPropertyInfo) {
      updatePropertyIcon(iconEl, currentPropertyInfo.type);
    } else if (rule.property) {
      (0, import_obsidian13.setIcon)(iconEl, "alert-circle");
    }
    const middleContainer = controlEl.createDiv({ cls: "property-middle-container" });
    const valueContainer = middleContainer.createDiv({ cls: "property-value-container" });
    if (this.activeFile) {
      this.app.fileManager.processFrontMatter(this.activeFile, async (frontmatter) => {
        rule.value = await executeRule("preview", this.app, this.plugin.settings, this.activeFile, "", rule, frontmatter);
      }, { "mtime": this.activeFile.stat.mtime });
    }
    const previewComponent = this.renderValueInput(valueContainer, currentPropertyInfo, rule.value, index);
    const propertyDevDropdown = new import_obsidian13.DropdownComponent(middleContainer);
    propertyDevDropdown.selectEl.setAttribute("style", "width:35%");
    propertyDevDropdown.addOption("", "Select a content");
    for (let ruleFunction of ruleFunctions) {
      if (ruleFunction.type.contains(rule.type)) {
        propertyDevDropdown.addOption(ruleFunction.id, ruleFunction.description);
      }
    }
    propertyDevDropdown.addOption("script", "JavaScript function (advanced)");
    propertyDevDropdown.setValue(rule.content);
    propertyDevDropdown.onChange(async (value) => {
      var _a, _b, _c, _d;
      if (value !== "") {
        const ruleFunction = getRuleFunctionById(value);
        switch (ruleFunction == null ? void 0 : ruleFunction.ruleType) {
          case "script":
            let oldOriginalCode = ((_a = getRuleFunctionById(value)) == null ? void 0 : _a.source) || ruleFunctions[0].source;
            if (rule.buildInCode !== "" && rule.buildInCode !== oldOriginalCode) {
              const shouldProceed = await new AlertModal(
                this.app,
                "Overwrite existing code?",
                "I sees like you have custom code for this rule! Should this be overwritten by default code for this parameter?",
                "Yes",
                "No"
              ).openAndGetValue();
              if (shouldProceed.proceed) {
                rule.buildInCode = ((_b = getRuleFunctionById(value)) == null ? void 0 : _b.source) || ruleFunctions[0].source;
                rule.useCustomCode = false;
              } else {
                rule.buildInCode;
              }
              await this.plugin.saveSettings();
            } else {
              rule.buildInCode = ((_c = getRuleFunctionById(value)) == null ? void 0 : _c.source) || ruleFunctions[0].source;
              rule.useCustomCode = false;
              await this.plugin.saveSettings();
            }
            break;
          case "buildIn.inputProperty":
          case "buildIn":
            rule.buildInCode = ((_d = getRuleFunctionById(value)) == null ? void 0 : _d.source) || ruleFunctions[0].source;
            rule.useCustomCode = false;
            await this.plugin.saveSettings();
            break;
          case "automation":
          case "autocomplete.modal":
            break;
          default:
        }
        rule.content = value;
        await this.plugin.saveSettings();
        this.updatePreview(rule, previewComponent);
        this.renderPropertyOptions(optionEL, rule, previewComponent);
      }
    });
    new import_obsidian13.ButtonComponent(middleContainer).setIcon("gear").setTooltip("open settings").setClass("property-icon-button").onClick(async () => {
      let settingsContainers = containerEl.getElementsByClassName("property-options-container");
      for (let container of settingsContainers) {
        if (container.getAttribute("id") !== rule.id)
          container.setAttribute("style", "display: none;");
      }
      this.renderPropertyOptions(optionEL, rule, previewComponent);
      optionEL.style.display = optionEL.style.display === "block" ? "none" : "block";
    });
    const deleteButtonContainer = controlEl.createDiv({ cls: "property-delete-button-container" });
    new import_obsidian13.ButtonComponent(deleteButtonContainer).setIcon("trash-2").setTooltip("remove this rule").setClass("mod-subtle").onClick(async () => {
      this.plugin.settings[this.settingsParameter].splice(index, 1);
      await this.plugin.saveSettings();
      this.display();
    });
    controlEl.style.display = "flex";
    controlEl.style.alignItems = "center";
    controlEl.style.justifyContent = "space-between";
    controlEl.style.width = "100%";
    leftContainer.style.display = "flex";
    leftContainer.style.alignItems = "center";
    leftContainer.style.minWidth = "150px";
    iconEl.style.marginRight = "8px";
    searchContainer.style.position = "relative";
    searchContainer.style.flexGrow = "1";
    valueContainer.style.flexGrow = "2";
    deleteButtonContainer.style.marginLeft = "auto";
    const optionEL = containerEl.createDiv({ cls: "property-options-container" });
    optionEL.id = rule.id;
    optionEL.style.display = "none";
  }
  renderPropertyOptions(optionEL, rule, previewComponent) {
    var _a, _b, _c, _d, _e, _f;
    optionEL.empty();
    const ruleFn = getRuleFunctionById(rule.content);
    if (useRuleOption(ruleFn, "removeContent")) {
      const removeContentButton = new import_obsidian13.Setting(optionEL).setName("Remove content").setDesc(`Before making changes you might consider to remove content generated by this rule`).addButton(
        (button) => {
          button.setWarning().setButtonText("Remove Content").setCta().onClick(() => {
            let count = this.plugin.removeFrontmatterParamsFromAllFiles(rule);
            button.removeCta();
            button.setDisabled(true);
            removeContentButton.setDesc(`Removed this rule from ${count.files} files.`);
          });
        }
      );
    }
    if (useRuleOption(ruleFn, "ruleActive")) {
      new import_obsidian13.Setting(optionEL).setName("Rule active").setDesc("If enabled, the rule will be executed").addToggle(
        (toggle) => toggle.setValue(rule.active).onChange(async (value) => {
          rule.active = value;
          await this.plugin.saveSettings();
        })
      );
    }
    if (useRuleOption(ruleFn, "modifyOnly")) {
      new import_obsidian13.Setting(optionEL).setName("Modify only").setDesc("Only modify existing properties").addToggle((toggle) => toggle.setValue(rule.onlyModify).onChange(async (value) => {
        rule.onlyModify = value;
        await this.plugin.saveSettings();
        this.updatePreview(rule, previewComponent);
      }));
    }
    if (rule.type === "text" || rule.type === "multitext" || rule.type === "tags" || rule.type === "aliases") {
      if (useRuleOption(ruleFn, "inputProperty")) {
        const ruleFunction2 = ruleFunctions.find((item) => item.id === rule.content);
        if (ruleFunction2 && ruleFunction2.inputProperty !== void 0) {
          let inputPropertiesDropdown;
          new import_obsidian13.Setting(optionEL).setName("Input Property").setDesc("Select a property as input").addDropdown((dropdown) => {
            inputPropertiesDropdown = dropdown;
            dropdown.setValue(rule.addContent).onChange(async (value) => {
              if (value !== "") {
                rule.inputProperty = value;
                await this.plugin.saveSettings();
                this.updatePreview(rule, previewComponent);
              }
            });
          });
          Object.entries(this.knownProperties).forEach((item) => {
            inputPropertiesDropdown.addOption(item[1].name, item[1].name);
          });
          inputPropertiesDropdown.setValue(rule.inputProperty);
        }
      }
      if (useRuleOption(ruleFn, "addPrefix")) {
        if (rule.type === "tags" || rule.type === "aliases") {
          new import_obsidian13.Setting(optionEL).setName("Prefix").setDesc('Optional prefix to add before the content (i.e. "prefix/")').addText((text) => text.setPlaceholder("no prefix").setValue(rule.prefix).onChange(async (value) => {
            rule.prefix = value;
            await this.plugin.saveSettings();
            this.updatePreview(rule, previewComponent);
          }));
        }
      }
      if (useRuleOption(ruleFn, "spaceReplacement")) {
        new import_obsidian13.Setting(optionEL).setName("Space replacement").setDesc('Character to replace spaces in folder names (suggested: "_")').addText((text) => text.setPlaceholder("no replacement").setValue(rule.spaceReplacement).onChange(async (value) => {
          rule.spaceReplacement = value;
          await this.plugin.saveSettings();
          this.updatePreview(rule, previewComponent);
        }));
      }
      if (useRuleOption(ruleFn, "specialCharacterReplacement")) {
        new import_obsidian13.Setting(optionEL).setName("Special character replacement").setDesc('Character to replace special characters (suggested: "-") - preserves letters with diacritics').addText((text) => text.setPlaceholder("no replacement").setValue(rule.specialCharReplacement).onChange(async (value) => {
          rule.specialCharReplacement = value;
          await this.plugin.saveSettings();
          this.updatePreview(rule, previewComponent);
        }));
      }
      if (useRuleOption(ruleFn, "convertToLowerCase")) {
        new import_obsidian13.Setting(optionEL).setName("Convert to lowercase").setDesc("Convert values to lowercase").addToggle((toggle) => toggle.setValue(rule.lowercaseTags).onChange(async (value) => {
          rule.lowercaseTags = value;
          await this.plugin.saveSettings();
          this.updatePreview(rule, previewComponent);
        }));
      }
      if (useRuleOption(ruleFn, "resultAsLink")) {
        new import_obsidian13.Setting(optionEL).setName("Result as Link").setDesc("Format Result as Link").addToggle(
          (toggle) => toggle.setValue(rule.asLink).onChange(async (value) => {
            rule.asLink = value;
            await this.plugin.saveSettings();
            this.updatePreview(rule, previewComponent);
          })
        );
      }
    }
    if (rule.type === "text" || rule.type === "multitext" || rule.type === "tags" || rule.type === "aliases") {
      if (useRuleOption(ruleFn, "addContent")) {
        new import_obsidian13.Setting(optionEL).setName("Add content").setDesc("select how the content should be stored").addDropdown(
          (dropdown) => dropdown.addOption("overwrite", "replace content").addOption("start", "place on start").addOption("end", "place on end").setValue(rule.addContent).onChange(async (value) => {
            if (value !== "") {
              rule.addContent = value === "overwrite" ? "overwrite" : value === "start" ? "start" : "end";
              await this.plugin.saveSettings();
              this.updatePreview(rule, previewComponent);
            }
          })
        );
      }
    }
    if (useRuleOption(ruleFn, "excludeFolders")) {
      const excludeEL = new import_obsidian13.Setting(optionEL).setName("Exclude Files and Folders from this rule").setDesc(`Currently ${((_a = rule.exclude) == null ? void 0 : _a.selectedFolders.length) || 0} folders and ${((_b = rule.exclude) == null ? void 0 : _b.selectedFiles.length) || 0} files will be ${((_c = rule.exclude) == null ? void 0 : _c.mode) || "exclude"}d.`).addButton((button) => {
        button.setIcon("folder-x").setButtonText("Exclude").setCta().onClick(() => {
          var _a2, _b2, _c2;
          openDirectorySelectionModal(
            this.app,
            ((_a2 = rule.exclude) == null ? void 0 : _a2.selectedFolders) || [],
            ((_b2 = rule.exclude) == null ? void 0 : _b2.selectedFiles) || [],
            {
              selectionMode: "exclude",
              displayMode: ((_c2 = rule.exclude) == null ? void 0 : _c2.display) || "folders",
              optionSelectionMode: false,
              optionShowFiles: true
            },
            (result) => {
              var _a3, _b3, _c3;
              if (!result)
                return;
              if (!rule.exclude) {
                rule.exclude = Object.assign({}, DEFAULT_FILTER_FILES_AND_FOLDERS, {
                  mode: "exclude"
                });
              }
              ;
              rule.exclude.selectedFolders = result.folders;
              rule.exclude.selectedFiles = result.files;
              rule.exclude.mode = "exclude";
              rule.exclude.display = result.display;
              this.plugin.saveSettings();
              console.log(rule.exclude);
              this.updateFilterIndicator(this.activeFile, this.propertiesListEl);
              excludeEL.setDesc(`Currently ${((_a3 = rule.exclude) == null ? void 0 : _a3.selectedFolders.length) || 0} folders and ${((_b3 = rule.exclude) == null ? void 0 : _b3.selectedFiles.length) || 0} files will be ${((_c3 = rule.exclude) == null ? void 0 : _c3.mode) || "exclude"}d.`);
            }
          );
        });
      });
    }
    if (useRuleOption(ruleFn, "includeFolders")) {
      const includeEL = new import_obsidian13.Setting(optionEL).setName("Include Files and Folders for this rule ").setDesc(`Currently ${((_d = rule.include) == null ? void 0 : _d.selectedFolders.length) || 0} folders and ${((_e = rule.include) == null ? void 0 : _e.selectedFiles.length) || 0} files will be ${((_f = rule.include) == null ? void 0 : _f.mode) || "include"}d even if they are excluded globally.`).addButton((button) => {
        button.setIcon("folder-check").setButtonText("Include").setCta().onClick(() => {
          var _a2, _b2, _c2;
          openDirectorySelectionModal(
            this.app,
            ((_a2 = rule.include) == null ? void 0 : _a2.selectedFolders) || [],
            ((_b2 = rule.include) == null ? void 0 : _b2.selectedFiles) || [],
            {
              selectionMode: "include",
              displayMode: ((_c2 = rule.include) == null ? void 0 : _c2.display) || "folders",
              optionSelectionMode: false,
              optionShowFiles: true
            },
            (result) => {
              var _a3, _b3, _c3;
              if (!result)
                return;
              if (!rule.include) {
                rule.include = Object.assign({}, DEFAULT_FILTER_FILES_AND_FOLDERS, {
                  mode: "include"
                });
              }
              ;
              rule.include.selectedFolders = result.folders;
              rule.include.selectedFiles = result.files;
              rule.include.mode = "include";
              rule.include.display = result.display;
              this.plugin.saveSettings();
              console.log(rule.include);
              this.updateFilterIndicator(this.activeFile, this.propertiesListEl);
              includeEL.setDesc(`Currently ${((_a3 = rule.include) == null ? void 0 : _a3.selectedFolders.length) || 0} folders and ${((_b3 = rule.include) == null ? void 0 : _b3.selectedFiles.length) || 0} files will be ${((_c3 = rule.include) == null ? void 0 : _c3.mode) || "include"}d.`);
            }
          );
        });
      });
    }
    if (useRuleOption(ruleFn, "script")) {
      new import_obsidian13.Setting(optionEL).setName("Script").setDesc("edit the script for own modifications").addButton((button) => {
        button.setButtonText("JS Editor").onClick(() => {
          var _a2, _b2;
          openCodeEditorModal(
            this.app,
            this.plugin,
            rule.content === "script" ? rule.jsCode : rule.buildInCode,
            ((_a2 = rule.typeProperty) == null ? void 0 : _a2.type) || "text",
            this.activeFile,
            this.activeFile ? ((_b2 = this.app.metadataCache.getFileCache(this.activeFile)) == null ? void 0 : _b2.frontmatter) || {} : {},
            (result) => {
              if (!result)
                return;
              if (rule.content === "script") {
                rule.jsCode = result.code;
                rule.useCustomCode = false;
              } else {
                rule.buildInCode = result.code;
                rule.useCustomCode = true;
                button.setCta();
              }
              this.plugin.saveSettings();
              this.updatePreview(rule, previewComponent);
            }
          );
        });
        if (rule.useCustomCode) {
          button.setCta();
        } else {
          button.removeCta();
        }
      });
    }
    const ruleFunction = getRuleFunctionById(rule.content);
    if (ruleFunction && typeof ruleFunction.configTab === "function") {
      ruleFunction.configTab(optionEL, rule, this, previewComponent);
    }
  }
  getOptionConfig(ruleId, propertyId) {
    const rule = this.plugin.settings.rules.find((rule2) => rule2.id === ruleId);
    if (rule) {
      const optionConfig = rule.optionsConfig[ruleId];
      if (optionConfig[propertyId]) {
        return optionConfig[propertyId];
      }
    }
    return void 0;
  }
  setOptionConfig(ruleId, propertyId, config) {
    const rule = this.plugin.settings.rules.find((rule2) => rule2.id === ruleId);
    if (rule) {
      if (!rule.optionsConfig)
        rule.optionsConfig = {};
      if (!rule.optionsConfig[ruleId])
        rule.optionsConfig[ruleId] = {};
      rule.optionsConfig[ruleId][propertyId] = config;
      this.plugin.saveSettings();
    }
  }
  setOptionConfigDefaults(ruleId, defaults) {
    const rule = this.plugin.settings.rules.find((rule2) => rule2.id === ruleId);
    if (rule) {
      if (!rule.optionsConfig)
        rule.optionsConfig = {};
      rule.optionsConfig[ruleId] = Object.assign({}, defaults, rule.optionsConfig[ruleId] || {});
    }
    return rule.optionsConfig[ruleId];
  }
  renderSearchResults(searchContainerEl, searchTerm, rowIndex) {
    this.clearSearchResults(searchContainerEl);
    const filteredProperties = Object.entries(this.knownProperties).filter(([name]) => name.toLowerCase().includes(searchTerm.toLowerCase()));
    if (filteredProperties.length === 0 && searchTerm) {
      return;
    }
    if (filteredProperties.length === 0 && !searchTerm) {
      return;
    }
    const resultsEl = searchContainerEl.createDiv({ cls: "property-search-results menu" });
    resultsEl.style.position = "absolute";
    resultsEl.style.top = "100%";
    resultsEl.style.left = "0";
    resultsEl.style.width = "calc(100% + 100px)";
    resultsEl.style.zIndex = "10";
    resultsEl.style.maxHeight = "200px";
    resultsEl.style.overflowY = "auto";
    let activeIndex = -1;
    const updateActiveItem = (newIndex) => {
      const items = resultsEl.querySelectorAll(".menu-item");
      items.forEach((item, index) => {
        if (index === newIndex) {
          item.addClass("property-search-is-active");
          item.scrollIntoView({ block: "nearest" });
        } else {
          item.removeClass("property-search-is-active");
        }
      });
      activeIndex = newIndex;
    };
    const selectActiveItem = async () => {
      if (activeIndex >= 0 && activeIndex < filteredProperties.length) {
        const [name, info] = filteredProperties[activeIndex];
        this.plugin.settings[this.settingsParameter][rowIndex].property = name;
        this.plugin.settings[this.settingsParameter][rowIndex].type = info.type;
        this.plugin.settings[this.settingsParameter][rowIndex].value = void 0;
        await this.plugin.saveSettings();
        this.clearSearchResults(searchContainerEl);
        this.display();
      }
    };
    filteredProperties.forEach(([name, info], index) => {
      const itemEl = resultsEl.createDiv({ cls: "menu-item" });
      const itemIcon = itemEl.createSpan({ cls: "menu-item-icon" });
      updatePropertyIcon(itemIcon, info.type);
      itemEl.createSpan({ text: name });
      itemEl.addEventListener("mousedown", async (e) => {
        e.preventDefault();
        activeIndex = index;
        await selectActiveItem();
      });
    });
    searchContainerEl.addEventListener("keydown", async (e) => {
      const items = resultsEl.querySelectorAll(".menu-item");
      if (e.key === "ArrowDown") {
        e.preventDefault();
        updateActiveItem((activeIndex + 1) % items.length);
      } else if (e.key === "ArrowUp") {
        e.preventDefault();
        updateActiveItem((activeIndex - 1 + items.length) % items.length);
      } else if (e.key === "Enter") {
        e.preventDefault();
        await selectActiveItem();
      }
    });
  }
  clearSearchResults(searchContainerEl) {
    const resultsEl = searchContainerEl.querySelector(".property-search-results");
    if (resultsEl) {
      resultsEl.remove();
    }
  }
  renderValueInput(containerEl, propertyInfo, currentValue, index) {
    let returnComponent;
    containerEl.empty();
    if (!propertyInfo) {
      containerEl.setText("");
      containerEl.addClass("text-muted");
      return;
    }
    const type = propertyInfo.type;
    switch (type) {
      case "number":
        returnComponent = new import_obsidian13.TextComponent(containerEl).setPlaceholder("Numeric Value").setValue(currentValue !== void 0 && currentValue !== null ? String(currentValue) : "").onChange(async (value) => {
          const numValue = value === "" ? void 0 : parseFloat(value);
          this.plugin.settings[this.settingsParameter][index].value = isNaN(numValue) ? void 0 : numValue;
          await this.plugin.saveSettings();
        });
        returnComponent.inputEl.type = "number";
        break;
      case "checkbox":
        returnComponent = containerEl.createDiv({ cls: "tri-state-checkbox clickable-icon" });
        returnComponent.setAttribute("aria-label", "Checkbox change state");
        returnComponent.setAttribute("role", "checkbox");
        const updateCheckboxVisual = (state) => {
          let iconName;
          let ariaState;
          if (state === true) {
            iconName = "check-square";
            ariaState = "true";
          } else if (state === false) {
            iconName = "square";
            ariaState = "false";
          } else {
            iconName = "minus-square";
            ariaState = "mixed";
          }
          (0, import_obsidian13.setIcon)(returnComponent, iconName);
          returnComponent.setAttribute("aria-checked", ariaState);
          returnComponent.dataset.state = String(state);
        };
        updateCheckboxVisual(currentValue);
        returnComponent.addEventListener("click", async () => {
          let currentState = returnComponent.dataset.state;
          let nextState;
          if (currentState === "false") {
            nextState = true;
          } else if (currentState === "true") {
            nextState = void 0;
          } else {
            nextState = false;
          }
          this.plugin.settings[this.settingsParameter][index].value = nextState;
          await this.plugin.saveSettings();
          updateCheckboxVisual(nextState);
        });
        break;
      case "date":
        returnComponent = new import_obsidian13.TextComponent(containerEl).setPlaceholder("YYYY-MM-DD").setValue(currentValue || "").onChange(async (value) => {
          this.plugin.settings[this.settingsParameter][index].value = value || void 0;
          await this.plugin.saveSettings();
        });
        returnComponent.inputEl.type = "date";
        break;
      case "datetime":
        returnComponent = new import_obsidian13.TextComponent(containerEl).setPlaceholder("YYYY-MM-DDTHH:mm").setValue(currentValue || "").onChange(async (value) => {
          this.plugin.settings[this.settingsParameter][index].value = value || void 0;
          await this.plugin.saveSettings();
        });
        returnComponent.inputEl.type = "datetime-local";
        break;
      case "aliases":
      case "tags":
      case "multitext":
        returnComponent = new import_obsidian13.TextComponent(containerEl).setPlaceholder("values (divided by comma)").setValue(Array.isArray(currentValue) ? currentValue.join(", ") : currentValue || "").onChange(async (value) => {
          const arrayValue = value.split(",").map((s) => s.trim()).filter((s) => s);
          this.plugin.settings[this.settingsParameter][index].value = arrayValue.length > 0 ? arrayValue : void 0;
          await this.plugin.saveSettings();
        });
        break;
      case "text":
      default:
        returnComponent = new import_obsidian13.TextComponent(containerEl).setPlaceholder("value").setValue(currentValue || "").onChange(async (value) => {
          this.plugin.settings[this.settingsParameter][index].value = value || void 0;
          await this.plugin.saveSettings();
        });
        break;
    }
    if (type !== "checkbox") {
      returnComponent.inputEl.style.backgroundColor = "transparent";
      returnComponent.inputEl.style.width = "100%";
      returnComponent.inputEl.style.border = "none";
    }
    return returnComponent;
  }
  async updatePreview(rule, previewComponent) {
    if (this.activeFile) {
      let ruleResult;
      await this.app.fileManager.processFrontMatter(this.activeFile, async (frontmatter) => {
        ruleResult = await executeRule("preview", this.app, this.plugin.settings, this.activeFile, "", rule, frontmatter);
      }, { "mtime": this.activeFile.stat.mtime });
      switch (typeof ruleResult) {
        case "object":
          if (Array.isArray(ruleResult))
            previewComponent.inputEl.value = ruleResult.toString();
          break;
        default:
          previewComponent.inputEl.value = ruleResult;
          break;
      }
    }
  }
  async display() {
    const containerEl = this.container;
    containerEl.empty();
    this.knownProperties = await this.tools.fetchKnownProperties(this.app);
    this.propertiesListEl = containerEl.createDiv("properties-list");
    this.plugin.settings.rules.forEach((rule, index) => {
      this.renderPropertyRow(this.propertiesListEl, rule, index);
    });
    let activeFile = this.app.workspace.getActiveFile();
    this.updateFilterIndicator(activeFile, this.propertiesListEl);
    const addBtnContainer = containerEl.createDiv({ cls: "setting-item-control" });
    addBtnContainer.style.justifyContent = "right";
    new import_obsidian13.ButtonComponent(addBtnContainer).setButtonText("Add Property").setIcon("plus-circle").setCta().onClick(async () => {
      const defaultName = "";
      this.plugin.settings[this.settingsParameter].push(Object.assign({}, DEFAULT_RULE_DEFINITION, {
        id: (0, import_crypto.randomUUID)().toString()
      }));
      await this.plugin.saveSettings();
      this.display();
    }).buttonEl.className = "property-plus-button";
  }
  updateFilterIndicator(activeFile, propertiesListEl) {
    if (activeFile) {
      this.plugin.settings.rules.forEach((rule, index) => {
        const propertyRowEl = propertiesListEl.getElementsByClassName("property-setting-row")[index];
        const propertyLeftDiv = propertyRowEl.querySelector(".property-left-container");
        if (checkIfFileAllowed(activeFile, this.plugin.settings, rule)) {
          propertyLeftDiv == null ? void 0 : propertyLeftDiv.addClass("property-left-container-allowed");
        } else {
          propertyLeftDiv == null ? void 0 : propertyLeftDiv.removeClass("property-left-container-allowed");
        }
      });
    }
  }
};

// src/settings.ts
var FolderTagSettingTab = class extends import_obsidian14.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.scriptingTools = new ScriptingTools(app, plugin);
  }
  hide() {
    this.plugin.settings.liveRules = [];
    this.plugin.settings.rules.forEach((rule) => {
      let ruleFunction = getRuleFunctionById(rule.content);
      if (!ruleFunction)
        return;
      if (ruleFunction.isLiveRule) {
        this.plugin.settings.liveRules.push(rule);
      }
    });
    this.plugin.saveSettings();
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile && activeFile.extension === "md") {
      this.plugin.updateFrontmatterParameters("active-leaf-change", activeFile, this.plugin.settings.rules);
    }
  }
  display() {
    this.knownProperties = getPropertiesFromMetadataManager(this.app);
    this.knownTypes = getTypesFromMetadataManager(this.app);
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: `Front matter automate V${versionString}` });
    new import_obsidian14.Setting(containerEl).setName("Exclude Files and Folders globally").setDesc(`Currently ${this.plugin.settings.exclude.selectedFolders.length} folders and ${this.plugin.settings.exclude.selectedFiles.length} files will be ${this.plugin.settings.exclude.mode}d.`).addButton((button) => {
      button.setIcon("folder-x").setButtonText("Exclude").setCta().onClick(() => {
        openDirectorySelectionModal(
          this.app,
          this.plugin.settings.exclude.selectedFolders || [],
          this.plugin.settings.exclude.selectedFiles || [],
          {
            selectionMode: this.plugin.settings.exclude.mode || "exclude",
            displayMode: this.plugin.settings.exclude.display || "folders",
            optionSelectionMode: false,
            optionShowFiles: true
          },
          (result) => {
            if (!result)
              return;
            this.plugin.settings.exclude.selectedFolders = result.folders;
            this.plugin.settings.exclude.selectedFiles = result.files;
            this.plugin.settings.exclude.mode = result.mode;
            this.plugin.settings.exclude.display = result.display;
            this.plugin.saveSettings();
            this.display();
          }
        );
      });
    });
    new import_obsidian14.Setting(containerEl).setName("Include Files and Folders globally").setDesc(`Currently ${this.plugin.settings.include.selectedFolders.length} folders and ${this.plugin.settings.include.selectedFiles.length} files will be ${this.plugin.settings.include.mode}d even if they are excluded.`).addButton((button) => {
      button.setIcon("folder-check").setButtonText("Include").setCta().onClick(() => {
        openDirectorySelectionModal(
          this.app,
          this.plugin.settings.include.selectedFolders || [],
          this.plugin.settings.include.selectedFiles || [],
          {
            selectionMode: this.plugin.settings.include.mode || "include",
            displayMode: this.plugin.settings.include.display || "folders",
            optionSelectionMode: false,
            optionShowFiles: true
          },
          (result) => {
            if (!result)
              return;
            this.plugin.settings.include.selectedFolders = result.folders;
            this.plugin.settings.include.selectedFiles = result.files;
            this.plugin.settings.include.mode = result.mode;
            this.plugin.settings.include.display = result.display;
            this.plugin.saveSettings();
            this.display();
          }
        );
      });
    });
    new import_obsidian14.Setting(containerEl).setName("Rules").setDesc("add rules to update selected parameters");
    this.rulesContainer = containerEl.createDiv("properties-list");
    const rulesTable = new RulesTable(this.app, this.plugin, this.rulesContainer, "rules");
    rulesTable.display();
  }
};

// main.ts
var FolderTagPlugin = class extends import_obsidian15.Plugin {
  //private oldFolderPaths = new Map<string, string | null>();
  async onload() {
    await this.loadSettings();
    this.tools = new ScriptingTools(this.app, this);
    ;
    let noticeMessage = `Front Matter Automate ${versionString}
 loading ...`;
    const loadingNotice = new import_obsidian15.Notice(noticeMessage, 0);
    noticeMessage = noticeMessage + "\n register events ...";
    loadingNotice.setMessage(noticeMessage);
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (file instanceof import_obsidian15.TFile && file.extension === "md") {
          console.log(`creating file: `, file.path);
          this.updateFrontmatterParameters("create", file, this.settings.rules);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => {
        if (file instanceof import_obsidian15.TFile && file.extension === "md") {
          console.log(`renaming file: `, file.path);
          this.updateFrontmatterParameters("rename", file, this.settings.rules, oldPath);
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", (leaf) => {
        if ((leaf == null ? void 0 : leaf.view) instanceof import_obsidian15.MarkdownView) {
          const activeFile = this.app.workspace.getActiveFile();
          console.log(`active-leaf-change file: `, activeFile == null ? void 0 : activeFile.path);
          if (activeFile)
            this.updateFrontmatterParameters("active-leaf-change", activeFile, this.settings.rules);
        }
      })
    );
    this.registerEvent(
      this.app.metadataCache.on("changed", async (file, data, cache) => {
        if (!checkIfFileAllowed(file, this.settings)) {
          console.log(`file ${file.path} globally rejected!`);
          return;
        }
        if (cache.frontmatter && Array.isArray(this.settings.liveRules) && this.settings.liveRules.length > 0) {
          console.log(`Event metadata changed: ${file.path} ${this.settings.liveRules.length} rules live`);
          this.app.fileManager.processFrontMatter(file, async (frontmatter) => {
            for (const rule of this.settings.liveRules) {
              if (checkIfFileAllowed(file, this.settings, rule)) {
                let result;
                if (rule.onlyModify && !frontmatter.hasOwnProperty(rule.property))
                  return;
                if (frontmatter) {
                  result = await executeRule("modify", this.app, this.settings, file, frontmatter[rule.property], rule, frontmatter);
                  if (result)
                    frontmatter[rule.property] = result;
                }
              } else {
                console.log(`file ${file.path} rejected ny rule ${rule.content}!`);
              }
            }
            console.log(`${this.settings.liveRules.length} rules updated metadata: `, frontmatter);
          }, { "mtime": file.stat.mtime });
        }
        ;
      })
    );
    noticeMessage = noticeMessage + "\n initial processing ...";
    loadingNotice.setMessage(noticeMessage);
    this.settings.liveRules = [];
    this.settings.rules.forEach((rule) => {
      let ruleFunction = getRuleFunctionById(rule.content);
      if (!ruleFunction)
        return;
      switch (ruleFunction.ruleType) {
        case "autocomplete.modal":
        case "buildIn.inputProperty":
        case "automation":
          this.settings.liveRules.push(rule);
          break;
      }
    });
    noticeMessage = noticeMessage + "\ndone!";
    loadingNotice.setMessage(noticeMessage);
    setTimeout(() => {
      loadingNotice.hide();
    }, 2e3);
    this.addSettingTab(new FolderTagSettingTab(this.app, this));
  }
  async loadSettings() {
    let data = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, data);
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  formatTagName(name) {
    if (name === null)
      return null;
    if (name === void 0)
      return void 0;
    let formatted = name.replace(/\s+/g, this.settings.spaceReplacement);
    formatted = formatted.replace(/[^a-zA-Z0-9\-_\/]/g, this.settings.specialCharReplacement);
    if (this.settings.lowercaseTags) {
      formatted = formatted.toLowerCase();
    }
    return formatted;
  }
  formatValue(value, type) {
    switch (type) {
      case "text":
      case "tags":
      case "aliases":
      case "multitext":
        return this.tools.toYamlSafeString(value);
      case "date":
      case "datetime":
        if (typeof value === "number") {
          return new Date(value).toISOString();
        }
        return value.toString();
      case "checkbox":
        return value ? "true" : "false";
      case "number":
        return Number(value);
      default:
        return this.tools.toYamlSafeString(value);
    }
  }
  updateFrontmatterParameters(eventName, file, rules, oldPath) {
    if (!checkIfFileAllowed(file, this.settings)) {
      console.log(`file ${file.path} globally rejected!`);
      return;
    }
    const currentPathTag = this.formatTagName(this.tools.getFolderFromPath(file.path));
    const oldPathTag = this.formatTagName(this.tools.getFolderFromPath(oldPath));
    this.app.fileManager.processFrontMatter(file, (frontmatter) => {
      var _a;
      console.log(`Event start ${eventName}: ${file.path} ${rules.length} rules`, frontmatter);
      for (let rule of rules) {
        let result = frontmatter[rule.property];
        if (!checkIfFileAllowed(file, this.settings, rule)) {
          console.log(`file ${file.path} rejected by rule (${rule.property}|${rule.content}) settings`);
          continue;
        }
        if (rule.onlyModify && !frontmatter.hasOwnProperty(rule.property)) {
          console.log(`file ${file.path} has not ${rule.property}(${rule.content}) onlyModify`);
          continue;
        }
        switch ((_a = this.tools.getRuleFunction(rule)) == null ? void 0 : _a.ruleType) {
          case "buildIn":
          case "script":
            result = executeRule(eventName, this.app, this.settings, file, frontmatter[rule.property], rule, frontmatter, oldPath);
            break;
          default:
        }
        frontmatter[rule.property] = result;
      }
      console.log("Frontmatter updated", frontmatter);
    }, { "mtime": file.stat.mtime });
  }
  async removeFrontmatterParamsFromAllFiles(rule) {
    let count = { files: 0, items: 0 };
    this.app.vault.getMarkdownFiles().forEach((file) => {
      count.files++;
      this.removeFrontmatterParameter(file, rule, count);
    });
    return count;
  }
  async removeFrontmatterParameter(file, rule, count) {
    if (!checkIfFileAllowed(file, this.settings, rule))
      return;
    const currentPathTag = this.formatTagName(this.tools.getFolderFromPath(file.path));
    let content = await this.app.vault.read(file);
    this.app.fileManager.processFrontMatter(file, (frontmatter) => {
      if (Array.isArray(frontmatter[rule.property]))
        count.items += frontmatter[rule.property].length;
      frontmatter[rule.property] = removeRule(this.app, this.settings, file, frontmatter[rule.property], rule, frontmatter);
      if (Array.isArray(frontmatter[rule.property]))
        count.items -= frontmatter[rule.property].length;
    }, { "mtime": file.stat.mtime });
    return count;
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJzcmMvc2V0dGluZ3MudHMiLCAic3JjL2Zyb250bWF0dGVyLXRvb2xzLnRzIiwgInNyYy90b29scy50cyIsICJzcmMvTG9nLnRzIiwgInNyYy9FcnJvci50cyIsICJzcmMvYWxlcnRCb3gudHMiLCAic3JjL3J1bGVzLnRzIiwgInNyYy9hdXRvY29tcGxldGVNb2RhbC50cyIsICJzcmMvdWlFbGVtZW50cy50cyIsICJzcmMvc3VnZ2VzdGVycy9Gb2xkZXJTdWdnZXN0ZXIudHMiLCAic3JjL3N1Z2dlc3RlcnMvc3VnZ2VzdC50cyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2VudW1zLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvdy5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21hdGguanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy91c2VyQWdlbnQuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNMYXlvdXRWaWV3cG9ydC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9jb250YWlucy5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzVGFibGVFbGVtZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRQYXJlbnROb2RlLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3dpdGhpbi5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcnJvdy5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldFZhcmlhdGlvbi5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGwuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsQmFyWC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRWaWV3cG9ydFJlY3QuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRSZWN0LmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzU2Nyb2xsUGFyZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFNjcm9sbFBhcmVudC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZU9mZnNldHMuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZXRlY3RPdmVyZmxvdy5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2ZsaXAuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaGlkZS5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9vZmZzZXQuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEFsdEF4aXMuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVTY3JvbGwuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGVib3VuY2UuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZUJ5TmFtZS5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2NyZWF0ZVBvcHBlci5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3BvcHBlci5qcyIsICJzcmMvc3VnZ2VzdGVycy9GaWxlU3VnZ2VzdGVyLnRzIiwgInNyYy9kaXJlY3RvcnlTZWxlY3Rpb25Nb2RhbC50cyIsICJzcmMvdHlwZXMudHMiLCAic3JjL3NldHRpbmdzLXByb3BlcnRpZXMudHMiLCAic3JjL2VkaXRvck1vZGFsLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBBcHAsIEVkaXRvciwgUGx1Z2luLCBNYXJrZG93blZpZXcsIE1hcmtkb3duUG9zdFByb2Nlc3NvciwgUGx1Z2luTWFuaWZlc3QsIFRGaWxlLCBURm9sZGVyLCBWYXVsdCwgcGFyc2VGcm9udE1hdHRlclRhZ3MsIE5vdGljZX0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgRm9sZGVyVGFnU2V0dGluZ1RhYiB9IGZyb20gJy4vc3JjL3NldHRpbmdzJztcbi8vaW1wb3J0IHsgRm9sZGVyVGFnU2V0dGluZ1RhYiB9IGZyb20gJy4vc3JjL3NldHRpbmdzLXByb3BlcnRpZXMnO1xuaW1wb3J0IHsgY2hlY2tJZkZpbGVBbGxvd2VkLCBleGVjdXRlUnVsZSwgZ2V0UnVsZUZ1bmN0aW9uQnlJZCwgcmVtb3ZlUnVsZSwgcnVsZUZ1bmN0aW9ucyB9IGZyb20gJy4vc3JjL3J1bGVzJztcbmltcG9ydCB7IHBhcnNlSlNDb2RlLCBTY3JpcHRpbmdUb29scyB9IGZyb20gJy4vc3JjL3Rvb2xzJztcbmltcG9ydCB7IHZlcnNpb25TdHJpbmcsIEZvbGRlclRhZ1NldHRpbmdzLCBERUZBVUxUX1NFVFRJTkdTLCBGb2xkZXJUYWdSdWxlRGVmaW5pdGlvbiwgUHJvcGVydHlUeXBlSW5mb30gZnJvbSAnLi9zcmMvdHlwZXMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZvbGRlclRhZ1BsdWdpbiBleHRlbmRzIFBsdWdpbiB7XG4gICAgc2V0dGluZ3M6IEZvbGRlclRhZ1NldHRpbmdzO1xuICAgIHByaXZhdGUgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzO1xuICAgIC8vcHJpdmF0ZSBvbGRGb2xkZXJQYXRocyA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmcgfCBudWxsPigpO1xuXG4gICAgYXN5bmMgb25sb2FkKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuICAgICAgICB0aGlzLnRvb2xzID0gbmV3IFNjcmlwdGluZ1Rvb2xzKHRoaXMuYXBwLCB0aGlzKTs7XG4gICAgICAgIGxldCBub3RpY2VNZXNzYWdlID0gYEZyb250IE1hdHRlciBBdXRvbWF0ZSAke3ZlcnNpb25TdHJpbmd9XFxuIGxvYWRpbmcgLi4uYDtcbiAgICAgICAgY29uc3QgbG9hZGluZ05vdGljZSA9IG5ldyBOb3RpY2Uobm90aWNlTWVzc2FnZSwwKVxuXG4gICAgICAgIG5vdGljZU1lc3NhZ2UgPSBub3RpY2VNZXNzYWdlICsgJ1xcbiByZWdpc3RlciBldmVudHMgLi4uJztcbiAgICAgICAgbG9hZGluZ05vdGljZS5zZXRNZXNzYWdlKG5vdGljZU1lc3NhZ2UpO1xuICAgICAgICAvLyBGaWxlIGNyZWF0aW9uIGhhbmRsZXJcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KFxuICAgICAgICAgICAgdGhpcy5hcHAudmF1bHQub24oJ2NyZWF0ZScsIChmaWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBURmlsZSAmJiBmaWxlLmV4dGVuc2lvbiA9PT0gJ21kJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgY3JlYXRpbmcgZmlsZTogYCwgZmlsZS5wYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVGcm9udG1hdHRlclBhcmFtZXRlcnMoJ2NyZWF0ZScsIGZpbGUsIHRoaXMuc2V0dGluZ3MucnVsZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gRmlsZSByZW5hbWUvbW92ZSBoYW5kbGVyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJFdmVudChcbiAgICAgICAgICAgIHRoaXMuYXBwLnZhdWx0Lm9uKCdyZW5hbWUnLCAoZmlsZSwgb2xkUGF0aCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmaWxlIGluc3RhbmNlb2YgVEZpbGUgJiYgZmlsZS5leHRlbnNpb24gPT09ICdtZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYHJlbmFtaW5nIGZpbGU6IGAsIGZpbGUucGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRnJvbnRtYXR0ZXJQYXJhbWV0ZXJzKCdyZW5hbWUnLCBmaWxlLCB0aGlzLnNldHRpbmdzLnJ1bGVzLCBvbGRQYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEZpbGUgY2xvc2UgaGFuZGxlclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRXZlbnQoXG4gICAgICAgICAgICB0aGlzLmFwcC53b3Jrc3BhY2Uub24oJ2FjdGl2ZS1sZWFmLWNoYW5nZScsIChsZWFmKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGxlYWY/LnZpZXcgaW5zdGFuY2VvZiBNYXJrZG93blZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWN0aXZlRmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBhY3RpdmUtbGVhZi1jaGFuZ2UgZmlsZTogYCwgYWN0aXZlRmlsZT8ucGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmVGaWxlKSB0aGlzLnVwZGF0ZUZyb250bWF0dGVyUGFyYW1ldGVycygnYWN0aXZlLWxlYWYtY2hhbmdlJywgYWN0aXZlRmlsZSwgdGhpcy5zZXR0aW5ncy5ydWxlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBNZXRhZGF0YSBjaGFuZ2VkIGhhbmRsZXJcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KFxuICAgICAgICAgICAgdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5vbignY2hhbmdlZCcsIGFzeW5jIChmaWxlLCBkYXRhLCBjYWNoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghY2hlY2tJZkZpbGVBbGxvd2VkKGZpbGUsIHRoaXMuc2V0dGluZ3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBmaWxlICR7ZmlsZS5wYXRofSBnbG9iYWxseSByZWplY3RlZCFgKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjYWNoZS5mcm9udG1hdHRlciAmJiBBcnJheS5pc0FycmF5KHRoaXMuc2V0dGluZ3MubGl2ZVJ1bGVzKSAmJiB0aGlzLnNldHRpbmdzLmxpdmVSdWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFdmVudCBtZXRhZGF0YSBjaGFuZ2VkOiAke2ZpbGUucGF0aH0gJHt0aGlzLnNldHRpbmdzLmxpdmVSdWxlcy5sZW5ndGh9IHJ1bGVzIGxpdmVgKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHAuZmlsZU1hbmFnZXIucHJvY2Vzc0Zyb250TWF0dGVyKGZpbGUsIGFzeW5jIChmcm9udG1hdHRlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXBwbHkgYWxsIGxpdmUgcnVsZXMgdG8gZnJvbnRtYXR0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcnVsZSBvZiB0aGlzLnNldHRpbmdzLmxpdmVSdWxlcykgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tJZkZpbGVBbGxvd2VkKGZpbGUsIHRoaXMuc2V0dGluZ3MsIHJ1bGUpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUub25seU1vZGlmeSAmJiAhZnJvbnRtYXR0ZXIuaGFzT3duUHJvcGVydHkocnVsZS5wcm9wZXJ0eSkpIHJldHVybjsgLy8gb25seSBtb2RpZnkgaWYgcHJvcGVydHkgZXhpc3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9udG1hdHRlcikgey8vIGNhY2hlLmZyb250bWF0dGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgZXhlY3V0ZVJ1bGUoJ21vZGlmeScsdGhpcy5hcHAsIHRoaXMuc2V0dGluZ3MsIGZpbGUsIGZyb250bWF0dGVyW3J1bGUucHJvcGVydHldLCBydWxlLCBmcm9udG1hdHRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSBmcm9udG1hdHRlcltydWxlLnByb3BlcnR5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBmaWxlICR7ZmlsZS5wYXRofSByZWplY3RlZCBueSBydWxlICR7cnVsZS5jb250ZW50fSFgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAke3RoaXMuc2V0dGluZ3MubGl2ZVJ1bGVzLmxlbmd0aH0gcnVsZXMgdXBkYXRlZCBtZXRhZGF0YTogYCwgZnJvbnRtYXR0ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9LHsnbXRpbWUnOmZpbGUuc3RhdC5tdGltZX0pOyAvLyBkbyBub3QgY2hhbmdlIHRoZSBtb2RpZnkgdGltZS5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgICAgIFxuICAgICAgICBub3RpY2VNZXNzYWdlID0gbm90aWNlTWVzc2FnZSArICdcXG4gaW5pdGlhbCBwcm9jZXNzaW5nIC4uLic7XG4gICAgICAgIGxvYWRpbmdOb3RpY2Uuc2V0TWVzc2FnZShub3RpY2VNZXNzYWdlKTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5saXZlUnVsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5ydWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xuICAgICAgICAgICAgbGV0IHJ1bGVGdW5jdGlvbiA9IGdldFJ1bGVGdW5jdGlvbkJ5SWQocnVsZS5jb250ZW50KTtcbiAgICAgICAgICAgIGlmICghcnVsZUZ1bmN0aW9uKSByZXR1cm47XG4gICAgICAgICAgICBzd2l0Y2ggKHJ1bGVGdW5jdGlvbi5ydWxlVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2F1dG9jb21wbGV0ZS5tb2RhbCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnYnVpbGRJbi5pbnB1dFByb3BlcnR5JzpcbiAgICAgICAgICAgICAgICBjYXNlICdhdXRvbWF0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5saXZlUnVsZXMucHVzaChydWxlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB9KVxuICAgICAgICBub3RpY2VNZXNzYWdlID0gbm90aWNlTWVzc2FnZSArICdcXG5kb25lISc7XG4gICAgICAgIGxvYWRpbmdOb3RpY2Uuc2V0TWVzc2FnZShub3RpY2VNZXNzYWdlKTtcbiAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgbG9hZGluZ05vdGljZS5oaWRlKCk7XG4gICAgICAgIH0sMjAwMClcblxuICAgICAgICAvLyBBZGQgc2V0dGluZ3MgdGFiXG4gICAgICAgIHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgRm9sZGVyVGFnU2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcykpO1xuICAgIH1cblxuICAgIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBhd2FpdCB0aGlzLmxvYWREYXRhKCk7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBkYXRhKTtcbiAgICB9XG4gICAgXG4gICAgYXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuICAgICAgICBhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZm9ybWF0VGFnTmFtZShuYW1lOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZHtcbiAgICAgICAgaWYgKG5hbWUgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBcbiAgICAgICAgLy8gRmlyc3QgcmVwbGFjZSBzcGFjZXMgYWNjb3JkaW5nIHRvIHNldHRpbmdzXG4gICAgICAgIGxldCBmb3JtYXR0ZWQgPSBuYW1lLnJlcGxhY2UoL1xccysvZywgdGhpcy5zZXR0aW5ncy5zcGFjZVJlcGxhY2VtZW50KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRoZW4gcmVwbGFjZSBzcGVjaWFsIGNoYXJhY3RlcnMgKHByZXNlcnZpbmcgbGV0dGVycyB3aXRoIGRpYWNyaXRpY3MpXG4gICAgICAgIGZvcm1hdHRlZCA9IGZvcm1hdHRlZC5yZXBsYWNlKC9bXmEtekEtWjAtOVxcLV9cXC9cdTAwRTRcdTAwRjZcdTAwRkNcdTAwREZcdTAwQzRcdTAwRDZcdTAwRENcdTAwRTFcdTAwRTlcdTAwRURcdTAwRjNcdTAwRkFcdTAwRkRcdTAwQzFcdTAwQzlcdTAwQ0RcdTAwRDNcdTAwREFcdTAwRERcdTAwRTBcdTAwRThcdTAwRUNcdTAwRjJcdTAwRjlcdTAwQzBcdTAwQzhcdTAwQ0NcdTAwRDJcdTAwRDlcdTAwRTJcdTAwRUFcdTAwRUVcdTAwRjRcdTAwRkJcdTAwQzJcdTAwQ0FcdTAwQ0VcdTAwRDRcdTAwREJcdTAwRTNcdTAwRjFcdTAwRjVcdTAwQzNcdTAwRDFcdTAwRDVdL2csIHRoaXMuc2V0dGluZ3Muc3BlY2lhbENoYXJSZXBsYWNlbWVudCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDb252ZXJ0IHRvIGxvd2VyY2FzZSBpZiBjb25maWd1cmVkXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmxvd2VyY2FzZVRhZ3MpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZCA9IGZvcm1hdHRlZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkO1xuICAgIH1cblxuICAgIGZvcm1hdFZhbHVlKHZhbHVlOmFueSwgdHlwZTpzdHJpbmcpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgIGNhc2UgJ3RhZ3MnOlxuICAgICAgICAgICAgY2FzZSAnYWxpYXNlcyc6XG4gICAgICAgICAgICBjYXNlICdtdWx0aXRleHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvb2xzLnRvWWFtbFNhZmVTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICBjYXNlICdkYXRldGltZSc6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9vbHMudG9ZYW1sU2FmZVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVGcm9udG1hdHRlclBhcmFtZXRlcnMoZXZlbnROYW1lOiAnY3JlYXRlJyB8ICdyZW5hbWUnIHwgJ2FjdGl2ZS1sZWFmLWNoYW5nZScsIGZpbGU6IFRGaWxlLCBydWxlczogRm9sZGVyVGFnUnVsZURlZmluaXRpb25bXSwgb2xkUGF0aD86IHN0cmluZykge1xuICAgICAgICBpZiAoIWNoZWNrSWZGaWxlQWxsb3dlZChmaWxlLCB0aGlzLnNldHRpbmdzKSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYGZpbGUgJHtmaWxlLnBhdGh9IGdsb2JhbGx5IHJlamVjdGVkIWApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFBhdGhUYWcgPSB0aGlzLmZvcm1hdFRhZ05hbWUodGhpcy50b29scy5nZXRGb2xkZXJGcm9tUGF0aChmaWxlLnBhdGgpKTtcbiAgICAgICAgY29uc3Qgb2xkUGF0aFRhZyA9IHRoaXMuZm9ybWF0VGFnTmFtZSh0aGlzLnRvb2xzLmdldEZvbGRlckZyb21QYXRoKG9sZFBhdGgpKVxuXG4gICAgICAgIHRoaXMuYXBwLmZpbGVNYW5hZ2VyLnByb2Nlc3NGcm9udE1hdHRlcihmaWxlLCAoZnJvbnRtYXR0ZXIpID0+IHtcbiAgICAgICAgICAgLy8gYXBwbHkgYWxsIHJ1bGVzIHRvIGZyb250bWF0dGVyXG4gICAgICAgICAgIGNvbnNvbGUubG9nKGBFdmVudCBzdGFydCAke2V2ZW50TmFtZX06ICR7ZmlsZS5wYXRofSAke3J1bGVzLmxlbmd0aH0gcnVsZXNgLGZyb250bWF0dGVyKTtcbiAgICAgICAgICAgIGZvciAobGV0IHJ1bGUgb2YgcnVsZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gZnJvbnRtYXR0ZXJbcnVsZS5wcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgaWYgKCFjaGVja0lmRmlsZUFsbG93ZWQoZmlsZSwgdGhpcy5zZXR0aW5ncywgcnVsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYGZpbGUgJHtmaWxlLnBhdGh9IHJlamVjdGVkIGJ5IHJ1bGUgKCR7cnVsZS5wcm9wZXJ0eX18JHtydWxlLmNvbnRlbnR9KSBzZXR0aW5nc2ApO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gb25seSBtb2RpZnkgaWYgZmlsZSBpcyBhbGxvd2VkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChydWxlLm9ubHlNb2RpZnkgJiYgIWZyb250bWF0dGVyLmhhc093blByb3BlcnR5KHJ1bGUucHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBmaWxlICR7ZmlsZS5wYXRofSBoYXMgbm90ICR7cnVsZS5wcm9wZXJ0eX0oJHtydWxlLmNvbnRlbnR9KSBvbmx5TW9kaWZ5YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBvbmx5IG1vZGlmeSBpZiBwcm9wZXJ0eSBleGlzdHNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnRvb2xzLmdldFJ1bGVGdW5jdGlvbihydWxlKT8ucnVsZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYnVpbGRJbic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NjcmlwdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBleGVjdXRlUnVsZShldmVudE5hbWUsIHRoaXMuYXBwLCB0aGlzLnNldHRpbmdzLCBmaWxlLCBmcm9udG1hdHRlcltydWxlLnByb3BlcnR5XSwgcnVsZSwgZnJvbnRtYXR0ZXIsIG9sZFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZyb250bWF0dGVyW3J1bGUucHJvcGVydHldID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0Zyb250bWF0dGVyIHVwZGF0ZWQnLGZyb250bWF0dGVyKTtcbiAgICAgICAgfSx7J210aW1lJzpmaWxlLnN0YXQubXRpbWV9KTsgLy8gZG8gbm90IGNoYW5nZSB0aGUgbW9kaWZ5IHRpbWUuXG4gICAgfVxuICAgIFxuICAgIGFzeW5jIHJlbW92ZUZyb250bWF0dGVyUGFyYW1zRnJvbUFsbEZpbGVzKHJ1bGU6IEZvbGRlclRhZ1J1bGVEZWZpbml0aW9uKXtcbiAgICAgICAgbGV0IGNvdW50ID0ge2ZpbGVzOjAsIGl0ZW1zOiAwfVxuICAgICAgICB0aGlzLmFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCkuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgICAgICAgIGNvdW50LmZpbGVzKys7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUZyb250bWF0dGVyUGFyYW1ldGVyKGZpbGUsIHJ1bGUsIGNvdW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG5cbiAgICBhc3luYyByZW1vdmVGcm9udG1hdHRlclBhcmFtZXRlcihmaWxlOiBURmlsZSwgcnVsZTogRm9sZGVyVGFnUnVsZURlZmluaXRpb24sIGNvdW50KSB7XG4gICAgICAgIGlmICghY2hlY2tJZkZpbGVBbGxvd2VkKGZpbGUsIHRoaXMuc2V0dGluZ3MsIHJ1bGUpKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQYXRoVGFnID0gdGhpcy5mb3JtYXRUYWdOYW1lKHRoaXMudG9vbHMuZ2V0Rm9sZGVyRnJvbVBhdGgoZmlsZS5wYXRoKSk7XG4gICAgICAgIGxldCBjb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChmaWxlKTtcbiAgICAgICAgdGhpcy5hcHAuZmlsZU1hbmFnZXIucHJvY2Vzc0Zyb250TWF0dGVyKGZpbGUsIChmcm9udG1hdHRlcikgPT4ge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZnJvbnRtYXR0ZXJbcnVsZS5wcm9wZXJ0eV0pKSBjb3VudC5pdGVtcyArPSBmcm9udG1hdHRlcltydWxlLnByb3BlcnR5XS5sZW5ndGg7XG4gICAgICAgICAgICBmcm9udG1hdHRlcltydWxlLnByb3BlcnR5XSA9IHJlbW92ZVJ1bGUodGhpcy5hcHAsIHRoaXMuc2V0dGluZ3MsIGZpbGUsIGZyb250bWF0dGVyW3J1bGUucHJvcGVydHldLCBydWxlLCBmcm9udG1hdHRlcik7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmcm9udG1hdHRlcltydWxlLnByb3BlcnR5XSkpIGNvdW50Lml0ZW1zIC09IGZyb250bWF0dGVyW3J1bGUucHJvcGVydHldLmxlbmd0aDtcbiAgICAgICAgfSx7J210aW1lJzpmaWxlLnN0YXQubXRpbWV9KTsgLy8gZG8gbm90IGNoYW5nZSB0aGUgbW9kaWZ5IHRpbWUuXG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgQXBwLCBCdXR0b25Db21wb25lbnQsIERyb3Bkb3duQ29tcG9uZW50LCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nLCBUZXh0Q29tcG9uZW50IH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQgKiBhcyBmbVRvb2xzIGZyb20gJy4vZnJvbnRtYXR0ZXItdG9vbHMnO1xyXG5pbXBvcnQgeyBwYXJzZUpTQ29kZSwgU2NyaXB0aW5nVG9vbHMgfSBmcm9tICcuL3Rvb2xzJztcclxuaW1wb3J0IHsgZ2V0UnVsZUZ1bmN0aW9uQnlJZCwgcnVsZUZ1bmN0aW9ucywgUnVsZUZ1bmN0aW9uIH0gZnJvbSAnLi9ydWxlcyc7XHJcbmltcG9ydCB7IHZlcnNpb25TdHJpbmcsIEZvbGRlclRhZ1J1bGVEZWZpbml0aW9uLCBERUZBVUxUX1JVTEVfREVGSU5JVElPTiwgUHJvcGVydHlUeXBlSW5mbywgT2JzaWRpYW5Qcm9wZXJ0eVR5cGVzfSBmcm9tICcuL3R5cGVzJztcclxuaW1wb3J0IHsgQWxlcnRNb2RhbCB9IGZyb20gJy4vYWxlcnRCb3gnO1xyXG5pbXBvcnQgeyBvcGVuRGlyZWN0b3J5U2VsZWN0aW9uTW9kYWwsIERpcmVjdG9yeVNlbGVjdGlvblJlc3VsdCB9IGZyb20gJy4vZGlyZWN0b3J5U2VsZWN0aW9uTW9kYWwnO1xyXG5pbXBvcnQgeyByYW5kb21VVUlEIH0gZnJvbSAnY3J5cHRvJztcclxuaW1wb3J0IHsgUnVsZXNUYWJsZSB9IGZyb20gJy4vc2V0dGluZ3MtcHJvcGVydGllcyc7XHJcblxyXG5leHBvcnQgY2xhc3MgRm9sZGVyVGFnU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xyXG4gICAgcGx1Z2luOiBhbnk7IC8vRm9sZGVyVGFnUGx1Z2luO1xyXG4gICAgcnVsZXNEaXY6IEhUTUxEaXZFbGVtZW50O1xyXG4gICAgcnVsZXNDb250YWluZXI6IEhUTUxEaXZFbGVtZW50O1xyXG4gICAgcnVsZXNDb250cm9sOiBIVE1MRGl2RWxlbWVudDtcclxuICAgIGtub3duUHJvcGVydGllczogUHJvcGVydHlUeXBlSW5mb1tdO1xyXG4gICAga25vd25UeXBlczogYW55O1xyXG4gICAgc2NyaXB0aW5nVG9vbHM6IFNjcmlwdGluZ1Rvb2xzO1xyXG4gICAgXHJcbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBhbnkgLypGb2xkZXJUYWdQbHVnaW4qLykge1xyXG4gICAgICAgIHN1cGVyKGFwcCwgcGx1Z2luKTtcclxuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuICAgICAgICB0aGlzLnNjcmlwdGluZ1Rvb2xzID0gbmV3IFNjcmlwdGluZ1Rvb2xzKGFwcCwgcGx1Z2luKTtcclxuICAgIH1cclxuICAgIGhpZGUoKTogdm9pZCB7XHJcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBydWxlcyB0byByZW1vdmUgdGhlIG9uZXMgdGhhdCBhcmUgbm90IGxpdmUgYW55bW9yZVxyXG4gICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmxpdmVSdWxlcz1bXTtcclxuICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5ydWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcnVsZUZ1bmN0aW9uID0gZ2V0UnVsZUZ1bmN0aW9uQnlJZChydWxlLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICBpZiAoIXJ1bGVGdW5jdGlvbikgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZiAocnVsZUZ1bmN0aW9uLmlzTGl2ZVJ1bGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmxpdmVSdWxlcy5wdXNoKHJ1bGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAvLyB1cGRhdGUgYWN0aXZlIGZpbGUgaWYgaXQgaXMgb3BlblxyXG4gICAgICAgIGNvbnN0IGFjdGl2ZUZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xyXG4gICAgICAgIGlmIChhY3RpdmVGaWxlICYmIGFjdGl2ZUZpbGUuZXh0ZW5zaW9uID09PSAnbWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnVwZGF0ZUZyb250bWF0dGVyUGFyYW1ldGVycygnYWN0aXZlLWxlYWYtY2hhbmdlJywgYWN0aXZlRmlsZSwgdGhpcy5wbHVnaW4uc2V0dGluZ3MucnVsZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRpc3BsYXkoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5rbm93blByb3BlcnRpZXMgPSBmbVRvb2xzLmdldFByb3BlcnRpZXNGcm9tTWV0YWRhdGFNYW5hZ2VyKHRoaXMuYXBwKTtcclxuICAgICAgICB0aGlzLmtub3duVHlwZXMgPSBmbVRvb2xzLmdldFR5cGVzRnJvbU1ldGFkYXRhTWFuYWdlcih0aGlzLmFwcCk7XHJcbiAgICAgICAgY29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcclxuXHJcbiAgICAgICAgY29udGFpbmVyRWwuZW1wdHkoKTtcclxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6IGBGcm9udCBtYXR0ZXIgYXV0b21hdGUgViR7dmVyc2lvblN0cmluZ31gIH0pO1xyXG5cclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAuc2V0TmFtZSgnRXhjbHVkZSBGaWxlcyBhbmQgRm9sZGVycyBnbG9iYWxseScpXHJcbiAgICAgICAgLnNldERlc2MoYEN1cnJlbnRseSAke3RoaXMucGx1Z2luLnNldHRpbmdzLmV4Y2x1ZGUuc2VsZWN0ZWRGb2xkZXJzLmxlbmd0aH0gZm9sZGVycyBhbmQgJHt0aGlzLnBsdWdpbi5zZXR0aW5ncy5leGNsdWRlLnNlbGVjdGVkRmlsZXMubGVuZ3RofSBmaWxlcyB3aWxsIGJlICR7dGhpcy5wbHVnaW4uc2V0dGluZ3MuZXhjbHVkZS5tb2RlfWQuYClcclxuICAgICAgICAuYWRkQnV0dG9uKGJ1dHRvbiA9PiB7XHJcbiAgICAgICAgICAgIGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgLnNldEljb24oJ2ZvbGRlci14JylcclxuICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdFeGNsdWRlJylcclxuICAgICAgICAgICAgICAgIC5zZXRDdGEoKSAvLyBNYWtlcyB0aGUgYnV0dG9uIG1vcmUgcHJvbWluZW50XHJcbiAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlbkRpcmVjdG9yeVNlbGVjdGlvbk1vZGFsKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZXhjbHVkZS5zZWxlY3RlZEZvbGRlcnMgfHwgW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmV4Y2x1ZGUuc2VsZWN0ZWRGaWxlcyB8fCBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbk1vZGU6IHRoaXMucGx1Z2luLnNldHRpbmdzLmV4Y2x1ZGUubW9kZSB8fCAnZXhjbHVkZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TW9kZTogdGhpcy5wbHVnaW4uc2V0dGluZ3MuZXhjbHVkZS5kaXNwbGF5IHx8ICdmb2xkZXJzJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvblNlbGVjdGlvbk1vZGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uU2hvd0ZpbGVzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAocmVzdWx0OiBEaXJlY3RvcnlTZWxlY3Rpb25SZXN1bHQgfCBudWxsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZXhjbHVkZS5zZWxlY3RlZEZvbGRlcnMgPSByZXN1bHQuZm9sZGVycztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmV4Y2x1ZGUuc2VsZWN0ZWRGaWxlcyA9IHJlc3VsdC5maWxlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmV4Y2x1ZGUubW9kZSA9IHJlc3VsdC5tb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZXhjbHVkZS5kaXNwbGF5ID0gcmVzdWx0LmRpc3BsYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTsgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTsgIFxyXG5cclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAuc2V0TmFtZSgnSW5jbHVkZSBGaWxlcyBhbmQgRm9sZGVycyBnbG9iYWxseScpXHJcbiAgICAgICAgLnNldERlc2MoYEN1cnJlbnRseSAke3RoaXMucGx1Z2luLnNldHRpbmdzLmluY2x1ZGUuc2VsZWN0ZWRGb2xkZXJzLmxlbmd0aH0gZm9sZGVycyBhbmQgJHt0aGlzLnBsdWdpbi5zZXR0aW5ncy5pbmNsdWRlLnNlbGVjdGVkRmlsZXMubGVuZ3RofSBmaWxlcyB3aWxsIGJlICR7dGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5jbHVkZS5tb2RlfWQgZXZlbiBpZiB0aGV5IGFyZSBleGNsdWRlZC5gKVxyXG4gICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IHtcclxuICAgICAgICAgICAgYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAuc2V0SWNvbignZm9sZGVyLWNoZWNrJylcclxuICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdJbmNsdWRlJylcclxuICAgICAgICAgICAgICAgIC5zZXRDdGEoKSAvLyBNYWtlcyB0aGUgYnV0dG9uIG1vcmUgcHJvbWluZW50XHJcbiAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlbkRpcmVjdG9yeVNlbGVjdGlvbk1vZGFsKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5jbHVkZS5zZWxlY3RlZEZvbGRlcnMgfHwgW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmluY2x1ZGUuc2VsZWN0ZWRGaWxlcyB8fCBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbk1vZGU6IHRoaXMucGx1Z2luLnNldHRpbmdzLmluY2x1ZGUubW9kZSB8fCAnaW5jbHVkZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TW9kZTogdGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5jbHVkZS5kaXNwbGF5IHx8ICdmb2xkZXJzJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvblNlbGVjdGlvbk1vZGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uU2hvd0ZpbGVzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAocmVzdWx0OiBEaXJlY3RvcnlTZWxlY3Rpb25SZXN1bHQgfCBudWxsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5jbHVkZS5zZWxlY3RlZEZvbGRlcnMgPSByZXN1bHQuZm9sZGVycztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmluY2x1ZGUuc2VsZWN0ZWRGaWxlcyA9IHJlc3VsdC5maWxlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmluY2x1ZGUubW9kZSA9IHJlc3VsdC5tb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5jbHVkZS5kaXNwbGF5ID0gcmVzdWx0LmRpc3BsYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTsgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTsgICAgXHJcbiAgICAgICAgXHJcbiAgXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgLnNldE5hbWUoJ1J1bGVzJylcclxuICAgICAgICAuc2V0RGVzYygnYWRkIHJ1bGVzIHRvIHVwZGF0ZSBzZWxlY3RlZCBwYXJhbWV0ZXJzJyk7XHJcblxyXG4gICAgICAgIHRoaXMucnVsZXNDb250YWluZXIgPSBjb250YWluZXJFbC5jcmVhdGVEaXYoJ3Byb3BlcnRpZXMtbGlzdCcpO1xyXG4gICAgICAgIGNvbnN0IHJ1bGVzVGFibGUgPSBuZXcgUnVsZXNUYWJsZSh0aGlzLmFwcCwgdGhpcy5wbHVnaW4sdGhpcy5ydWxlc0NvbnRhaW5lciwncnVsZXMnKTtcclxuICAgICAgICBydWxlc1RhYmxlLmRpc3BsYXkoKTtcclxuICAgIH1cclxufSIsICJpbXBvcnQgeyBBcHAsIE5vdGljZSwgU3VnZ2VzdE1vZGFsLCBURmlsZSB9IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IHsgUHJvcGVydHlUeXBlSW5mbywgUHJvcGVydHlUeXBlLCBPYnNpZGlhblByb3BlcnR5VHlwZXN9IGZyb20gJy4vdHlwZXMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfUFJPUEVSVFlfVFlQRV9JTkZPOiBQcm9wZXJ0eVR5cGVJbmZvID0ge1xyXG4gICAgbmFtZSA6IFwiXCIsXHJcbiAgICB0eXBlIDogJ3RleHQnLFxyXG4gICAgaXNBcnJheTogZmFsc2UsXHJcbiAgICB2YWx1ZXM6IFtdLFxyXG4gICAgc291cmNlOiAncmVnaXN0ZXJlZCcsXHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyBhbGwgYXZhaWxhYmxlIHByb3BlcnRpZXMgd2l0aCB0aGVpciB0eXBlIGluZm9ybWF0aW9uXHJcbiAqIEBwYXJhbSBhcHAgVGhlIE9ic2lkaWFuIEFwcCBpbnN0YW5jZVxyXG4gKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gYXJyYXkgb2YgUHJvcGVydHlUeXBlSW5mb1xyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbFByb3BlcnRpZXNXaXRoVHlwZXMoYXBwOiBBcHApOiBQcm9taXNlPFByb3BlcnR5VHlwZUluZm9bXT4ge1xyXG4gICAgLy8gVHJ5IHRvIGdldCByZWdpc3RlcmVkIHByb3BlcnRpZXMgKGZhbGxiYWNrIHRvIGVtcHR5IGFycmF5IGlmIEFQSSBjaGFuZ2VkKVxyXG4gICAgY29uc3QgcmVnaXN0ZXJlZFByb3BzID0gYXdhaXQgZ2V0UmVnaXN0ZXJlZFByb3BlcnRpZXNTYWZlKGFwcCk7XHJcbiAgICBcclxuICAgIC8vIEdldCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgZm91bmQgaW4gbm90ZXNcclxuICAgIGNvbnN0IGZpbGVQcm9wcyA9IGF3YWl0IGdldFByb3BlcnRpZXNGcm9tRmlsZXMoYXBwKTtcclxuICAgIFxyXG4gICAgLy8gQ29tYmluZSByZXN1bHRzIChmYXZvciByZWdpc3RlcmVkIHByb3BlcnRpZXMgd2hlbiBkdXBsaWNhdGVzIGV4aXN0KVxyXG4gICAgY29uc3QgY29tYmluZWQgPSBuZXcgTWFwPHN0cmluZywgUHJvcGVydHlUeXBlSW5mbz4oKTtcclxuICAgIFxyXG4gICAgLy8gQWRkIHByb3BlcnRpZXMgZm91bmQgaW4gZmlsZXMgZmlyc3RcclxuICAgIGZpbGVQcm9wcy5mb3JFYWNoKHByb3AgPT4ge1xyXG4gICAgICAgIGNvbWJpbmVkLnNldChwcm9wLm5hbWUsIHByb3ApO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIFRoZW4gb3ZlcnJpZGUgd2l0aCByZWdpc3RlcmVkIHByb3BlcnRpZXMgKHdoaWNoIGhhdmUgbW9yZSBjb21wbGV0ZSB0eXBlIGluZm8pXHJcbiAgICByZWdpc3RlcmVkUHJvcHMuZm9yRWFjaChwcm9wID0+IHtcclxuICAgICAgICBjb21iaW5lZC5zZXQocHJvcC5uYW1lLCBwcm9wKTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICByZXR1cm4gQXJyYXkuZnJvbShjb21iaW5lZC52YWx1ZXMoKSkuc29ydCgoYSwgYikgPT4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgUHJvcGVydGllcyBmcm9tIE1ldGFkYXRhTWFuYWdlclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb3BlcnRpZXNGcm9tTWV0YWRhdGFNYW5hZ2VyKGFwcDogQXBwKTogUHJvcGVydHlUeXBlSW5mb1tdIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgbWV0YWRhdGFNYW5hZ2VyID0gKGFwcCBhcyBhbnkpLm1ldGFkYXRhVHlwZU1hbmFnZXI7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJnZXQgcHJvcGVydGllczpcIixtZXRhZGF0YU1hbmFnZXIpO1xyXG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKG1ldGFkYXRhTWFuYWdlci5wcm9wZXJ0aWVzKS5tYXAoICh2YWx1ZTphbnkpOlByb3BlcnR5VHlwZUluZm8gPT4gKHtcclxuICAgICAgICAgICAgbmFtZTogdmFsdWUubmFtZSxcclxuICAgICAgICAgICAgdHlwZTogdmFsdWUudHlwZSxcclxuICAgICAgICAgICAgY291bnQ6IHZhbHVlLmNvdW50LFxyXG4gICAgICAgICAgICBzb3VyY2U6ICdyZWdpc3RlcmVkJ1xyXG4gICAgICAgIH0pKS5zb3J0KChhLCBiKSA9PiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpKTtcclxuXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNvdWxkbid0IGFjY2VzcyBwcm9wZXJ0aWVzIGZyb20gTWV0YWRhdGEgTWFuYWdlclwiLCBlKTtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEdldCBUeXBlcyBmcm9tIE1ldGFkYXRhTWFuYWdlclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFR5cGVzRnJvbU1ldGFkYXRhTWFuYWdlcihhcHA6IEFwcCk6IGFueSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhTWFuYWdlciA9IChhcHAgYXMgYW55KS5tZXRhZGF0YVR5cGVNYW5hZ2VyO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiZ2V0IHR5cGVzOlwiLG1ldGFkYXRhTWFuYWdlcik7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMobWV0YWRhdGFNYW5hZ2VyLnJlZ2lzdGVyZWRUeXBlV2lkZ2V0cykubWFwKCAodmFsdWU6YW55LCBpbmRleCwgYXJyYXkpOlByb3BlcnR5VHlwZSAgPT4gKHtcclxuICAgICAgICAgICAgdHlwZTogdmFsdWUudHlwZSxcclxuICAgICAgICAgICAgaWNvbjogdmFsdWUuaWNvbixcclxuICAgICAgICAgICAganNUeXBlOiAnJyxcclxuICAgICAgICB9KSkuc29ydCgoYSwgYikgPT4gYS50eXBlLmxvY2FsZUNvbXBhcmUoYi50eXBlKSk7XHJcblxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb3VsZG4ndCBhY2Nlc3MgcHJvcGVydGllcyBmcm9tIE1ldGFkYXRhIE1hbmFnZXJcIiwgZSk7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTYWZlIG1ldGhvZCB0byBnZXQgcmVnaXN0ZXJlZCBwcm9wZXJ0aWVzIHRoYXQgd29uJ3QgdGhyb3cgaWYgQVBJIGNoYW5nZXNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGdldFJlZ2lzdGVyZWRQcm9wZXJ0aWVzU2FmZShhcHA6IEFwcCk6IFByb21pc2U8UHJvcGVydHlUeXBlSW5mb1tdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhTWFuYWdlciA9IChhcHAgYXMgYW55KS5tZXRhZGF0YVR5cGVNYW5hZ2VyO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKG1ldGFkYXRhTWFuYWdlcik7XHJcbiAgICAgICAgaWYgKCFtZXRhZGF0YU1hbmFnZXIpIHJldHVybiBbXTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBUcnkgZGlmZmVyZW50IHdheXMgdG8gZ2V0IHByb3BlcnRpZXMgYmFzZWQgb24gT2JzaWRpYW4gdmVyc2lvblxyXG4gICAgICAgIGlmICh0eXBlb2YgbWV0YWRhdGFNYW5hZ2VyLmdldEFsbEZyb250bWF0dGVyVHlwZXMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgLy8gT2xkZXIgT2JzaWRpYW4gdmVyc2lvbnNcclxuICAgICAgICAgICAgY29uc3QgZnJvbnRtYXR0ZXJUeXBlcyA9IG1ldGFkYXRhTWFuYWdlci5nZXRBbGxGcm9udG1hdHRlclR5cGVzKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmcm9udG1hdHRlclR5cGVzLm1hcCgobmFtZTogc3RyaW5nKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JywgLy8gRGVmYXVsdCB0eXBlIGlmIHdlIGNhbid0IGdldCBtb3JlIGluZm9cclxuICAgICAgICAgICAgICAgIHNvdXJjZTogJ3JlZ2lzdGVyZWQnXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtZXRhZGF0YU1hbmFnZXIuZ2V0UHJvcGVydGllcyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAvLyBOZXdlciBPYnNpZGlhbiB2ZXJzaW9ucyBtaWdodCB1c2UgdGhpc1xyXG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gbWV0YWRhdGFNYW5hZ2VyLmdldFByb3BlcnRpZXMoKTtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHByb3BlcnRpZXMpLm1hcCgoW25hbWUsIHR5cGVdOiBbc3RyaW5nLCBhbnldKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2U6ICdyZWdpc3RlcmVkJ1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb3VsZG4ndCBhY2Nlc3MgcmVnaXN0ZXJlZCBwcm9wZXJ0aWVzOlwiLCBlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBbXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNjYW5zIGZpbGVzIGZvciBhZGRpdGlvbmFsIHByb3BlcnRpZXMgd2l0aCB0eXBlIGluZmVyZW5jZVxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZ2V0UHJvcGVydGllc0Zyb21GaWxlcyhhcHA6IEFwcCk6IFByb21pc2U8UHJvcGVydHlUeXBlSW5mb1tdPiB7XHJcbiAgICBjb25zdCBmaWxlcyA9IGFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCk7XHJcbiAgICBjb25zdCBwcm9wZXJ0eU1hcCA9IG5ldyBNYXA8c3RyaW5nLCB7IHZhbHVlczogU2V0PGFueT4sIHR5cGVzOiBTZXQ8c3RyaW5nPiB9PigpO1xyXG4gICAgXHJcbiAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMuc2xpY2UoMCwgMTAwMCkpIHsgLy8gTGltaXQgdG8gMTAwMCBmaWxlcyBmb3IgcGVyZm9ybWFuY2VcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBjYWNoZSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlPy5mcm9udG1hdHRlcikge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoY2FjaGUuZnJvbnRtYXR0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3Bvc2l0aW9uJykgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wZXJ0eU1hcC5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eU1hcC5zZXQoa2V5LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IG5ldyBTZXQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzOiBuZXcgU2V0KClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BEYXRhID0gcHJvcGVydHlNYXAuZ2V0KGtleSkhO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BEYXRhLnZhbHVlcy5hZGQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BEYXRhLnR5cGVzLmFkZChpbmZlclR5cGVGcm9tVmFsdWUodmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgZmlsZSAke2ZpbGUucGF0aH06YCwgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIEFycmF5LmZyb20ocHJvcGVydHlNYXAuZW50cmllcygpKS5tYXAoKFtuYW1lLCBkYXRhXSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSBkZXRlcm1pbmVQcmltYXJ5VHlwZShkYXRhLnR5cGVzKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICBpc0FycmF5OiBkYXRhLnR5cGVzLmhhcygnYXJyYXknKSxcclxuICAgICAgICAgICAgdmFsdWVzOiBkYXRhLnZhbHVlcy5zaXplID4gMCA/IEFycmF5LmZyb20oZGF0YS52YWx1ZXMpLm1hcChTdHJpbmcpIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBzb3VyY2U6ICdpbmZlcnJlZCdcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIHRoZSBwcmltYXJ5IHR5cGUgZnJvbSBhIFNldCBvZiBvYnNlcnZlZCB0eXBlc1xyXG4gKiBAcGFyYW0gdHlwZXMgU2V0IG9mIG9ic2VydmVkIHR5cGVzIGZvciBhIHByb3BlcnR5XHJcbiAqIEByZXR1cm5zIFRoZSBtb3N0IHNwZWNpZmljIHR5cGUgd2UgY2FuIGRldGVybWluZVxyXG4gKi9cclxuZnVuY3Rpb24gZGV0ZXJtaW5lUHJpbWFyeVR5cGUodHlwZXM6IFNldDxzdHJpbmc+KTogT2JzaWRpYW5Qcm9wZXJ0eVR5cGVzIHtcclxuICAgIC8vIEhhbmRsZSBlbXB0eSBjYXNlIChzaG91bGRuJ3QgaGFwcGVuIGJ1dCBUeXBlU2NyaXB0IHdhbnRzIHVzIHRvIGNoZWNrKVxyXG4gICAgaWYgKHR5cGVzLnNpemUgPT09IDApIHJldHVybiAndGV4dCc7XHJcbiAgICBcclxuICAgIC8vIElmIG9ubHkgb25lIHR5cGUgb2JzZXJ2ZWQsIHVzZSB0aGF0XHJcbiAgICBpZiAodHlwZXMuc2l6ZSA9PT0gMSkgcmV0dXJuIHR5cGVzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcclxuICAgIFxyXG4gICAgLy8gUHJpb3JpdHkgb3JkZXIgZm9yIHR5cGUgcmVzb2x1dGlvblxyXG4gICAgY29uc3QgdHlwZVByaW9yaXR5OiBPYnNpZGlhblByb3BlcnR5VHlwZXNbXSA9IFtcclxuICAgICAgICAnZGF0ZScsXHJcbiAgICAgICAgJ2RhdGV0aW1lJyxcclxuICAgICAgICAnY2hlY2tib3gnLFxyXG4gICAgICAgICdudW1iZXInLFxyXG4gICAgICAgICd0YWdzJyxcclxuICAgICAgICAnYWxpYXNlcycsXHJcbiAgICAgICAgJ211bHRpdGV4dCcsXHJcbiAgICAgICAgJ3RleHQnIC8vIGZhbGxiYWNrXHJcbiAgICBdO1xyXG4gICAgXHJcbiAgICAvLyBSZXR1cm4gdGhlIGhpZ2hlc3QgcHJpb3JpdHkgdHlwZSB3ZSBmaW5kXHJcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdHlwZVByaW9yaXR5KSB7XHJcbiAgICAgICAgaWYgKHR5cGVzLmhhcyh0eXBlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEZpbmFsIGZhbGxiYWNrXHJcbiAgICByZXR1cm4gJ3RleHQnO1xyXG59XHJcblxyXG4vKipcclxuICogRW5oYW5jZWQgdHlwZSBpbmZlcmVuY2Ugd2l0aCBiZXR0ZXIgZGF0ZSBkZXRlY3Rpb25cclxuICovXHJcbmZ1bmN0aW9uIGluZmVyVHlwZUZyb21WYWx1ZSh2YWx1ZTogYW55KTogc3RyaW5nIHtcclxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuICdudWxsJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQ2hlY2sgYXJyYXkgZmlyc3RcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGFycmF5IGVsZW1lbnQgdHlwZXNcclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudFR5cGVzID0gbmV3IFNldCh2YWx1ZS5tYXAoaW5mZXJUeXBlRnJvbVZhbHVlKSk7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50VHlwZXMuc2l6ZSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGBhcnJheTwke2VsZW1lbnRUeXBlcy52YWx1ZXMoKS5uZXh0KCkudmFsdWV9PmA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICdhcnJheSc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIENoZWNrIGJhc2ljIHR5cGVzXHJcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xyXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOiByZXR1cm4gJ2Jvb2xlYW4nO1xyXG4gICAgICAgIGNhc2UgJ251bWJlcic6IHJldHVybiAnbnVtYmVyJztcclxuICAgICAgICBjYXNlICdvYmplY3QnOiByZXR1cm4gJ29iamVjdCc7IC8vIGZvciBmdXR1cmUgZXhwYW5zaW9uXHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIE11c3QgYmUgc3RyaW5nIGF0IHRoaXMgcG9pbnQgLSBjaGVjayBmb3Igc3BlY2lhbCBzdHJpbmcgZm9ybWF0c1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAvLyBJU08gRGF0ZSAoWVlZWS1NTS1ERClcclxuICAgICAgICBpZiAoL15cXGR7NH0tXFxkezJ9LVxcZHsyfSQvLnRlc3QodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnZGF0ZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIElTTyBEYXRlVGltZVxyXG4gICAgICAgIGlmICgvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9W1QgXVxcZHsyfTpcXGR7Mn06XFxkezJ9Ly50ZXN0KHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2RhdGV0aW1lJztcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gT2JzaWRpYW4gdGFnXHJcbiAgICAgICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJyMnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3RhZyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBEZWZhdWx0IHRvIHN0cmluZ1xyXG4gICAgcmV0dXJuICdzdHJpbmcnO1xyXG59XHJcblxyXG5mdW5jdGlvbiB2YWx1ZSh2YWx1ZTogdW5rbm93biwgaW5kZXg6IG51bWJlciwgYXJyYXk6IHVua25vd25bXSk6IHVua25vd24ge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQuJyk7XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBTZWxlY3RQcm9wZXJ0eSBleHRlbmRzIFN1Z2dlc3RNb2RhbDxQcm9wZXJ0eVR5cGVJbmZvPiB7XHJcbiAgICBwcml2YXRlIG9uU3VibWl0OiAocmVzdWx0OiBQcm9wZXJ0eVR5cGVJbmZvKSA9PiB2b2lkO1xyXG4gICAgcHJvcGVydHk6IFByb3BlcnR5VHlwZUluZm8gfCB1bmRlZmluZWQ7XHJcbiAgICBrbm93blByb3BlcnRpZXM6UHJvcGVydHlUeXBlSW5mb1tdO1xyXG4gICAgdHlwZWRUZXh0OiBzdHJpbmc7XHJcbiAgICBuZXdUZXh0RmxhZzogQm9vbGVhbjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvciAoYXBwOkFwcCwga25vd25Qcm9wZXJ0aWVzOlByb3BlcnR5VHlwZUluZm9bXSwgcHJvcGVydHk6IFByb3BlcnR5VHlwZUluZm8gfCB1bmRlZmluZWQsIG9uU3VibWl0OiAocmVzdWx0OiBQcm9wZXJ0eVR5cGVJbmZvKSA9PiB2b2lkKSB7XHJcbiAgICAgICAgc3VwZXIoYXBwKTtcclxuICAgICAgICB0aGlzLm9uU3VibWl0ID0gb25TdWJtaXQ7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xyXG4gICAgICAgIHRoaXMudHlwZWRUZXh0ID0gJyc7XHJcbiAgICAgICAgdGhpcy5uZXdUZXh0RmxhZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5rbm93blByb3BlcnRpZXMgPSBrbm93blByb3BlcnRpZXM7XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIGFsbCBhdmFpbGFibGUgc3VnZ2VzdGlvbnMuXHJcbiAgICBnZXRTdWdnZXN0aW9ucyhxdWVyeTogc3RyaW5nKTogUHJvcGVydHlUeXBlSW5mb1tdIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmtub3duUHJvcGVydGllcy5maWx0ZXIoKHByb3BlcnR5KSA9PiBwcm9wZXJ0eS5uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocXVlcnkudG9Mb3dlckNhc2UoKSkpO1xyXG4gICAgICAgIHRoaXMubmV3VGV4dEZsYWcgPSAocmVzdWx0Lmxlbmd0aCA9PT0gMCk7XHJcbiAgICAgICAgdGhpcy50eXBlZFRleHQgPSBxdWVyeTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgb25PcGVuKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLnByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UGxhY2Vob2xkZXIodGhpcy5wcm9wZXJ0eS5uYW1lKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnNldFBsYWNlaG9sZGVyKCdubyBwcm9wZXJ0eSBzZWxlY3RlZCEnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRUaXRsZSgnU2VsZWN0IG9yIHR5cGUgYSBwcm9wZXJ0eSBuYW1lJyk7XHJcbiAgICB9XHJcbiAgICAvLyBSZW5kZXJzIGVhY2ggc3VnZ2VzdGlvbiBpdGVtLlxyXG4gICAgcmVuZGVyU3VnZ2VzdGlvbihwcm9wZXJ0eTogUHJvcGVydHlUeXBlSW5mbywgZWw6IEhUTUxFbGVtZW50KSB7XHJcbiAgICAgIGVsLmNyZWF0ZUVsKCdkaXYnLCB7IHRleHQ6IHByb3BlcnR5Lm5hbWUgfSk7XHJcbiAgICAgIGVsLmNyZWF0ZUVsKCdzbWFsbCcsIHsgdGV4dDogcHJvcGVydHkudHlwZSB9KTtcclxuICAgIH1cclxuICAgIG9uQ2xvc2UoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMubmV3VGV4dEZsYWcgJiYgdGhpcy5wcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnR5Lm5hbWUgPSB0aGlzLnR5cGVkVGV4dDtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eS50eXBlID0gJ3RleHQnO1xyXG4gICAgICAgICAgICB0aGlzLm9uU3VibWl0KHRoaXMucHJvcGVydHkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBQZXJmb3JtIGFjdGlvbiBvbiB0aGUgc2VsZWN0ZWQgc3VnZ2VzdGlvbi5cclxuICAgIG9uQ2hvb3NlU3VnZ2VzdGlvbihwcm9wZXJ0eTogUHJvcGVydHlUeXBlSW5mbywgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xyXG4gICAgICAgIGlmIChldnQgaW5zdGFuY2VvZiBLZXlib2FyZEV2ZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBrZXlib2FyZCAke3RoaXMudHlwZWRUZXh0fSAke3RoaXMubmV3VGV4dEZsYWd9YCwgcHJvcGVydHkpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdvbkNob29zZVN1Z2dlc3Rpb24nLCBldnQpXHJcbiAgICAgICAgdGhpcy5vblN1Ym1pdChwcm9wZXJ0eSk7XHJcbiAgICB9XHJcbiAgfVxyXG4iLCAiaW1wb3J0IHsgQXBwLCBub3JtYWxpemVQYXRoLCBUQWJzdHJhY3RGaWxlLCBURmlsZSwgVEZvbGRlciwgVmF1bHQgfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCB7IEZvbGRlclRhZ1J1bGVEZWZpbml0aW9uLCBGb2xkZXJUYWdTZXR0aW5ncywgUHJvcGVydHlJbmZvLCBQcm9wZXJ0eVR5cGVJbmZvIH0gZnJvbSAnLi90eXBlcydcclxuaW1wb3J0IHsgRXJyb3JNYW5hZ2VyIH0gZnJvbSBcIi4vRXJyb3JcIjtcclxuaW1wb3J0IHsgQWxlcnRNb2RhbCB9IGZyb20gJy4vYWxlcnRCb3gnO1xyXG5pbXBvcnQgeyBydWxlRnVuY3Rpb25zIH0gZnJvbSAnLi9ydWxlcyc7XHJcbi8qKlxyXG4gKiBQYXJzZSBhIEphdmFTY3JpcHQgZnVuY3Rpb24sIGNsZWFuIGNvbW1lbnRzIGFuZCBkZWZpbmUgdGhlIGZ1bmN0aW9uIFxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBqc0NvZGVcclxuICogQHJldHVybiB7Kn0gIHsoRnVuY3Rpb24gfCBzdHJpbmcgfCB1bmRlZmluZWQpfVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSlNDb2RlKGpzQ29kZTpzdHJpbmcpOiBGdW5jdGlvbiB8IHN0cmluZyB8IHVuZGVmaW5lZCB7XHJcbiAgICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uIChqc0NvZGU6IHN0cmluZyk6IEZ1bmN0aW9uIHwgc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgIGpzQ29kZSA9IGNsZWFuQ29kZVN0cmluZyhqc0NvZGUpO1xyXG4gICAgICAgIHZhciBmdW5jUmVnID0gL2Z1bmN0aW9uICpcXCgoW14oKV0qKVxcKVsgXFxuXFx0XSp7KC4qKX0vZ21pO1xyXG4gICAgICAgIHZhciBtYXRjaCA9IGZ1bmNSZWcuZXhlYyhqc0NvZGUucmVwbGFjZSgvXFxuL2csICcgJykpO1xyXG4gICAgICAgIGlmICghbWF0Y2gpIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBtYXRjaFsxXS5zcGxpdCgnLCcpO1xyXG4gICAgICAgIGFyZ3MucHVzaChtYXRjaFsyXSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbiguLi5hcmdzKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdlcnJvciBwYXJzaW5nIEpTIGZ1bmN0aW9uIScsIGVycm9yKTtcclxuICAgICAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uKGpzQ29kZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDbGVhbnMgYSBKYXZhU2NyaXB0L1R5cGVTY3JpcHQgY29kZSBzdHJpbmcgYnkgcmVtb3ZpbmcgY29tbWVudHMuXHJcbiAqIFRoaXMgZnVuY3Rpb24gaGFuZGxlcyBib3RoIHNpbmdsZS1saW5lIGNvbW1lbnRzIChgLy8gLi4uYCkgYW5kXHJcbiAqIG11bHRpLWxpbmUgY29tbWVudHMgKGAvKiAuLi4gKlxcL2ApLiBJdCBhbHNvIGNvcnJlY3RseSBoYW5kbGVzXHJcbiAqIGNvbW1lbnRzIHdpdGhpbiBzdHJpbmdzIGFuZCByZWd1bGFyIGV4cHJlc3Npb25zLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZVN0cmluZyBUaGUgY29kZSBzdHJpbmcgdG8gY2xlYW4uXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjbGVhbmVkIGNvZGUgc3RyaW5nIHdpdGggY29tbWVudHMgcmVtb3ZlZC5cclxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0aGUgaW5wdXQgaXMgbm90IGEgc3RyaW5nLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFuQ29kZVN0cmluZyhjb2RlU3RyaW5nOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgLy8gRW5zdXJlIHRoZSBpbnB1dCBpcyBhIHN0cmluZ1xyXG4gICAgaWYgKHR5cGVvZiBjb2RlU3RyaW5nICE9PSAnc3RyaW5nJykge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnB1dCBtdXN0IGJlIGEgc3RyaW5nLicpO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgLy8gRmxhZ3MgdG8gdHJhY2sgdGhlIGN1cnJlbnQgcGFyc2luZyBjb250ZXh0XHJcbiAgICBsZXQgaW5NdWx0aUxpbmVDb21tZW50OiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBsZXQgaW5TaW5nbGVMaW5lQ29tbWVudDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgbGV0IGluU3RyaW5nOiAnXCInIHwgXCInXCIgfCBudWxsID0gbnVsbDsgLy8gVHJhY2tzIGlmIGluc2lkZSBzaW5nbGUgb3IgZG91YmxlIHF1b3Rlc1xyXG4gICAgbGV0IGluUmVnRXhwOiBib29sZWFuID0gZmFsc2U7IC8vIFRyYWNrcyBpZiBpbnNpZGUgYSByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbFxyXG4gIFxyXG4gICAgLy8gVGhlIHJlc3VsdGluZyBzdHJpbmcgd2l0aG91dCBjb21tZW50c1xyXG4gICAgbGV0IGNsZWFuZWRDb2RlOiBzdHJpbmcgPSAnJztcclxuICAgIC8vIEN1cnJlbnQgaW5kZXggaW4gdGhlIGlucHV0IHN0cmluZ1xyXG4gICAgbGV0IGk6IG51bWJlciA9IDA7XHJcbiAgXHJcbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGlucHV0IHN0cmluZyBjaGFyYWN0ZXIgYnkgY2hhcmFjdGVyXHJcbiAgICB3aGlsZSAoaSA8IGNvZGVTdHJpbmcubGVuZ3RoKSB7XHJcbiAgICAgIGNvbnN0IGNoYXI6IHN0cmluZyA9IGNvZGVTdHJpbmdbaV07XHJcbiAgICAgIGNvbnN0IG5leHRDaGFyOiBzdHJpbmcgfCB1bmRlZmluZWQgPSBjb2RlU3RyaW5nW2kgKyAxXTsgLy8gVXNlIHVuZGVmaW5lZCBmb3IgcG90ZW50aWFsIGVuZCBvZiBzdHJpbmdcclxuICBcclxuICAgICAgLy8gLS0tIFN0YXRlOiBJbnNpZGUgYSBtdWx0aS1saW5lIGNvbW1lbnQgLS0tXHJcbiAgICAgIGlmIChpbk11bHRpTGluZUNvbW1lbnQpIHtcclxuICAgICAgICAvLyBDaGVjayBmb3IgdGhlIGVuZCBvZiB0aGUgbXVsdGktbGluZSBjb21tZW50ICcqLydcclxuICAgICAgICBpZiAoY2hhciA9PT0gJyonICYmIG5leHRDaGFyID09PSAnLycpIHtcclxuICAgICAgICAgIGluTXVsdGlMaW5lQ29tbWVudCA9IGZhbHNlO1xyXG4gICAgICAgICAgaSArPSAyOyAvLyBTa2lwIHRoZSAnKi8nXHJcbiAgICAgICAgICBjb250aW51ZTsgLy8gTW92ZSB0byB0aGUgbmV4dCBpdGVyYXRpb25cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaSsrOyAvLyBTa2lwIHRoZSBjaGFyYWN0ZXIgaW5zaWRlIHRoZSBjb21tZW50XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgLy8gLS0tIFN0YXRlOiBJbnNpZGUgYSBzaW5nbGUtbGluZSBjb21tZW50IC0tLVxyXG4gICAgICBpZiAoaW5TaW5nbGVMaW5lQ29tbWVudCkge1xyXG4gICAgICAgIC8vIENoZWNrIGZvciB0aGUgZW5kIG9mIHRoZSBsaW5lIChuZXdsaW5lIG9yIGNhcnJpYWdlIHJldHVybilcclxuICAgICAgICBpZiAoY2hhciA9PT0gJ1xcbicgfHwgY2hhciA9PT0gJ1xccicpIHtcclxuICAgICAgICAgIGluU2luZ2xlTGluZUNvbW1lbnQgPSBmYWxzZTtcclxuICAgICAgICAgIGNsZWFuZWRDb2RlICs9IGNoYXI7IC8vIEtlZXAgdGhlIG5ld2xpbmUgY2hhcmFjdGVyXHJcbiAgICAgICAgICBpKys7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaSsrOyAvLyBTa2lwIHRoZSBjaGFyYWN0ZXIgaW5zaWRlIHRoZSBjb21tZW50XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgLy8gLS0tIFN0YXRlOiBJbnNpZGUgYSBzdHJpbmcgbGl0ZXJhbCAtLS1cclxuICAgICAgaWYgKGluU3RyaW5nKSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGNsb3NlcyB0aGUgc3RyaW5nXHJcbiAgICAgICAgaWYgKGNoYXIgPT09IGluU3RyaW5nKSB7XHJcbiAgICAgICAgICBpblN0cmluZyA9IG51bGw7IC8vIEV4aXQgc3RyaW5nIHN0YXRlXHJcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnXFxcXCcpIHtcclxuICAgICAgICAgIC8vIEhhbmRsZSBlc2NhcGVkIGNoYXJhY3RlcnMgd2l0aGluIHN0cmluZ3MgKGUuZy4sIFwiaXRcXCdzXCIpXHJcbiAgICAgICAgICBjbGVhbmVkQ29kZSArPSBjaGFyOyAvLyBBZGQgdGhlIGJhY2tzbGFzaFxyXG4gICAgICAgICAgaSsrOyAvLyBNb3ZlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciAodGhlIGVzY2FwZWQgb25lKVxyXG4gICAgICAgICAgaWYgKGkgPCBjb2RlU3RyaW5nLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgY2xlYW5lZENvZGUgKz0gY29kZVN0cmluZ1tpXTsgLy8gQWRkIHRoZSBlc2NhcGVkIGNoYXJhY3RlclxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFkZCB0aGUgY2hhcmFjdGVyIHRvIHRoZSByZXN1bHQgaWYgaXQncyBwYXJ0IG9mIHRoZSBzdHJpbmdcclxuICAgICAgICBjbGVhbmVkQ29kZSArPSBjaGFyO1xyXG4gICAgICAgIGkrKztcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAgLy8gLS0tIFN0YXRlOiBJbnNpZGUgYSByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbCAtLS1cclxuICAgICAgIGlmIChpblJlZ0V4cCkge1xyXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGNsb3NlcyB0aGUgcmVnZXggbGl0ZXJhbFxyXG4gICAgICAgICAgLy8gTm90ZTogVGhpcyBkb2Vzbid0IGhhbmRsZSByZWdleCBmbGFncyBwZXJmZWN0bHkgYnV0IGNvdmVycyBiYXNpYyBjYXNlcy5cclxuICAgICAgICAgIGlmIChjaGFyID09PSAnLycpIHtcclxuICAgICAgICAgICAgICBpblJlZ0V4cCA9IGZhbHNlOyAvLyBFeGl0IHJlZ2V4IHN0YXRlXHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICdcXFxcJykge1xyXG4gICAgICAgICAgICAgIC8vIEhhbmRsZSBlc2NhcGVkIGNoYXJhY3RlcnMgd2l0aGluIHJlZ2V4IChlLmcuLCAvXFwvLylcclxuICAgICAgICAgICAgICBjbGVhbmVkQ29kZSArPSBjaGFyOyAvLyBBZGQgdGhlIGJhY2tzbGFzaFxyXG4gICAgICAgICAgICAgIGkrKzsgLy8gTW92ZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgICBpZiAoaSA8IGNvZGVTdHJpbmcubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgY2xlYW5lZENvZGUgKz0gY29kZVN0cmluZ1tpXTsgLy8gQWRkIHRoZSBlc2NhcGVkIGNoYXJhY3RlclxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBBZGQgdGhlIGNoYXJhY3RlciB0byB0aGUgcmVzdWx0IGlmIGl0J3MgcGFydCBvZiB0aGUgcmVnZXhcclxuICAgICAgICAgIGNsZWFuZWRDb2RlICs9IGNoYXI7XHJcbiAgICAgICAgICBpKys7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgIH1cclxuICBcclxuICAgICAgLy8gLS0tIERlZmF1bHQgU3RhdGU6IENoZWNrIGZvciBjb21tZW50L3N0cmluZy9yZWdleCBzdGFydHMgLS0tXHJcbiAgXHJcbiAgICAgIC8vIENoZWNrIGZvciB0aGUgc3RhcnQgb2YgYSBtdWx0aS1saW5lIGNvbW1lbnQgJy8qJ1xyXG4gICAgICBpZiAoY2hhciA9PT0gJy8nICYmIG5leHRDaGFyID09PSAnKicpIHtcclxuICAgICAgICBpbk11bHRpTGluZUNvbW1lbnQgPSB0cnVlO1xyXG4gICAgICAgIGkgKz0gMjsgLy8gU2tpcCB0aGUgJy8qJ1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIC8vIENoZWNrIGZvciB0aGUgc3RhcnQgb2YgYSBzaW5nbGUtbGluZSBjb21tZW50ICcvLydcclxuICAgICAgaWYgKGNoYXIgPT09ICcvJyAmJiBuZXh0Q2hhciA9PT0gJy8nKSB7XHJcbiAgICAgICAgaW5TaW5nbGVMaW5lQ29tbWVudCA9IHRydWU7XHJcbiAgICAgICAgaSArPSAyOyAvLyBTa2lwIHRoZSAnLy8nXHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBzdGFydCBvZiBhIHN0cmluZyBsaXRlcmFsICgnIG9yIFwiKVxyXG4gICAgICBpZiAoY2hhciA9PT0gJ1wiJyB8fCBjaGFyID09PSBcIidcIikge1xyXG4gICAgICAgIGluU3RyaW5nID0gY2hhcjsgLy8gRW50ZXIgc3RyaW5nIHN0YXRlLCByZW1lbWJlcmluZyB0aGUgcXVvdGUgdHlwZVxyXG4gICAgICAgIGNsZWFuZWRDb2RlICs9IGNoYXI7IC8vIEFkZCB0aGUgb3BlbmluZyBxdW90ZVxyXG4gICAgICAgIGkrKztcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvLyBDaGVjayBmb3IgdGhlIHN0YXJ0IG9mIGEgcmVndWxhciBleHByZXNzaW9uIGxpdGVyYWwgJy8nXHJcbiAgICAgIC8vIEJhc2ljIGNoZWNrOiBhc3N1bWVzICcvJyBpbmRpY2F0ZXMgYSByZWdleCBzdGFydCBpZiBub3QgcHJlY2VkZWQgYnkgb3BlcmF0b3JzL2tleXdvcmRzXHJcbiAgICAgIC8vIEEgbW9yZSByb2J1c3Qgc29sdXRpb24gd291bGQgcmVxdWlyZSBtb3JlIGNvbXBsZXggcGFyc2luZy5cclxuICAgICAgaWYgKGNoYXIgPT09ICcvJykge1xyXG4gICAgICAgICAgLy8gVmVyeSBiYXNpYyBjaGVjayB0byBkaWZmZXJlbnRpYXRlIGRpdmlzaW9uIGZyb20gcmVnZXggc3RhcnQuXHJcbiAgICAgICAgICAvLyBUaGlzIG1pZ2h0IG5lZWQgcmVmaW5lbWVudCBmb3IgY29tcGxleCBjYXNlcy5cclxuICAgICAgICAgIGNvbnN0IHByZXZNZWFuaW5nZnVsQ2hhciA9IGNsZWFuZWRDb2RlLnRyaW0oKS5zbGljZSgtMSk7XHJcbiAgICAgICAgICBpZiAocHJldk1lYW5pbmdmdWxDaGFyID09PSAnJyB8fCBbJygnLCAnLCcsICc9JywgJzonLCAnWycsICchJywgJyYnLCAnfCcsICc/JywgJ3snLCAnOycsICdcXG4nLCAnXFxyJ10uaW5jbHVkZXMocHJldk1lYW5pbmdmdWxDaGFyKSkge1xyXG4gICAgICAgICAgICAgIGluUmVnRXhwID0gdHJ1ZTtcclxuICAgICAgICAgICAgICBjbGVhbmVkQ29kZSArPSBjaGFyO1xyXG4gICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvLyBJZiBub25lIG9mIHRoZSBhYm92ZSwgaXQncyByZWd1bGFyIGNvZGU7IGFkZCBpdCB0byB0aGUgcmVzdWx0XHJcbiAgICAgIGNsZWFuZWRDb2RlICs9IGNoYXI7XHJcbiAgICAgIGkrKztcclxuICAgIH1cclxuICBcclxuICAgIC8vIFJldHVybiB0aGUgYWNjdW11bGF0ZWQgY2xlYW5lZCBjb2RlIHN0cmluZ1xyXG4gICAgcmV0dXJuIGNsZWFuZWRDb2RlO1xyXG4gIH1cclxuICBleHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUZvbGRlcihhcHA6IEFwcCwgZm9sZGVyX3N0cjogc3RyaW5nKTogVEZvbGRlciB7XHJcbiAgICBmb2xkZXJfc3RyID0gbm9ybWFsaXplUGF0aChmb2xkZXJfc3RyKTtcclxuXHJcbiAgICBjb25zdCBmb2xkZXIgPSBhcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGZvbGRlcl9zdHIpO1xyXG4gICAgaWYgKCFmb2xkZXIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3JNYW5hZ2VyKGBGb2xkZXIgXCIke2ZvbGRlcl9zdHJ9XCIgZG9lc24ndCBleGlzdGApO1xyXG4gICAgfVxyXG4gICAgaWYgKCEoZm9sZGVyIGluc3RhbmNlb2YgVEZvbGRlcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3JNYW5hZ2VyKGAke2ZvbGRlcl9zdHJ9IGlzIGEgZmlsZSwgbm90IGEgZm9sZGVyYCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZvbGRlcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVGaWxlKGFwcDogQXBwLCBmaWxlX3N0cjogc3RyaW5nKTogVEZpbGUge1xyXG4gICAgZmlsZV9zdHIgPSBub3JtYWxpemVQYXRoKGZpbGVfc3RyKTtcclxuXHJcbiAgICBjb25zdCBmaWxlID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChmaWxlX3N0cik7XHJcbiAgICBpZiAoIWZpbGUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3JNYW5hZ2VyKGBGaWxlIFwiJHtmaWxlX3N0cn1cIiBkb2Vzbid0IGV4aXN0YCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yTWFuYWdlcihgJHtmaWxlX3N0cn0gaXMgYSBmb2xkZXIsIG5vdCBhIGZpbGVgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmlsZTtcclxufVxyXG4gIGV4cG9ydCBmdW5jdGlvbiBnZXRGaWxlc0Zyb21Gb2xkZXIoXHJcbiAgICBhcHA6IEFwcCxcclxuICAgIGZvbGRlcl9zdHI6IHN0cmluZ1xyXG4gICk6IEFycmF5PFRGaWxlPiB7XHJcbiAgICBjb25zdCBmb2xkZXIgPSByZXNvbHZlRm9sZGVyKGFwcCwgZm9sZGVyX3N0cik7XHJcblxyXG4gICAgY29uc3QgZmlsZXM6IEFycmF5PFRGaWxlPiA9IFtdO1xyXG4gICAgVmF1bHQucmVjdXJzZUNoaWxkcmVuKGZvbGRlciwgKGZpbGU6IFRBYnN0cmFjdEZpbGUpID0+IHtcclxuICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcbiAgICAgICAgICAgIGZpbGVzLnB1c2goZmlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgZmlsZXMuc29ydCgoYSwgYikgPT4geyAgXHJcbiAgICAgICAgcmV0dXJuIGEucGF0aC5sb2NhbGVDb21wYXJlKGIucGF0aCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gZmlsZXM7XHJcbn1cclxuICBleHBvcnQgY2xhc3MgU2NyaXB0aW5nVG9vbHMge1xyXG4gICAgYXBwOiBBcHAgfCB1bmRlZmluZWQ7XHJcbiAgICBwbHVnaW46IGFueTsgLy9Gb2xkZXJUYWdQbHVnaW47XHJcbiAgICBzZXR0aW5nczogRm9sZGVyVGFnU2V0dGluZ3MgfCB1bmRlZmluZWQ7XHJcbiAgICBydWxlOiBGb2xkZXJUYWdSdWxlRGVmaW5pdGlvbiB8IHVuZGVmaW5lZDtcclxuICAgIGZyb250bWF0dGVyOiBhbnk7XHJcbiAgICBjdXJyZW50Q29udGVudDogYW55O1xyXG4gICAgYWN0aXZlRmlsZTogVEZpbGUgfCB1bmRlZmluZWQ7XHJcbiAgICBrbm93blByb3BlcnRpZXM6IFJlY29yZDxzdHJpbmcsIFByb3BlcnR5SW5mbz47XHJcblxyXG4gICAgY29uc3RydWN0b3IoYXBwPzpBcHAsIHBsdWdpbj86YW55LCBzZXR0aW5ncz86Rm9sZGVyVGFnU2V0dGluZ3MsIHJ1bGU/OiBGb2xkZXJUYWdSdWxlRGVmaW5pdGlvbiwgZnJvbnRtYXR0ZXI/OiBhbnksIGFjdGl2ZUZpbGU/OiBURmlsZSkge1xyXG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xyXG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5nc1xyXG4gICAgICAgIHRoaXMucnVsZSA9IHJ1bGU7XHJcbiAgICAgICAgdGhpcy5mcm9udG1hdHRlciA9IGZyb250bWF0dGVyO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRmlsZSA9IGFjdGl2ZUZpbGU7XHJcbiAgICB9XHJcbiAgICBnZXRGcm9udG1hdHRlcigpIHsgXHJcbiAgICAgIHJldHVybiB0aGlzLmZyb250bWF0dGVyO1xyXG4gICAgfVxyXG4gICAgc2V0RnJvbnRtYXR0ZXIoZnJvbnRtYXR0ZXI6YW55KSB7XHJcbiAgICAgICAgdGhpcy5mcm9udG1hdHRlciA9IGZyb250bWF0dGVyO1xyXG4gICAgfVxyXG4gICAgc2V0RnJvbnRtYXR0ZXJQcm9wZXJ0eShrZXk6c3RyaW5nLCB2YWx1ZTphbnkpIHtcclxuICAgICAgaWYgKCF0aGlzLmZyb250bWF0dGVyKSB0aGlzLmZyb250bWF0dGVyID0ge307XHJcbiAgICAgIHRoaXMuZnJvbnRtYXR0ZXJba2V5XSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0RnJvbnRtYXR0ZXJQcm9wZXJ0eShrZXk6c3RyaW5nKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZyb250bWF0dGVyW2tleV1cclxuICAgIH1cclxuICAgIHNldEFjdGl2ZUZpbGUoZmlsZTpURmlsZSkge1xyXG4gICAgICB0aGlzLmFjdGl2ZUZpbGUgPSBmaWxlO1xyXG4gICAgfVxyXG4gICAgZ2V0QWN0aXZlRmlsZSgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlRmlsZTtcclxuICAgIH1cclxuICAgIHNldFJ1bGUocnVsZTpGb2xkZXJUYWdSdWxlRGVmaW5pdGlvbikge1xyXG4gICAgICB0aGlzLnJ1bGUgPSBydWxlO1xyXG4gICAgfVxyXG4gICAgZ2V0UnVsZSgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucnVsZTtcclxuICAgIH1cclxuICAgIGdldFJ1bGVGdW5jdGlvbihydWxlPzpGb2xkZXJUYWdSdWxlRGVmaW5pdGlvbikge1xyXG4gICAgICBpZiAoIXJ1bGUpIHJ1bGUgPSB0aGlzLnJ1bGU7XHJcbiAgICAgIGlmIChydWxlKSB7XHJcbiAgICAgICAgY29uc3QgZnVuY3Rpb25JbmRleCA9IHJ1bGVGdW5jdGlvbnMuZmluZEluZGV4KGZ4ID0+IGZ4LmlkID09PSBydWxlLmNvbnRlbnQpO1xyXG4gICAgICAgICAgaWYgKGZ1bmN0aW9uSW5kZXghPT0tMSl7XHJcbiAgICAgICAgICAgIHJldHVybiBydWxlRnVuY3Rpb25zW2Z1bmN0aW9uSW5kZXhdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldEN1cnJlbnRDb250ZW50KGNvbnRlbnQ6YW55KSB7XHJcbiAgICAgIHRoaXMuY3VycmVudENvbnRlbnQgPSBjb250ZW50O1xyXG4gICAgfVxyXG4gICAgZ2V0Q3VycmVudENvbnRlbnQoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRDb250ZW50O1xyXG4gICAgfVxyXG4gICAgdXBkYXRlRnJvbnRtYXR0ZXIocHJvcGVydHksIG5ld0NvbnRlbnQsIGZpbGU/OlRGaWxlKSB7XHJcbiAgICAgIGlmICghdGhpcy5hcHApIHJldHVybjtcclxuICAgICAgaWYgKCFmaWxlKSBmaWxlID0gdGhpcy5hY3RpdmVGaWxlO1xyXG4gICAgICBpZiAoIWZpbGUpIHJldHVybjtcclxuICAgICAgdGhpcy5hcHAuZmlsZU1hbmFnZXIucHJvY2Vzc0Zyb250TWF0dGVyKGZpbGUsIChmcm9udG1hdHRlcikgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGB1cGRhdGVGcm9udG1hdHRlciAnJHtmaWxlLnBhdGh9JyBmcm9udG1hdHRlciAnJHtwcm9wZXJ0eX0nIHRvICcke25ld0NvbnRlbnQudG9TdHJpbmcoKX0nYCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdDb250ZW50ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShuZXdDb250ZW50KSkge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKGB1cGRhdGVGcm9udG1hdHRlciAnJHtmaWxlLnBhdGh9J3wnJHtwcm9wZXJ0eX0nIG9iamVjdCBub3Qgc3VwcG9ydGVkIWApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBmcm9udG1hdHRlcltwcm9wZXJ0eV0gPSBuZXdDb250ZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgfSx7J210aW1lJzpmaWxlLnN0YXQubXRpbWV9KTsgLy8gZG8gbm90IGNoYW5nZSB0aGUgbW9kaWZ5IHRpbWUuXHJcbiAgICB9XHJcbiAgICBhc3luYyBzaG93Q29uZmlybURpYWxvZyhtZXNzYWdlOnN0cmluZywgdGl0bGU6c3RyaW5nID0gJ0NvbmZpcm0nLCBidXR0b24xOnN0cmluZyA9ICdZZXMnLCBidXR0b24yOnN0cmluZyA9ICdObycpIHtcclxuICAgICAgY29uc3QgcmVzdWx0ID0gIGF3YWl0IG5ldyBBbGVydE1vZGFsKHRoaXMuYXBwISwgdGl0bGUsIG1lc3NhZ2UsIGJ1dHRvbjEsIGJ1dHRvbjIpLm9wZW5BbmRHZXRWYWx1ZSgpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0LnByb2NlZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICogR2V0IHRoZSBvcHRpb24gY29uZmlnIGZvciBhIHNwZWNpZmljIHJ1bGUuIE9wdGlvbmFsIHRoZSBzcGVjaWZpYyBwYXJhbWV0ZXIgYnkgcHJvdmlkaW5nIGFuIG9wdGlvbiBJRC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcnVsZUlkXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbklkXVxyXG4gICAgICogQHJldHVybiB7Kn0gXHJcbiAgICAgKiBAbWVtYmVyb2YgU2NyaXB0aW5nVG9vbHNcclxuICAgICAqL1xyXG4gICAgZ2V0T3B0aW9uQ29uZmlnKHJ1bGVJZDpzdHJpbmd8dW5kZWZpbmVkLCBvcHRpb25JZD86c3RyaW5nKXtcclxuICAgICAgaWYgKCFydWxlSWQgfHwgcnVsZUlkID09PSB1bmRlZmluZWQgfHwgIXRoaXMuc2V0dGluZ3MgKSByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICBjb25zdCBydWxlID0gdGhpcy5zZXR0aW5ncy5ydWxlcy5maW5kKChydWxlOiBGb2xkZXJUYWdSdWxlRGVmaW5pdGlvbikgPT4gcnVsZS5pZCA9PT0gcnVsZUlkKTtcclxuICAgICAgaWYgKHJ1bGUgJiYgcnVsZS5oYXNPd25Qcm9wZXJ0eSgnb3B0aW9uc0NvbmZpZycpKSB7XHJcbiAgICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICAgIGNvbnN0IG9wdGlvbkNvbmZpZyA9IHJ1bGUub3B0aW9uc0NvbmZpZ1tydWxlSWRdXHJcbiAgICAgICAgICBpZiAob3B0aW9uQ29uZmlnKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25JZCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBvcHRpb25Db25maWdbb3B0aW9uSWRdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJldHVybiBvcHRpb25Db25maWc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEZpbGVzSW5WYXVsdChtYXRjaGluZzogc3RyaW5nKTogVEZpbGVbXSB7XHJcbiAgICAgICAgbWF0Y2hpbmcgPSBtYXRjaGluZy5yZXBsYWNlKC9eXFwvfFxcLyQvZywgXCJcIikgKyAnLyc7IC8vIEVuc3VyZSBpdCBlbmRzIHdpdGggYSAnLydcclxuICAgICAgICBjb25zdCBmaWxlcyA9IHRoaXMuYXBwIS52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCk7IC8vIFJldHJpZXZlIGFsbCBtYXJrZG93biBmaWxlc1xyXG4gICAgICAgIGNvbnN0IG1hdGNoaW5nRmlsZXMgPSBmaWxlcy5maWx0ZXIoZmlsZSA9PiBmaWxlIGluc3RhbmNlb2YgVEZpbGUgJiYgZmlsZS5wYXRoLmluY2x1ZGVzKG1hdGNoaW5nKSk7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoaW5nRmlsZXM7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RmlsZUZyb21QYXRoKHBhdGg6IHN0cmluZywgZmlsZXNDaGVjazogVEZpbGVbXSB8IHVuZGVmaW5lZCkge1xyXG4gICAgICBjb25zdCBmaWxlcyA9IGZpbGVzQ2hlY2sgPyBmaWxlc0NoZWNrIDogdGhpcy5hcHAhLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKTsgLy8gUmV0cmlldmUgYWxsIG1hcmtkb3duIGZpbGVzXHJcbiAgICAgIGNvbnN0IG1hdGNoaW5nRmlsZXMgPSBmaWxlcy5maWx0ZXIoZmlsZSA9PiBcclxuICAgICAgICBmaWxlIGluc3RhbmNlb2YgVEZpbGUgJiYgXHJcbiAgICAgICAgZmlsZS5wYXRoLnRvTG9jYWxlTG93ZXJDYXNlKCkuaW5jbHVkZXMocGF0aC50b0xvY2FsZUxvd2VyQ2FzZSgpKVxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gbWF0Y2hpbmdGaWxlcy5sZW5ndGggPiAwID8gbWF0Y2hpbmdGaWxlc1swXSA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGFzeW5jIGNyZWF0ZUZpbGVGcm9tUGF0aChmaWxlTmFtZVdpdGhQYXRoOnN0cmluZywgdGVtcGxhdGVGaWxlV2l0aFBhdGg6c3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgZmlsZU5hbWUgPSBmaWxlTmFtZVdpdGhQYXRoLnJlcGxhY2UoL15cXC98XFwvJC9nLCBcIlwiKTsgLy8gUmVtb3ZlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXNcclxuICAgICAgICBjb25zdCB0ZW1wbGF0ZUZpbGUgPSB0ZW1wbGF0ZUZpbGVXaXRoUGF0aC5yZXBsYWNlKC9eXFwvfFxcLyQvZywgXCJcIik7IC8vIFJlbW92ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzXHJcbiAgICAgICAgY29uc3QgZm9sZGVyUGF0aCA9IHRoaXMuZ2V0Rm9sZGVyRnJvbVBhdGgoZmlsZU5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGZpbGVOYW1lT25seSA9IGZpbGVOYW1lLnNwbGl0KCcvJykucG9wKCkgfHwgZmlsZU5hbWU7IC8vIEdldCB0aGUgbGFzdCBwYXJ0IG9mIHRoZSBwYXRoIGFzIHRoZSBmaWxlIG5hbWVcclxuICAgICAgICBpZiAoIWZvbGRlclBhdGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yTWFuYWdlcihgSW52YWxpZCBmb2xkZXIgcGF0aDogXCIke2ZvbGRlclBhdGh9XCJgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZm9sZGVyID0gdGhpcy5hcHAhLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChmb2xkZXJQYXRoKSBhcyBURm9sZGVyO1xyXG4gICAgICAgIGlmICghZm9sZGVyKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvck1hbmFnZXIoYEZvbGRlciBcIiR7Zm9sZGVyUGF0aH1cIiBkb2Vzbid0IGV4aXN0YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKGZvbGRlciBpbnN0YW5jZW9mIFRGb2xkZXIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvck1hbmFnZXIoYCR7Zm9sZGVyUGF0aH0gaXMgYSBmaWxlLCBub3QgYSBmb2xkZXJgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGVtcGxhdGVDb250ZW50ID0gYXdhaXQgdGhpcy5hcHAhLnZhdWx0LnJlYWQodGhpcy5hcHAhLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCh0ZW1wbGF0ZUZpbGUpIGFzIFRGaWxlKTtcclxuICAgICAgICBjb25zdCBmaWxlRXhpc3RzID0gdGhpcy5hcHAhLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChmaWxlTmFtZVdpdGhQYXRoKSBhcyBURmlsZTtcclxuICAgICAgICBpZiAoIWZpbGVFeGlzdHMpIHtcclxuICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmFwcCEudmF1bHQuY3JlYXRlKGZvbGRlci5wYXRoICsgJy8nICsgZmlsZU5hbWVPbmx5LCB0ZW1wbGF0ZUNvbnRlbnQpOyAvLyBjcmVhdGUgdGhlIGZpbGUgZnJvbSB0aGUgdGVtcGxhdGVcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZpbGVFeGlzdHM7IC8vIHJldHVybiB0aGUgZmlsZSBpZiBpdCBhbHJlYWR5IGV4aXN0c1xyXG4gICAgfTsgLy8gY3JlYXRlIHRoZSBmaWxlIGlmIGl0IGRvZXMgbm90IGV4aXN0XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAqIEZldGNoZXMgY3VzdG9tIHByb3BlcnR5IGluZm9ybWF0aW9uIGZyb20gYWxsIG1hcmtkb3duIGZpbGVzIGluIHRoZSB2YXVsdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHsqfSBcclxuICAgICAqL1xyXG4gICAgZmV0Y2hDdXN0b21Qcm9wZXJ0eUluZm9zKGFwcDpBcHApOiBSZWNvcmQ8c3RyaW5nLCBQcm9wZXJ0eUluZm8+IHtcclxuICAgICAgICBjb25zdCBwcm9wZXJ0eUluZm9zOiBSZWNvcmQ8c3RyaW5nLCBQcm9wZXJ0eUluZm8+ID0ge307XHJcblxyXG4gICAgICAgIGNvbnN0IGZpbGVzID0gYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKTsgLy8gUmV0cmlldmUgYWxsIG1hcmtkb3duIGZpbGVzXHJcbiAgICAgICAgZmlsZXMuZm9yRWFjaChmaWxlID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk7XHJcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YT8uZnJvbnRtYXR0ZXIpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG1ldGFkYXRhLmZyb250bWF0dGVyKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wZXJ0eUluZm9zW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlJbmZvc1trZXldID0geyBuYW1lOiBrZXksIHR5cGU6ICd0ZXh0JyB9OyAvLyBEZWZhdWx0IHR5cGUgYXMgJ3RleHQnXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5SW5mb3M7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZldGNoZXMga25vd24gcHJvcGVydGllcyBmcm9tIHRoZSBtZXRhZGF0YSBjYWNoZS5cclxuICAgICAqIElmIHRoZSBtZXRob2QgZ2V0QWxsUHJvcGVydHlJbmZvcyBpcyBub3QgYXZhaWxhYmxlLCBpdCBmYWxscyBiYWNrIHRvIGZldGNoQ3VzdG9tUHJvcGVydHlJbmZvcy5cclxuICAgICAqIEBwYXJhbSBhcHAgVGhlIE9ic2lkaWFuIGFwcCBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZmV0Y2hLbm93blByb3BlcnRpZXMoYXBwOkFwcCkge1xyXG4gICAgICBsZXQgcHJvcGVydHlJbmZvczogUmVjb3JkPHN0cmluZywgUHJvcGVydHlJbmZvPiA9IHt9O1xyXG4gICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgIGlmICh0eXBlb2YgYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0QWxsUHJvcGVydHlJbmZvcyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgcHJvcGVydHlJbmZvcyA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEFsbFByb3BlcnR5SW5mb3MoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwcm9wZXJ0eUluZm9zID0gdGhpcy5mZXRjaEN1c3RvbVByb3BlcnR5SW5mb3MoYXBwKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBzb3J0IHRoZSBwcm9wZXJ0aWVzIGJ5IG5hbWVcclxuICAgICAgcHJvcGVydHlJbmZvcyA9IE9iamVjdC5mcm9tRW50cmllcyhcclxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHByb3BlcnR5SW5mb3MpLnNvcnQoKFtrZXlBXSwgW2tleUJdKSA9PiBrZXlBLmxvY2FsZUNvbXBhcmUoa2V5QikpXHJcbiAgICAgICk7XHJcbiAgICAgIC8vIHJlc3RvcmUgdG8ga2VlcCBwcm9wZXJ0aWVzIHRvIGNhc2Ugc2Vuc2l0aXZlXHJcbiAgICAgIHRoaXMua25vd25Qcm9wZXJ0aWVzID0ge307XHJcbiAgICAgIE9iamVjdC5rZXlzKHByb3BlcnR5SW5mb3MpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICB0aGlzLmtub3duUHJvcGVydGllc1twcm9wZXJ0eUluZm9zW2tleV0ubmFtZV0gPSBwcm9wZXJ0eUluZm9zW2tleV07XHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zb2xlLmxvZyh0aGlzLmtub3duUHJvcGVydGllcyk7XHJcbiAgICAgIHJldHVybiB0aGlzLmtub3duUHJvcGVydGllcztcclxuICAgIH1cclxuICAgIFxyXG4gICAgZ2V0S25vd25Qcm9wZXJ0aWVzKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5rbm93blByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5rbm93blByb3BlcnRpZXMgPSB0aGlzLmZldGNoQ3VzdG9tUHJvcGVydHlJbmZvcyh0aGlzLmFwcCEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5rbm93blByb3BlcnRpZXM7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGV4dHJhY3RMaW5rUGFydHMobGluazogc3RyaW5nKTogeyBwYXRoOiBzdHJpbmc7IHRpdGxlOiBzdHJpbmcgfSB7XHJcbiAgICAgIC8vIFJlbW92ZSBhbGwgc3F1YXJlIGJyYWNrZXRzIGZyb20gdGhlIHN0cmluZ1xyXG4gICAgICBjb25zdCBjbGVhbmVkTGluayA9IGxpbmsucmVwbGFjZSgvW1xcW1xcXV0vZywgXCJcIik7XHJcbiAgXHJcbiAgICAgIC8vIFNwbGl0IHRoZSBzdHJpbmcgYnkgdGhlIFwifFwiIGNoYXJhY3RlclxyXG4gICAgICBjb25zdCBwYXJ0cyA9IGNsZWFuZWRMaW5rLnNwbGl0KFwifFwiKTtcclxuICBcclxuICAgICAgLy8gSWYgb25seSBvbmUgcGFydCBleGlzdHMsIHVzZSBpdCBhcyBib3RoIHBhdGggYW5kIHRpdGxlXHJcbiAgICAgIGNvbnN0IHBhdGggPSBwYXJ0c1swXS50cmltKCk7XHJcbiAgICAgIGNvbnN0IHRpdGxlID0gcGFydHMubGVuZ3RoID4gMSA/IHBhcnRzWzFdLnRyaW0oKSA6IHBhdGg7XHJcbiAgICAgIC8vY29uc29sZS5sb2coYGV4dHJhY3RMaW5rUGFydHMoJHtsaW5rfSkgLT4gcGF0aDogJHtwYXRofSwgdGl0bGU6ICR7dGl0bGV9YCk7XHJcbiAgICAgIHJldHVybiB7IHBhdGgsIHRpdGxlIH07XHJcbiAgICB9XHJcbiAgICByZW1vdmVMZWFkaW5nU2xhc2gocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXlxcLysvLCBcIlwiKTtcclxuICAgIH1cclxuICAgIGFkZExlYWRpbmdTbGFzaChwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9eKD8hXFwvKS8sIFwiL1wiKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgYSBzdHJpbmcgY29tcGxpZXMgd2l0aCBJU08gU3RhbmRhcmRcclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHN0ciBBbnkgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHRvIGxvb2sgZm9yXHJcbiAgICAgKiBAcmV0dXJucyBcclxuICAgICAqL1xyXG4gICAgaXNJU09TdHJpbmcoXHJcbiAgICAgIHN0cjogc3RyaW5nLFxyXG4gICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgd2l0aE1pbGxpc2Vjb25kcz86IGJvb2xlYW47XHJcbiAgICAgICAgd2l0aFRpbWV6b25lPzogYm9vbGVhbjtcclxuICAgICAgICB3aXRoVGltZT86IGJvb2xlYW47XHJcbiAgICAgICAgd2l0aERhdGU/OiBib29sZWFuOyBcclxuICAgICAgfSA9IHt9XHJcbiAgICApOiBib29sZWFuIHtcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIHdpdGhNaWxsaXNlY29uZHMgPSBmYWxzZSxcclxuICAgICAgICB3aXRoVGltZXpvbmUgPSBmYWxzZSxcclxuICAgICAgICB3aXRoVGltZSA9IHRydWUsXHJcbiAgICAgICAgd2l0aERhdGUgPSB0cnVlLCBcclxuICAgICAgfSA9IG9wdGlvbnM7XHJcbiAgICBcclxuICAgICAgbGV0IGRhdGVSZWdleFN0ciA9IFwiXig/OlxcXFxkezR9LSg/OjBbMS05XXwxWzAtMl0pLSg/OjBbMS05XXxbMTJdXFxcXGR8M1swMV0pKVwiO1xyXG4gICAgICBsZXQgdGltZVJlZ2V4U3RyID0gXCIoPzpUKD86WzAxXVxcXFxkfDJbMC0zXSk6WzAtNV1cXFxcZDpbMC01XVxcXFxkXCI7XHJcbiAgICBcclxuICAgICAgaWYgKHdpdGhNaWxsaXNlY29uZHMpIHtcclxuICAgICAgICB0aW1lUmVnZXhTdHIgKz0gXCJcXFxcLlxcXFxkezN9XCI7XHJcbiAgICAgIH1cclxuICAgIFxyXG4gICAgICBpZiAod2l0aFRpbWV6b25lKSB7XHJcbiAgICAgICAgdGltZVJlZ2V4U3RyICs9IFwiKD86WnxbKy1dKD86WzAxXVxcXFxkfDJbMC0zXSk6WzAtNV1cXFxcZCk/KT9cIjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aW1lUmVnZXhTdHIgKz0gXCIpP1wiO1xyXG4gICAgICB9XHJcbiAgICBcclxuICAgICAgbGV0IHJlZ2V4U3RyID0gXCJcIjtcclxuICAgICAgaWYgKHdpdGhEYXRlICYmIHdpdGhUaW1lKSB7XHJcbiAgICAgICAgcmVnZXhTdHIgPSBgJHtkYXRlUmVnZXhTdHJ9JHt0aW1lUmVnZXhTdHJ9JGA7XHJcbiAgICAgIH0gZWxzZSBpZiAod2l0aERhdGUpIHtcclxuICAgICAgICByZWdleFN0ciA9IGAke2RhdGVSZWdleFN0cn0kYDtcclxuICAgICAgfSBlbHNlIGlmICh3aXRoVGltZSkge1xyXG4gICAgICAgIHJlZ2V4U3RyID0gYF4ke3RpbWVSZWdleFN0ci5zbGljZSg0KX0kYDsgXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlOyBcclxuICAgICAgfVxyXG4gICAgXHJcbiAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChyZWdleFN0cik7XHJcbiAgICAgIHJldHVybiByZWdleC50ZXN0KHN0cik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyeSB0byBjb252ZXJ0IEFueSBUeXBlcyB0byBhIHNwZWNpZmljIFR5cGVcclxuICAgICAqIEBwYXJhbSBpbnB1dCBcclxuICAgICAqIEBwYXJhbSB0eXBlU3RyaW5nICdzdHJpbmcnIHwgJ251bWJlcicgfCAnYm9vbGVhbicgfCAnc3RyaW5nW10nXHJcbiAgICAgKiBAcmV0dXJucyBcclxuICAgICAqL1xyXG4gICAgdHJ5Q29udmVydChpbnB1dDogYW55LCB0eXBlU3RyaW5nOiAnc3RyaW5nJyB8ICdudW1iZXInIHwgJ2Jvb2xlYW4nIHwgJ3N0cmluZ1tdJyk6IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBzdHJpbmdbXSB8IHVuZGVmaW5lZCB7XHJcbiAgICAgIHN3aXRjaCAodHlwZVN0cmluZykge1xyXG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIGNhc2UgJ251bWJlcic6XHJcbiAgICAgICAgICBjb25zdCBudW0gPSBOdW1iZXIoaW5wdXQpO1xyXG4gICAgICAgICAgaWYgKCFpc05hTihudW0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gaW5wdXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICBjb25zdCBsb3dlclZhbHVlID0gaW5wdXQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICBpZiAobG93ZXJWYWx1ZSA9PT0gJ3RydWUnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKGxvd2VyVmFsdWUgPT09ICdmYWxzZScpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICBpZiAoaW5wdXQgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoaW5wdXQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICBjYXNlICdzdHJpbmdbXSc6XHJcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkgJiYgaW5wdXQuZXZlcnkoaXRlbSA9PiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgZm9ybWF0VG9ZQU1MU2F2ZVN0cmluZyh0ZXh0OnN0cmluZywgcmVwbGFjZUJ5OnN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCk6c3RyaW5nIHtcclxuICAgICAgbGV0IHJlcGxhY2VTdHJpbmcgPSAnLSc7XHJcbiAgICAgIGlmICghcmVwbGFjZUJ5ICYmIHRoaXMuc2V0dGluZ3MpIHtcclxuICAgICAgICByZXBsYWNlU3RyaW5nID0gdGhpcy5zZXR0aW5ncy5zcGVjaWFsQ2hhclJlcGxhY2VtZW50IHx8ICctJztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAocmVwbGFjZUJ5KSByZXBsYWNlU3RyaW5nID0gcmVwbGFjZUJ5O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1teYS16QS1aMC05XFwtX1xcL1x1MDBFNFx1MDBGNlx1MDBGQ1x1MDBERlx1MDBDNFx1MDBENlx1MDBEQ1x1MDBFMVx1MDBFOVx1MDBFRFx1MDBGM1x1MDBGQVx1MDBGRFx1MDBDMVx1MDBDOVx1MDBDRFx1MDBEM1x1MDBEQVx1MDBERFx1MDBFMFx1MDBFOFx1MDBFQ1x1MDBGMlx1MDBGOVx1MDBDMFx1MDBDOFx1MDBDQ1x1MDBEMlx1MDBEOVx1MDBFMlx1MDBFQVx1MDBFRVx1MDBGNFx1MDBGQlx1MDBDMlx1MDBDQVx1MDBDRVx1MDBENFx1MDBEQlx1MDBFM1x1MDBGMVx1MDBGNVx1MDBDM1x1MDBEMVx1MDBENV0vZywgcmVwbGFjZVN0cmluZyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYSBzdHJpbmcgdG8gYSBZQU1MLXNhZmUgZm9ybWF0IGJ5IGFkZGluZyBxdW90ZXMgd2hlbiBuZWNlc3NhcnkuXHJcbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIHN0cmluZywgYm9vbGVhbiwgbnVtYmVyIG9yIGFycmF5IHRvIG1ha2UgWUFNTC1zYWZlXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgc2FmZWx5IHF1b3RlZCBzdHJpbmcgd2hlbiBuZWVkZWQsIG9yIHRoZSBvcmlnaW5hbCBzdHJpbmcgaWYgc2FmZVxyXG4gICAgICovXHJcbiAgICB0b1lhbWxTYWZlU3RyaW5nKGlucHV0OiBzdHJpbmd8bnVtYmVyfGJvb2xlYW58c3RyaW5nW10pOiBzdHJpbmd8bnVtYmVyfHN0cmluZ1tdIHtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XHJcbiAgICAgICAgaW5wdXQuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgIGlucHV0W2luZGV4XSA9IHRoaXMudG9ZYW1sU2FmZVN0cmluZyhpdGVtKS50b1N0cmluZygpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgcmV0dXJuIGlucHV0O1xyXG4gICAgICB9XHJcbiAgICAgIHN3aXRjaCAodHlwZW9mIGlucHV0KSB7XHJcbiAgICAgICAgY2FzZSAnbnVtYmVyJzogcmV0dXJuIGlucHV0O1xyXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOiByZXR1cm4gaW5wdXQgPyAndHJ1ZScgOiAnZmFsc2UnO1xyXG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgICAgICAvLyBUcmltIHdoaXRlc3BhY2UgZmlyc3RcclxuICAgICAgICAgIGNvbnN0IHRyaW1tZWQgPSBpbnB1dC50cmltKCk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIEVtcHR5IHN0cmluZ3MgbmVlZCBxdW90ZXNcclxuICAgICAgICAgIGlmICh0cmltbWVkID09PSAnJykgcmV0dXJuICdcIlwiJztcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIHNwZWNpYWwgY2hhcmFjdGVycy9wYXR0ZXJucyB0aGF0IHJlcXVpcmUgcXVvdGluZ1xyXG4gICAgICAgICAgY29uc3QgbmVlZHNRdW90ZXMgPSAvWzp7fVxcW1xcXSwmKiM/fDw+PSElQGBcIidcXFxcXXxeWy0/XFxuXXxbXFxzXFxuXXxeW3lZbk5dfF5bMC05XXxeWystXXxeKHRydWV8ZmFsc2V8eWVzfG5vfG9ufG9mZikkL2kudGVzdCh0cmltbWVkKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHN0cmluZyBpcyBhbHJlYWR5IHByb3Blcmx5IHF1b3RlZFxyXG4gICAgICAgICAgY29uc3QgaXNBbHJlYWR5UXVvdGVkID0gKHRyaW1tZWQuc3RhcnRzV2l0aCgnXCInKSAmJiB0cmltbWVkLmVuZHNXaXRoKCdcIicpKSB8fCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodHJpbW1lZC5zdGFydHNXaXRoKFwiJ1wiKSAmJiB0cmltbWVkLmVuZHNXaXRoKFwiJ1wiKSk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmICghbmVlZHNRdW90ZXMgJiYgIWlzQWxyZWFkeVF1b3RlZCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiB0cmltbWVkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgd2UgbmVlZCBxdW90ZXNcclxuICAgICAgICAgIC8vIFVzZSBkb3VibGUgcXVvdGVzIGFuZCBlc2NhcGUgYW55IGV4aXN0aW5nIGRvdWJsZSBxdW90ZXNcclxuICAgICAgICAgIGlmICghaXNBbHJlYWR5UXVvdGVkKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGBcIiR7dHJpbW1lZC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJyl9XCJgO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBJZiBhbHJlYWR5IHF1b3RlZCwgcmV0dXJuIGFzLWlzXHJcbiAgICAgICAgICByZXR1cm4gdHJpbW1lZDtcclxuICAgICAgICBkZWZhdWx0OiBcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYHRvWWFtbFNhZmVTdHJpbmcoJHtpbnB1dH0pIGlmIG9mIHR5cGUgJyR7dHlwZW9mIGlucHV0fSdgKTtcclxuICAgICAgICAgIHJldHVybiBpbnB1dDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlcGxhY2VTcGFjZXModGV4dDpzdHJpbmcsIHJlcGxhY2VCeTpzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQpOnN0cmluZyB7XHJcbiAgICAgIGxldCByZXBsYWNlU3RyaW5nID0gJ18nO1xyXG4gICAgICBpZiAoIXJlcGxhY2VCeSAmJiB0aGlzLnNldHRpbmdzKSB7XHJcbiAgICAgICAgcmVwbGFjZVN0cmluZyA9IHRoaXMuc2V0dGluZ3Muc3BhY2VSZXBsYWNlbWVudCB8fCAnXyc7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKHJlcGxhY2VCeSkgcmVwbGFjZVN0cmluZyA9IHJlcGxhY2VCeTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9cXHMrL2csIHJlcGxhY2VTdHJpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvcm1hdENhbWVsQ2FzZSh0ZXh0OnN0cmluZyk6c3RyaW5nIHtcclxuICAgICAgbGV0IHRleHRQYXJ0cyA9IHRleHQuc3BsaXQoJyAnKTtcclxuICAgICAgbGV0IGNvbnZlcnRlZFRleHRQYXJ0czpzdHJpbmdbXSA9IFtdO1xyXG4gICAgICB0ZXh0UGFydHMuZm9yRWFjaCgodGV4dCxpbmRleCkgPT4ge1xyXG4gICAgICAgIGxldCBuZXdUZXh0UGFydCA9IHRleHQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBpZiAoaW5kZXg+MCkgbmV3VGV4dFBhcnQgPSBuZXdUZXh0UGFydC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5ld1RleHRQYXJ0LnNsaWNlKDEpO1xyXG4gICAgICAgIGNvbnZlcnRlZFRleHRQYXJ0cy5wdXNoKG5ld1RleHRQYXJ0KTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBjb252ZXJ0ZWRUZXh0UGFydHMuam9pbignJyk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9ybWF0VXBwZXJDYW1lbENhc2UodGV4dDpzdHJpbmcpOnN0cmluZyB7XHJcbiAgICAgIGxldCB0ZXh0UGFydHMgPSB0ZXh0LnNwbGl0KCcgJyk7XHJcbiAgICAgIGxldCBjb252ZXJ0ZWRUZXh0UGFydHM6c3RyaW5nW10gPSBbXTtcclxuICAgICAgdGV4dFBhcnRzLmZvckVhY2goKHRleHQsaW5kZXgpID0+IHtcclxuICAgICAgICBsZXQgbmV3VGV4dFBhcnQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgbmV3VGV4dFBhcnQgPSBuZXdUZXh0UGFydC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5ld1RleHRQYXJ0LnNsaWNlKDEpO1xyXG4gICAgICAgIGNvbnZlcnRlZFRleHRQYXJ0cy5wdXNoKG5ld1RleHRQYXJ0KTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBjb252ZXJ0ZWRUZXh0UGFydHMuam9pbignJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQgdGhlIHBhdGggdG8gYSBmaWxlIGZyb20gYSBzdHJpbmcgY29udGFpbmluZyB0aGUgZnVsbCBwYXJoL25hbWUgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBzdHJpbmdcclxuICAgICAqIEBwYXJhbSBzZXBhcmF0b3Igc3RyaW5nIGRlZmF1bHRzIHRvICcvJ1xyXG4gICAgICogQHJldHVybnMgc3RyaW5nXHJcbiAgICAgKi9cclxuICAgIGdldEZvbGRlckZyb21QYXRoIChwYXRoOnN0cmluZ3xudWxsfHVuZGVmaW5lZCwgc2VwYXJhdG9yID0gJy8nKSB7XHJcbiAgICAgICAgaWYgKHBhdGggPT09IG51bGwpIHJldHVybiBudWxsO1xyXG4gICAgICAgIGlmIChwYXRoID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFBhdGhQYXJ0cyA9IHBhdGguc3BsaXQoJy8nKTtcclxuICAgICAgICBjdXJyZW50UGF0aFBhcnRzLnBvcCgpOyAvLyByZW1vdmUgRmlsZSBuYW1lO1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50UGF0aFBhcnRzLmpvaW4oc2VwYXJhdG9yKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiByZW1vdmVzIGR1cGxpY2F0ZSBzdHJpbmdzIGluIGFuIGFycmF5IGFuZCBkZWxldGVzIGVtcHR5IHN0cmluZ3NcclxuICAgICAqIEBwYXJhbSBzdHJpbmdBcnJheSBcclxuICAgICAqIEByZXR1cm5zIFxyXG4gICAgICovXHJcbiAgICByZW1vdmVEdXBsaWNhdGVTdHJpbmdzKHN0cmluZ0FycmF5OiBzdHJpbmdbXSk6IHN0cmluZ1tdIHtcclxuICAgICAgaWYgKCFzdHJpbmdBcnJheSkgcmV0dXJuIFtdO1xyXG4gICAgICBjb25zdCB1bmlxdWVTdHJpbmdzU2V0ID0gbmV3IFNldDxzdHJpbmc+KHN0cmluZ0FycmF5KTtcclxuICAgICAgdW5pcXVlU3RyaW5nc1NldC5kZWxldGUoJycpOyAvLyByZW1vdmUgZW1wdHkgc3RyaW5nc1xyXG4gICAgICByZXR1cm4gWy4uLnVuaXF1ZVN0cmluZ3NTZXRdO1xyXG4gICAgfVxyXG4gIH1cclxuLyoqXHJcbiAqIGdldCB0aGUgcGF0aCB0byBhIGZpbGUgZnJvbSBhIHN0cmluZyBjb250YWluaW5nIHRoZSBmdWxsIHBhcmgvbmFtZSBzdHJpbmdcclxuICogQHBhcmFtIHBhdGggc3RyaW5nXHJcbiAqIEBwYXJhbSBzZXBhcmF0b3Igc3RyaW5nIGRlZmF1bHRzIHRvICcvJ1xyXG4gKiBAcmV0dXJucyBzdHJpbmdcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRGb2xkZXJGcm9tUGF0aCAocGF0aDpzdHJpbmd8bnVsbHx1bmRlZmluZWQsIHNlcGFyYXRvciA9ICcvJykge1xyXG4gICAgaWYgKHBhdGggPT09IG51bGwpIHJldHVybiBudWxsO1xyXG4gICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IGN1cnJlbnRQYXRoUGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XHJcbiAgICBjdXJyZW50UGF0aFBhcnRzLnBvcCgpOyAvLyByZW1vdmUgRmlsZSBuYW1lO1xyXG4gICAgcmV0dXJuIGN1cnJlbnRQYXRoUGFydHMuam9pbihzZXBhcmF0b3IpO1xyXG59XHJcbiAgICAiLCAiaW1wb3J0IHsgTm90aWNlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBFcnJvck1hbmFnZXIgfSBmcm9tIFwiLi9FcnJvclwiO1xuXG5leHBvcnQgZnVuY3Rpb24gbG9nVXBkYXRlKG1zZzogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3Qgbm90aWNlID0gbmV3IE5vdGljZShcIlwiLCAxNTAwMCk7XG4gICAgbm90aWNlLm1lc3NhZ2VFbC5pbm5lckhUTUwgPSBgPGI+RnJvbnRtYXR0ZXIgQXV0b21hdGUgdXBkYXRlPC9iPjo8YnIvPiR7bXNnfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2dFcnJvcihlOiBFcnJvciB8IEVycm9yTWFuYWdlcik6IHZvaWQge1xuICAgIGNvbnN0IG5vdGljZSA9IG5ldyBOb3RpY2UoXCJcIiwgODAwMCk7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvck1hbmFnZXIgJiYgZS5jb25zb2xlX21zZykge1xuICAgICAgICBub3RpY2UubWVzc2FnZUVsLmlubmVySFRNTCA9IGA8Yj5Gcm9udG1hdHRlciBBdXRvbWF0ZSBFcnJvcjwvYj46PGJyLz4ke2UubWVzc2FnZX08YnIvPkNoZWNrIGNvbnNvbGUgZm9yIG1vcmUgaW5mb3JtYXRpb25gO1xuICAgICAgICBjb25zb2xlLmVycm9yKGBGcm9udG1hdHRlciBFcnJvcjpgLCBlLm1lc3NhZ2UsIFwiXFxuXCIsIGUuY29uc29sZV9tc2cpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vdGljZS5tZXNzYWdlRWwuaW5uZXJIVE1MID0gYDxiPkZyb250bWF0dGVyIEF1dG9tYXRlIEVycm9yPC9iPjo8YnIvPiR7ZS5tZXNzYWdlfWA7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IGxvZ0Vycm9yIH0gZnJvbSBcIi4vTG9nXCI7XG5cbmV4cG9ydCBjbGFzcyBFcnJvck1hbmFnZXIgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobXNnOiBzdHJpbmcsIHB1YmxpYyBjb25zb2xlX21zZz86IHN0cmluZykge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlcnJvcldyYXBwZXI8VD4oXG4gICAgZm46ICgpID0+IFByb21pc2U8VD4sXG4gICAgbXNnOiBzdHJpbmdcbik6IFByb21pc2U8VD4ge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBmbigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIEVycm9yTWFuYWdlcikpIHtcbiAgICAgICAgICAgIGxvZ0Vycm9yKG5ldyBFcnJvck1hbmFnZXIobXNnLCBlLm1lc3NhZ2UpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0Vycm9yKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsIGFzIFQ7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXJyb3JXcmFwcGVyU3luYzxUPihmbjogKCkgPT4gVCwgbXNnOiBzdHJpbmcpOiBUIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ0Vycm9yKG5ldyBFcnJvck1hbmFnZXIobXNnLCBlLm1lc3NhZ2UpKTtcbiAgICAgICAgcmV0dXJuIG51bGwgYXMgVDtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgTW9kYWwsIEFwcCwgU2V0dGluZyB9IGZyb20gJ29ic2lkaWFuJztcclxuXHJcbi8qKlxyXG4gKiBkaXNwbGF5IGFuIEFsZXJ0IE1vZGFsXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQWxlcnRNb2RhbCBleHRlbmRzIE1vZGFsIHtcclxuICAgIHByaXZhdGUgdGl0bGU6IHN0cmluZztcclxuICAgIHByaXZhdGUgZGVzY3JpcHRpb246IHN0cmluZztcclxuICAgIHByaXZhdGUgcmVzb2x2ZVByb21pc2U6ICh2YWx1ZToge3Byb2NlZWQ6Ym9vbGVhbiwgZGF0YTphbnl9KSA9PiB2b2lkO1xyXG4gICAgcHJpdmF0ZSBwcm9taXNlOiBQcm9taXNlPHtwcm9jZWVkOmJvb2xlYW4sIGRhdGE6YW55fT47XHJcbiAgICBwcml2YXRlIGJ0bjFUZXh0OiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIGJ0bjJUZXh0OiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIGNoZWNrYm94RWw6IEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIGFza0FnYWluTGFiZWw6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICBcclxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCB0aXRsZTogc3RyaW5nLCBkZXNjcmlwdGlvbjogc3RyaW5nLCBidG4xOiBzdHJpbmcsIGJ0bjI6c3RyaW5nLCBhc2tBZ2FpbkxhYmVsPzogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XHJcbiAgICAgIHN1cGVyKGFwcCk7XHJcbiAgICAgIHRoaXMudGl0bGUgPSB0aXRsZTtcclxuICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xyXG4gICAgICB0aGlzLmJ0bjFUZXh0ID0gYnRuMTtcclxuICAgICAgdGhpcy5idG4yVGV4dCA9IGJ0bjI7XHJcbiAgICAgIHRoaXMuYXNrQWdhaW5MYWJlbCA9IGFza0FnYWluTGFiZWw7XHJcbiAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgdGhpcy5yZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgb25PcGVuKCkge1xyXG4gICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcclxuICBcclxuICAgICAgY29udGVudEVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogdGhpcy50aXRsZSB9KTtcclxuICAgICAgY29udGVudEVsLmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiB0aGlzLmRlc2NyaXB0aW9uIH0pO1xyXG4gIFxyXG4gICAgICBjb25zdCBzZXR0aW5ncyA9IG5ldyBTZXR0aW5nKGNvbnRlbnRFbCk7XHJcbiAgICAgIGlmICh0aGlzLmFza0FnYWluTGFiZWwpIHtcclxuICAgICAgICBjb25zdCBpdGVtSW5mb0RpdiA9IHNldHRpbmdzLnNldHRpbmdFbC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdzZXR0aW5nLWl0ZW0taW5mbycpWzBdO1xyXG4gICAgICAgIGlmIChpdGVtSW5mb0Rpdikge1xyXG4gICAgICAgICAgdGhpcy5jaGVja2JveEVsID0gaXRlbUluZm9EaXYuY3JlYXRlRWwoJ2lucHV0JywgeyB0eXBlOiAnY2hlY2tib3gnIH0pO1xyXG4gICAgICAgICAgY29uc3QgbGFiZWwgPSBpdGVtSW5mb0Rpdi5jcmVhdGVFbCgnbGFiZWwnLCB7IHRleHQ6IHRoaXMuYXNrQWdhaW5MYWJlbCB9KTtcclxuICAgICAgICAgIGxhYmVsLnN0eWxlLm1hcmdpbkxlZnQgPSAnOHB4JztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgc2V0dGluZ3MuYWRkQnV0dG9uKChidG4pID0+IHtcclxuICAgICAgICAgIGJ0bi5zZXRCdXR0b25UZXh0KHRoaXMuYnRuMVRleHQpXHJcbiAgICAgICAgICAgIC5zZXRDdGEoKVxyXG4gICAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgIHRoaXMucmVzb2x2ZVByb21pc2Uoe3Byb2NlZWQ6dHJ1ZSwgZGF0YTp7YXNrQ29uZmlybWF0aW9uOiB0aGlzLmNoZWNrYm94RWw/LmNoZWNrZWR9fSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgIHNldHRpbmdzLmFkZEJ1dHRvbigoYnRuKSA9PiB7XHJcbiAgICAgICAgICBidG4uc2V0QnV0dG9uVGV4dCh0aGlzLmJ0bjJUZXh0KVxyXG4gICAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgIHRoaXMucmVzb2x2ZVByb21pc2Uoe3Byb2NlZWQ6ZmFsc2UsIGRhdGE6e2Fza0NvbmZpcm1hdGlvbjogdGhpcy5jaGVja2JveEVsPy5jaGVja2VkfX0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICBcclxuICAgIG9uQ2xvc2UoKSB7XHJcbiAgICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xyXG4gICAgICBjb250ZW50RWwuZW1wdHkoKTtcclxuICAgIH1cclxuICBcclxuICAgIGFzeW5jIG9wZW5BbmRHZXRWYWx1ZSgpOiBQcm9taXNlPHtwcm9jZWVkOmJvb2xlYW4sIGRhdGE6YW55fT4ge1xyXG4gICAgICB0aGlzLm9wZW4oKTtcclxuICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZTtcclxuICAgIH1cclxuICB9IiwgImltcG9ydCB7IEFwcCwgcmVuZGVyUmVzdWx0cywgU2VhcmNoQ29tcG9uZW50LCBTZXR0aW5nLCBURmlsZSwgVEZvbGRlciB9IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IHsgZ2V0Rm9sZGVyRnJvbVBhdGgsIHBhcnNlSlNDb2RlLCBTY3JpcHRpbmdUb29scyB9IGZyb20gJy4vdG9vbHMnO1xyXG5pbXBvcnQgeyBPYnNpZGlhblByb3BlcnR5VHlwZXMsIEZvbGRlclRhZ1J1bGVEZWZpbml0aW9uLCBGb2xkZXJUYWdTZXR0aW5ncywgRnJvbnRtYXR0ZXJBdXRvbWF0ZUV2ZW50cyB9IGZyb20gJy4vdHlwZXMnO1xyXG5pbXBvcnQgeyBBdXRvY29tcGxldGVNb2RhbCwgYXV0b2NvbXBsZXRlTW9kYWxSZXN1bHQsIG9wZW5BdXRvY29tcGxldGVNb2RhbCB9IGZyb20gJy4vYXV0b2NvbXBsZXRlTW9kYWwnO1xyXG5pbXBvcnQgeyBjb2RlRWRpdG9yTW9kYWxSZXN1bHQgfSBmcm9tICcuL2VkaXRvck1vZGFsJztcclxuaW1wb3J0IHsgRm9sZGVyU3VnZ2VzdCB9IGZyb20gXCIuL3N1Z2dlc3RlcnMvRm9sZGVyU3VnZ2VzdGVyXCI7XHJcbmltcG9ydCB7IEZpbGVTdWdnZXN0IH0gZnJvbSBcIi4vc3VnZ2VzdGVycy9GaWxlU3VnZ2VzdGVyXCI7XHJcbmltcG9ydCB7IERpcmVjdG9yeVNlbGVjdGlvblJlc3VsdCwgb3BlbkRpcmVjdG9yeVNlbGVjdGlvbk1vZGFsIH0gZnJvbSAnLi9kaXJlY3RvcnlTZWxlY3Rpb25Nb2RhbCc7XHJcbmltcG9ydCB7IHRlc3RGdW5rdGlvbiB9IGZyb20gJy4vc2ltcGxlQWxlcnRCb3gnO1xyXG5pbXBvcnQgeyBBbGVydE1vZGFsIH0gZnJvbSAnLi9hbGVydEJveCc7XHJcblxyXG5leHBvcnQgdHlwZSBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVR5cGVzID0gJ2J1aWxkSW4nIHwgJ2J1aWxkSW4uaW5wdXRQcm9wZXJ0eScgfCAnYXV0b2NvbXBsZXRlLm1vZGFsJyB8ICdhdXRvbWF0aW9uJyB8ICdzY3JpcHQnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDb25maWdFbGVtZW50cyB7XHJcbiAgICByZW1vdmVDb250ZW50OiBib29sZWFuO1xyXG4gICAgcnVsZUFjdGl2ZTogYm9vbGVhbjtcclxuICAgIG1vZGlmeU9ubHk6IGJvb2xlYW47XHJcbiAgICBpbnB1dFByb3BlcnR5OiBib29sZWFuO1xyXG4gICAgYWRkUHJlZml4OiBib29sZWFuO1xyXG4gICAgc3BhY2VSZXBsYWNlbWVudDogYm9vbGVhbjtcclxuICAgIHNwZWNpYWxDaGFyYWN0ZXJSZXBsYWNlbWVudDogYm9vbGVhbjtcclxuICAgIGNvbnZlcnRUb0xvd2VyQ2FzZTogYm9vbGVhbjtcclxuICAgIHJlc3VsdEFzTGluazogYm9vbGVhbjtcclxuICAgIGFkZENvbnRlbnQ6IGJvb2xlYW47XHJcbiAgICBleGNsdWRlRm9sZGVyczogYm9vbGVhbjtcclxuICAgIGluY2x1ZGVGb2xkZXJzOiBib29sZWFuO1xyXG4gICAgc2NyaXB0OiBib29sZWFuO1xyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgUnVsZUZ1bmN0aW9uIHtcclxuICAgIGlkOnN0cmluZztcclxuICAgIHJ1bGVUeXBlOiBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVR5cGVzO1xyXG4gICAgZGVzY3JpcHRpb246c3RyaW5nO1xyXG4gICAgdG9vbHRpcD86IHN0cmluZztcclxuICAgIGlucHV0UHJvcGVydHk/OiBib29sZWFuO1xyXG4gICAgaXNMaXZlUnVsZT86IGJvb2xlYW47XHJcbiAgICBzb3VyY2U6c3RyaW5nO1xyXG4gICAgdHlwZTpPYnNpZGlhblByb3BlcnR5VHlwZXNbXTtcclxuICAgIGZ4OkZ1bmN0aW9uO1xyXG4gICAgY29uZmlnRWxlbWVudHM6IENvbmZpZ0VsZW1lbnRzO1xyXG4gICAgY29uZmlnVGFiPzogKG9wdGlvbkVsOiBIVE1MRWxlbWVudCwgcnVsZTpGb2xkZXJUYWdSdWxlRGVmaW5pdGlvbiwgdGhhdDphbnksIHByZXZpZXdDb21wb25lbnQ6YW55KSA9PiB2b2lkOyAvLyBmdW5jdGlvbiB0byByZW5kZXIgdGhlIGNvbmZpZyB0YWIgZm9yIHRoZSBydWxlXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBydWxlRnVuY3Rpb25zOlJ1bGVGdW5jdGlvbltdPVtdO1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UnVsZUZ1bmN0aW9uQnlJZCAoaWQgOiBzdHJpbmcpOlJ1bGVGdW5jdGlvbiB8IHVuZGVmaW5lZCB7XHJcbiAgICByZXR1cm4gcnVsZUZ1bmN0aW9ucy5maW5kKHJ1bGUgPT4gcnVsZS5pZCA9PT0gaWQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseUZvcm1hdE9wdGlvbnModmFsdWU6YW55LCBydWxlOkZvbGRlclRhZ1J1bGVEZWZpbml0aW9uKTphbnkge1xyXG4gIGlmIChydWxlLnR5cGUgPT09ICdkYXRlJyB8fCBydWxlLnR5cGUgPT09ICdkYXRldGltZScpIHJldHVybiB2YWx1ZTsgLy8gbGVhdmUgZGF0ZSBhbmQgZGF0ZVRpbWUgdW50b3VjaGVkXHJcbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcclxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxyXG4gICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgY2FzZSAnc3RyaW5nJzpcclxuICAgICAgaWYgKHJ1bGUuc3BhY2VSZXBsYWNlbWVudCAmJiBydWxlLnNwYWNlUmVwbGFjZW1lbnQgIT09ICcnKSB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xccysvZywgcnVsZS5zcGFjZVJlcGxhY2VtZW50KTtcclxuICAgICAgaWYgKHJ1bGUuc3BlY2lhbENoYXJSZXBsYWNlbWVudCAmJiBydWxlLnNwZWNpYWxDaGFyUmVwbGFjZW1lbnQgIT09JycpIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW15hLXpBLVowLTlcXC1fXFwvXHUwMEU0XHUwMEY2XHUwMEZDXHUwMERGXHUwMEM0XHUwMEQ2XHUwMERDXHUwMEUxXHUwMEU5XHUwMEVEXHUwMEYzXHUwMEZBXHUwMEZEXHUwMEMxXHUwMEM5XHUwMENEXHUwMEQzXHUwMERBXHUwMEREXHUwMEUwXHUwMEU4XHUwMEVDXHUwMEYyXHUwMEY5XHUwMEMwXHUwMEM4XHUwMENDXHUwMEQyXHUwMEQ5XHUwMEUyXHUwMEVBXHUwMEVFXHUwMEY0XHUwMEZCXHUwMEMyXHUwMENBXHUwMENFXHUwMEQ0XHUwMERCXHUwMEUzXHUwMEYxXHUwMEY1XHUwMEMzXHUwMEQxXHUwMEQ1XS9nLCBydWxlLnNwZWNpYWxDaGFyUmVwbGFjZW1lbnQpO1xyXG4gICAgICBpZiAocnVsZS5sb3dlcmNhc2VUYWdzKSB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgIGlmIChydWxlLnByZWZpeCAmJiBydWxlLnByZWZpeCAhPT0gJycpIHZhbHVlID0gcnVsZS5wcmVmaXggKyB2YWx1ZTtcclxuICAgICAgaWYgKHJ1bGUuYXNMaW5rKSB2YWx1ZSA9IGBbWyR7dmFsdWV9XV1gO1xyXG4gICAgICByZXR1cm4gdmFsdWVcclxuICAgIGNhc2UgJ29iamVjdCc6XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAodmFsdWUgPT4gYXBwbHlGb3JtYXRPcHRpb25zKHZhbHVlLCBydWxlKSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gIH1cclxuICByZXR1cm5cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0UnVsZVJlc3VsdChydWxlRng6IEZ1bmN0aW9uLCBhcHA6IEFwcCwgcnVsZTogRm9sZGVyVGFnUnVsZURlZmluaXRpb24sIHJ1bGVGdW5jdGlvbjogUnVsZUZ1bmN0aW9uLCBjdXJyZW50RmlsZTogVEZpbGUsIHRvb2xzOlNjcmlwdGluZ1Rvb2xzLCBmcm9udE1hdHRlcjphbnkpOlByb21pc2U8YW55PiB7XHJcbiAgbGV0IHJlc3VsdDphbnkgPSB1bmRlZmluZWQ7XHJcbiAgLy9jb25zb2xlLmxvZygnZ2V0UnVsZVJlc3VsdCcsIHJ1bGVGeCwgcnVsZUZ1bmN0aW9uLCBjdXJyZW50RmlsZSwgdG9vbHMsIGZyb250TWF0dGVyKTtcclxuICBzd2l0Y2ggKHJ1bGVGdW5jdGlvbi5ydWxlVHlwZSkge1xyXG4gICAgY2FzZSAnc2NyaXB0JzpcclxuICAgIGNhc2UgJ2J1aWxkSW4nOlxyXG4gICAgICByZXN1bHQgPSBhcHBseUZvcm1hdE9wdGlvbnMocnVsZUZ4KGFwcCwgY3VycmVudEZpbGUsIHRvb2xzKSwgcnVsZSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnYnVpbGRJbi5pbnB1dFByb3BlcnR5JzpcclxuICAgICAgcmVzdWx0ID0gYXBwbHlGb3JtYXRPcHRpb25zKHJ1bGVGeChhcHAsIGN1cnJlbnRGaWxlLCB0b29scywgZnJvbnRNYXR0ZXJbcnVsZS5pbnB1dFByb3BlcnR5XSksIHJ1bGUpO1xyXG4gICAgICBicmVha1xyXG4gICAgY2FzZSAnYXV0b2NvbXBsZXRlLm1vZGFsJzpcclxuICAgICAgcnVsZUZ4KGFwcCwgY3VycmVudEZpbGUsIHRvb2xzKTtcclxuICAgICAgLy9jb25zb2xlLmxvZygnYXV0b2NvbXBsZXRlIG1vZGFsJywgcnVsZUZ4LCBydWxlRnVuY3Rpb24sIGN1cnJlbnRGaWxlLCB0b29scyk7XHJcbiAgICAgIHJlc3VsdCA9IG51bGw7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnYXV0b21hdGlvbic6XHJcbiAgICAgIC8vY29uc29sZS5sb2coJ2F1dG9tYXRpb24nLCBydWxlRnVuY3Rpb24sIGN1cnJlbnRGaWxlLCB0b29scyk7XHJcbiAgICAgIHJlc3VsdCA9IGFwcGx5Rm9ybWF0T3B0aW9ucyhydWxlRngoYXBwLCBjdXJyZW50RmlsZSwgdG9vbHMpLCBydWxlKTtcclxuICAgICAgYnJlYWs7XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBleGVjdXRlUnVsZSAoZXZlbnQ6IEZyb250bWF0dGVyQXV0b21hdGVFdmVudHMsIGFwcCwgc2V0dGluZ3MsIGN1cnJlbnRGaWxlOiBURmlsZSB8IG51bGwsIHJldHVyblJlc3VsdDogYW55LCBydWxlOkZvbGRlclRhZ1J1bGVEZWZpbml0aW9uLCBmcm9udE1hdHRlciwgb2xkUGF0aD86c3RyaW5nKSB7XHJcbiAgLy9jb25zb2xlLmxvZyhgRXZlbnQ6ICR7ZXZlbnR9IGZvciBydWxlICR7cnVsZS5wcm9wZXJ0eX18JHtydWxlLmNvbnRlbnR9YCwgcnVsZSk7XHJcbiAgaWYgKCFydWxlLmFjdGl2ZSB8fCAhY3VycmVudEZpbGUpIHJldHVybiByZXR1cm5SZXN1bHQ7XHJcbiAgY29uc3QgdG9vbHMgPSBuZXcgU2NyaXB0aW5nVG9vbHMoYXBwLCB0aGlzLCBzZXR0aW5ncywgcnVsZSwgZnJvbnRNYXR0ZXIsIGN1cnJlbnRGaWxlKTtcclxuICBsZXQgZnhSZXN1bHQgPSByZXR1cm5SZXN1bHQ7XHJcbiAgbGV0IG9sZFJlc3VsdDphbnk7XHJcbiAgbGV0IG9sZEZpbGU6VEZpbGUgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcbiAgaWYgKG9sZFBhdGgpIHtcclxuICAgIGxldCBvbGRGaWxlUGFydHMgPSBvbGRQYXRoLnNwbGl0KCcvJyk7XHJcbiAgICBvbGRGaWxlID0ge1xyXG4gICAgICBwYXRoOiBvbGRQYXRoLFxyXG4gICAgICBleHRlbnNpb246IG9sZEZpbGVQYXJ0c1tvbGRGaWxlUGFydHMubGVuZ3RoLTFdLnNwbGl0KCcuJylbMV0sXHJcbiAgICAgIG5hbWU6IG9sZEZpbGVQYXJ0c1tvbGRGaWxlUGFydHMubGVuZ3RoLTFdLnNwbGl0KCcuJylbMF0sXHJcbiAgICAgIHN0YXQ6IGN1cnJlbnRGaWxlLnN0YXQsXHJcbiAgICAgIGJhc2VuYW1lOiBjdXJyZW50RmlsZS5iYXNlbmFtZSxcclxuICAgICAgdmF1bHQ6IGN1cnJlbnRGaWxlLnZhdWx0LFxyXG4gICAgICBwYXJlbnQ6IGN1cnJlbnRGaWxlLnBhcmVudFxyXG4gICAgfVxyXG4gIH1cclxuICB0cnkge1xyXG4gICAgY29uc3QgZnVuY3Rpb25JbmRleCA9IHJ1bGVGdW5jdGlvbnMuZmluZEluZGV4KGZ4ID0+IGZ4LmlkID09PSBydWxlLmNvbnRlbnQpO1xyXG4gICAgaWYgKGZ1bmN0aW9uSW5kZXg9PT0tMSl7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFJ1bGUgZnVuY3Rpb24gJHtydWxlLmNvbnRlbnR9IG5vdCBmb3VuZCFgKTtcclxuICAgICAgcmV0dXJuIHJldHVyblJlc3VsdDsgLy8gcmV0dXJuIHRoZSBvcmlnaW5hbCB2YWx1ZSBpZiB0aGUgZnVuY3Rpb24gaXMgbm90IGZvdW5kXHJcbiAgICB9XHJcbiAgICBjb25zdCBydWxlRnVuY3Rpb25Db25maWcgPSBydWxlRnVuY3Rpb25zW2Z1bmN0aW9uSW5kZXhdO1xyXG4gICAgdG9vbHMuc2V0Q3VycmVudENvbnRlbnQoZnJvbnRNYXR0ZXJbcnVsZS5wcm9wZXJ0eV0pXHJcbiAgICB0b29scy5zZXRSdWxlKHJ1bGUpO1xyXG4gICAgdG9vbHMuc2V0RnJvbnRtYXR0ZXIoZnJvbnRNYXR0ZXIpO1xyXG4gICAgc3dpdGNoIChydWxlRnVuY3Rpb25Db25maWcucnVsZVR5cGUpIHtcclxuICAgICAgY2FzZSAnc2NyaXB0JzogXHJcbiAgICAgICAgY29uc3QgY3VzdG9tUnVsZUZ1bmN0aW9uID0gcGFyc2VKU0NvZGUocnVsZS5qc0NvZGUpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY3VzdG9tUnVsZUZ1bmN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBDb3VsZCBub3QgcGFyc2UgY3VzdG9tIGZ1bmN0aW9uIGZvciAke3J1bGUuY29udGVudH0hYCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ4UmVzdWx0ID0gYXBwbHlGb3JtYXRPcHRpb25zKGN1c3RvbVJ1bGVGdW5jdGlvbihhcHAsIGN1cnJlbnRGaWxlLCB0b29scyksIHJ1bGUpO1xyXG4gICAgICAgIGlmIChvbGRGaWxlKSB7XHJcbiAgICAgICAgICBvbGRSZXN1bHQgPSBhcHBseUZvcm1hdE9wdGlvbnMoY3VzdG9tUnVsZUZ1bmN0aW9uKGFwcCwgb2xkRmlsZSwgdG9vbHMpLCBydWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2J1aWxkSW4uaW5wdXRQcm9wZXJ0eSc6XHJcbiAgICAgIGNhc2UgJ2J1aWxkSW4nOiAgXHJcbiAgICAgICAgY29uc3QgcnVsZUZ1bmN0aW9uID0gcnVsZS51c2VDdXN0b21Db2RlID8gcGFyc2VKU0NvZGUocnVsZS5idWlsZEluQ29kZSkgOiBydWxlRnVuY3Rpb25Db25maWcuZng7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBydWxlRnVuY3Rpb24gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYENvdWxkIG5vdCBwYXJzZSBjdXN0b20gZnVuY3Rpb24gZm9yICR7cnVsZS5jb250ZW50fSFgKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmeFJlc3VsdCA9IGdldFJ1bGVSZXN1bHQocnVsZUZ1bmN0aW9uLCBhcHAsIHJ1bGUsIHJ1bGVGdW5jdGlvbkNvbmZpZywgY3VycmVudEZpbGUsIHRvb2xzLCBmcm9udE1hdHRlcik7XHJcbiAgICAgICAgaWYgKG9sZEZpbGUpIHtcclxuICAgICAgICAgICAgb2xkUmVzdWx0ID0gZ2V0UnVsZVJlc3VsdChydWxlRnVuY3Rpb24sIGFwcCwgcnVsZSwgcnVsZUZ1bmN0aW9uQ29uZmlnLCBvbGRGaWxlLCB0b29scywgZnJvbnRNYXR0ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zb2xlLmxvZyhgZXhlY3V0ZVJ1bGU6ICR7cnVsZS5jb250ZW50fSAke3J1bGUucHJvcGVydHl9IFske3J1bGUudHlwZX1dPSAnJHtmeFJlc3VsdH0nYClcclxuXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2F1dG9jb21wbGV0ZS5tb2RhbCc6XHJcbiAgICAgICAgZnhSZXN1bHQgPSBnZXRSdWxlUmVzdWx0KHJ1bGVGdW5jdGlvbkNvbmZpZy5meCwgYXBwLCBydWxlLCBydWxlRnVuY3Rpb25Db25maWcsIGN1cnJlbnRGaWxlLCB0b29scywgZnJvbnRNYXR0ZXIpO1xyXG4gICAgICAgIGJyZWFrOyAvLyBoYW5kbGVkIGluIHRoZSBhdXRvY29tcGxldGUgbW9kYWxcclxuICAgICAgY2FzZSAnYXV0b21hdGlvbic6XHJcbiAgICAgICAgZnhSZXN1bHQgPSBnZXRSdWxlUmVzdWx0KHJ1bGVGdW5jdGlvbkNvbmZpZy5meCwgYXBwLCBydWxlLCBydWxlRnVuY3Rpb25Db25maWcsIGN1cnJlbnRGaWxlLCB0b29scywgZnJvbnRNYXR0ZXIpO1xyXG4gICAgICAgIGJyZWFrOyAvLyBoYW5kbGVkIGluIHRoZSBhdXRvbWF0aW9uIG1vZGFsXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZXhlY3V0aW5nIHJ1bGUgJHtydWxlLnByb3BlcnR5fXwke3J1bGUuY29udGVudH0gZm9yIGZpbGUgJHtjdXJyZW50RmlsZS5wYXRofTogJHtlcnJvcn1gKTtcclxuICAgIHJldHVybiByZXR1cm5SZXN1bHQ7IC8vIHJldHVybiB0aGUgb3JpZ2luYWwgdmFsdWUgaWYgdGhlcmUgaXMgYW4gZXJyb3JcclxuICB9XHJcblxyXG4gIGlmIChydWxlLnR5cGUgPT09ICdudW1iZXInIHx8IHJ1bGUudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBydWxlLnR5cGUgPT09ICdkYXRlJyB8fCBydWxlLnR5cGUgPT09ICdkYXRldGltZScpIHtcclxuICAgICAgcmV0dXJuIGZ4UmVzdWx0O1xyXG4gIH1cclxuICBzd2l0Y2ggKHJ1bGUuYWRkQ29udGVudCkge1xyXG4gICAgICBjYXNlICdvdmVyd3JpdGUnOlxyXG4gICAgICAgICAgcmV0dXJuUmVzdWx0ID0gZnhSZXN1bHQ7IC8vIHVwZGF0ZSBvciBhZGQgdGhlIG5ldyB2YWx1ZVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2VuZCc6XHJcbiAgICAgICAgICBpZiAocnVsZS50eXBlID09PSAnbXVsdGl0ZXh0JyB8fCBydWxlLnR5cGUgPT09ICd0YWdzJyB8fCBydWxlLnR5cGUgPT09ICdhbGlhc2VzJykge1xyXG4gICAgICAgICAgICAgIGlmICghZnhSZXN1bHQpIGZ4UmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmeFJlc3VsdCA9PT0gJ3N0cmluZycpIGZ4UmVzdWx0ID0gW2Z4UmVzdWx0XTsgLy8gY29udmVydCBzdHJpbmcgdG8gYXJyYXkgXHJcbiAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJldHVyblJlc3VsdCkpIHJldHVyblJlc3VsdCA9IFtyZXR1cm5SZXN1bHRdO1xyXG4gICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvbGRSZXN1bHQpKSBvbGRSZXN1bHQgPSBbb2xkUmVzdWx0XTtcclxuICAgICAgICAgICAgICBsZXQgZmlsdGVyZWQgPSByZXR1cm5SZXN1bHQuZmlsdGVyKCh2YWx1ZSkgPT4gIW9sZFJlc3VsdC5pbmNsdWRlcyh2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgcmV0dXJuUmVzdWx0ID0gdG9vbHMucmVtb3ZlRHVwbGljYXRlU3RyaW5ncyhmaWx0ZXJlZC5jb25jYXQoZnhSZXN1bHQpKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaWYgKCFyZXR1cm5SZXN1bHQpIHJldHVyblJlc3VsdCA9ICcnO1xyXG4gICAgICAgICAgICAgIHJldHVyblJlc3VsdCA9IHJldHVyblJlc3VsdC5yZXBsYWNlQWxsKHJldHVyblJlc3VsdCxvbGRSZXN1bHQpO1xyXG4gICAgICAgICAgICAgIHJldHVyblJlc3VsdCA9IHJldHVyblJlc3VsdCArIGZ4UmVzdWx0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3N0YXJ0JzpcclxuICAgICAgICAgIGlmIChydWxlLnR5cGUgPT09ICdtdWx0aXRleHQnIHx8IHJ1bGUudHlwZSA9PT0gJ3RhZ3MnIHx8IHJ1bGUudHlwZSA9PT0gJ2FsaWFzZXMnKSB7XHJcbiAgICAgICAgICAgICAgaWYgKCFmeFJlc3VsdCkgZnhSZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGZ4UmVzdWx0ID09PSAnc3RyaW5nJykgZnhSZXN1bHQgPSBbZnhSZXN1bHRdOyAvLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSBcclxuICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmV0dXJuUmVzdWx0KSkgcmV0dXJuUmVzdWx0ID0gW3JldHVyblJlc3VsdF07XHJcbiAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9sZFJlc3VsdCkpIG9sZFJlc3VsdCA9IFtvbGRSZXN1bHRdO1xyXG4gICAgICAgICAgICAgIGxldCBmaWx0ZXJlZCA9IHJldHVyblJlc3VsdC5maWx0ZXIoKHZhbHVlKSA9PiAhb2xkUmVzdWx0LmluY2x1ZGVzKHZhbHVlKSlcclxuICAgICAgICAgICAgICByZXR1cm5SZXN1bHQgPSB0b29scy5yZW1vdmVEdXBsaWNhdGVTdHJpbmdzKGZ4UmVzdWx0LmNvbmNhdChmaWx0ZXJlZCkpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpZiAoIXJldHVyblJlc3VsdCkgcmV0dXJuUmVzdWx0ID0gJyc7XHJcbiAgICAgICAgICAgICAgcmV0dXJuUmVzdWx0ID0gcmV0dXJuUmVzdWx0LnJlcGxhY2VBbGwocmV0dXJuUmVzdWx0LG9sZFJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuUmVzdWx0ID0gZnhSZXN1bHQgKyByZXR1cm5SZXN1bHQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICB9XHJcbiAgcmV0dXJuIHJldHVyblJlc3VsdDtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVSdWxlIChhcHAsIHNldHRpbmdzLCBjdXJyZW50RmlsZTogVEZpbGUsIHJldHVyblJlc3VsdDogYW55LCBydWxlOkZvbGRlclRhZ1J1bGVEZWZpbml0aW9uLCBmcm9udE1hdHRlcikge1xyXG4gIGNvbnN0IHRvb2xzID0gbmV3IFNjcmlwdGluZ1Rvb2xzKGFwcCwgc2V0dGluZ3MsIGZyb250TWF0dGVyKTtcclxuICBsZXQgZnhSZXN1bHQ6YW55O1xyXG4gIGlmIChydWxlLmNvbnRlbnQgPT09ICdzY3JpcHQnKSB7XHJcbiAgICAgIGNvbnN0IHJ1bGVGdW5jdGlvbiA9IHBhcnNlSlNDb2RlKHJ1bGUuanNDb2RlKTtcclxuICAgICAgaWYgKHR5cGVvZiBydWxlRnVuY3Rpb24gIT09ICdmdW5jdGlvbicpIHJldHVybjtcclxuICAgICAgZnhSZXN1bHQgPSBydWxlRnVuY3Rpb24oYXBwLCBjdXJyZW50RmlsZSwgdG9vbHMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IGZ1bmN0aW9uSW5kZXggPSBydWxlRnVuY3Rpb25zLmZpbmRJbmRleChmeCA9PiBmeC5pZCA9PT0gcnVsZS5jb250ZW50KTtcclxuICAgICAgaWYgKGZ1bmN0aW9uSW5kZXghPT0tMSl7XHJcbiAgICAgICAgICBjb25zdCBydWxlRnVuY3Rpb24gPSBydWxlLnVzZUN1c3RvbUNvZGUgPyBwYXJzZUpTQ29kZShydWxlLmJ1aWxkSW5Db2RlKSA6IHJ1bGVGdW5jdGlvbnNbZnVuY3Rpb25JbmRleF0uZng7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIHJ1bGVGdW5jdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBDb3VsZCBub3QgcGFyc2UgY3VzdG9tIGZ1bmN0aW9uIGZvciAke3J1bGUuY29udGVudH0hYCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChydWxlRnVuY3Rpb25zW2Z1bmN0aW9uSW5kZXhdLmlucHV0UHJvcGVydHkpIHtcclxuICAgICAgICAgICAgZnhSZXN1bHQgPSBhcHBseUZvcm1hdE9wdGlvbnMocnVsZUZ1bmN0aW9uKGFwcCwgY3VycmVudEZpbGUsIHRvb2xzLCBmcm9udE1hdHRlcltydWxlLmlucHV0UHJvcGVydHldKSwgcnVsZSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmeFJlc3VsdCA9IGFwcGx5Rm9ybWF0T3B0aW9ucyhydWxlRnVuY3Rpb24oYXBwLCBjdXJyZW50RmlsZSwgdG9vbHMpLCBydWxlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gIH1cclxuICBzd2l0Y2ggKHJ1bGUuYWRkQ29udGVudCkge1xyXG4gICAgICBjYXNlICdvdmVyd3JpdGUnOlxyXG4gICAgICAgICAgcmV0dXJuUmVzdWx0ID0gZnhSZXN1bHQ7IC8vIHVwZGF0ZSBvciBhZGQgdGhlIG5ldyB2YWx1ZVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2VuZCc6XHJcbiAgICAgICAgICBpZiAocnVsZS50eXBlID09PSAnbXVsdGl0ZXh0JyB8fCBydWxlLnR5cGUgPT09ICd0YWdzJyB8fCBydWxlLnR5cGUgPT09ICdhbGlhc2VzJykge1xyXG4gICAgICAgICAgICAgIGlmICghZnhSZXN1bHQpIGZ4UmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmeFJlc3VsdCA9PT0gJ3N0cmluZycpIGZ4UmVzdWx0ID0gW2Z4UmVzdWx0XTsgLy8gY29udmVydCBzdHJpbmcgdG8gYXJyYXkgXHJcbiAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJldHVyblJlc3VsdCkpIHJldHVyblJlc3VsdCA9IFtyZXR1cm5SZXN1bHRdO1xyXG4gICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShmeFJlc3VsdCkpIGZ4UmVzdWx0ID0gW2Z4UmVzdWx0XTtcclxuICAgICAgICAgICAgICBsZXQgZmlsdGVyZWQgPSByZXR1cm5SZXN1bHQuZmlsdGVyKCh2YWx1ZSkgPT4gIWZ4UmVzdWx0LmluY2x1ZGVzKHZhbHVlKSlcclxuICAgICAgICAgICAgICByZXR1cm5SZXN1bHQgPSB0b29scy5yZW1vdmVEdXBsaWNhdGVTdHJpbmdzKGZpbHRlcmVkKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaWYgKCFyZXR1cm5SZXN1bHQpIHJldHVyblJlc3VsdCA9ICcnO1xyXG4gICAgICAgICAgICAgIHJldHVyblJlc3VsdCA9IHJldHVyblJlc3VsdC5yZXBsYWNlQWxsKHJldHVyblJlc3VsdCxmeFJlc3VsdCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnc3RhcnQnOlxyXG4gICAgICAgICAgaWYgKHJ1bGUudHlwZSA9PT0gJ211bHRpdGV4dCcgfHwgcnVsZS50eXBlID09PSAndGFncycgfHwgcnVsZS50eXBlID09PSAnYWxpYXNlcycpIHtcclxuICAgICAgICAgICAgICBpZiAoIWZ4UmVzdWx0KSBmeFJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZnhSZXN1bHQgPT09ICdzdHJpbmcnKSBmeFJlc3VsdCA9IFtmeFJlc3VsdF07IC8vIGNvbnZlcnQgc3RyaW5nIHRvIGFycmF5IFxyXG4gICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXR1cm5SZXN1bHQpKSByZXR1cm5SZXN1bHQgPSBbcmV0dXJuUmVzdWx0XTtcclxuICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZnhSZXN1bHQpKSBmeFJlc3VsdCA9IFtmeFJlc3VsdF07XHJcbiAgICAgICAgICAgICAgbGV0IGZpbHRlcmVkID0gcmV0dXJuUmVzdWx0LmZpbHRlcigodmFsdWUpID0+ICFmeFJlc3VsdC5pbmNsdWRlcyh2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgcmV0dXJuUmVzdWx0ID0gdG9vbHMucmVtb3ZlRHVwbGljYXRlU3RyaW5ncyhmaWx0ZXJlZCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGlmICghcmV0dXJuUmVzdWx0KSByZXR1cm5SZXN1bHQgPSAnJztcclxuICAgICAgICAgICAgICByZXR1cm5SZXN1bHQgPSByZXR1cm5SZXN1bHQucmVwbGFjZUFsbChyZXR1cm5SZXN1bHQsZnhSZXN1bHQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgfVxyXG4gIHJldHVybiByZXR1cm5SZXN1bHQ7XHJcblxyXG59XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpbHRlcnMgYSBnaXZlbiBmaWxlIGFuZCByZXR1cm5zIHRydWUgaWYgaXQgaXMgaW5jbHVkZWQgaW4gYSBmb2xkZXIgb3IgZmlsZSBsaXN0XHJcbiAgICogQHBhcmFtIGZpbGUgXHJcbiAgICogQHBhcmFtIGZpbHRlck1vZGUgJ2V4Y2x1ZGUnfCdpbmNsdWRlJ1xyXG4gICAqIEBwYXJhbSB0eXBlICdmb2xkZXJzJ3wnZmlsZXMnXHJcbiAgICogQHJldHVybnMgXHJcbiAgICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJGaWxlKGZpbGU6IFRGaWxlLCBmaWxlTGlzdDogYW55LCBmaWx0ZXJNb2RlOiBzdHJpbmcsIHR5cGU6c3RyaW5nKTpib29sZWFuIHtcclxuICAgIGxldCByZXN1bHQgPSBmYWxzZTtcclxuICAgIGNvbnN0IGZpbHRlckFycmF5ID0gKHR5cGU9PT0nZm9sZGVycycpID8gZmlsZUxpc3RbZmlsdGVyTW9kZV0uc2VsZWN0ZWRGb2xkZXJzIDogZmlsZUxpc3RbZmlsdGVyTW9kZV0uc2VsZWN0ZWRGaWxlcztcclxuICAgIGlmIChmaWx0ZXJBcnJheS5sZW5ndGggPT09IDApIHJldHVybiAoZmlsdGVyTW9kZSA9PT0gJ2luY2x1ZGUnKT8gZmFsc2UgOiB0cnVlO1xyXG4gICAgY29uc3QgZmlsZVBhdGggPSBmaWxlLnBhdGg7XHJcbiAgICBjb25zdCBmaWxlRm9sZGVyID0gZ2V0Rm9sZGVyRnJvbVBhdGgoZmlsZS5wYXRoKTtcclxuICAgIGNvbnN0IGZpbGVOYW1lID0gZmlsZS5iYXNlbmFtZSArICcuJyArIGZpbGUuZXh0ZW5zaW9uO1xyXG4gICAgXHJcbiAgICBpZiAodHlwZSA9PT0gJ2ZpbGVzJykge1xyXG4gICAgICAgIHJlc3VsdCA9IGZpbHRlckFycmF5LmluY2x1ZGVzKGZpbGVQYXRoKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlID09PSAnZm9sZGVycycpIHtcclxuICAgICAgICBmb3IgKGxldCBwYXRoIG9mIGZpbHRlckFycmF5KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGZpbGVGb2xkZXI/LnN0YXJ0c1dpdGgocGF0aC5zbGljZSgxKSkgfHwgZmFsc2U7IC8vIHJlbW92ZSByb290ICcvJ1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB0cnVlKSByZXR1cm4gKGZpbHRlck1vZGUgPT09ICdleGNsdWRlJyk/ICFyZXN1bHQgOiByZXN1bHQ7O1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIChmaWx0ZXJNb2RlID09PSAnZXhjbHVkZScpPyAhcmVzdWx0IDogcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tJZkZpbGVBbGxvd2VkKGZpbGU6IFRGaWxlLCBzZXR0aW5ncz86Rm9sZGVyVGFnU2V0dGluZ3MsIHJ1bGU/OkZvbGRlclRhZ1J1bGVEZWZpbml0aW9uKTpib29sZWFuIHtcclxuICAgICAgbGV0IHJlc3VsdCA9IHRydWU7XHJcbiAgICAgIGlmICghZmlsZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAoc2V0dGluZ3MgJiYgIXJ1bGUpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhgY2hlY2sgZmlsZSAke2ZpbGUucGF0aH0gYWdhaW5zdCBzZXR0aW5nc2AsIHNldHRpbmdzLmluY2x1ZGUsIHNldHRpbmdzLmV4Y2x1ZGUpO1xyXG4gICAgICAgICAgaWYgKHNldHRpbmdzLmV4Y2x1ZGUuc2VsZWN0ZWRGaWxlcy5sZW5ndGg+MCkgeyAvLyB0aGVyZSBhcmUgZmlsZXMgaW4gdGhlIGV4Y2x1ZGUgZmlsZXMgbGlzdC5cclxuICAgICAgICAgICAgICByZXN1bHQgPSBmaWx0ZXJGaWxlKGZpbGUsIHNldHRpbmdzLCAnZXhjbHVkZScsICdmaWxlcycpOyAgICBcclxuICAgICAgICAgIH0gICAgICAgIFxyXG4gICAgICAgICAgaWYgKHNldHRpbmdzLmV4Y2x1ZGUuc2VsZWN0ZWRGb2xkZXJzLmxlbmd0aD4wKSB7IC8vIHRoZXJlIGFyZSBmb2xkZXJzIGluIHRoZSBpbmNsdWRlIGZvbGRlcnMgbGlzdC5cclxuICAgICAgICAgICAgICByZXN1bHQgPSBmaWx0ZXJGaWxlKGZpbGUsIHNldHRpbmdzLCAnZXhjbHVkZScsICdmb2xkZXJzJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoc2V0dGluZ3MuaW5jbHVkZS5zZWxlY3RlZEZpbGVzLmxlbmd0aD4wKSB7IC8vIHRoZXJlIGFyZSBmaWxlcyBpbiB0aGUgaW5jbHVkZSBmaWxlcyBsaXN0XHJcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZmlsdGVyRmlsZShmaWxlLCBzZXR0aW5ncywgJ2luY2x1ZGUnLCAnZmlsZXMnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChzZXR0aW5ncy5pbmNsdWRlLnNlbGVjdGVkRm9sZGVycy5sZW5ndGg+MCkgeyAvLyB0aGVyZSBhcmUgZm9sZGVycyBpbiB0aGUgaW5jbHVkZSBmb2xkZXJzIGxpc3RcclxuICAgICAgICAgICAgICByZXN1bHQgPSBmaWx0ZXJGaWxlKGZpbGUsIHNldHRpbmdzLCAnaW5jbHVkZScsICdmb2xkZXJzJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBpZiAocmVzdWx0ID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlOyAvLyBpZiB0aGUgZmlsZSBpcyBleGNsdWRlZCwgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZpbHRlcmluZyBmaWxlICR7ZmlsZS5wYXRofSBnbG9iYWxseTogJHtlcnJvcn1gKTtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gZGVmYXVsdCB0byBmYWxzZSBpZiB0aGVyZSBpcyBhbiBlcnJvclxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZihydWxlKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIC8vY29uc29sZS5sb2coYGNoZWNrIGZpbGUgJHtmaWxlLnBhdGh9IGFnYWluc3QgcnVsZWAsIHJ1bGUuaW5jbHVkZSwgcnVsZS5leGNsdWRlKTtcclxuICAgICAgICAgIGlmIChydWxlLmV4Y2x1ZGUuc2VsZWN0ZWRGaWxlcy5sZW5ndGg+MCkgeyAvLyB0aGVyZSBhcmUgZmlsZXMgaW4gdGhlIGV4Y2x1ZGUgZmlsZXMgbGlzdC5cclxuICAgICAgICAgICAgICByZXN1bHQgPSBmaWx0ZXJGaWxlKGZpbGUsIHJ1bGUsICdleGNsdWRlJywgJ2ZpbGVzJyk7XHJcbiAgICAgICAgICB9ICAgICAgICBcclxuICAgICAgICAgIGlmIChydWxlLmV4Y2x1ZGUuc2VsZWN0ZWRGb2xkZXJzLmxlbmd0aD4wKSB7IC8vIHRoZXJlIGFyZSBmb2xkZXJzIGluIHRoZSBpbmNsdWRlIGZvbGRlcnMgbGlzdC5cclxuICAgICAgICAgICAgICByZXN1bHQgPSBmaWx0ZXJGaWxlKGZpbGUsIHJ1bGUsICdleGNsdWRlJywgJ2ZvbGRlcnMnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChydWxlLmluY2x1ZGUuc2VsZWN0ZWRGaWxlcy5sZW5ndGg+MCkgeyAvLyB0aGVyZSBhcmUgZmlsZXMgaW4gdGhlIGluY2x1ZGUgZmlsZXMgbGlzdFxyXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZpbHRlckZpbGUoZmlsZSwgcnVsZSwgJ2luY2x1ZGUnLCAnZmlsZXMnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChydWxlLmluY2x1ZGUuc2VsZWN0ZWRGb2xkZXJzLmxlbmd0aD4wKSB7IC8vIHRoZXJlIGFyZSBmb2xkZXJzIGluIHRoZSBpbmNsdWRlIGZvbGRlcnMgbGlzdFxyXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZpbHRlckZpbGUoZmlsZSwgcnVsZSwgJ2luY2x1ZGUnLCAnZm9sZGVycycpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmaWx0ZXJpbmcgZmlsZSAke2ZpbGUucGF0aH0gYnkgcnVsZSAke3J1bGUucHJvcGVydHl9fCR7cnVsZS5jb250ZW50fTogJHtlcnJvcn1gKTtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gZGVmYXVsdCB0byBmYWxzZSBpZiB0aGVyZSBpcyBhbiBlcnJvclxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZWZhdWx0Q29uZmlnRWxlbWVudHMobW9kaWZpZXJzOkNvbmZpZ0VsZW1lbnRzIHwgYW55KTpDb25maWdFbGVtZW50cyB7XHJcbiAgY29uc3QgY29uZmlnRWxlbWVudHM6IENvbmZpZ0VsZW1lbnRzID0ge1xyXG4gICAgcmVtb3ZlQ29udGVudDogdHJ1ZSxcclxuICAgIHJ1bGVBY3RpdmU6IHRydWUsXHJcbiAgICBtb2RpZnlPbmx5OiB0cnVlLFxyXG4gICAgaW5wdXRQcm9wZXJ0eTogZmFsc2UsXHJcbiAgICBhZGRQcmVmaXg6IHRydWUsXHJcbiAgICBzcGFjZVJlcGxhY2VtZW50OiB0cnVlLFxyXG4gICAgc3BlY2lhbENoYXJhY3RlclJlcGxhY2VtZW50OiB0cnVlLFxyXG4gICAgY29udmVydFRvTG93ZXJDYXNlOiB0cnVlLFxyXG4gICAgcmVzdWx0QXNMaW5rOiB0cnVlLFxyXG4gICAgYWRkQ29udGVudDogdHJ1ZSxcclxuICAgIGV4Y2x1ZGVGb2xkZXJzOiB0cnVlLFxyXG4gICAgaW5jbHVkZUZvbGRlcnM6IHRydWUsIFxyXG4gICAgc2NyaXB0OiB0cnVlLFxyXG4gIH1cclxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnRWxlbWVudHMsIG1vZGlmaWVycyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBzcGVjaWZpYyBvcHRpb24gaXMgZW5hYmxlZCBmb3IgYSBnaXZlbiBydWxlIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gcnVsZUZuIC0gVGhlIHJ1bGUgZnVuY3Rpb24gb2JqZWN0LCB3aGljaCBtYXkgYmUgdW5kZWZpbmVkLiBJZiBkZWZpbmVkLCBpdCBzaG91bGQgY29udGFpbiBhIGBjb25maWdFbGVtZW50c2AgcHJvcGVydHkuXHJcbiAqIEBwYXJhbSBvcHRpb24gLSBUaGUgbmFtZSBvZiB0aGUgb3B0aW9uIHRvIGNoZWNrIHdpdGhpbiB0aGUgYGNvbmZpZ0VsZW1lbnRzYCBvZiB0aGUgcnVsZSBmdW5jdGlvbi5cclxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBvcHRpb24gaXMgdW5kZWZpbmVkIGluIHRoZSBgY29uZmlnRWxlbWVudHNgIG9yIGlmIHRoZSBvcHRpb24gaXMgZXhwbGljaXRseSBzZXQgdG8gYHRydWVgLlxyXG4gKiAgICAgICAgICBSZXR1cm5zIGBmYWxzZWAgaWYgdGhlIG9wdGlvbiBpcyBleHBsaWNpdGx5IHNldCB0byBgZmFsc2VgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJ1bGVPcHRpb24ocnVsZUZuIDogUnVsZUZ1bmN0aW9uIHwgdW5kZWZpbmVkLCBvcHRpb24gOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICBpZiAocnVsZUZuPy5jb25maWdFbGVtZW50c1tvcHRpb25dID09PSB1bmRlZmluZWQpIHJldHVybiB0cnVlO1xyXG4gIHJldHVybiBydWxlRm4uY29uZmlnRWxlbWVudHNbb3B0aW9uXTtcclxufVxyXG5cclxucnVsZUZ1bmN0aW9ucy5wdXNoKHtcclxuICAgIGlkOidkZWZhdWx0JyxcclxuICAgIHJ1bGVUeXBlOiAnYnVpbGRJbicsXHJcbiAgICBkZXNjcmlwdGlvbjogJ1Bhc3MgcGFyYW1ldGVyJyxcclxuICAgIHNvdXJjZTogXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIGxldCByZXN1bHQgPSAnJztcXG4gIHJldHVybiByZXN1bHQ7XFxufVwiLFxyXG4gICAgdHlwZTogWyd0ZXh0J10sXHJcbiAgICBjb25maWdFbGVtZW50czogZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KSxcclxuICAgIGZ4OiBmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29sczpTY3JpcHRpbmdUb29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG59KTtcclxuXHJcbnJ1bGVGdW5jdGlvbnMucHVzaCh7XHJcbiAgaWQ6J2NvbnN0YW50JyxcclxuICBydWxlVHlwZTogJ2J1aWxkSW4nLFxyXG4gIGRlc2NyaXB0aW9uOiAnQ29uc3RhbnQgdmFsdWUnLFxyXG4gIHNvdXJjZTogXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIC8vIGFjcXVpcmUgZmlsZSBwYXRoXFxuICBjb25zdCBwYXRoID0gZmlsZS5wYXRoO1xcbiAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XFxuICBsZXQgcmVzdWx0ID0gJyc7XFxuICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xcbiAgICBwYXJ0cy5wb3AoKTsgLy8gcmVtb3ZlIGZpbGUgbmFtZVxcbiAgICByZXN1bHQgPSByZXN1bHQgKyBwYXJ0cy5qb2luKCcvJyk7XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIixcclxuICB0eXBlOiBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywnbXVsdGl0ZXh0J10sXHJcbiAgY29uZmlnRWxlbWVudHM6IGRlZmF1bHRDb25maWdFbGVtZW50cyh7XHJcbiAgICBhZGRQcmVmaXg6IGZhbHNlLFxyXG4gICAgc3BhY2VSZXBsYWNlbWVudDogZmFsc2UsXHJcbiAgICBzcGVjaWFsQ2hhcmFjdGVyUmVwbGFjZW1lbnQ6IGZhbHNlLFxyXG4gICAgY29udmVydFRvTG93ZXJDYXNlOiBmYWxzZSxcclxuICAgIHJlc3VsdEFzTGluazogZmFsc2UsfSksXHJcbiAgZng6ZnVuY3Rpb24gKGFwcDogQXBwLCBmaWxlOlRGaWxlLCB0b29sczpTY3JpcHRpbmdUb29scyl7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRvb2xzLmdldE9wdGlvbkNvbmZpZyh0b29scy5nZXRSdWxlKCk/LmlkLCdjb25zdGFudFZhbHVlJyk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfSxcclxuICBjb25maWdUYWI6IGZ1bmN0aW9uIChvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6Rm9sZGVyVGFnUnVsZURlZmluaXRpb24sIHRoYXQ6YW55LCBwcmV2aWV3Q29tcG9uZW50KSB7XHJcblxyXG4gICAgdGhhdC5zZXRPcHRpb25Db25maWdEZWZhdWx0cyhydWxlLmlkLCB7XHJcbiAgICAgIGNvbnN0YW50VmFsdWU6ICcnLFxyXG4gICAgfSlcclxuXHJcbiAgICBuZXcgU2V0dGluZyhvcHRpb25FTClcclxuICAgIC5zZXROYW1lKCdDb25zdGFudCB2YWx1ZScpXHJcbiAgICAuc2V0RGVzYygnRW50ZXIgYSBjb25zdGFudCB2YWx1ZSB0byBiZSB1c2VkIGluIHRoZSBydWxlJylcclxuICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxyXG4gICAgICAgIC5zZXRWYWx1ZSh0aGF0LmdldE9wdGlvbkNvbmZpZyhydWxlLmlkICwnY29uc3RhbnRWYWx1ZScpIHx8ICcnKVxyXG4gICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQsJ2NvbnN0YW50VmFsdWUnLCB2YWx1ZSk7XHJcbiAgICAgICAgICB0aGF0LnVwZGF0ZVByZXZpZXcocnVsZSwgcHJldmlld0NvbXBvbmVudCk7XHJcbiAgICAgICAgfSkpO1xyXG4gIH1cclxufSk7XHJcblxyXG5ydWxlRnVuY3Rpb25zLnB1c2goe1xyXG4gIGlkOidmdWxsUGF0aCcsXHJcbiAgcnVsZVR5cGU6ICdidWlsZEluJyxcclxuICBkZXNjcmlwdGlvbjogJ0Z1bGwgcGF0aCwgZmlsZW5hbWUnLFxyXG4gIHNvdXJjZTogXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIC8vIGFjcXVpcmUgZmlsZSBwYXRoXFxuICBjb25zdCBwYXRoID0gZmlsZS5wYXRoO1xcbiAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XFxuICBsZXQgcmVzdWx0ID0gJyc7XFxuICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xcbiAgICBwYXJ0cy5wb3AoKTsgLy8gcmVtb3ZlIGZpbGUgbmFtZVxcbiAgICByZXN1bHQgPSByZXN1bHQgKyBwYXJ0cy5qb2luKCcvJyk7XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIixcclxuICB0eXBlOiBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywnbXVsdGl0ZXh0J10sXHJcbiAgY29uZmlnRWxlbWVudHM6IGRlZmF1bHRDb25maWdFbGVtZW50cyh7fSksXHJcbiAgZng6ZnVuY3Rpb24gKGFwcDogQXBwLCBmaWxlOlRGaWxlLCB0b29sczpTY3JpcHRpbmdUb29scyl7XHJcbiAgICAgIGxldCBwYXJ0cyA9IGZpbGUucGF0aC5zcGxpdCgnLycpO1xyXG4gICAgICBwYXJ0cy5wb3AoKTtcclxuICAgICAgcGFydHMucHVzaChmaWxlLmJhc2VuYW1lKTtcclxuICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJy8nKTtcclxuICB9XHJcbn0pO1xyXG5cclxucnVsZUZ1bmN0aW9ucy5wdXNoKHtcclxuICAgIGlkOidmdWxsUGF0aEV4dCcsXHJcbiAgICBydWxlVHlwZTogJ2J1aWxkSW4nLFxyXG4gICAgZGVzY3JpcHRpb246ICdGdWxsIHBhdGgsIGZpbGVuYW1lIGFuZCBFeHRlbnNpb24nLFxyXG4gICAgc291cmNlOiBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgLy8gYWNxdWlyZSBmaWxlIHBhdGhcXG4gIGNvbnN0IHJlc3VsdCA9IGZpbGUucGF0aDtcXG4gIHJldHVybiByZXN1bHQ7XFxufVwiLFxyXG4gICAgdHlwZTogWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcyddLFxyXG4gICAgY29uZmlnRWxlbWVudHM6IGRlZmF1bHRDb25maWdFbGVtZW50cyh7fSksXHJcbiAgICBmeDogZnVuY3Rpb24gKGFwcDogQXBwLCBmaWxlOlRGaWxlLCB0b29sczpTY3JpcHRpbmdUb29scyl7XHJcbiAgICAgICAgICAgIHJldHVybiBgJHtmaWxlLnBhdGh9YDtcclxuICAgICAgICB9XHJcbn0pO1xyXG5cclxucnVsZUZ1bmN0aW9ucy5wdXNoKHtcclxuICAgIGlkOidwYXRoJyxcclxuICAgIHJ1bGVUeXBlOiAnYnVpbGRJbicsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0Z1bGwgUGF0aCcsXHJcbiAgICBzb3VyY2U6IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICAvLyBhY3F1aXJlIGZpbGUgcGF0aFxcbiAgY29uc3QgcGF0aCA9IGZpbGUucGF0aDtcXG4gIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLycpO1xcbiAgbGV0IHJlc3VsdCA9ICcnO1xcbiAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcXG4gICAgcGFydHMucG9wKCk7IC8vIHJlbW92ZSBmaWxlIG5hbWVcXG4gICAgcmVzdWx0ID0gcmVzdWx0ICsgcGFydHMuam9pbignLycpO1xcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59XCIsXHJcbiAgICB0eXBlOiBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJ10sXHJcbiAgICBjb25maWdFbGVtZW50czogZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KSxcclxuICAgIGZ4OmZ1bmN0aW9uIChhcHA6IEFwcCwgZmlsZTpURmlsZSwgdG9vbHM6U2NyaXB0aW5nVG9vbHMpe1xyXG4gICAgICAgIGxldCBwYXJ0cyA9IGZpbGUucGF0aC5zcGxpdCgnLycpO1xyXG4gICAgICAgIHBhcnRzLnBvcCgpO1xyXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKCcvJyk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxucnVsZUZ1bmN0aW9ucy5wdXNoKHtcclxuICAgIGlkOidsaW5rVG9GaWxlJyxcclxuICAgIHJ1bGVUeXBlOiAnYnVpbGRJbicsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0xpbmsgdG8gZmlsZScsXHJcbiAgICBzb3VyY2U6IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICAvLyBhY3F1aXJlIGZpbGUgcGF0aFxcbiAgY29uc3QgcGF0aCA9IGZpbGUucGF0aDtcXG4gIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLycpO1xcbiAgbGV0IHJlc3VsdCA9ICcnO1xcbiAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcXG4gICAgcGFydHMucG9wKCk7IC8vIHJlbW92ZSBmaWxlIG5hbWVcXG4gICAgcmVzdWx0ID0gcmVzdWx0ICsgcGFydHMuam9pbignLycpO1xcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59XCIsXHJcbiAgICB0eXBlOiBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywnbXVsdGl0ZXh0J10sXHJcbiAgICBjb25maWdFbGVtZW50czogZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHtyZXN1bHRBc0xpbms6IGZhbHNlfSksXHJcbiAgICBmeDpmdW5jdGlvbiAoYXBwOiBBcHAsIGZpbGU6VEZpbGUsIHRvb2xzOlNjcmlwdGluZ1Rvb2xzKXtcclxuICAgICAgICBjb25zdCBwYXJ0cyA9IGZpbGUucGF0aC5zcGxpdCgnLycpO1xyXG4gICAgICAgIGNvbnN0IHJ1bGUgPSB0b29scy5nZXRSdWxlKCk7XHJcbiAgICAgICAgaWYgKCFydWxlKSByZXR1cm4gdG9vbHMuZ2V0Q3VycmVudENvbnRlbnQoKTtcclxuICAgICAgICBjb25zdCBhZGRFeHRlbnNpb24gPSB0b29scy5nZXRPcHRpb25Db25maWcocnVsZS5pZCwnYWRkRXh0ZW5zaW9uJykgXHJcbiAgICAgICAgcGFydHMucG9wKCk7XHJcbiAgICAgICAgaWYgKHBhcnRzW3BhcnRzLmxlbmd0aC0xXSA9PT0gZmlsZS5iYXNlbmFtZSkgcGFydHMucG9wKCk7XHJcbiAgICAgICAgbGV0IGZpbGVOYW1lID0gYWRkRXh0ZW5zaW9uPyBmaWxlLmJhc2VuYW1lICsgJy4nICsgZmlsZS5leHRlbnNpb24gOiBmaWxlLmJhc2VuYW1lOyBcclxuICAgICAgICByZXR1cm4gYFtbJHtwYXJ0cy5qb2luKCcvJyl9LyR7ZmlsZU5hbWV9fCR7ZmlsZS5iYXNlbmFtZX1dXWA7XHJcbiAgICB9LFxyXG4gICAgY29uZmlnVGFiOiBmdW5jdGlvbiAob3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOkZvbGRlclRhZ1J1bGVEZWZpbml0aW9uLCB0aGF0OmFueSwgcHJldmlld0NvbXBvbmVudCkge1xyXG5cclxuICAgICAgdGhhdC5zZXRPcHRpb25Db25maWdEZWZhdWx0cyhydWxlLmlkLCB7XHJcbiAgICAgICAgYWRkRXh0ZW5zaW9uOiB0cnVlXHJcbiAgICAgIH0pXHJcbiAgXHJcbiAgICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgIC5zZXROYW1lKCdJbmNsdWRlIGZpbGUgZXh0ZW5zaW9uJylcclxuICAgICAgICAuc2V0RGVzYygnQWRkIGZpbGUgZXh0ZW5zaW9uIHRvIHBhdGhuYW1lJylcclxuICAgICAgICAuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcclxuICAgICAgICAgICAgLnNldFZhbHVlKHRoYXQuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQgLCdhZGRFeHRlbnNpb24nKSB8fCBmYWxzZSlcclxuICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWcocnVsZS5pZCwnYWRkRXh0ZW5zaW9uJywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC51cGRhdGVQcmV2aWV3KHJ1bGUsIHByZXZpZXdDb21wb25lbnQpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICk7XHJcbiAgICB9ICBcclxufSk7XHJcblxyXG5ydWxlRnVuY3Rpb25zLnB1c2goe1xyXG4gICAgaWQ6J3BhdGhGb2xkZXJOb3RlcycsXHJcbiAgICBydWxlVHlwZTogJ2J1aWxkSW4nLFxyXG4gICAgZGVzY3JpcHRpb246ICdQYXRoIChmb2xkZXIgbm90ZXMpJyxcclxuICAgIHNvdXJjZTogXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIC8vIGFjcXVpcmUgZmlsZSBwYXRoXFxuICBjb25zdCBwYXRoID0gZmlsZS5wYXRoO1xcbiAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XFxuICBsZXQgcmVzdWx0ID0gJyc7XFxuICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xcbiAgICBwYXJ0cy5wb3AoKTsgLy8gcmVtb3ZlIGZpbGUgbmFtZVxcbiAgICByZXN1bHQgPSByZXN1bHQgKyBwYXJ0cy5qb2luKCcvJyk7XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIixcclxuICAgIHR5cGU6IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCdtdWx0aXRleHQnXSxcclxuICAgIGNvbmZpZ0VsZW1lbnRzOiBkZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pLFxyXG4gICAgZng6ZnVuY3Rpb24gKGFwcDogQXBwLCBmaWxlOlRGaWxlLCB0b29sczpTY3JpcHRpbmdUb29scyl7XHJcbiAgICAgICAgbGV0IHBhcnRzID0gZmlsZS5wYXRoLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgcGFydHMucG9wKCk7XHJcbiAgICAgICAgaWYgKHBhcnRzW3BhcnRzLmxlbmd0aC0xXSA9PT0gZmlsZS5iYXNlbmFtZSkgcGFydHMucG9wKCk7IC8vIHJlbW92ZSBwYXJlbnQgZm9sZGVyIGlmIHNhbWUgbmFtZSBhcyB0aGUgZmlsZVxyXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKCcvJyk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxucnVsZUZ1bmN0aW9ucy5wdXNoKHtcclxuICBpZDonZnVsbFBhdGhGb2xkZXJOb3RlcycsXHJcbiAgcnVsZVR5cGU6ICdidWlsZEluJyxcclxuICBkZXNjcmlwdGlvbjogJ0Z1bGwgUGF0aCAoY29tcGx5IHdpdGggXCJmb2xkZXIgbm90ZXNcIiknLFxyXG4gIHNvdXJjZTogXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIC8vIGFjcXVpcmUgZmlsZSBwYXRoXFxuICBjb25zdCBwYXRoID0gZmlsZS5wYXRoO1xcbiAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XFxuICBsZXQgcmVzdWx0ID0gJyc7XFxuICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xcbiAgICBwYXJ0cy5wb3AoKTsgLy8gcmVtb3ZlIGZpbGUgbmFtZVxcbiAgICByZXN1bHQgPSByZXN1bHQgKyBwYXJ0cy5qb2luKCcvJyk7XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIixcclxuICB0eXBlOiBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJ10sXHJcbiAgY29uZmlnRWxlbWVudHM6IGRlZmF1bHRDb25maWdFbGVtZW50cyh7fSksXHJcbiAgZng6ZnVuY3Rpb24gKGFwcDogQXBwLCBmaWxlOlRGaWxlLCB0b29sczpTY3JpcHRpbmdUb29scyl7XHJcbiAgICAgIGxldCBwYXJ0cyA9IGZpbGUucGF0aC5zcGxpdCgnLycpO1xyXG4gICAgICBwYXJ0cy5wb3AoKTsgLy8gcmVtb3ZlIGZpbGUgbmFtZVxyXG4gICAgICBpZiAocGFydHNbcGFydHMubGVuZ3RoLTFdID09PSBmaWxlLmJhc2VuYW1lKSBwYXJ0cy5wb3AoKTsgLy8gcmVtb3ZlIHBhcmVudCBmb2xkZXIgaWYgc2FtZSBuYW1lIGFzIHRoZSBmaWxlXHJcbiAgICAgIHBhcnRzLnB1c2goZmlsZS5iYXNlbmFtZSk7IC8vIGFkZCB0aGUgZmlsZSBuYW1lIGJhY2tcclxuICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJy8nKTtcclxuICB9XHJcbn0pO1xyXG5cclxucnVsZUZ1bmN0aW9ucy5wdXNoKHtcclxuICAgIGlkOidmdWxsUGF0aEV4dEZvbGRlck5vdGVzJyxcclxuICAgIHJ1bGVUeXBlOiAnYnVpbGRJbicsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0Z1bGwgUGF0aCB3aXRoIEV4dGVuc2lvbiAoY29tcGx5IHdpdGggXCJmb2xkZXIgbm90ZXNcIiknLFxyXG4gICAgc291cmNlOiBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgLy8gYWNxdWlyZSBmaWxlIHBhdGhcXG4gIGNvbnN0IHBhdGggPSBmaWxlLnBhdGg7XFxuICBjb25zdCBwYXJ0cyA9IHBhdGguc3BsaXQoJy8nKTtcXG4gIGxldCByZXN1bHQgPSAnJztcXG4gIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XFxuICAgIHBhcnRzLnBvcCgpOyAvLyByZW1vdmUgZmlsZSBuYW1lXFxuICAgIHJlc3VsdCA9IHJlc3VsdCArIHBhcnRzLmpvaW4oJy8nKTtcXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxufVwiLFxyXG4gICAgdHlwZTogWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcyddLFxyXG4gICAgY29uZmlnRWxlbWVudHM6IGRlZmF1bHRDb25maWdFbGVtZW50cyh7fSksXHJcbiAgICBmeDpmdW5jdGlvbiAoYXBwOiBBcHAsIGZpbGU6VEZpbGUsIHRvb2xzOlNjcmlwdGluZ1Rvb2xzKXtcclxuICAgICAgICBsZXQgcGFydHMgPSBmaWxlLnBhdGguc3BsaXQoJy8nKTtcclxuICAgICAgICBwYXJ0cy5wb3AoKTsgLy8gcmVtb3ZlIGZpbGUgbmFtZVxyXG4gICAgICAgIGlmIChwYXJ0c1twYXJ0cy5sZW5ndGgtMV0gPT09IGZpbGUuYmFzZW5hbWUpIHBhcnRzLnBvcCgpOyAvLyByZW1vdmUgcGFyZW50IGZvbGRlciBpZiBzYW1lIG5hbWUgYXMgdGhlIGZpbGVcclxuICAgICAgICBwYXJ0cy5wdXNoKGZpbGUubmFtZSk7IC8vIGFkZCB0aGUgZmlsZSBuYW1lIGJhY2tcclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbignLycpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbnJ1bGVGdW5jdGlvbnMucHVzaCh7XHJcbiAgICBpZDonaXNSb290JyxcclxuICAgIHJ1bGVUeXBlOiAnYnVpbGRJbicsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0ZpbGUgaW4gUm9vdCBmb2xkZXInLFxyXG4gICAgc291cmNlOiBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgbGV0IHBhcnRzID0gZmlsZS5wYXRoLnNwbGl0KCcvJyk7XFxuICByZXR1cm4gcGFydHMubGVuZ3RoID09PSAxO1xcbn1cIixcclxuICAgIHR5cGU6IFsnY2hlY2tib3gnXSxcclxuICAgIGNvbmZpZ0VsZW1lbnRzOiBkZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pLFxyXG4gICAgZng6ZnVuY3Rpb24gKGFwcDogQXBwLCBmaWxlOlRGaWxlLCB0b29sczpTY3JpcHRpbmdUb29scyl7XHJcbiAgICAgICAgbGV0IHBhcnRzID0gZmlsZS5wYXRoLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmxlbmd0aCA9PT0gMTtcclxuICAgIH1cclxufSk7XHJcblxyXG5ydWxlRnVuY3Rpb25zLnB1c2goe1xyXG4gICAgaWQ6J2ZvbGRlcicsXHJcbiAgICBydWxlVHlwZTogJ2J1aWxkSW4nLFxyXG4gICAgZGVzY3JpcHRpb246ICdQYXJlbnQgRm9sZGVyJyxcclxuICAgIHNvdXJjZTogXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIC8vIGFjcXVpcmUgZmlsZSBwYXRoXFxuICBjb25zdCBwYXRoID0gZmlsZS5wYXRoO1xcbiAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XFxuICBsZXQgcmVzdWx0ID0gJyc7XFxuICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xcbiAgICByZXN1bHQgPSBwYXJ0c1twYXJ0cy5sZW5ndGgtMl07XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIixcclxuICAgIHR5cGU6IFsndGV4dCcsICd0YWdzJ10sXHJcbiAgICBjb25maWdFbGVtZW50czogZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KSxcclxuICAgIGZ4OmZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzOlNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIC8vIGFjcXVpcmUgZmlsZSBwYXRoXHJcbiAgICAgICAgY29uc3QgcGF0aCA9IGZpbGUucGF0aDtcclxuICAgICAgICBjb25zdCBwYXJ0cyA9IHBhdGguc3BsaXQoJy8nKTtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XHJcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgIHJlc3VsdCA9IHBhcnRzW3BhcnRzLmxlbmd0aC0yXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG59KTtcclxuXHJcbnJ1bGVGdW5jdGlvbnMucHVzaCh7XHJcbiAgICBpZDonZm9sZGVyRm9sZGVyTm90ZXMnLFxyXG4gICAgcnVsZVR5cGU6ICdidWlsZEluJyxcclxuICAgIGRlc2NyaXB0aW9uOiAnUGFyZW50IEZvbGRlciAoY29tcGxpZXMgd2l0aCBcImZvbGRlciBub3Rlc1wiKScsXHJcbiAgICBzb3VyY2U6IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBjb25zdCBwYXJ0cyA9IGZpbGUucGF0aC5zcGxpdCgnLycpO1xcbiAgbGV0IGluZGV4ID0gcGFydHMubGVuZ3RoLTI7IC8vIGluZGV4IG9mIHBhcmVudCBmb2xkZXJcXG4gIGlmIChwYXJ0c1twYXJ0cy5sZW5ndGgtMl09PT1maWxlLmJhc2VuYW1lKSB7XFxuICAgICAgaW5kZXgtLTsgLy8gZm9sZGVyIG5vdGUgcGFyZW50IGlzIHRoZSBjaGlsZFxcbiAgfVxcbiAgaWYgKGluZGV4ID49IDApIHtcXG4gICAgcmV0dXJuIHBhcnRzW2luZGV4XTsgLy8gZmlsZSBpbiBmb2xkZXJcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiB0b29scy5hcHA/LnZhdWx0Py5nZXROYW1lKCkgfHwgJ1ZhdWx0JzsgLy8gZmlsZSBpbiByb290ID0gdmF1bHRcXG4gIH1cXG59XCIsXHJcbiAgICB0eXBlOiBbJ3RleHQnLCAndGFncyddLFxyXG4gICAgY29uZmlnRWxlbWVudHM6IGRlZmF1bHRDb25maWdFbGVtZW50cyh7fSksXHJcbiAgICBmeDpmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgICAgY29uc3QgcGFydHMgPSBmaWxlLnBhdGguc3BsaXQoJy8nKTtcclxuICAgICAgbGV0IGluZGV4ID0gcGFydHMubGVuZ3RoLTI7IC8vIGluZGV4IG9mIHBhcmVudCBmb2xkZXJcclxuICAgICAgaWYgKHBhcnRzW3BhcnRzLmxlbmd0aC0yXT09PWZpbGUuYmFzZW5hbWUpIHtcclxuICAgICAgICAgIGluZGV4LS07IC8vIGZvbGRlciBub3RlIHBhcmVudCBpcyB0aGUgY2hpbGRcclxuICAgICAgfVxyXG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xyXG4gICAgICAgIHJldHVybiBwYXJ0c1tpbmRleF07IC8vIGZpbGUgaW4gZm9sZGVyXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRvb2xzLmFwcD8udmF1bHQ/LmdldE5hbWUoKSB8fCAnVmF1bHQnOyAvLyBmaWxlIGluIHJvb3QgPSB2YXVsdFxyXG4gICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxucnVsZUZ1bmN0aW9ucy5wdXNoKHtcclxuICAgIGlkOidmb2xkZXJzJyxcclxuICAgIHJ1bGVUeXBlOiAnYnVpbGRJbicsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0FsbCBmb2xkZXJzIG9mIHRoZSBmaWxlIGFzIGEgbGlzdCcsXHJcbiAgICBzb3VyY2U6IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBjb25zdCBwYXRoID0gZmlsZS5wYXRoOyAvLyBhY3F1aXJlIGZpbGUgcGF0aFxcbiAgY29uc3QgcmVzdWx0ID0gcGF0aC5zcGxpdCgnLycpO1xcbiAgcmVzdWx0LnBvcCgpOyAvLyByZW1vdmUgZmlsZSBuYW1lXFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIixcclxuICAgIHR5cGU6IFsnbXVsdGl0ZXh0JywndGFncycsJ2FsaWFzZXMnXSxcclxuICAgIGNvbmZpZ0VsZW1lbnRzOiBkZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pLFxyXG4gICAgZng6ZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHM6U2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAgICAgLy8gYWNxdWlyZSBmaWxlIHBhdGhcclxuICAgICAgICBjb25zdCBwYXRoID0gZmlsZS5wYXRoO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhdGguc3BsaXQoJy8nKTtcclxuICAgICAgICByZXN1bHQucG9wKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG59KTtcclxuXHJcbnJ1bGVGdW5jdGlvbnMucHVzaCh7XHJcbiAgICBpZDoncm9vdEZvbGRlcicsXHJcbiAgICBydWxlVHlwZTogJ2J1aWxkSW4nLFxyXG4gICAgZGVzY3JpcHRpb246ICdSb290IGZvbGRlcicsXHJcbiAgICBzb3VyY2U6IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICAvLyBhY3F1aXJlIGZpbGUgcGF0aFxcbiAgY29uc3QgcGF0aCA9IGZpbGUucGF0aDtcXG4gIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLycpO1xcbiAgbGV0IHJlc3VsdCA9ICcnO1xcbiAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcXG4gICAgcmVzdWx0ID0gcGFydHNbMF07XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIixcclxuICAgIHR5cGU6IFsndGV4dCcsICdtdWx0aXRleHQnLCAndGFncycsICdhbGlhc2VzJ10sXHJcbiAgICBjb25maWdFbGVtZW50czogZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KSxcclxuICAgIGZ4OmZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzOlNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIC8vIGFjcXVpcmUgZmlsZSBwYXRoXHJcbiAgICAgICAgY29uc3QgcGF0aCA9IGZpbGUucGF0aDtcclxuICAgICAgICBjb25zdCBwYXJ0cyA9IHBhdGguc3BsaXQoJy8nKTtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XHJcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgIHJlc3VsdCA9IHBhcnRzWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9XHJcbn0pO1xyXG5cclxucnVsZUZ1bmN0aW9ucy5wdXNoKHtcclxuICAgIGlkOiduYW1lJyxcclxuICAgIHJ1bGVUeXBlOiAnYnVpbGRJbicsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0ZpbGUgbmFtZSB3aXRob3V0IGV4dGVuc2lvbicsXHJcbiAgICBzb3VyY2U6IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICAvLyBhY3F1aXJlIGZpbGUgbmFtZVxcbiAgY29uc3QgcmVzdWx0ID0gZmlsZS5uYW1lLnNwbGl0KCcuJyk7XFxuICByZXN1bHQucG9wKCk7IC8vIHJlbW92ZSBleHRlbnNpb25cXG4gIHJlc3VsdC5qb2luKCcuJyk7IC8vIHJlY29uc3RydWN0IHRoZSBmaWxlIG5hbWVcXG4gIHJldHVybiByZXN1bHQ7XFxufVwiLFxyXG4gICAgdHlwZTogWyd0ZXh0JywgJ211bHRpdGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnXSxcclxuICAgIGNvbmZpZ0VsZW1lbnRzOiBkZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pLFxyXG4gICAgZng6ZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHM6U2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAgICAgLy8gYWNxdWlyZSBmaWxlIG5hbWVcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBmaWxlLm5hbWUuc3BsaXQoJy4nKTtcclxuICAgICAgICByZXN1bHQucG9wKCk7IC8vIHJlbW92ZSBleHRlbnNpb25cclxuICAgICAgICByZXN1bHQuam9pbignLicpOyAvLyByZWNvbnN0cnVjdCB0aGUgZmlsZSBuYW1lXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG59KTtcclxuXHJcbnJ1bGVGdW5jdGlvbnMucHVzaCh7XHJcbiAgICBpZDonbmFtZUV4dCcsXHJcbiAgICBydWxlVHlwZTogJ2J1aWxkSW4nLFxyXG4gICAgZGVzY3JpcHRpb246ICdGaWxlIG5hbWUgd2l0aCBleHRlbnNpb24nLFxyXG4gICAgc291cmNlOiBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgLy8gYWNxdWlyZSBmaWxlIG5hbWVcXG4gIGNvbnN0IHJlc3VsdCA9IGZpbGUubmFtZTtcXG4gIHJldHVybiByZXN1bHQ7XFxufVwiLFxyXG4gICAgdHlwZTogWyd0ZXh0JywgJ211bHRpdGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnXSxcclxuICAgIGNvbmZpZ0VsZW1lbnRzOiBkZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pLFxyXG4gICAgZng6ZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHM6U2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAgICAgLy8gYWNxdWlyZSBmaWxlIG5hbWVcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBmaWxlLm5hbWU7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG59KTtcclxuXHJcbnJ1bGVGdW5jdGlvbnMucHVzaCh7XHJcbiAgICBpZDonZ2V0UHJvcGVydHknLFxyXG4gICAgcnVsZVR5cGU6ICdidWlsZEluLmlucHV0UHJvcGVydHknLFxyXG4gICAgZGVzY3JpcHRpb246ICdHZXQgYSBwcm9wZXJ0eScsXHJcbiAgICBpc0xpdmVSdWxlOiB0cnVlLFxyXG4gICAgaW5wdXRQcm9wZXJ0eTogdHJ1ZSxcclxuICAgIHNvdXJjZTogXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIGNvbnN0IHJlc3VsdCA9IGlucHV0O1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59XCIsXHJcbiAgICB0eXBlOiBbJ3RleHQnLCAnbXVsdGl0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcyddLFxyXG4gICAgY29uZmlnRWxlbWVudHM6IGRlZmF1bHRDb25maWdFbGVtZW50cyh7aW5wdXRQcm9wZXJ0eTp0cnVlfSksXHJcbiAgICBmeDpmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29sczpTY3JpcHRpbmdUb29scywgaW5wdXQ/KSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGlucHV0O1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH1cclxufSk7XHJcblxyXG5ydWxlRnVuY3Rpb25zLnB1c2goe1xyXG4gICAgaWQ6J2RhdGVUaW1lQ3JlYXRlZCcsXHJcbiAgICBydWxlVHlwZTogJ2J1aWxkSW4nLFxyXG4gICAgZGVzY3JpcHRpb246ICdEYXRlIChhbmQgVGltZSkgY3JlYXRlZCcsXHJcbiAgICBzb3VyY2U6IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBjb25zdCB0aW1lT2Zmc2V0ID0gbmV3IERhdGUoRGF0ZS5ub3coKSkuZ2V0VGltZXpvbmVPZmZzZXQoKSo2MDAwMDsgLy8gZ2V0IGxvY2FsIHRpbWUgb2Zmc2V0XFxuICBjb25zdCByZXN1bHQgPSBuZXcgRGF0ZShmaWxlLnN0YXQuY3RpbWUtdGltZU9mZnNldCk7XFxuICByZXR1cm4gcmVzdWx0LnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1onKVswXTsgLy8gcmVtb3ZlIFVUQyBzeW1ib2xcXG59XCIsXHJcbiAgICB0eXBlOiBbJ2RhdGUnLCAnZGF0ZXRpbWUnXSxcclxuICAgIGNvbmZpZ0VsZW1lbnRzOiBkZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pLFxyXG4gICAgZng6ZnVuY3Rpb24gKGFwcDogQXBwLCBmaWxlOlRGaWxlLCB0b29sczpTY3JpcHRpbmdUb29scykgeyBcclxuICAgICAgICBjb25zdCB0aW1lT2Zmc2V0ID0gbmV3IERhdGUoRGF0ZS5ub3coKSkuZ2V0VGltZXpvbmVPZmZzZXQoKSo2MDAwMDsgLy8gZ2V0IGxvY2FsIHRpbWUgb2Zmc2V0XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IERhdGUoZmlsZS5zdGF0LmN0aW1lLXRpbWVPZmZzZXQpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQudG9JU09TdHJpbmcoKS5zcGxpdCgnWicpWzBdOyAvLyByZW1vdmUgVVRDIHN5bWJvbFxyXG4gICAgICB9XHJcbn0pO1xyXG5cclxucnVsZUZ1bmN0aW9ucy5wdXNoKHtcclxuICAgIGlkOidkYXRlVGltZU1vZGlmaWVkJyxcclxuICAgIHJ1bGVUeXBlOiAnYnVpbGRJbicsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0RhdGUgKGFuZCBUaW1lKSBtb2RpZmllZCcsXHJcbiAgICBzb3VyY2U6IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBjb25zdCB0aW1lT2Zmc2V0ID0gbmV3IERhdGUoRGF0ZS5ub3coKSkuZ2V0VGltZXpvbmVPZmZzZXQoKSo2MDAwMDtcXG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBEYXRlKGZpbGUuc3RhdC5tdGltZS10aW1lT2Zmc2V0KTsgLy8gQXBwbHkgb2Zmc2V0IHRvIEdNVCBUaW1lc3RhbXBcXG4gIHJldHVybiByZXN1bHQudG9JU09TdHJpbmcoKS5zcGxpdCgnWicpWzBdOyAvLyByZW1vdmUgVVRDIHN5bWJvbFxcbn1cIixcclxuICAgIHR5cGU6IFsnZGF0ZScsICdkYXRldGltZSddLFxyXG4gICAgY29uZmlnRWxlbWVudHM6IGRlZmF1bHRDb25maWdFbGVtZW50cyh7fSksXHJcbiAgICBmeDpmdW5jdGlvbiAoYXBwOiBBcHAsIGZpbGU6VEZpbGUsIHRvb2xzOlNjcmlwdGluZ1Rvb2xzKSB7IFxyXG4gICAgICAgIGNvbnN0IHRpbWVPZmZzZXQgPSBuZXcgRGF0ZShEYXRlLm5vdygpKS5nZXRUaW1lem9uZU9mZnNldCgpKjYwMDAwO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBEYXRlKGZpbGUuc3RhdC5tdGltZS10aW1lT2Zmc2V0KTsgLy8gQXBwbHkgb2Zmc2V0IHRvIEdNVCBUaW1lc3RhbXBcclxuICAgICAgICByZXR1cm4gcmVzdWx0LnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1onKVswXTsgLy8gcmVtb3ZlIFVUQyBzeW1ib2xcclxuICAgICAgfVxyXG59KTtcclxuXHJcbnJ1bGVGdW5jdGlvbnMucHVzaCh7XHJcbiAgICBpZDonZmlsZVNpemVCeXRlcycsXHJcbiAgICBydWxlVHlwZTogJ2J1aWxkSW4nLFxyXG4gICAgZGVzY3JpcHRpb246ICdGaWxlIHNpemUgaW4gYnl0ZXMnLFxyXG4gICAgc291cmNlOiBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgLy8gYWNxdWlyZSBmaWxlIHNpemVcXG4gIGNvbnN0IHJlc3VsdCA9IGZpbGUuc3RhdC5zaXplO1xcbiAgcmV0dXJuIHJlc3VsdDsgLy8gcmV0dXJuIHlvdSByZXN1bHQuXFxufVwiLFxyXG4gICAgdHlwZTogWydudW1iZXInXSxcclxuICAgIGNvbmZpZ0VsZW1lbnRzOiBkZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pLFxyXG4gICAgZng6ZnVuY3Rpb24gKGFwcDogQXBwLCBmaWxlOlRGaWxlLCB0b29sczpTY3JpcHRpbmdUb29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgICAgICAvLyBhY3F1aXJlIGZpbGUgc2l6ZVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGZpbGUuc3RhdC5zaXplO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7IC8vIHJldHVybiB5b3UgcmVzdWx0LlxyXG4gICAgICB9XHJcbn0pO1xyXG5cclxucnVsZUZ1bmN0aW9ucy5wdXNoKHtcclxuICAgIGlkOidmaWxlU2l6ZVN0cmluZycsXHJcbiAgICBydWxlVHlwZTogJ2J1aWxkSW4nLFxyXG4gICAgZGVzY3JpcHRpb246ICdGaWxlIHNpemUgZm9ybWF0dGVkIGFzIHRleHQnLFxyXG4gICAgc291cmNlOiBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgLy8gYWNxdWlyZSBmaWxlIHNpemVcXG4gIGxldCBzaXplID1maWxlLnN0YXQuc2l6ZTtcXG4gIGNvbnN0IHByZWNpc2lvbiA9IDI7IC8vIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xcbiAgaWYgKHNpemUgPiAxMDI0KSB7XFxuICAgIHNpemUgPSBzaXplIC8gMTAyNDtcXG4gICAgaWYgKHNpemUgPiAxMDI0KSB7XFxuICAgICAgc2l6ZSA9IHNpemUgLyAxMDI0O1xcbiAgICAgIGlmIChzaXplID4gMTAyNCkge1xcbiAgICAgICAgc2l6ZSA9IHNpemUgLyAxMDI0O1xcbiAgICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUZsb2F0KHNpemUpLnRvRml4ZWQocHJlY2lzaW9uKSArICcgR0InO1xcbiAgICAgIH0gXFxuICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUZsb2F0KHNpemUpLnRvRml4ZWQocHJlY2lzaW9uKSArICcgTUInO1xcbiAgICB9XFxuICAgIHJldHVybiBOdW1iZXIucGFyc2VGbG9hdChzaXplKS50b0ZpeGVkKHByZWNpc2lvbikgKyAnIEtCJztcXG4gIH0gICBcXG4gIHJldHVybiBzaXplICsgJyBCeXRlcyc7IC8vIHJldHVybiB5b3UgcmVzdWx0Llxcbn1cIixcclxuICAgIHR5cGU6IFsndGV4dCddLFxyXG4gICAgY29uZmlnRWxlbWVudHM6IGRlZmF1bHRDb25maWdFbGVtZW50cyh7fSksXHJcbiAgICBmeDpmdW5jdGlvbiAoYXBwOiBBcHAsIGZpbGU6VEZpbGUsIHRvb2xzOlNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIC8vIGFjcXVpcmUgZmlsZSBzaXplXHJcbiAgICAgICAgbGV0IHNpemUgPWZpbGUuc3RhdC5zaXplO1xyXG4gICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IDI7IC8vIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xyXG4gICAgICAgIGlmIChzaXplID4gMTAyNCkge1xyXG4gICAgICAgICAgc2l6ZSA9IHNpemUgLyAxMDI0O1xyXG4gICAgICAgICAgaWYgKHNpemUgPiAxMDI0KSB7XHJcbiAgICAgICAgICAgIHNpemUgPSBzaXplIC8gMTAyNDtcclxuICAgICAgICAgICAgaWYgKHNpemUgPiAxMDI0KSB7XHJcbiAgICAgICAgICAgICAgc2l6ZSA9IHNpemUgLyAxMDI0O1xyXG4gICAgICAgICAgICAgIHJldHVybiBzaXplLnRvRml4ZWQocHJlY2lzaW9uKSArICcgR0InO1xyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICByZXR1cm4gc2l6ZS50b0ZpeGVkKHByZWNpc2lvbikgKyAnIE1CJztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBzaXplLnRvRml4ZWQocHJlY2lzaW9uKSArICcgS0InO1xyXG4gICAgICAgIH0gICBcclxuICAgICAgICByZXR1cm4gc2l6ZSArICcgQnl0ZXMnOyAvLyByZXR1cm4geW91IHJlc3VsdC5cclxuICAgICAgfVxyXG59KTtcclxuXHJcbnJ1bGVGdW5jdGlvbnMucHVzaCh7XHJcbiAgaWQ6ICdhdXRvY29tcGxldGUubW9kYWwnLFxyXG4gIHJ1bGVUeXBlOiAnYXV0b2NvbXBsZXRlLm1vZGFsJyxcclxuICBkZXNjcmlwdGlvbjogJ0F1dG9jb21wbGV0ZSBNb2RhbCAoYWR2YW5jZWQpJyxcclxuICBpc0xpdmVSdWxlOiB0cnVlLFxyXG4gIHNvdXJjZTogJycsXHJcbiAgdHlwZTogWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsJ211bHRpdGV4dCddLFxyXG4gIGNvbmZpZ0VsZW1lbnRzOiBkZWZhdWx0Q29uZmlnRWxlbWVudHMoe3JlbW92ZUNvbnRlbnQ6IGZhbHNlLCAgaW5wdXRQcm9wZXJ0eTogZmFsc2UsIGFkZFByZWZpeDogZmFsc2UsIHNwYWNlUmVwbGFjZW1lbnQ6IGZhbHNlLCBzcGVjaWFsQ2hhcmFjdGVyUmVwbGFjZW1lbnQ6IGZhbHNlLCBjb252ZXJ0VG9Mb3dlckNhc2U6IGZhbHNlLCByZXN1bHRBc0xpbms6IGZhbHNlLCBhZGRDb250ZW50OiBmYWxzZSwgc2NyaXB0OiBmYWxzZX0pLFxyXG4gIGZ4OiBhc3luYyBmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29sczpTY3JpcHRpbmdUb29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgIGNvbnNvbGUubG9nKGBhdXRvY29tcGxldGUgbW9kYWwsIHdvcmsgaW4gcHJvZ3Jlc3MuLi5gKTtcclxuICAgIGNvbnN0IGN1cnJlbnRDb250ZW50ID0gdG9vbHMuZ2V0Q3VycmVudENvbnRlbnQoKTtcclxuICAgIGNvbnN0IHJ1bGUgPSB0b29scy5nZXRSdWxlKCk7XHJcbiAgICBpZiAoIXJ1bGUpIHJldHVybiBjdXJyZW50Q29udGVudDtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSB0b29scy5nZXRPcHRpb25Db25maWcocnVsZS5pZCk7XHJcbiAgICBpZiAoIXJ1bGUpIHJldHVybiB0b29scy5nZXRDdXJyZW50Q29udGVudCgpIHx8ICdhdXRvY29tcGxldGUubW9kYWwnOyAvLyByZXR1cm4gY3VycmVudCBjb250ZW50IGlmIG5vdCBpbXBsZW1lbnRlZCB5ZXRcclxuICAgIGNvbnN0IGZyb250bWF0dGVyID0gdG9vbHMuZ2V0RnJvbnRtYXR0ZXIoKTtcclxuICAgIGNvbnN0IGhhc0F1dG9jb21wbGV0ZVByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhmcm9udG1hdHRlcikuc29tZShrZXkgPT4gXHJcbiAgICAgIGtleS5zdGFydHNXaXRoKHJ1bGUucHJvcGVydHkgKyBvcHRpb25zLnByb3BlcnR5RGVsaW1pdGVyKSAmJlxyXG4gICAgICAoZnJvbnRtYXR0ZXJba2V5XSA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgIGZyb250bWF0dGVyW2tleV0gPT09IG51bGwgfHxcclxuICAgICAgZnJvbnRtYXR0ZXJba2V5XSA9PT0gJycpXHJcbiAgICApO1xyXG4gICAgaWYgKCFoYXNBdXRvY29tcGxldGVQcm9wZXJ0aWVzKSByZXR1cm4gdG9vbHMuZ2V0Q3VycmVudENvbnRlbnQoKSB8fCAnYXV0b2NvbXBsZXRlLm1vZGFsJzsgLy8gcmV0dXJuIGN1cnJlbnQgY29udGVudCBpZiBub3QgaW1wbGVtZW50ZWQgeWV0XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBvcGVuQXV0b2NvbXBsZXRlTW9kYWwoXHJcbiAgICAgICAgdGhpcy5hcHAsXHJcbiAgICAgICAgdGhpcy5wbHVnaW4sXHJcbiAgICAgICAgcnVsZSxcclxuICAgICAgICBvcHRpb25zLFxyXG4gICAgICAgIHRvb2xzLmdldEFjdGl2ZUZpbGUoKSxcclxuICAgICAgICB0b29scy5nZXRGcm9udG1hdHRlcigpXHJcbiAgICAgICk7XHJcbiAgICBjb25zb2xlLmxvZygnYXV0b2NvbXBsZXRlIG1vZGFsIHJlc3VsdCcsIHJlc3VsdCwgdG9vbHMuZ2V0RnJvbnRtYXR0ZXIoKSk7XHJcbiAgICBpZiAocmVzdWx0Py52YWx1ZXMpIHtcclxuICAgICAgdGhpcy5hcHAuZmlsZU1hbmFnZXIucHJvY2Vzc0Zyb250TWF0dGVyKGZpbGUsIChmcm9udG1hdHRlcikgPT4ge1xyXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJlc3VsdC52YWx1ZXMpKSB7XHJcbiAgICAgICAgICBmcm9udG1hdHRlcltrZXldID0gdmFsdWU7IC8vIHNldCB0aGUgZnJvbnRtYXR0ZXIgdmFsdWVcclxuICAgICAgICB9XHJcbiAgICAgIH0seydtdGltZSc6ZmlsZS5zdGF0Lm10aW1lfSk7IC8vIGRvIG5vdCBjaGFuZ2UgdGhlIG1vZGlmeSB0aW1lLlxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvb2xzLmdldEN1cnJlbnRDb250ZW50KCkgfHwgJ2F1dG9jb21wbGV0ZS5tb2RhbCc7IC8vIHJldHVybiBjdXJyZW50IGNvbnRlbnQgaWYgbm90IGltcGxlbWVudGVkIHlldFxyXG4gIH0sXHJcbiAgY29uZmlnVGFiOiBmdW5jdGlvbiAob3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOkZvbGRlclRhZ1J1bGVEZWZpbml0aW9uLCB0aGF0OmFueSwgcHJldmlld0NvbXBvbmVudCkge1xyXG5cclxuICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnRGVmYXVsdHMocnVsZS5pZCwge1xyXG4gICAgICBwcm9wZXJ0eURlbGltaXRlcjogJy4nLFxyXG4gICAgfSlcclxuXHJcbiAgICBuZXcgU2V0dGluZyhvcHRpb25FTClcclxuICAgIC5zZXROYW1lKCdEZWxpbWl0ZXInKVxyXG4gICAgLnNldERlc2MoJ0NoYXJhY3RlciB0byBkZXRlcm1pbmUgd2hpY2ggcHJvcGVydHkgc2hvdWxkIGFwcGVhciBpbiB0aGUgbW9kYWwnKVxyXG4gICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgLnNldFZhbHVlKHRoYXQuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQgLCdwcm9wZXJ0eURlbGltaXRlcicpIHx8ICcuJylcclxuICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZyhydWxlLmlkLCdwcm9wZXJ0eURlbGltaXRlcicsIHZhbHVlKTtcclxuICAgICAgICB9KSk7XHJcbiAgfVxyXG59KVxyXG5cclxucnVsZUZ1bmN0aW9ucy5wdXNoKHtcclxuICBpZDogJ2F1dG9MaW5rJyxcclxuICBydWxlVHlwZTogJ2F1dG9tYXRpb24nLFxyXG4gIGRlc2NyaXB0aW9uOiAnQXV0byBMaW5rIChhZHZhbmNlZCknLFxyXG4gIGlzTGl2ZVJ1bGU6IHRydWUsXHJcbiAgc291cmNlOiAnJyxcclxuICB0eXBlOiBbJ3RleHQnLCdtdWx0aXRleHQnXSxcclxuICBjb25maWdFbGVtZW50czogZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHtyZW1vdmVDb250ZW50OiBmYWxzZSwgIGlucHV0UHJvcGVydHk6IGZhbHNlLCBhZGRQcmVmaXg6IGZhbHNlLCBzcGFjZVJlcGxhY2VtZW50OiBmYWxzZSwgc3BlY2lhbENoYXJhY3RlclJlcGxhY2VtZW50OiBmYWxzZSwgY29udmVydFRvTG93ZXJDYXNlOiBmYWxzZSwgcmVzdWx0QXNMaW5rOiBmYWxzZSwgc2NyaXB0OiBmYWxzZX0pLFxyXG4gIGZ4OiBhc3luYyBmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29sczpTY3JpcHRpbmdUb29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgIGNvbnN0IGN1cnJlbnRDb250ZW50ID0gdG9vbHMuZ2V0Q3VycmVudENvbnRlbnQoKTtcclxuICAgIGxldCBuZXdDb250ZW50ID0gbmV3IEFycmF5PHN0cmluZz4oKTtcclxuICAgIGNvbnN0IHJ1bGUgPSB0b29scy5nZXRSdWxlKCk7XHJcbiAgICBpZiAoIXJ1bGUpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgYXV0b0xpbms6IHJ1bGUgbm90IGZvdW5kLCByZXR1cm5pbmcgY3VycmVudCBjb250ZW50ICR7Y3VycmVudENvbnRlbnR9YCk7XHJcbiAgICAgIHJldHVybiBjdXJyZW50Q29udGVudDtcclxuICAgIH0gXHJcbiAgICBjb25zdCBvcHRpb25zID0gdG9vbHMuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQpO1xyXG4gICAgY29uc3QgZmlsZXNUb0NoZWNrID0gdG9vbHMuZ2V0RmlsZXNJblZhdWx0KG9wdGlvbnMuZGVzdGluYXRpb25Gb2xkZXIpO1xyXG4gICAgbGV0IGxpbmtzID0gY3VycmVudENvbnRlbnQgfHwgW107XHJcbiAgICBpZiAodHlwZW9mIGxpbmtzID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShsaW5rcykpIHtcclxuICAgICAgbGlua3MgPSBbXTsgLy8gY29udmVydCBvYmplY3QgdG8gYXJyYXlcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpbmtzID09PSAnc3RyaW5nJykge1xyXG4gICAgICBsaW5rcyA9IFtsaW5rc107IC8vIGNvbnZlcnQgdG8gYXJyYXkgaWYgbm90IGFscmVhZHkgYW4gYXJyYXlcclxuICAgIH1cclxuICAgIC8vIGNvbnNvbGUubG9nKGBhdXRvTGluazogbGlua3MgdG8gY2hlY2tgLCBsaW5rcywgZmlsZXNUb0NoZWNrKTtcclxuICBcclxuICAgIGZvciAoY29uc3QgcGFydCBvZiBsaW5rcykgIHtcclxuICAgICAgbGV0IGxpbmsgPSB0b29scy5leHRyYWN0TGlua1BhcnRzKHBhcnQpO1xyXG4gICAgICBsZXQgbGlua0ZpbGUgPSB0b29scy5nZXRGaWxlRnJvbVBhdGgobGluay5wYXRoLCBmaWxlc1RvQ2hlY2spO1xyXG4gICAgICBpZiAoIWxpbmtGaWxlKSB7IC8vIGNyZWF0ZSBuZXcgRmlsZVxyXG4gICAgICAgIGlmIChvcHRpb25zLmFza0NvbmZpcm1hdGlvbikge1xyXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbmV3IEFsZXJ0TW9kYWwoYXBwLCAnQ3JlYXRlIG5ldyBmaWxlJywgYEZpbGUgJHtsaW5rLnBhdGh9IGRvZXMgbm90IGV4aXN0LiBEbyB5b3Ugd2FudCB0byBjcmVhdGUgaXQ/YCwgJ0NyZWF0ZScsICdDYW5jZWwnLCBcIkRvbid0IGFzayBhZ2Fpbi5cIikub3BlbkFuZEdldFZhbHVlKCk7XHJcbiAgICAgICAgICBpZiAoIXJlc3VsdC5wcm9jZWVkKSByZXR1cm47IC8vIGRvIG5vdCBjcmVhdGUgdGhlIGZpbGUgaWYgdGhlIHVzZXIgZG9lcyBub3QgY29uZmlybVxyXG4gICAgICAgICAgb3B0aW9ucy5hc2tDb25maXJtYXRpb24gPSAhcmVzdWx0LmRhdGEuYXNrQ29uZmlybWF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsaW5rLnBhdGggPSBvcHRpb25zLmRlc3RpbmF0aW9uRm9sZGVyICsgJy8nICsgbGluay50aXRsZSArICcubWQnOyAvLyBhZGQgdGhlIGRlc3RpbmF0aW9uIGZvbGRlciB0byB0aGUgbGluayBwYXRoXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhgYXV0b0xpbms6IGNyZWF0aW5nIG5ldyBmaWxlICR7bGluay5wYXRofWApO1xyXG4gICAgICAgIGxpbmtGaWxlID0gYXdhaXQgdG9vbHMuY3JlYXRlRmlsZUZyb21QYXRoKGxpbmsucGF0aCwgb3B0aW9ucy5hZGRUZW1wbGF0ZSA/IG9wdGlvbnMudGVtcGxhdGVGaWxlIDogdW5kZWZpbmVkKTsgLy8gY3JlYXRlIHRoZSBmaWxlIGlmIGl0IGRvZXMgbm90IGV4aXN0XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhgYXV0b0xpbms6IG5ldyBmaWxlIGNyZWF0ZWQgJHtsaW5rRmlsZS5wYXRofWApO1xyXG4gICAgICAgIHRvb2xzLnVwZGF0ZUZyb250bWF0dGVyKHJ1bGUucHJvcGVydHksIFtgW1ske3Rvb2xzLnJlbW92ZUxlYWRpbmdTbGFzaChsaW5rLnBhdGgpfXwke2xpbmsudGl0bGV9XV1gXSwgbGlua0ZpbGUpOyAvLyBhZGQgbG9jYXRpb24gb2YgbmV3IHBhdGggdG8gaXRzZWxmXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhgYXV0b0xpbms6IGNyZWF0aW5nIExpbmsgdG8gZXhpc3RpbmcgRmlsZSAke2xpbmtGaWxlLnBhdGh9YCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGxpbmtGaWxlKSB7XHJcbiAgICAgICAgbGluay5wYXRoID0gbGlua0ZpbGUucGF0aDtcclxuICAgICAgICBuZXdDb250ZW50LnB1c2goYFtbJHt0b29scy5yZW1vdmVMZWFkaW5nU2xhc2gobGluay5wYXRoKX18JHtsaW5rLnRpdGxlfV1dYCk7IC8vIGFkZCB0aGUgZmlsZSBwYXRoIHRvIHRoZSBuZXcgY29udGVudFxyXG4gICAgICB9XHJcbiAgICAgIC8vY29uc29sZS5sb2coYGF1dG9MaW5rOiBuZXcgY29udGVudGAsIG5ld0NvbnRlbnQpO1xyXG4gICAgfVxyXG4gICAgLy9jb25zb2xlLmxvZyhgYXV0b0xpbms6IHdyaXRlIGNvbnRlbnRgLCBuZXdDb250ZW50KTtcclxuICAgIHRvb2xzLnVwZGF0ZUZyb250bWF0dGVyKHJ1bGUucHJvcGVydHksIG5ld0NvbnRlbnQpOyAvLyB1cGRhdGUgdGhlIGZyb250bWF0dGVyIHdpdGggdGhlIG5ldyBjb250ZW50XHJcbiAgICByZXR1cm4gbmV3Q29udGVudDsgICAgXHJcbiAgfSxcclxuICBjb25maWdUYWI6IGZ1bmN0aW9uIChvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6Rm9sZGVyVGFnUnVsZURlZmluaXRpb24sIHRoYXQ6YW55LCBwcmV2aWV3Q29tcG9uZW50KSB7XHJcblxyXG4gICAgdGhhdC5zZXRPcHRpb25Db25maWdEZWZhdWx0cyhydWxlLmlkLCB7XHJcbiAgICAgIGFkZFRlbXBsYXRlOiB0cnVlLFxyXG4gICAgICBhc2tDb25maXJtYXRpb246IHRydWUsXHJcbiAgICAgIGRlc3RpbmF0aW9uRm9sZGVyOiAnLycsXHJcbiAgICAgIHRlbXBsYXRlRmlsZTogJycsXHJcbiAgICB9KVxyXG5cclxuICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAuc2V0TmFtZSgnQWRkIHRlbXBsYXRlIHRvIG5ldyBmaWxlcycpXHJcbiAgICAgIC5zZXREZXNjKCdBdXRvbWF0aWNhbGx5IGFkZCB0ZW1wbGF0ZSB0byBuZXcgZmlsZXMnKVxyXG4gICAgICAuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcclxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGF0LmdldE9wdGlvbkNvbmZpZyhydWxlLmlkICwnYWRkVGVtcGxhdGUnKSB8fCBmYWxzZSlcclxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZyhydWxlLmlkLCdhZGRUZW1wbGF0ZScsIHZhbHVlKTtcclxuICAgICAgICAgIH0pKTtcclxuXHJcbiAgICBuZXcgU2V0dGluZyhvcHRpb25FTClcclxuICAgICAgLnNldE5hbWUoJ0FzayBmb3IgY29uZmlybWF0aW9uJylcclxuICAgICAgLnNldERlc2MoJ0FzayBmb3IgY29uZmlybWF0aW9uIGJlZm9yZSBjcmVhdGluZyBuZXcgZmlsZXMnKVxyXG4gICAgICAuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcclxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGF0LmdldE9wdGlvbkNvbmZpZyhydWxlLmlkICwnYXNrQ29uZmlybWF0aW9uJykgfHwgZmFsc2UpXHJcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWcocnVsZS5pZCwnYXNrQ29uZmlybWF0aW9uJywgdmFsdWUpO1xyXG4gICAgICAgICAgfSkpO1xyXG5cclxuICAgIGxldCBkZXN0aW5hdGlvbkZvbGRlckVsOlNlYXJjaENvbXBvbmVudDsgIFxyXG4gICAgbmV3IFNldHRpbmcob3B0aW9uRUwpXHJcbiAgICAgIC5zZXROYW1lKCdEZXN0aW5hdGlvbiBGb2xkZXInKVxyXG4gICAgICAuc2V0RGVzYygnRm9sZGVyIHRvIHBsYWNlIG5ldyBmaWxlcycpXHJcbiAgICAgIC5hZGRTZWFyY2goKGNiKSA9PiB7XHJcbiAgICAgICAgICBkZXN0aW5hdGlvbkZvbGRlckVsID0gY2I7XHJcbiAgICAgICAgICBuZXcgRm9sZGVyU3VnZ2VzdCh0aGF0LmFwcCwgY2IuaW5wdXRFbCk7XHJcbiAgICAgICAgICBjYi5zZXRQbGFjZWhvbGRlcihcImVudGVyIGZvbGRlciBvciBicm93c2UgLi4uXCIpXHJcbiAgICAgICAgICAgICAgLnNldFZhbHVlKHRoYXQuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQgLCdkZXN0aW5hdGlvbkZvbGRlcicpIHx8ICcnKVxyXG4gICAgICAgICAgICAgIC5vbkNoYW5nZSgobmV3Rm9sZGVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgIG5ld0ZvbGRlciA9IG5ld0ZvbGRlci50cmltKClcclxuICAgICAgICAgICAgICAgICAgbmV3Rm9sZGVyID0gbmV3Rm9sZGVyLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWcocnVsZS5pZCwnZGVzdGluYXRpb25Gb2xkZXInLCBuZXdGb2xkZXIpO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgY2IuY29udGFpbmVyRWwuYWRkQ2xhc3MoXCJmcm9udG1hdHRlci1hdXRvbWF0ZS1zZWFyY2hcIik7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5hZGRFeHRyYUJ1dHRvbigoYnV0dG9uKSA9PlxyXG4gICAgICAgIGJ1dHRvblxyXG4gICAgICAgICAgLnNldEljb24oJ2ZvbGRlci10cmVlJylcclxuICAgICAgICAgIC5zZXRUb29sdGlwKCdTZWxlY3QgdGVtcGxhdGUgZm9sZGVyJylcclxuICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgb3BlbkRpcmVjdG9yeVNlbGVjdGlvbk1vZGFsKFxyXG4gICAgICAgICAgICAgIHRoYXQuYXBwLFxyXG4gICAgICAgICAgICAgIFt0aGF0LmdldE9wdGlvbkNvbmZpZyhydWxlLmlkICwnZGVzdGluYXRpb25Gb2xkZXInKV0sXHJcbiAgICAgICAgICAgICAgW10sXHJcbiAgICAgICAgICAgICAgeyBcclxuICAgICAgICAgICAgICAgICAgdGl0bGU6ICdTZWxlY3QgZm9sZGVyIHRvIHBsYWNlIG5ldyBmaWxlcycsXHJcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbk1vZGU6ICdpbmNsdWRlJyxcclxuICAgICAgICAgICAgICAgICAgZGlzcGxheU1vZGU6ICdmb2xkZXInLFxyXG4gICAgICAgICAgICAgICAgICBvcHRpb25TZWxlY3Rpb25Nb2RlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgb3B0aW9uU2hvd0ZpbGVzOiBmYWxzZSxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIChyZXN1bHQ6IERpcmVjdG9yeVNlbGVjdGlvblJlc3VsdCB8IG51bGwpID0+IHtcclxuICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5mb2xkZXJzLmxlbmd0aCA9PT0gMCB8fCAhcmVzdWx0LmZvbGRlcnNbMF0gfHwgdHlwZW9mIHJlc3VsdC5mb2xkZXJzWzBdICE9PSAnc3RyaW5nJykgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICBsZXQgc2VsZWN0ZWRGb2xkZXIgPSByZXN1bHQuZm9sZGVyc1swXS50cmltKCkucmVwbGFjZSgvXFwvJC8sIFwiXCIpOyAvLyByZW1vdmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAoL15cXC98XFwvJC9nLCBcIlwiKVxyXG4gICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRGb2xkZXIgPT09ICcnKSBzZWxlY3RlZEZvbGRlciA9ICcvJzsgLy8gaWYgZW1wdHksIHNldCB0byByb290IGZvbGRlclxyXG4gICAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdGVkRm9sZGVyKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uRm9sZGVyRWwuc2V0VmFsdWUoc2VsZWN0ZWRGb2xkZXIpO1xyXG4gICAgICAgICAgICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZyhydWxlLmlkLCdkZXN0aW5hdGlvbkZvbGRlcicsIHNlbGVjdGVkRm9sZGVyKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgKTtcclxuICAgIFxyXG4gICAgbGV0IGRlc3RpbmF0aW9uRmlsZUVsOlNlYXJjaENvbXBvbmVudDsgIFxyXG4gICAgbmV3IFNldHRpbmcob3B0aW9uRUwpXHJcbiAgICAgIC5zZXROYW1lKCdUZW1wbGF0ZSBGaWxlJylcclxuICAgICAgLnNldERlc2MoJ1NlbGVjdCBhIHRlbXBsYXRlIGZpbGUgdG8gYWRkIHRvIG5ldyBmaWxlcycpXHJcbiAgICAgIC5hZGRTZWFyY2goKGNiKSA9PiB7XHJcbiAgICAgICAgICBkZXN0aW5hdGlvbkZpbGVFbCA9IGNiO1xyXG4gICAgICAgICAgbmV3IEZpbGVTdWdnZXN0KGNiLmlucHV0RWwsIHRoYXQucGx1Z2luLCAnJyk7XHJcbiAgICAgICAgICBjYi5zZXRQbGFjZWhvbGRlcihcImVudGVyIGZvbGRlciBvciBicm93c2UgLi4uXCIpXHJcbiAgICAgICAgICAgICAgLnNldFZhbHVlKHRoYXQuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQgLCd0ZW1wbGF0ZUZpbGUnKSB8fCAnJylcclxuICAgICAgICAgICAgICAub25DaGFuZ2UoKG5ld0ZpbGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgbmV3RmlsZSA9IG5ld0ZpbGUudHJpbSgpXHJcbiAgICAgICAgICAgICAgICAgIG5ld0ZpbGUgPSBuZXdGaWxlLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWcocnVsZS5pZCwndGVtcGxhdGVGaWxlJywgbmV3RmlsZSk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICBjYi5jb250YWluZXJFbC5hZGRDbGFzcyhcImZyb250bWF0dGVyLWF1dG9tYXRlLXNlYXJjaFwiKTtcclxuICAgICAgfSlcclxuICAgICAgLmFkZEV4dHJhQnV0dG9uKChidXR0b24pID0+XHJcbiAgICAgICAgYnV0dG9uXHJcbiAgICAgICAgICAuc2V0SWNvbignZm9sZGVyLXRyZWUnKVxyXG4gICAgICAgICAgLnNldFRvb2x0aXAoJ1NlbGVjdCB0ZW1wbGF0ZSBmaWxlJylcclxuICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgb3BlbkRpcmVjdG9yeVNlbGVjdGlvbk1vZGFsKFxyXG4gICAgICAgICAgICAgIHRoYXQuYXBwLFxyXG4gICAgICAgICAgICAgIFtdLFxyXG4gICAgICAgICAgICAgIFt0aGF0LmdldE9wdGlvbkNvbmZpZyhydWxlLmlkLCd0ZW1wbGF0ZUZpbGUnKV0sXHJcbiAgICAgICAgICAgICAgeyBcclxuICAgICAgICAgICAgICAgICAgdGl0bGU6ICdTZWxlY3QgdGVtcGxhdGUgZm9yIG5ldyBmaWxlcycsXHJcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbk1vZGU6ICdpbmNsdWRlJyxcclxuICAgICAgICAgICAgICAgICAgZGlzcGxheU1vZGU6ICdmaWxlJyxcclxuICAgICAgICAgICAgICAgICAgb3B0aW9uU2VsZWN0aW9uTW9kZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgIG9wdGlvblNob3dGaWxlczogdHJ1ZSxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIChyZXN1bHQ6IERpcmVjdG9yeVNlbGVjdGlvblJlc3VsdCB8IG51bGwpID0+IHtcclxuICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5maWxlcy5sZW5ndGggPT09IDAgfHwgIXJlc3VsdC5maWxlc1swXSB8fCB0eXBlb2YgcmVzdWx0LmZpbGVzWzBdICE9PSAnc3RyaW5nJykgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICBsZXQgc2VsZWN0ZWRGaWxlID0gcmVzdWx0LmZpbGVzWzBdLnRyaW0oKS5yZXBsYWNlKC9cXC8kLywgXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgIGlmICghc2VsZWN0ZWRGaWxlKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uRmlsZUVsLnNldFZhbHVlKHNlbGVjdGVkRmlsZSk7XHJcbiAgICAgICAgICAgICAgICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQsJ3RlbXBsYXRlRmlsZScsIHNlbGVjdGVkRmlsZSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9KSIsICJcclxuaW1wb3J0IHsgQXBwLCBNb2RhbCwgU2V0dGluZywgVEFic3RyYWN0RmlsZSwgVEZpbGUsIFRGb2xkZXIsIFZhdWx0LCBzZXRJY29uLEJ1dHRvbkNvbXBvbmVudCwgVGV4dENvbXBvbmVudCwgQ29uc3RydWN0b3IgfSBmcm9tICdvYnNpZGlhbic7IC8vIEFkZGVkIHNldEljb25cclxuaW1wb3J0IHsgRm9sZGVyVGFnUnVsZURlZmluaXRpb24sIE9ic2lkaWFuUHJvcGVydHlUeXBlcywgUHJvcGVydHlJbmZvIH0gZnJvbSAnLi90eXBlcyc7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSAnLi90b29scyc7XHJcbmltcG9ydCB7IHJlbmRlclZhbHVlSW5wdXQsIHVwZGF0ZVByb3BlcnR5SWNvbiB9IGZyb20gJy4vdWlFbGVtZW50cyc7IC8vIEltcG9ydCB0aGUgZnVuY3Rpb24gdG8gcmVuZGVyIHZhbHVlIGlucHV0XHJcblxyXG5cclxuLy8gRGVmaW5lIHRoZSByZXN1bHQgc3RydWN0dXJlIHJldHVybmVkIGJ5IHRoZSBtb2RhbFxyXG5leHBvcnQgaW50ZXJmYWNlIGF1dG9jb21wbGV0ZU1vZGFsUmVzdWx0IHtcclxuICAgIHZhbHVlczoge307XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBPYnNpZGlhbiBNb2RhbCBmb3Igc2VsZWN0aW5nIGRpcmVjdG9yaWVzIGFuZCBmaWxlcyBmcm9tIHRoZSB2YXVsdCBzdHJ1Y3R1cmUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQXV0b2NvbXBsZXRlTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XHJcblxyXG4gICAgXHJcbiAgICBwcml2YXRlIHJlc29sdmVQcm9taXNlITogKHJlc3VsdDogYXV0b2NvbXBsZXRlTW9kYWxSZXN1bHQgfCBudWxsKSA9PiB2b2lkO1xyXG4gICAgcHJpdmF0ZSBwcm9taXNlOiBQcm9taXNlPGF1dG9jb21wbGV0ZU1vZGFsUmVzdWx0IHwgbnVsbD47XHJcblxyXG4gICAgLy8gSW5pdGlhbCBzdGF0ZSBwYXNzZWQgdG8gdGhlIG1vZGFsIChzdG9yZWQgZm9yIHJlc2V0IGZ1bmN0aW9uYWxpdHkpXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IG9rQ2FsbGJhY2s6IChyZXN1bHQ6IGF1dG9jb21wbGV0ZU1vZGFsUmVzdWx0IHwgbnVsbCkgPT4gdm9pZDtcclxuICAgIHByaXZhdGUgcGx1Z2luOiBhbnk7XHJcbiAgICBwcml2YXRlIG9wdGlvbnM6IGFueTtcclxuICAgIHByaXZhdGUgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzO1xyXG4gICAgcHJpdmF0ZSBleHBlY3RlZFR5cGU6IE9ic2lkaWFuUHJvcGVydHlUeXBlcztcclxuICAgIHByaXZhdGUgcnVsZTogRm9sZGVyVGFnUnVsZURlZmluaXRpb247XHJcbiAgICBwcml2YXRlIGtub3duUHJvcGVydGllczogUmVjb3JkPHN0cmluZywgUHJvcGVydHlJbmZvPiA9IHt9O1xyXG5cclxuICAgIC8vIEN1cnJlbnQgc3RhdGUgYmVpbmcgbW9kaWZpZWQgd2l0aGluIHRoZSBtb2RhbFxyXG4gICAgcHJpdmF0ZSBhY3RpdmVGaWxlOiBURmlsZSB8IFRGb2xkZXIgfCB1bmRlZmluZWRcclxuICAgIHByaXZhdGUgZnJvbnRtYXR0ZXI6IGFueTsgLy8gRnJvbnRtYXR0ZXIgZGF0YSBmb3IgdGhlIGFjdGl2ZSBmaWxlXHJcblxyXG4gICAgLy8gVUkgRWxlbWVudHNcclxuICAgIHByaXZhdGUgY29udGVudFJvb3RFbGVtZW50OiBIVE1MRWxlbWVudDtcclxuICAgIHByaXZhdGUgZnVuY3Rpb25UZXN0QnV0dG9uOiBCdXR0b25Db21wb25lbnQ7XHJcbiAgICBwcml2YXRlIGZ1bmN0aW9uUmVzdWx0VGV4dENvbXBvbmVudDogVGV4dENvbXBvbmVudCB8IHVuZGVmaW5lZDtcclxuICAgIHByaXZhdGUgcmVzdWx0OiBhbnkgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhlIERpcmVjdG9yeVNlbGVjdGlvbk1vZGFsLlxyXG4gICAgICogQHBhcmFtIGFwcCAtIFRoZSBPYnNpZGlhbiBBcHAgaW5zdGFuY2UuXHJcbiAgICAgKiBAcGFyYW0gcGx1Z2luIC0gVGhlIHBsdWdpbiBpbnN0YW5jZS5cclxuICAgICAqIEBwYXJhbSBleHBlY3RlZFR5cGUgLSBFeHBlY3RlZCByZXR1cm4gdHlwZS5cclxuICAgICAqIEBwYXJhbSBhY3RpdmVGaWxlIC0gVGhlIGN1cnJlbnRseSBhY3RpdmUgZmlsZSBvciBmb2xkZXIuXHJcbiAgICAgKiBAcGFyYW0gZnJvbnRtYXR0ZXIgLSBGcm9udG1hdHRlciBkYXRhIGZvciB0aGUgYWN0aXZlIGZpbGUuXHJcbiAgICAgKiBAcGFyYW0gb2tDYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgdXNlciBjbGlja3MgXCJPS1wiLiBSZWNlaXZlcyB0aGUgc2VsZWN0aW9uIHJlc3VsdC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgYXBwOiBBcHAsXHJcbiAgICAgICAgcGx1Z2luOiBhbnksXHJcbiAgICAgICAgcnVsZTogRm9sZGVyVGFnUnVsZURlZmluaXRpb24sXHJcbiAgICAgICAgb3B0aW9uczogYW55LFxyXG4gICAgICAgIGFjdGl2ZUZpbGU6IFRGaWxlIHwgVEZvbGRlciB8IHVuZGVmaW5lZCxcclxuICAgICAgICBmcm9udG1hdHRlcjogYW55LCAgIFxyXG4gICAgICAgIG9rQ2FsbGJhY2s/OiAocmVzdWx0OiBhdXRvY29tcGxldGVNb2RhbFJlc3VsdCB8IG51bGwpID0+IHZvaWRcclxuICAgICkge1xyXG4gICAgICAgIHN1cGVyKGFwcCk7XHJcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICAgICAgLy8gU3RvcmUgaW5pdGlhbCBzdGF0ZSBmb3IgcmVzZXRcclxuICAgICAgICB0aGlzLnRvb2xzPSBuZXcgU2NyaXB0aW5nVG9vbHMoYXBwLCB0aGlzLnBsdWdpbiwgdGhpcy5mcm9udG1hdHRlcik7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVGaWxlID0gYWN0aXZlRmlsZTtcclxuICAgICAgICB0aGlzLmZyb250bWF0dGVyID0gZnJvbnRtYXR0ZXI7IC8vIFN0b3JlIGZyb250bWF0dGVyIGRhdGFcclxuXHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICAgICAgdGhpcy5ydWxlID0gcnVsZTtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zOyAvLyBTdG9yZSBvcHRpb25zIGZvciB0aGUgbW9kYWxcclxuICAgICAgICB0aGlzLmV4cGVjdGVkVHlwZSA9IHJ1bGUudHlwZTsgLy8gRXhwZWN0ZWQgdHlwZSBmb3IgdGhlIG1vZGFsXHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHByb21pc2VcclxuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAob2tDYWxsYmFjaykgdGhpcy5va0NhbGxiYWNrID0gb2tDYWxsYmFjaztcclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBjdXJyZW50IHN0YXRlIGZyb20gaW5pdGlhbCBzdGF0ZSBmb3IgZWRpdGluZ1xyXG4gICAgICAgIHRoaXMucmVzZXRUb0luaXRpYWwoKTsgLy8gVXNlIGEgbWV0aG9kIGZvciBpbml0aWFsaXphdGlvbiBhbmQgcmVzZXRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGUgY3VycmVudCBzZWxlY3Rpb24gc3RhdGUgdG8gdGhlIGluaXRpYWwgc3RhdGUgcHJvdmlkZWQgYXQgY29uc3RydWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlc2V0VG9Jbml0aWFsKCk6IHZvaWQge1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBzdGF0ZSB0byBlbXB0eS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZXNldFRvRW1wdHkoKTogdm9pZCB7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgbW9kYWwgaXMgb3BlbmVkLiBCdWlsZHMgdGhlIFVJLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBvbk9wZW4oKSB7XHJcbiAgICAgICAgdGhpcy5rbm93blByb3BlcnRpZXMgPSBhd2FpdCB0aGlzLnRvb2xzLmZldGNoS25vd25Qcm9wZXJ0aWVzKHRoaXMuYXBwKTsgLy8gSW5pdGlhbGl6ZSBrbm93biBwcm9wZXJ0aWVzXHJcbiAgICAgICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGNvbnRlbnRFbC5wYXJlbnRFbGVtZW50KSBjb250ZW50RWwucGFyZW50RWxlbWVudC5zdHlsZS53aWR0aCA9ICc5MDBweCc7XHJcbiAgICAgICAgY29udGVudEVsLmVtcHR5KCk7IC8vIENsZWFyIHByZXZpb3VzIFxyXG4gICAgICAgIGNvbnRlbnRFbC5hZGRDbGFzcygnY29kZUVkaXRvci1tb2RhbCcpOyBcclxuXHJcbiAgICAgICAgLy8gLS0tIE1vZGFsIFRpdGxlIC0tLVxyXG4gICAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdQbGVhc2UgY29tcGxldGUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzJyB9KTsgICAgXHJcbiAgICAgICAgY29udGVudEVsLmNyZWF0ZUVsKCdib2R5JywgeyB0ZXh0OiBgRmlsZTogJHt0aGlzLmFjdGl2ZUZpbGU/LnBhdGh9YCB9KTsgXHJcblxyXG4gICAgICAgIC8vIC0tLSBUcmVlIENvbnRhaW5lciAtLS1cclxuICAgICAgICB0aGlzLmNvbnRlbnRSb290RWxlbWVudCA9IGNvbnRlbnRFbC5jcmVhdGVEaXYoeyBjbHM6ICdjb2RlRWRpdG9yLWNvbnRhaW5lcicgfSk7XHJcbiAgICAgICAgLy8gQmFzaWMgc3R5bGluZyBmb3IgdGhlIHNjcm9sbGFibGUgdHJlZSBhcmVhXHJcbiAgICAgICAgLy8gdGhpcy5lZGl0b3JSb290RWxlbWVudC5zdHlsZS53aWR0aCA9ICc2MDBweCc7XHJcbiAgICAgICAgLy8gdGhpcy5jb250ZW50Um9vdEVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJzYwMHB4JztcclxuICAgICAgICB0aGlzLmNvbnRlbnRSb290RWxlbWVudC5zdHlsZS5vdmVyZmxvd1kgPSAnYXV0byc7XHJcbiAgICAgICAgLy90aGlzLmVkaXRvclJvb3RFbGVtZW50LnN0eWxlLmJvcmRlciA9ICcxcHggc29saWQgdmFyKC0tYmFja2dyb3VuZC1tb2RpZmllci1ib3JkZXIpJztcclxuICAgICAgICB0aGlzLmNvbnRlbnRSb290RWxlbWVudC5zdHlsZS5wYWRkaW5nID0gJzEwcHgnO1xyXG4gICAgICAgIHRoaXMuY29udGVudFJvb3RFbGVtZW50LnN0eWxlLm1hcmdpblRvcCA9ICcxMHB4JztcclxuICAgICAgICB0aGlzLmNvbnRlbnRSb290RWxlbWVudC5zdHlsZS5tYXJnaW5Cb3R0b20gPSAnMTBweCc7XHJcblxyXG5cclxuICAgICAgICBjb25zdCBwcm9wZXJ0eUNvbnRhaW5lckVsID0gY29udGVudEVsLmNyZWF0ZURpdih7IGNsczogXCJjb2RlRWRpdG9yLW9wdGlvbnNcIiB9KTtcclxuICAgICAgICBwcm9wZXJ0eUNvbnRhaW5lckVsLnN0eWxlLmZsZXhEaXJlY3Rpb24gPSAnY29sdW1uJzsgLy8gU3RhY2sgaXRlbXMgdmVydGljYWxseVxyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmZyb250bWF0dGVyKSkge1xyXG4gICAgICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgodGhpcy5ydWxlLnByb3BlcnR5ICsgdGhpcy5vcHRpb25zLnByb3BlcnR5RGVsaW1pdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgcm93RWwgPSBwcm9wZXJ0eUNvbnRhaW5lckVsLmNyZWF0ZURpdih7IGNsczogJ3Byb3BlcnR5LXNldHRpbmctcm93IHNldHRpbmctaXRlbScgfSk7XHJcbiAgICAgICAgICAgICAgICByb3dFbC5zdHlsZS53aWR0aCA9ICcxMDAlJzsgLy8gRnVsbCB3aWR0aFxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xFbCA9IHJvd0VsLmNyZWF0ZURpdih7IGNsczogJ3NldHRpbmctaXRlbS1jb250cm9sJyB9KTtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xFbC5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xyXG4gICAgICAgICAgICAgICAgY29udHJvbEVsLnN0eWxlLmFsaWduSXRlbXMgPSAnY2VudGVyJztcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xFbC5zdHlsZS5qdXN0aWZ5Q29udGVudCA9ICdzcGFjZS1iZXR3ZWVuJztcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xFbC5zdHlsZS53aWR0aCA9ICcxMDAlJztcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xFbC5zdHlsZS5nYXAgPSAnMHB4JzsgLy8gUHJldmVudCBnYXAgZnJvbSBiZWluZyBhZGRlZCB0byB0aGUgbGVmdCBzaWRlXHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdENvbnRhaW5lciA9IGNvbnRyb2xFbC5jcmVhdGVEaXYoeyBjbHM6ICdwcm9wZXJ0eS1sZWZ0LWNvbnRhaW5lcicgfSk7XHJcbiAgICAgICAgICAgICAgICBsZWZ0Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XHJcbiAgICAgICAgICAgICAgICBsZWZ0Q29udGFpbmVyLnN0eWxlLmFsaWduSXRlbXMgPSAnY2VudGVyJztcclxuICAgICAgICAgICAgICAgIGxlZnRDb250YWluZXIuc3R5bGUubWluV2lkdGggPSAnMjUwcHgnOyBcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBpY29uRWwgPSBsZWZ0Q29udGFpbmVyLmNyZWF0ZVNwYW4oeyBjbHM6ICdwcm9wZXJ0eS1pY29uIHNldHRpbmctaXRlbS1pY29uJyB9KTtcclxuICAgICAgICAgICAgICAgIGljb25FbC5zdHlsZS5tYXJnaW5SaWdodCA9ICc4cHgnO1xyXG5cclxuICAgICAgICAgICAgICAgIHVwZGF0ZVByb3BlcnR5SWNvbihpY29uRWwsIHRoaXMua25vd25Qcm9wZXJ0aWVzW2tleV0udHlwZSk7IC8vIFVwZGF0ZSBpY29uIGJhc2VkIG9uIHR5cGVcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlYXJjaENvbnRhaW5lciA9IGxlZnRDb250YWluZXIuY3JlYXRlRGl2KHsgY2xzOiAncHJvcGVydHktc2VhcmNoLWNvbnRhaW5lcicgfSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lSW5wdXQgPSBuZXcgVGV4dENvbXBvbmVudChzZWFyY2hDb250YWluZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKGtleSlcclxuICAgICAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ1Byb3BlcnR5IG5hbWUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXREaXNhYmxlZCh0cnVlKTsgLy8gRGlzYWJsZSB0aGUgaW5wdXQgZmllbGRcclxuICAgICAgICAgICAgICAgIG5hbWVJbnB1dC5pbnB1dEVsLnN0eWxlLmJvcmRlciA9ICdub25lJzsgLy8gbWFrZSBib3JkZXIgaW52aXNpYmxlXHJcbiAgICAgICAgICAgICAgICBjb25zdCBtaWRkbGVDb250YWluZXIgPSBjb250cm9sRWwuY3JlYXRlRGl2KHsgY2xzOiAncHJvcGVydHktbWlkZGxlLWNvbnRhaW5lcicgfSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUNvbnRhaW5lciA9IG1pZGRsZUNvbnRhaW5lci5jcmVhdGVEaXYoeyBjbHM6ICdwcm9wZXJ0eS12YWx1ZS1jb250YWluZXInIH0pO1xyXG4gICAgICAgICAgICAgICAgdmFsdWVDb250YWluZXIuc3R5bGUud2lkdGggPSAnMTAwJSc7IC8vIEZ1bGwgd2lkdGggZm9yIHZhbHVlIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgbGV0IHByZXZpZXdDb21wb25lbnQgPSByZW5kZXJWYWx1ZUlucHV0KHZhbHVlQ29udGFpbmVyLCB0aGlzLmtub3duUHJvcGVydGllc1trZXldLCB0aGlzLmZyb250bWF0dGVyW2tleV0sIHRoaXMuY2hhbmdlQ2FsbGJhY2spO1xyXG5cclxuICAgICAgICAgICAgICAgIHByZXZpZXdDb21wb25lbnQuaW5wdXRFbC5zdHlsZS53aWR0aCA9ICcxMDAlJzsgLy8gTWFrZSB0aGUgaW5wdXQgZmllbGQgdGFrZSBmdWxsIHdpZHRoXHJcbiAgICAgICAgICAgICAgICBwcmV2aWV3Q29tcG9uZW50LmlucHV0RWwuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3RyYW5zcGFyZW50JzsgLy8gbWFrZSBpdCBpbnZpc2libGVcclxuICAgICAgICAgICAgICAgIC8vIC0tLSByaWdodCBwYXJ0IC0tLVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZGVsZXRlQnV0dG9uQ29udGFpbmVyID0gY29udHJvbEVsLmNyZWF0ZURpdih7IGNsczogJ3Byb3BlcnR5LXJpZ2h0LWNvbnRhaW5lcicgfSk7XHJcbiAgICAgICAgICAgICAgICBkZWxldGVCdXR0b25Db250YWluZXIuc3R5bGUubWFyZ2luTGVmdCA9ICdhdXRvJzsgLy8gUHVzaCB0byB0aGUgcmlnaHRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gLS0tIEFjdGlvbiBCdXR0b25zIC0tLVxyXG4gICAgICAgIHRoaXMuY3JlYXRlQWN0aW9uQnV0dG9ucyhjb250ZW50RWwpOyAvLyBDcmVhdGUgT0sgYW5kIFJlc2V0IGJ1dHRvbnNcclxuICAgIH1cclxuXHJcbiAgICBjaGFuZ2VDYWxsYmFjayA9IChwcm9wZXJ0eUluZm86IFByb3BlcnR5SW5mbyB8IHVuZGVmaW5lZCwgdmFsdWU6YW55KSA9PiB7XHJcbiAgICAgICAgLy8gU2F2ZSB0aGUgcmVzdWx0IHRvIHRoZSBjdXJyZW50IHN0YXRlXHJcbiAgICAgICAgaWYgKHByb3BlcnR5SW5mbykge1xyXG4gICAgICAgICAgICB0aGlzLnJlc3VsdFtwcm9wZXJ0eUluZm8ubmFtZV0gPSB2YWx1ZTsgLy8gVXBkYXRlIHRoZSByZXN1bHQgd2l0aCB0aGUgbmV3IHZhbHVlXHJcbiAgICAgICAgfVxyXG4gICAgfSAgIFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgXCJPS1wiIGFuZCBcIlJlc2V0XCIgYnV0dG9ucy5cclxuICAgICAqIEBwYXJhbSBjb250YWluZXJFbCAtIFRoZSBIVE1MIGVsZW1lbnQgdG8gYXBwZW5kIHRoZSBidXR0b25zIHRvLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNyZWF0ZUFjdGlvbkJ1dHRvbnMoY29udGFpbmVyRWw6IEhUTUxFbGVtZW50KTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgYnV0dG9uc0VsID0gY29udGFpbmVyRWwuY3JlYXRlRGl2KHsgY2xzOiAnbW9kYWwtYnV0dG9ucycgfSk7XHJcbiAgICAgICAgYnV0dG9uc0VsLnN0eWxlLm1hcmdpblRvcCA9ICcxNXB4JztcclxuICAgICAgICBidXR0b25zRWwuc3R5bGUuZGlzcGxheSA9ICdmbGV4JzsgLy8gVXNlIGZsZXggZm9yIGFsaWdubWVudFxyXG4gICAgICAgIGJ1dHRvbnNFbC5zdHlsZS5qdXN0aWZ5Q29udGVudCA9ICdmbGV4LWVuZCc7IC8vIEFsaWduIGJ1dHRvbnMgdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgYnV0dG9uc0VsLnN0eWxlLmdhcCA9ICcxMHB4JzsgLy8gU3BhY2UgYmV0d2VlbiBidXR0b25zXHJcblxyXG4gICAgICAgIC8vIFJlc2V0IEJ1dHRvbiAoVW5kbyBcdTIxQUFcdUZFMEYpXHJcbiAgICAgICAgY29uc3QgcmVzZXRCdXR0b24gPSBidXR0b25zRWwuY3JlYXRlRWwoJ2J1dHRvbicpO1xyXG4gICAgICAgIC8vIFVzZSBPYnNpZGlhbidzIHNldEljb24gZm9yIGNvbnNpc3RlbmN5LCBvciB1c2UgdGV4dFxyXG4gICAgICAgIHNldEljb24ocmVzZXRCdXR0b24sICdyZXNldCcpOyAvLyBVc2UgYSBzdWl0YWJsZSBpY29uIGxpa2UgJ3Jlc2V0JyBvciAndW5kbydcclxuICAgICAgICByZXNldEJ1dHRvbi5hcmlhTGFiZWwgPSAnUmVzZXQgc2VsZWN0aW9uJzsgLy8gQWNjZXNzaWJpbGl0eVxyXG4gICAgICAgIHJlc2V0QnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzZXRUb0luaXRpYWwoKTsgLy8gUmVzZXQgaW50ZXJuYWwgc3RhdGVcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBDbGVhciBCdXR0b24gKENsZWFyIFx1RDgzRFx1REVBRSlcclxuICAgICAgICBjb25zdCBlbXB0eUJ1dHRvbiA9IGJ1dHRvbnNFbC5jcmVhdGVFbCgnYnV0dG9uJyk7XHJcbiAgICAgICAgLy8gVXNlIE9ic2lkaWFuJ3Mgc2V0SWNvbiBmb3IgY29uc2lzdGVuY3ksIG9yIHVzZSB0ZXh0XHJcbiAgICAgICAgc2V0SWNvbihlbXB0eUJ1dHRvbiwgJ2VyYXNlcicpOyAvLyBVc2UgYSBzdWl0YWJsZSBpY29uIGxpa2UgJ3Jlc2V0JyBvciAndW5kbydcclxuICAgICAgICBlbXB0eUJ1dHRvbi5hcmlhTGFiZWwgPSAnQ2xlYXIgc2VsZWN0aW9uJzsgLy8gQWNjZXNzaWJpbGl0eVxyXG4gICAgICAgIGVtcHR5QnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzZXRUb0VtcHR5KCk7IC8vIENsZWFyIHN0YXRlXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gY2FuY2VsIEJ1dHRvblxyXG4gICAgICAgIGNvbnN0IGNhbmNlbEJ1dHRvbiA9IGJ1dHRvbnNFbC5jcmVhdGVFbCgnYnV0dG9uJywgeyB0ZXh0OiAnQ2FuY2VsJyB9KTtcclxuICAgICAgICBjYW5jZWxCdXR0b24uYXJpYUxhYmVsID0gJ2Nsb3NlIGFuZCBkaXNjYXJkIGNoYW5nZXMnOyAvLyBBY2Nlc3NpYmlsaXR5XHJcbiAgICAgICAgY2FuY2VsQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ2FuY2VsIENsaWNrZWQgLSBSZXR1cm5pbmdcIik7IC8vIERlYnVnIGxvZ1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVQcm9taXNlKG51bGwpOyAvLyBSZXNvbHZlIHRoZSBwcm9taXNlIHdpdGggbnVsbFxyXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gT0sgQnV0dG9uXHJcbiAgICAgICAgY29uc3Qgb2tCdXR0b24gPSBidXR0b25zRWwuY3JlYXRlRWwoJ2J1dHRvbicsIHsgdGV4dDogJ09LJywgY2xzOiAnbW9kLWN0YScgfSk7XHJcbiAgICAgICAgY2FuY2VsQnV0dG9uLmFyaWFMYWJlbCA9ICdjbG9zZSBhbmQgc2F2ZSBjaGFuZ2VzJzsgLy8gQWNjZXNzaWJpbGl0eVxyXG4gICAgICAgIG9rQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZVByb21pc2UoeyB2YWx1ZXM6IHRoaXMucmVzdWx0IH0pOyAvLyBSZXNvbHZlIHRoZSBwcm9taXNlIHdpdGggdGhlIHJlc3VsdFxyXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIG1vZGFsIGlzIGNsb3NlZC4gQ2xlYW5zIHVwIHJlc291cmNlcy5cclxuICAgICAqL1xyXG4gICAgb25DbG9zZSgpIHtcclxuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcclxuICAgICAgICBjb250ZW50RWwuZW1wdHkoKTsgLy8gQ2xlYXIgdGhlIG1vZGFsJ3MgY29udGVudFxyXG4gICAgfVxyXG5cclxuICAgIG9wZW5BbmRHZXRWYWx1ZXMoKTogUHJvbWlzZTxhdXRvY29tcGxldGVNb2RhbFJlc3VsdCB8IG51bGw+IHtcclxuICAgICAgICB0aGlzLm9wZW4oKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlOyAvLyBSZXR1cm4gdGhlIHByb21pc2VcclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBPcGVucyBhbiBhdXRvY29tcGxldGUgbW9kYWwgZm9yIHNlbGVjdGluZyBvciBlbnRlcmluZyB2YWx1ZXMgYmFzZWQgb24gdGhlIHByb3ZpZGVkIHBhcmFtZXRlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcHAgLSBUaGUgT2JzaWRpYW4gYXBwbGljYXRpb24gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBwbHVnaW4gLSBUaGUgcGx1Z2luIGluc3RhbmNlIHRoYXQgaXMgaW52b2tpbmcgdGhlIG1vZGFsLlxyXG4gKiBAcGFyYW0gcnVsZSAtIFRoZSBmb2xkZXItdG8tdGFnIHJ1bGUgZGVmaW5pdGlvbiB0byBiZSB1c2VkIGluIHRoZSBtb2RhbC5cclxuICogQHBhcmFtIGFjdGl2ZUZpbGUgLSBUaGUgY3VycmVudGx5IGFjdGl2ZSBmaWxlIG9yIGZvbGRlciwgaWYgYW55LlxyXG4gKiBAcGFyYW0gZnJvbnRtYXR0ZXIgLSBUaGUgZnJvbnRtYXR0ZXIgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGFjdGl2ZSBmaWxlLlxyXG4gKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcmVzdWx0IG9mIHRoZSBhdXRvY29tcGxldGUgbW9kYWwsIG9yIGBudWxsYCBpZiBubyBzZWxlY3Rpb24gd2FzIG1hZGUuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gb3BlbkF1dG9jb21wbGV0ZU1vZGFsKFxyXG4gICAgYXBwOiBBcHAsXHJcbiAgICBwbHVnaW46IGFueSxcclxuICAgIHJ1bGU6IEZvbGRlclRhZ1J1bGVEZWZpbml0aW9uLFxyXG4gICAgb3B0aW9uczogYW55LFxyXG4gICAgYWN0aXZlRmlsZTogVEZpbGUgfCBURm9sZGVyIHwgdW5kZWZpbmVkLFxyXG4gICAgZnJvbnRtYXR0ZXI6IGFueVxyXG4pOiBQcm9taXNlPGF1dG9jb21wbGV0ZU1vZGFsUmVzdWx0IHwgbnVsbD4ge1xyXG4gICAgLy8gQ3JlYXRlIGFuZCBvcGVuIHRoZSBtb2RhbCBpbnN0YW5jZVxyXG4gICAgY29uc3QgbW9kYWwgPSBuZXcgQXV0b2NvbXBsZXRlTW9kYWwoYXBwLCBwbHVnaW4sIHJ1bGUsIG9wdGlvbnMsIGFjdGl2ZUZpbGUsIGZyb250bWF0dGVyKTtcclxuICAgIHJldHVybiBhd2FpdCBtb2RhbC5vcGVuQW5kR2V0VmFsdWVzKCk7IC8vIFdhaXQgZm9yIHRoZSBwcm9taXNlIHRvIHJlc29sdmVcclxufSIsICJpbXBvcnQgeyBzZXRJY29uLCBUZXh0Q29tcG9uZW50IH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7IE9ic2lkaWFuUHJvcGVydHlUeXBlcywgUHJvcGVydHlJbmZvIH0gZnJvbSBcIi4vdHlwZXNcIjtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJWYWx1ZUlucHV0KGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCwgcHJvcGVydHlJbmZvOiBQcm9wZXJ0eUluZm8gfCB1bmRlZmluZWQsIGN1cnJlbnRWYWx1ZTogYW55LCBjaGFuZ2VDYWxsYmFjazogKHByb3BlcnR5SW5mbzogUHJvcGVydHlJbmZvIHwgdW5kZWZpbmVkLCB2YWx1ZTogYW55KSA9PiB2b2lkKSB7XHJcbiAgICBsZXQgcmV0dXJuQ29tcG9uZW50O1xyXG4gICAgY29udGFpbmVyRWwuZW1wdHkoKTsgXHJcblxyXG4gICAgaWYgKCFwcm9wZXJ0eUluZm8pIHtcclxuICAgICAgICAgICAgY29udGFpbmVyRWwuc2V0VGV4dCgnJyk7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lckVsLmFkZENsYXNzKCd0ZXh0LW11dGVkJyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0eXBlID0gcHJvcGVydHlJbmZvLnR5cGU7XHJcblxyXG4gICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50ID0gbmV3IFRleHRDb21wb25lbnQoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ051bWVyaWMgVmFsdWUnKVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKGN1cnJlbnRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIGN1cnJlbnRWYWx1ZSAhPT0gbnVsbCA/IFN0cmluZyhjdXJyZW50VmFsdWUpIDogJycpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtVmFsdWUgPSB2YWx1ZSA9PT0gJycgPyB1bmRlZmluZWQgOiBwYXJzZUZsb2F0KHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VDYWxsYmFjayhwcm9wZXJ0eUluZm8sIGlzTmFOKG51bVZhbHVlIGFzIG51bWJlcikgPyB1bmRlZmluZWQgOiBudW1WYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50LmlucHV0RWwudHlwZSA9ICdudW1iZXInO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdjaGVja2JveCc6XHJcbiAgICAgICAgICAgIHJldHVybkNvbXBvbmVudCA9IGNvbnRhaW5lckVsLmNyZWF0ZURpdih7IGNsczogJ3RyaS1zdGF0ZS1jaGVja2JveCBjbGlja2FibGUtaWNvbicgfSk7XHJcbiAgICAgICAgICAgIHJldHVybkNvbXBvbmVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCAnQ2hlY2tib3ggY2hhbmdlIHN0YXRlJyk7XHJcbiAgICAgICAgICAgIHJldHVybkNvbXBvbmVudC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnY2hlY2tib3gnKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZUNoZWNrYm94VmlzdWFsID0gKHN0YXRlOiBib29sZWFuIHwgdW5kZWZpbmVkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaWNvbk5hbWU6IHN0cmluZztcclxuICAgICAgICAgICAgICAgIGxldCBhcmlhU3RhdGU6ICd0cnVlJyB8ICdmYWxzZScgfCAnbWl4ZWQnO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWNvbk5hbWUgPSAnY2hlY2stc3F1YXJlJztcclxuICAgICAgICAgICAgICAgICAgICBhcmlhU3RhdGUgPSAndHJ1ZSc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGljb25OYW1lID0gJ3NxdWFyZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJpYVN0YXRlID0gJ2ZhbHNlJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIHVuZGVmaW5lZCBvciBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgaWNvbk5hbWUgPSAnbWludXMtc3F1YXJlJztcclxuICAgICAgICAgICAgICAgICAgICBhcmlhU3RhdGUgPSAnbWl4ZWQnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2V0SWNvbihyZXR1cm5Db21wb25lbnQsIGljb25OYW1lKTtcclxuICAgICAgICAgICAgICAgIHJldHVybkNvbXBvbmVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtY2hlY2tlZCcsIGFyaWFTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5Db21wb25lbnQuZGF0YXNldC5zdGF0ZSA9IFN0cmluZyhzdGF0ZSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB1cGRhdGVDaGVja2JveFZpc3VhbChjdXJyZW50VmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRTdGF0ZSA9IHJldHVybkNvbXBvbmVudC5kYXRhc2V0LnN0YXRlO1xyXG4gICAgICAgICAgICAgICAgbGV0IG5leHRTdGF0ZTogYm9vbGVhbiB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFN0YXRlID09PSAnZmFsc2UnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFN0YXRlID09PSAndHJ1ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUgPSB1bmRlZmluZWQ7IFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgXHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlID0gZmFsc2U7IFxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNoYW5nZUNhbGxiYWNrKHByb3BlcnR5SW5mbywgIG5leHRTdGF0ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdXBkYXRlQ2hlY2tib3hWaXN1YWwobmV4dFN0YXRlKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdkYXRlJzpcclxuICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50ID0gbmV3IFRleHRDb21wb25lbnQoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ1lZWVktTU0tREQnKVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKGN1cnJlbnRWYWx1ZSB8fCAnJylcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VDYWxsYmFjayhwcm9wZXJ0eUluZm8sIHZhbHVlIHx8IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50LmlucHV0RWwudHlwZSA9ICdkYXRlJztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxyXG4gICAgICAgICAgICByZXR1cm5Db21wb25lbnQgPSBuZXcgVGV4dENvbXBvbmVudChjb250YWluZXJFbClcclxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignWVlZWS1NTS1ERFRISDptbScpXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUoY3VycmVudFZhbHVlIHx8ICcnKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUNhbGxiYWNrKHByb3BlcnR5SW5mbywgdmFsdWUgfHwgdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICByZXR1cm5Db21wb25lbnQuaW5wdXRFbC50eXBlID0gJ2RhdGV0aW1lLWxvY2FsJztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnYWxpYXNlcyc6XHJcbiAgICAgICAgY2FzZSAndGFncyc6XHJcbiAgICAgICAgY2FzZSAnbXVsdGl0ZXh0JzpcclxuICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50ID0gbmV3IFRleHRDb21wb25lbnQoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ3ZhbHVlcyAoZGl2aWRlZCBieSBjb21tYSknKVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKEFycmF5LmlzQXJyYXkoY3VycmVudFZhbHVlKSA/IGN1cnJlbnRWYWx1ZS5qb2luKCcsICcpIDogKGN1cnJlbnRWYWx1ZSB8fCAnJykpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJyYXlWYWx1ZSA9IHZhbHVlLnNwbGl0KCcsJykubWFwKHMgPT4gcy50cmltKCkpLmZpbHRlcihzID0+IHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUNhbGxiYWNrKHByb3BlcnR5SW5mbywgYXJyYXlWYWx1ZS5sZW5ndGggPiAwID8gYXJyYXlWYWx1ZSA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAndGV4dCc6XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50ID0gbmV3IFRleHRDb21wb25lbnQoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ3ZhbHVlJylcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShjdXJyZW50VmFsdWUgfHwgJycpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlQ2FsbGJhY2socHJvcGVydHlJbmZvLCB2YWx1ZSB8fCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIGlmICh0eXBlICE9PSAnY2hlY2tib3gnKSB7XHJcbiAgICAgICAgcmV0dXJuQ29tcG9uZW50LmlucHV0RWwuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3RyYW5zcGFyZW50JzsgLy8gbWFrZSBpdCBpbnZpc2libGVcclxuICAgICAgICByZXR1cm5Db21wb25lbnQuaW5wdXRFbC5zdHlsZS53aWR0aCA9ICcxMDAlJztcclxuICAgICAgICByZXR1cm5Db21wb25lbnQuaW5wdXRFbC5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0dXJuQ29tcG9uZW50O1xyXG59IFxyXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlUHJvcGVydHlJY29uKGljb25FbDogSFRNTEVsZW1lbnQsIHR5cGU6IE9ic2lkaWFuUHJvcGVydHlUeXBlcyB8IHVuZGVmaW5lZCkge1xyXG4gICAgbGV0IGljb25OYW1lID0gJ2hhc2gnO1xyXG4gICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgY2FzZSAndGV4dCc6IGljb25OYW1lID0gJ2FsaWduLWxlZnQnOyBicmVhaztcclxuICAgICAgICBjYXNlICdudW1iZXInOiBpY29uTmFtZSA9ICdiaW5hcnknOyBicmVhaztcclxuICAgICAgICBjYXNlICdtdWx0aXRleHQnOiBpY29uTmFtZSA9ICdsaXN0JzsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnZGF0ZSc6IGljb25OYW1lID0gJ2NhbGVuZGFyJzsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOiBpY29uTmFtZSA9ICdjbG9jayc7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2NoZWNrYm94JzogaWNvbk5hbWUgPSAnY2hlY2stc3F1YXJlJzsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAndGFncyc6IGljb25OYW1lID0gJ3RhZ3MnOyBicmVhaztcclxuICAgICAgICBjYXNlICdhbGlhc2VzJzogaWNvbk5hbWUgPSAnZm9yd2FyZCc7IGJyZWFrO1xyXG4gXHJcbiAgICAgICAgZGVmYXVsdDogaWNvbk5hbWUgPSAnaGVscC1jaXJjbGUnO1xyXG4gICAgfVxyXG4gICAgc2V0SWNvbihpY29uRWwsIGljb25OYW1lKTtcclxufSIsICIvLyBDcmVkaXRzIGdvIHRvIExpYW0ncyBQZXJpb2RpYyBOb3RlcyBQbHVnaW46IGh0dHBzOi8vZ2l0aHViLmNvbS9saWFtY2Fpbi9vYnNpZGlhbi1wZXJpb2RpYy1ub3Rlc1xuLy8gYW5kIFRlbXBsYXRlciBwbHVnaW46IGh0dHBzOi8vZ2l0aHViLmNvbS9TaWxlbnRWb2lkMTMvVGVtcGxhdGVyIHdoZXJlIEkgZ290IHRoZSBjb2RlIGZvciB0aGUgc3VnZ2VzdGVyc1xuXG5pbXBvcnQgeyBBcHAsIFRBYnN0cmFjdEZpbGUsIFRGb2xkZXIgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IFRleHRJbnB1dFN1Z2dlc3QgfSBmcm9tIFwiLi9zdWdnZXN0XCI7XG5cbmV4cG9ydCBjbGFzcyBGb2xkZXJTdWdnZXN0IGV4dGVuZHMgVGV4dElucHV0U3VnZ2VzdDxURm9sZGVyPiB7XG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIGlucHV0RWw6IEhUTUxJbnB1dEVsZW1lbnQgfCBIVE1MVGV4dEFyZWFFbGVtZW50KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgaW5wdXRFbCk7XG4gICAgfVxuXG4gICAgZ2V0U3VnZ2VzdGlvbnMoaW5wdXRTdHI6IHN0cmluZyk6IFRGb2xkZXJbXSB7XG4gICAgICAgIGNvbnN0IGFic3RyYWN0RmlsZXMgPSB0aGlzLmFwcC52YXVsdC5nZXRBbGxMb2FkZWRGaWxlcygpO1xuICAgICAgICBjb25zdCBmb2xkZXJzOiBURm9sZGVyW10gPSBbXTtcbiAgICAgICAgY29uc3QgbG93ZXJDYXNlSW5wdXRTdHIgPSBpbnB1dFN0ci50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGFic3RyYWN0RmlsZXMuZm9yRWFjaCgoZm9sZGVyOiBUQWJzdHJhY3RGaWxlKSA9PiB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZm9sZGVyIGluc3RhbmNlb2YgVEZvbGRlciAmJlxuICAgICAgICAgICAgICAgIGZvbGRlci5wYXRoLnRvTG93ZXJDYXNlKCkuY29udGFpbnMobG93ZXJDYXNlSW5wdXRTdHIpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBmb2xkZXJzLnB1c2goZm9sZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZvbGRlcnMuc2xpY2UoMCwgMTAwMCk7XG4gICAgfVxuXG4gICAgcmVuZGVyU3VnZ2VzdGlvbihmaWxlOiBURm9sZGVyLCBlbDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAgICAgZWwuc2V0VGV4dChmaWxlLnBhdGgucmVwbGFjZSgvXig/IVxcLykvLCBcIi9cIikpO1xuICAgIH1cblxuICAgIHNlbGVjdFN1Z2dlc3Rpb24oZmlsZTogVEZvbGRlcik6IHZvaWQge1xuICAgICAgICB0aGlzLmlucHV0RWwudmFsdWUgPSBmaWxlLnBhdGgucmVwbGFjZSgvXig/IVxcLykvLCBcIi9cIik7XG4gICAgICAgIHRoaXMuaW5wdXRFbC50cmlnZ2VyKFwiaW5wdXRcIik7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG59XG4iLCAiLy8gQ3JlZGl0cyBnbyB0byBMaWFtJ3MgUGVyaW9kaWMgTm90ZXMgUGx1Z2luOiBodHRwczovL2dpdGh1Yi5jb20vbGlhbWNhaW4vb2JzaWRpYW4tcGVyaW9kaWMtbm90ZXNcbi8vIGFuZCBUZW1wbGF0ZXIgcGx1Z2luOiBodHRwczovL2dpdGh1Yi5jb20vU2lsZW50Vm9pZDEzL1RlbXBsYXRlciB3aGVyZSBJIGdvdCB0aGUgY29kZSBmb3IgdGhlIHN1Z2dlc3RlcnNcblxuaW1wb3J0IHsgQXBwLCBJU3VnZ2VzdE93bmVyLCBTY29wZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgY3JlYXRlUG9wcGVyLCBJbnN0YW5jZSBhcyBQb3BwZXJJbnN0YW5jZSB9IGZyb20gXCJAcG9wcGVyanMvY29yZVwiO1xuXG5jb25zdCB3cmFwQXJvdW5kID0gKHZhbHVlOiBudW1iZXIsIHNpemU6IG51bWJlcik6IG51bWJlciA9PiB7XG4gICAgcmV0dXJuICgodmFsdWUgJSBzaXplKSArIHNpemUpICUgc2l6ZTtcbn07XG5cbmNsYXNzIFN1Z2dlc3Q8VD4ge1xuICAgIHByaXZhdGUgb3duZXI6IElTdWdnZXN0T3duZXI8VD47XG4gICAgcHJpdmF0ZSB2YWx1ZXM6IFRbXTtcbiAgICBwcml2YXRlIHN1Z2dlc3Rpb25zOiBIVE1MRGl2RWxlbWVudFtdO1xuICAgIHByaXZhdGUgc2VsZWN0ZWRJdGVtOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBjb250YWluZXJFbDogSFRNTEVsZW1lbnQ7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgb3duZXI6IElTdWdnZXN0T3duZXI8VD4sXG4gICAgICAgIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCxcbiAgICAgICAgc2NvcGU6IFNjb3BlXG4gICAgKSB7XG4gICAgICAgIHRoaXMub3duZXIgPSBvd25lcjtcbiAgICAgICAgdGhpcy5jb250YWluZXJFbCA9IGNvbnRhaW5lckVsO1xuXG4gICAgICAgIGNvbnRhaW5lckVsLm9uKFxuICAgICAgICAgICAgXCJjbGlja1wiLFxuICAgICAgICAgICAgXCIuc3VnZ2VzdGlvbi1pdGVtXCIsXG4gICAgICAgICAgICB0aGlzLm9uU3VnZ2VzdGlvbkNsaWNrLmJpbmQodGhpcylcbiAgICAgICAgKTtcbiAgICAgICAgY29udGFpbmVyRWwub24oXG4gICAgICAgICAgICBcIm1vdXNlbW92ZVwiLFxuICAgICAgICAgICAgXCIuc3VnZ2VzdGlvbi1pdGVtXCIsXG4gICAgICAgICAgICB0aGlzLm9uU3VnZ2VzdGlvbk1vdXNlb3Zlci5iaW5kKHRoaXMpXG4gICAgICAgICk7XG5cbiAgICAgICAgc2NvcGUucmVnaXN0ZXIoW10sIFwiQXJyb3dVcFwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICghZXZlbnQuaXNDb21wb3NpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGVkSXRlbSh0aGlzLnNlbGVjdGVkSXRlbSAtIDEsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2NvcGUucmVnaXN0ZXIoW10sIFwiQXJyb3dEb3duXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFldmVudC5pc0NvbXBvc2luZykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0ZWRJdGVtKHRoaXMuc2VsZWN0ZWRJdGVtICsgMSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBzY29wZS5yZWdpc3RlcihbXSwgXCJFbnRlclwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICghZXZlbnQuaXNDb21wb3NpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVzZVNlbGVjdGVkSXRlbShldmVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvblN1Z2dlc3Rpb25DbGljayhldmVudDogTW91c2VFdmVudCwgZWw6IEhUTUxEaXZFbGVtZW50KTogdm9pZCB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuc3VnZ2VzdGlvbnMuaW5kZXhPZihlbCk7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0ZWRJdGVtKGl0ZW0sIGZhbHNlKTtcbiAgICAgICAgdGhpcy51c2VTZWxlY3RlZEl0ZW0oZXZlbnQpO1xuICAgIH1cblxuICAgIG9uU3VnZ2VzdGlvbk1vdXNlb3ZlcihfZXZlbnQ6IE1vdXNlRXZlbnQsIGVsOiBIVE1MRGl2RWxlbWVudCk6IHZvaWQge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5zdWdnZXN0aW9ucy5pbmRleE9mKGVsKTtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3RlZEl0ZW0oaXRlbSwgZmFsc2UpO1xuICAgIH1cblxuICAgIHNldFN1Z2dlc3Rpb25zKHZhbHVlczogVFtdKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWwuZW1wdHkoKTtcbiAgICAgICAgY29uc3Qgc3VnZ2VzdGlvbkVsczogSFRNTERpdkVsZW1lbnRbXSA9IFtdO1xuXG4gICAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3VnZ2VzdGlvbkVsID0gdGhpcy5jb250YWluZXJFbC5jcmVhdGVEaXYoXCJzdWdnZXN0aW9uLWl0ZW1cIik7XG4gICAgICAgICAgICB0aGlzLm93bmVyLnJlbmRlclN1Z2dlc3Rpb24odmFsdWUsIHN1Z2dlc3Rpb25FbCk7XG4gICAgICAgICAgICBzdWdnZXN0aW9uRWxzLnB1c2goc3VnZ2VzdGlvbkVsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIHRoaXMuc3VnZ2VzdGlvbnMgPSBzdWdnZXN0aW9uRWxzO1xuICAgICAgICB0aGlzLnNldFNlbGVjdGVkSXRlbSgwLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdXNlU2VsZWN0ZWRJdGVtKGV2ZW50OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLnZhbHVlc1t0aGlzLnNlbGVjdGVkSXRlbV07XG4gICAgICAgIGlmIChjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMub3duZXIuc2VsZWN0U3VnZ2VzdGlvbihjdXJyZW50VmFsdWUsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFNlbGVjdGVkSXRlbShzZWxlY3RlZEluZGV4OiBudW1iZXIsIHNjcm9sbEludG9WaWV3OiBib29sZWFuKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJbmRleCA9IHdyYXBBcm91bmQoXG4gICAgICAgICAgICBzZWxlY3RlZEluZGV4LFxuICAgICAgICAgICAgdGhpcy5zdWdnZXN0aW9ucy5sZW5ndGhcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcHJldlNlbGVjdGVkU3VnZ2VzdGlvbiA9IHRoaXMuc3VnZ2VzdGlvbnNbdGhpcy5zZWxlY3RlZEl0ZW1dO1xuICAgICAgICBjb25zdCBzZWxlY3RlZFN1Z2dlc3Rpb24gPSB0aGlzLnN1Z2dlc3Rpb25zW25vcm1hbGl6ZWRJbmRleF07XG5cbiAgICAgICAgcHJldlNlbGVjdGVkU3VnZ2VzdGlvbj8ucmVtb3ZlQ2xhc3MoXCJpcy1zZWxlY3RlZFwiKTtcbiAgICAgICAgc2VsZWN0ZWRTdWdnZXN0aW9uPy5hZGRDbGFzcyhcImlzLXNlbGVjdGVkXCIpO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtID0gbm9ybWFsaXplZEluZGV4O1xuXG4gICAgICAgIGlmIChzY3JvbGxJbnRvVmlldykge1xuICAgICAgICAgICAgc2VsZWN0ZWRTdWdnZXN0aW9uLnNjcm9sbEludG9WaWV3KGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFRleHRJbnB1dFN1Z2dlc3Q8VD4gaW1wbGVtZW50cyBJU3VnZ2VzdE93bmVyPFQ+IHtcbiAgICBwcm90ZWN0ZWQgYXBwOiBBcHA7XG4gICAgcHJvdGVjdGVkIGlucHV0RWw6IEhUTUxJbnB1dEVsZW1lbnQgfCBIVE1MVGV4dEFyZWFFbGVtZW50O1xuXG4gICAgcHJpdmF0ZSBwb3BwZXI6IFBvcHBlckluc3RhbmNlO1xuICAgIHByaXZhdGUgc2NvcGU6IFNjb3BlO1xuICAgIHByaXZhdGUgc3VnZ2VzdEVsOiBIVE1MRWxlbWVudDtcbiAgICBwcml2YXRlIHN1Z2dlc3Q6IFN1Z2dlc3Q8VD47XG5cbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgaW5wdXRFbDogSFRNTElucHV0RWxlbWVudCB8IEhUTUxUZXh0QXJlYUVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgICAgIHRoaXMuaW5wdXRFbCA9IGlucHV0RWw7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBuZXcgU2NvcGUoKTtcblxuICAgICAgICB0aGlzLnN1Z2dlc3RFbCA9IGNyZWF0ZURpdihcInN1Z2dlc3Rpb24tY29udGFpbmVyXCIpO1xuICAgICAgICBjb25zdCBzdWdnZXN0aW9uID0gdGhpcy5zdWdnZXN0RWwuY3JlYXRlRGl2KFwic3VnZ2VzdGlvblwiKTtcbiAgICAgICAgdGhpcy5zdWdnZXN0ID0gbmV3IFN1Z2dlc3QodGhpcywgc3VnZ2VzdGlvbiwgdGhpcy5zY29wZSk7XG5cbiAgICAgICAgdGhpcy5zY29wZS5yZWdpc3RlcihbXSwgXCJFc2NhcGVcIiwgdGhpcy5jbG9zZS5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLmlucHV0RWwuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMub25JbnB1dENoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuaW5wdXRFbC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5vbklucHV0Q2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5pbnB1dEVsLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuY2xvc2UuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuc3VnZ2VzdEVsLm9uKFxuICAgICAgICAgICAgXCJtb3VzZWRvd25cIixcbiAgICAgICAgICAgIFwiLnN1Z2dlc3Rpb24tY29udGFpbmVyXCIsXG4gICAgICAgICAgICAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cblxuICAgIG9uSW5wdXRDaGFuZ2VkKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBpbnB1dFN0ciA9IHRoaXMuaW5wdXRFbC52YWx1ZTtcbiAgICAgICAgY29uc3Qgc3VnZ2VzdGlvbnMgPSB0aGlzLmdldFN1Z2dlc3Rpb25zKGlucHV0U3RyKTtcblxuICAgICAgICBpZiAoIXN1Z2dlc3Rpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3VnZ2VzdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zdWdnZXN0LnNldFN1Z2dlc3Rpb25zKHN1Z2dlc3Rpb25zKTtcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5vcGVuKHRoaXMuYXBwLmRvbS5hcHBDb250YWluZXJFbCwgdGhpcy5pbnB1dEVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9wZW4oY29udGFpbmVyOiBIVE1MRWxlbWVudCwgaW5wdXRFbDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hcHAua2V5bWFwLnB1c2hTY29wZSh0aGlzLnNjb3BlKTtcblxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zdWdnZXN0RWwpO1xuICAgICAgICB0aGlzLnBvcHBlciA9IGNyZWF0ZVBvcHBlcihpbnB1dEVsLCB0aGlzLnN1Z2dlc3RFbCwge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBcImJvdHRvbS1zdGFydFwiLFxuICAgICAgICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInNhbWVXaWR0aFwiLFxuICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBmbjogKHsgc3RhdGUsIGluc3RhbmNlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IHBvc2l0aW9uaW5nIG5lZWRzIHRvIGJlIGNhbGN1bGF0ZWQgdHdpY2UgLVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmlyc3QgcGFzcyAtIHBvc2l0aW9uaW5nIGl0IGFjY29yZGluZyB0byB0aGUgd2lkdGggb2YgdGhlIHBvcHBlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2Vjb25kIHBhc3MgLSBwb3NpdGlvbiBpdCB3aXRoIHRoZSB3aWR0aCBib3VuZCB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gZWFybHkgZXhpdCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRXaWR0aCA9IGAke3N0YXRlLnJlY3RzLnJlZmVyZW5jZS53aWR0aH1weGA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc3R5bGVzLnBvcHBlci53aWR0aCA9PT0gdGFyZ2V0V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zdHlsZXMucG9wcGVyLndpZHRoID0gdGFyZ2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGhhc2U6IFwiYmVmb3JlV3JpdGVcIixcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZXM6IFtcImNvbXB1dGVTdHlsZXNcIl0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNsb3NlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmFwcC5rZXltYXAucG9wU2NvcGUodGhpcy5zY29wZSk7XG5cbiAgICAgICAgdGhpcy5zdWdnZXN0LnNldFN1Z2dlc3Rpb25zKFtdKTtcbiAgICAgICAgaWYgKHRoaXMucG9wcGVyKSB0aGlzLnBvcHBlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc3VnZ2VzdEVsLmRldGFjaCgpO1xuICAgIH1cblxuICAgIGFic3RyYWN0IGdldFN1Z2dlc3Rpb25zKGlucHV0U3RyOiBzdHJpbmcpOiBUW107XG4gICAgYWJzdHJhY3QgcmVuZGVyU3VnZ2VzdGlvbihpdGVtOiBULCBlbDogSFRNTEVsZW1lbnQpOiB2b2lkO1xuICAgIGFic3RyYWN0IHNlbGVjdFN1Z2dlc3Rpb24oaXRlbTogVCk6IHZvaWQ7XG59XG4iLCAiZXhwb3J0IHZhciB0b3AgPSAndG9wJztcbmV4cG9ydCB2YXIgYm90dG9tID0gJ2JvdHRvbSc7XG5leHBvcnQgdmFyIHJpZ2h0ID0gJ3JpZ2h0JztcbmV4cG9ydCB2YXIgbGVmdCA9ICdsZWZ0JztcbmV4cG9ydCB2YXIgYXV0byA9ICdhdXRvJztcbmV4cG9ydCB2YXIgYmFzZVBsYWNlbWVudHMgPSBbdG9wLCBib3R0b20sIHJpZ2h0LCBsZWZ0XTtcbmV4cG9ydCB2YXIgc3RhcnQgPSAnc3RhcnQnO1xuZXhwb3J0IHZhciBlbmQgPSAnZW5kJztcbmV4cG9ydCB2YXIgY2xpcHBpbmdQYXJlbnRzID0gJ2NsaXBwaW5nUGFyZW50cyc7XG5leHBvcnQgdmFyIHZpZXdwb3J0ID0gJ3ZpZXdwb3J0JztcbmV4cG9ydCB2YXIgcG9wcGVyID0gJ3BvcHBlcic7XG5leHBvcnQgdmFyIHJlZmVyZW5jZSA9ICdyZWZlcmVuY2UnO1xuZXhwb3J0IHZhciB2YXJpYXRpb25QbGFjZW1lbnRzID0gLyojX19QVVJFX18qL2Jhc2VQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCArIFwiLVwiICsgc3RhcnQsIHBsYWNlbWVudCArIFwiLVwiICsgZW5kXSk7XG59LCBbXSk7XG5leHBvcnQgdmFyIHBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovW10uY29uY2F0KGJhc2VQbGFjZW1lbnRzLCBbYXV0b10pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCwgcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTsgLy8gbW9kaWZpZXJzIHRoYXQgbmVlZCB0byByZWFkIHRoZSBET01cblxuZXhwb3J0IHZhciBiZWZvcmVSZWFkID0gJ2JlZm9yZVJlYWQnO1xuZXhwb3J0IHZhciByZWFkID0gJ3JlYWQnO1xuZXhwb3J0IHZhciBhZnRlclJlYWQgPSAnYWZ0ZXJSZWFkJzsgLy8gcHVyZS1sb2dpYyBtb2RpZmllcnNcblxuZXhwb3J0IHZhciBiZWZvcmVNYWluID0gJ2JlZm9yZU1haW4nO1xuZXhwb3J0IHZhciBtYWluID0gJ21haW4nO1xuZXhwb3J0IHZhciBhZnRlck1haW4gPSAnYWZ0ZXJNYWluJzsgLy8gbW9kaWZpZXIgd2l0aCB0aGUgcHVycG9zZSB0byB3cml0ZSB0byB0aGUgRE9NIChvciB3cml0ZSBpbnRvIGEgZnJhbWV3b3JrIHN0YXRlKVxuXG5leHBvcnQgdmFyIGJlZm9yZVdyaXRlID0gJ2JlZm9yZVdyaXRlJztcbmV4cG9ydCB2YXIgd3JpdGUgPSAnd3JpdGUnO1xuZXhwb3J0IHZhciBhZnRlcldyaXRlID0gJ2FmdGVyV3JpdGUnO1xuZXhwb3J0IHZhciBtb2RpZmllclBoYXNlcyA9IFtiZWZvcmVSZWFkLCByZWFkLCBhZnRlclJlYWQsIGJlZm9yZU1haW4sIG1haW4sIGFmdGVyTWFpbiwgYmVmb3JlV3JpdGUsIHdyaXRlLCBhZnRlcldyaXRlXTsiLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZU5hbWUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudCA/IChlbGVtZW50Lm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbn0iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAobm9kZS50b1N0cmluZygpICE9PSAnW29iamVjdCBXaW5kb3ddJykge1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cgOiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn0iLCAiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcblxuZnVuY3Rpb24gaXNFbGVtZW50KG5vZGUpIHtcbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KG5vZGUpIHtcbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuSFRNTEVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzU2hhZG93Um9vdChub2RlKSB7XG4gIC8vIElFIDExIGhhcyBubyBTaGFkb3dSb290XG4gIGlmICh0eXBlb2YgU2hhZG93Um9vdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5TaGFkb3dSb290O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Q7XG59XG5cbmV4cG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCwgaXNTaGFkb3dSb290IH07IiwgImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4uL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7IC8vIFRoaXMgbW9kaWZpZXIgdGFrZXMgdGhlIHN0eWxlcyBwcmVwYXJlZCBieSB0aGUgYGNvbXB1dGVTdHlsZXNgIG1vZGlmaWVyXG4vLyBhbmQgYXBwbGllcyB0aGVtIHRvIHRoZSBIVE1MRWxlbWVudHMgc3VjaCBhcyBwb3BwZXIgYW5kIGFycm93XG5cbmZ1bmN0aW9uIGFwcGx5U3R5bGVzKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZTtcbiAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS5zdHlsZXNbbmFtZV0gfHwge307XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07IC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuXG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRmxvdyBkb2Vzbid0IHN1cHBvcnQgdG8gZXh0ZW5kIHRoaXMgcHJvcGVydHksIGJ1dCBpdCdzIHRoZSBtb3N0XG4gICAgLy8gZWZmZWN0aXZlIHdheSB0byBhcHBseSBzdHlsZXMgdG8gYW4gSFRNTEVsZW1lbnRcbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cblxuXG4gICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcblxuICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGU7XG4gIHZhciBpbml0aWFsU3R5bGVzID0ge1xuICAgIHBvcHBlcjoge1xuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAnMCcsXG4gICAgICB0b3A6ICcwJyxcbiAgICAgIG1hcmdpbjogJzAnXG4gICAgfSxcbiAgICBhcnJvdzoge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICB9LFxuICAgIHJlZmVyZW5jZToge31cbiAgfTtcbiAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGluaXRpYWxTdHlsZXMucG9wcGVyKTtcbiAgc3RhdGUuc3R5bGVzID0gaW5pdGlhbFN0eWxlcztcblxuICBpZiAoc3RhdGUuZWxlbWVudHMuYXJyb3cpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLmFycm93LnN0eWxlLCBpbml0aWFsU3R5bGVzLmFycm93KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgICB2YXIgc3R5bGVQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoc3RhdGUuc3R5bGVzLmhhc093blByb3BlcnR5KG5hbWUpID8gc3RhdGUuc3R5bGVzW25hbWVdIDogaW5pdGlhbFN0eWxlc1tuYW1lXSk7IC8vIFNldCBhbGwgdmFsdWVzIHRvIGFuIGVtcHR5IHN0cmluZyB0byB1bnNldCB0aGVtXG5cbiAgICAgIHZhciBzdHlsZSA9IHN0eWxlUHJvcGVydGllcy5yZWR1Y2UoZnVuY3Rpb24gKHN0eWxlLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdHlsZVtwcm9wZXJ0eV0gPSAnJztcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfSwge30pOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBhcHBseVN0eWxlcyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ2NvbXB1dGVTdHlsZXMnXVxufTsiLCAiaW1wb3J0IHsgYXV0byB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufSIsICJleHBvcnQgdmFyIG1heCA9IE1hdGgubWF4O1xuZXhwb3J0IHZhciBtaW4gPSBNYXRoLm1pbjtcbmV4cG9ydCB2YXIgcm91bmQgPSBNYXRoLnJvdW5kOyIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRVQVN0cmluZygpIHtcbiAgdmFyIHVhRGF0YSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhO1xuXG4gIGlmICh1YURhdGEgIT0gbnVsbCAmJiB1YURhdGEuYnJhbmRzICYmIEFycmF5LmlzQXJyYXkodWFEYXRhLmJyYW5kcykpIHtcbiAgICByZXR1cm4gdWFEYXRhLmJyYW5kcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLmJyYW5kICsgXCIvXCIgKyBpdGVtLnZlcnNpb247XG4gICAgfSkuam9pbignICcpO1xuICB9XG5cbiAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XG59IiwgImltcG9ydCBnZXRVQVN0cmluZyBmcm9tIFwiLi4vdXRpbHMvdXNlckFnZW50LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0xheW91dFZpZXdwb3J0KCkge1xuICByZXR1cm4gIS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XG59IiwgImltcG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgaXNMYXlvdXRWaWV3cG9ydCBmcm9tIFwiLi9pc0xheW91dFZpZXdwb3J0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlLCBpc0ZpeGVkU3RyYXRlZ3kpIHtcbiAgaWYgKGluY2x1ZGVTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNGaXhlZFN0cmF0ZWd5ID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBjbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNjYWxlWCA9IDE7XG4gIHZhciBzY2FsZVkgPSAxO1xuXG4gIGlmIChpbmNsdWRlU2NhbGUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIHNjYWxlWCA9IGVsZW1lbnQub2Zmc2V0V2lkdGggPiAwID8gcm91bmQoY2xpZW50UmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDEgOiAxO1xuICAgIHNjYWxlWSA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ID4gMCA/IHJvdW5kKGNsaWVudFJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDEgOiAxO1xuICB9XG5cbiAgdmFyIF9yZWYgPSBpc0VsZW1lbnQoZWxlbWVudCkgPyBnZXRXaW5kb3coZWxlbWVudCkgOiB3aW5kb3csXG4gICAgICB2aXN1YWxWaWV3cG9ydCA9IF9yZWYudmlzdWFsVmlld3BvcnQ7XG5cbiAgdmFyIGFkZFZpc3VhbE9mZnNldHMgPSAhaXNMYXlvdXRWaWV3cG9ydCgpICYmIGlzRml4ZWRTdHJhdGVneTtcbiAgdmFyIHggPSAoY2xpZW50UmVjdC5sZWZ0ICsgKGFkZFZpc3VhbE9mZnNldHMgJiYgdmlzdWFsVmlld3BvcnQgPyB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0IDogMCkpIC8gc2NhbGVYO1xuICB2YXIgeSA9IChjbGllbnRSZWN0LnRvcCArIChhZGRWaXN1YWxPZmZzZXRzICYmIHZpc3VhbFZpZXdwb3J0ID8gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wIDogMCkpIC8gc2NhbGVZO1xuICB2YXIgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoIC8gc2NhbGVYO1xuICB2YXIgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZVk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHRvcDogeSxcbiAgICByaWdodDogeCArIHdpZHRoLFxuICAgIGJvdHRvbTogeSArIGhlaWdodCxcbiAgICBsZWZ0OiB4LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufSIsICJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiOyAvLyBSZXR1cm5zIHRoZSBsYXlvdXQgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuIExheW91dFxuLy8gbWVhbnMgaXQgZG9lc24ndCB0YWtlIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zLlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRMYXlvdXRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7IC8vIFVzZSB0aGUgY2xpZW50UmVjdCBzaXplcyBpZiBpdCdzIG5vdCBiZWVuIHRyYW5zZm9ybWVkLlxuICAvLyBGaXhlcyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEyMjNcblxuICB2YXIgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3Qud2lkdGggLSB3aWR0aCkgPD0gMSkge1xuICAgIHdpZHRoID0gY2xpZW50UmVjdC53aWR0aDtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LmhlaWdodCAtIGhlaWdodCkgPD0gMSkge1xuICAgIGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBlbGVtZW50Lm9mZnNldExlZnQsXG4gICAgeTogZWxlbWVudC5vZmZzZXRUb3AsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59IiwgImltcG9ydCB7IGlzU2hhZG93Um9vdCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgdmFyIHJvb3ROb2RlID0gY2hpbGQuZ2V0Um9vdE5vZGUgJiYgY2hpbGQuZ2V0Um9vdE5vZGUoKTsgLy8gRmlyc3QsIGF0dGVtcHQgd2l0aCBmYXN0ZXIgbmF0aXZlIG1ldGhvZFxuXG4gIGlmIChwYXJlbnQuY29udGFpbnMoY2hpbGQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcbiAgZWxzZSBpZiAocm9vdE5vZGUgJiYgaXNTaGFkb3dSb290KHJvb3ROb2RlKSkge1xuICAgICAgdmFyIG5leHQgPSBjaGlsZDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAobmV4dCAmJiBwYXJlbnQuaXNTYW1lTm9kZShuZXh0KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXTogbmVlZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMuLi5cblxuXG4gICAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGUgfHwgbmV4dC5ob3N0O1xuICAgICAgfSB3aGlsZSAobmV4dCk7XG4gICAgfSAvLyBHaXZlIHVwLCB0aGUgcmVzdWx0IGlzIGZhbHNlXG5cblxuICByZXR1cm4gZmFsc2U7XG59IiwgImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufSIsICJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFsndGFibGUnLCAndGQnLCAndGgnXS5pbmRleE9mKGdldE5vZGVOYW1lKGVsZW1lbnQpKSA+PSAwO1xufSIsICJpbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkge1xuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gIHJldHVybiAoKGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQub3duZXJEb2N1bWVudCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICBlbGVtZW50LmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudDtcbn0iLCAiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IHsgaXNTaGFkb3dSb290IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gIGlmIChnZXROb2RlTmFtZShlbGVtZW50KSA9PT0gJ2h0bWwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gKC8vIHRoaXMgaXMgYSBxdWlja2VyIChidXQgbGVzcyB0eXBlIHNhZmUpIHdheSB0byBzYXZlIHF1aXRlIHNvbWUgYnl0ZXMgZnJvbSB0aGUgYnVuZGxlXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIGVsZW1lbnQuYXNzaWduZWRTbG90IHx8IC8vIHN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlXG4gICAgZWxlbWVudC5wYXJlbnROb2RlIHx8ICggLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWRcbiAgICBpc1NoYWRvd1Jvb3QoZWxlbWVudCkgPyBlbGVtZW50Lmhvc3QgOiBudWxsKSB8fCAvLyBTaGFkb3dSb290IGRldGVjdGVkXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IEhUTUxFbGVtZW50IGlzIGEgTm9kZVxuICAgIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSAvLyBmYWxsYmFja1xuXG4gICk7XG59IiwgImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQsIGlzU2hhZG93Um9vdCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBpc1RhYmxlRWxlbWVudCBmcm9tIFwiLi9pc1RhYmxlRWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGdldFVBU3RyaW5nIGZyb20gXCIuLi91dGlscy91c2VyQWdlbnQuanNcIjtcblxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzgzN1xuICBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG59IC8vIGAub2Zmc2V0UGFyZW50YCByZXBvcnRzIGBudWxsYCBmb3IgZml4ZWQgZWxlbWVudHMsIHdoaWxlIGFic29sdXRlIGVsZW1lbnRzXG4vLyByZXR1cm4gdGhlIGNvbnRhaW5pbmcgYmxvY2tcblxuXG5mdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICB2YXIgaXNGaXJlZm94ID0gL2ZpcmVmb3gvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xuICB2YXIgaXNJRSA9IC9UcmlkZW50L2kudGVzdChnZXRVQVN0cmluZygpKTtcblxuICBpZiAoaXNJRSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgLy8gSW4gSUUgOSwgMTAgYW5kIDExIGZpeGVkIGVsZW1lbnRzIGNvbnRhaW5pbmcgYmxvY2sgaXMgYWx3YXlzIGVzdGFibGlzaGVkIGJ5IHRoZSB2aWV3cG9ydFxuICAgIHZhciBlbGVtZW50Q3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgIGlmIChlbGVtZW50Q3NzLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuXG4gIGlmIChpc1NoYWRvd1Jvb3QoY3VycmVudE5vZGUpKSB7XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5ob3N0O1xuICB9XG5cbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmIFsnaHRtbCcsICdib2R5J10uaW5kZXhPZihnZXROb2RlTmFtZShjdXJyZW50Tm9kZSkpIDwgMCkge1xuICAgIHZhciBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnROb2RlKTsgLy8gVGhpcyBpcyBub24tZXhoYXVzdGl2ZSBidXQgY292ZXJzIHRoZSBtb3N0IGNvbW1vbiBDU1MgcHJvcGVydGllcyB0aGF0XG4gICAgLy8gY3JlYXRlIGEgY29udGFpbmluZyBibG9jay5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuXG4gICAgaWYgKGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fCBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fCBjc3MuY29udGFpbiA9PT0gJ3BhaW50JyB8fCBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZSddLmluZGV4T2YoY3NzLndpbGxDaGFuZ2UpICE9PSAtMSB8fCBpc0ZpcmVmb3ggJiYgY3NzLndpbGxDaGFuZ2UgPT09ICdmaWx0ZXInIHx8IGlzRmlyZWZveCAmJiBjc3MuZmlsdGVyICYmIGNzcy5maWx0ZXIgIT09ICdub25lJykge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59IC8vIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgcG9zaXRpb25lZCBlbGVtZW50LiBIYW5kbGVzIHNvbWUgZWRnZSBjYXNlcyxcbi8vIHN1Y2ggYXMgdGFibGUgYW5jZXN0b3JzIGFuZCBjcm9zcyBicm93c2VyIGJ1Z3MuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCk7XG5cbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICBpZiAob2Zmc2V0UGFyZW50ICYmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnaHRtbCcgfHwgZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2JvZHknICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbmRvdztcbn0iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpID49IDAgPyAneCcgOiAneSc7XG59IiwgImltcG9ydCB7IG1heCBhcyBtYXRoTWF4LCBtaW4gYXMgbWF0aE1pbiB9IGZyb20gXCIuL21hdGguanNcIjtcbmV4cG9ydCBmdW5jdGlvbiB3aXRoaW4obWluLCB2YWx1ZSwgbWF4KSB7XG4gIHJldHVybiBtYXRoTWF4KG1pbiwgbWF0aE1pbih2YWx1ZSwgbWF4KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gd2l0aGluTWF4Q2xhbXAobWluLCB2YWx1ZSwgbWF4KSB7XG4gIHZhciB2ID0gd2l0aGluKG1pbiwgdmFsdWUsIG1heCk7XG4gIHJldHVybiB2ID4gbWF4ID8gbWF4IDogdjtcbn0iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RnJlc2hTaWRlT2JqZWN0KCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9O1xufSIsICJpbXBvcnQgZ2V0RnJlc2hTaWRlT2JqZWN0IGZyb20gXCIuL2dldEZyZXNoU2lkZU9iamVjdC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VQYWRkaW5nT2JqZWN0KHBhZGRpbmdPYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGdldEZyZXNoU2lkZU9iamVjdCgpLCBwYWRkaW5nT2JqZWN0KTtcbn0iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXhwYW5kVG9IYXNoTWFwKHZhbHVlLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoaGFzaE1hcCwga2V5KSB7XG4gICAgaGFzaE1hcFtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIGhhc2hNYXA7XG4gIH0sIHt9KTtcbn0iLCAiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuLi9kb20tdXRpbHMvY29udGFpbnMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgd2l0aGluIH0gZnJvbSBcIi4uL3V0aWxzL3dpdGhpbi5qc1wiO1xuaW1wb3J0IG1lcmdlUGFkZGluZ09iamVjdCBmcm9tIFwiLi4vdXRpbHMvbWVyZ2VQYWRkaW5nT2JqZWN0LmpzXCI7XG5pbXBvcnQgZXhwYW5kVG9IYXNoTWFwIGZyb20gXCIuLi91dGlscy9leHBhbmRUb0hhc2hNYXAuanNcIjtcbmltcG9ydCB7IGxlZnQsIHJpZ2h0LCBiYXNlUGxhY2VtZW50cywgdG9wLCBib3R0b20gfSBmcm9tIFwiLi4vZW51bXMuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgdG9QYWRkaW5nT2JqZWN0ID0gZnVuY3Rpb24gdG9QYWRkaW5nT2JqZWN0KHBhZGRpbmcsIHN0YXRlKSB7XG4gIHBhZGRpbmcgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ2Z1bmN0aW9uJyA/IHBhZGRpbmcoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiBwYWRkaW5nO1xuICByZXR1cm4gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbn07XG5cbmZ1bmN0aW9uIGFycm93KF9yZWYpIHtcbiAgdmFyIF9zdGF0ZSRtb2RpZmllcnNEYXRhJDtcblxuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgYXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgdmFyIGlzVmVydGljYWwgPSBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgaWYgKCFhcnJvd0VsZW1lbnQgfHwgIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGFkZGluZ09iamVjdCA9IHRvUGFkZGluZ09iamVjdChvcHRpb25zLnBhZGRpbmcsIHN0YXRlKTtcbiAgdmFyIGFycm93UmVjdCA9IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KTtcbiAgdmFyIG1pblByb3AgPSBheGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICB2YXIgbWF4UHJvcCA9IGF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICB2YXIgZW5kRGlmZiA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtsZW5dICsgc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnBvcHBlcltsZW5dO1xuICB2YXIgc3RhcnREaWZmID0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXTtcbiAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGFycm93RWxlbWVudCk7XG4gIHZhciBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBheGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoIHx8IDAgOiAwO1xuICB2YXIgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7IC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgcG9wcGVyIGlmIHRoZSBjZW50ZXIgcG9pbnQgaXNcbiAgLy8gb3V0c2lkZSBvZiB0aGUgcG9wcGVyIGJvdW5kc1xuXG4gIHZhciBtaW4gPSBwYWRkaW5nT2JqZWN0W21pblByb3BdO1xuICB2YXIgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93UmVjdFtsZW5dIC0gcGFkZGluZ09iamVjdFttYXhQcm9wXTtcbiAgdmFyIGNlbnRlciA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dSZWN0W2xlbl0gLyAyICsgY2VudGVyVG9SZWZlcmVuY2U7XG4gIHZhciBvZmZzZXQgPSB3aXRoaW4obWluLCBjZW50ZXIsIG1heCk7IC8vIFByZXZlbnRzIGJyZWFraW5nIHN5bnRheCBoaWdobGlnaHRpbmcuLi5cblxuICB2YXIgYXhpc1Byb3AgPSBheGlzO1xuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gKF9zdGF0ZSRtb2RpZmllcnNEYXRhJCA9IHt9LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSRbYXhpc1Byb3BdID0gb2Zmc2V0LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQuY2VudGVyT2Zmc2V0ID0gb2Zmc2V0IC0gY2VudGVyLCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQpO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQsXG4gICAgICBhcnJvd0VsZW1lbnQgPSBfb3B0aW9ucyRlbGVtZW50ID09PSB2b2lkIDAgPyAnW2RhdGEtcG9wcGVyLWFycm93XScgOiBfb3B0aW9ucyRlbGVtZW50O1xuXG4gIGlmIChhcnJvd0VsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBDU1Mgc2VsZWN0b3JcblxuXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29udGFpbnMoc3RhdGUuZWxlbWVudHMucG9wcGVyLCBhcnJvd0VsZW1lbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhdGUuZWxlbWVudHMuYXJyb3cgPSBhcnJvd0VsZW1lbnQ7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdhcnJvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBhcnJvdyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXVxufTsiLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59IiwgImltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgZW5kIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgdW5zZXRTaWRlcyA9IHtcbiAgdG9wOiAnYXV0bycsXG4gIHJpZ2h0OiAnYXV0bycsXG4gIGJvdHRvbTogJ2F1dG8nLFxuICBsZWZ0OiAnYXV0bydcbn07IC8vIFJvdW5kIHRoZSBvZmZzZXRzIHRvIHRoZSBuZWFyZXN0IHN1aXRhYmxlIHN1YnBpeGVsIGJhc2VkIG9uIHRoZSBEUFIuXG4vLyBab29taW5nIGNhbiBjaGFuZ2UgdGhlIERQUiwgYnV0IGl0IHNlZW1zIHRvIHJlcG9ydCBhIHZhbHVlIHRoYXQgd2lsbFxuLy8gY2xlYW5seSBkaXZpZGUgdGhlIHZhbHVlcyBpbnRvIHRoZSBhcHByb3ByaWF0ZSBzdWJwaXhlbHMuXG5cbmZ1bmN0aW9uIHJvdW5kT2Zmc2V0c0J5RFBSKF9yZWYsIHdpbikge1xuICB2YXIgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnk7XG4gIHZhciBkcHIgPSB3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4ge1xuICAgIHg6IHJvdW5kKHggKiBkcHIpIC8gZHByIHx8IDAsXG4gICAgeTogcm91bmQoeSAqIGRwcikgLyBkcHIgfHwgMFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwVG9TdHlsZXMoX3JlZjIpIHtcbiAgdmFyIF9PYmplY3QkYXNzaWduMjtcblxuICB2YXIgcG9wcGVyID0gX3JlZjIucG9wcGVyLFxuICAgICAgcG9wcGVyUmVjdCA9IF9yZWYyLnBvcHBlclJlY3QsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmMi5wbGFjZW1lbnQsXG4gICAgICB2YXJpYXRpb24gPSBfcmVmMi52YXJpYXRpb24sXG4gICAgICBvZmZzZXRzID0gX3JlZjIub2Zmc2V0cyxcbiAgICAgIHBvc2l0aW9uID0gX3JlZjIucG9zaXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfcmVmMi5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBhZGFwdGl2ZSA9IF9yZWYyLmFkYXB0aXZlLFxuICAgICAgcm91bmRPZmZzZXRzID0gX3JlZjIucm91bmRPZmZzZXRzLFxuICAgICAgaXNGaXhlZCA9IF9yZWYyLmlzRml4ZWQ7XG4gIHZhciBfb2Zmc2V0cyR4ID0gb2Zmc2V0cy54LFxuICAgICAgeCA9IF9vZmZzZXRzJHggPT09IHZvaWQgMCA/IDAgOiBfb2Zmc2V0cyR4LFxuICAgICAgX29mZnNldHMkeSA9IG9mZnNldHMueSxcbiAgICAgIHkgPSBfb2Zmc2V0cyR5ID09PSB2b2lkIDAgPyAwIDogX29mZnNldHMkeTtcblxuICB2YXIgX3JlZjMgPSB0eXBlb2Ygcm91bmRPZmZzZXRzID09PSAnZnVuY3Rpb24nID8gcm91bmRPZmZzZXRzKHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfSkgOiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG5cbiAgeCA9IF9yZWYzLng7XG4gIHkgPSBfcmVmMy55O1xuICB2YXIgaGFzWCA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3gnKTtcbiAgdmFyIGhhc1kgPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd5Jyk7XG4gIHZhciBzaWRlWCA9IGxlZnQ7XG4gIHZhciBzaWRlWSA9IHRvcDtcbiAgdmFyIHdpbiA9IHdpbmRvdztcblxuICBpZiAoYWRhcHRpdmUpIHtcbiAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KHBvcHBlcik7XG4gICAgdmFyIGhlaWdodFByb3AgPSAnY2xpZW50SGVpZ2h0JztcbiAgICB2YXIgd2lkdGhQcm9wID0gJ2NsaWVudFdpZHRoJztcblxuICAgIGlmIChvZmZzZXRQYXJlbnQgPT09IGdldFdpbmRvdyhwb3BwZXIpKSB7XG4gICAgICBvZmZzZXRQYXJlbnQgPSBnZXREb2N1bWVudEVsZW1lbnQocG9wcGVyKTtcblxuICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiAhPT0gJ3N0YXRpYycgJiYgcG9zaXRpb24gPT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgaGVpZ2h0UHJvcCA9ICdzY3JvbGxIZWlnaHQnO1xuICAgICAgICB3aWR0aFByb3AgPSAnc2Nyb2xsV2lkdGgnO1xuICAgICAgfVxuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FzdF06IGZvcmNlIHR5cGUgcmVmaW5lbWVudCwgd2UgY29tcGFyZSBvZmZzZXRQYXJlbnQgd2l0aCB3aW5kb3cgYWJvdmUsIGJ1dCBGbG93IGRvZXNuJ3QgZGV0ZWN0IGl0XG5cblxuICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudDtcblxuICAgIGlmIChwbGFjZW1lbnQgPT09IHRvcCB8fCAocGxhY2VtZW50ID09PSBsZWZ0IHx8IHBsYWNlbWVudCA9PT0gcmlnaHQpICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XG4gICAgICBzaWRlWSA9IGJvdHRvbTtcbiAgICAgIHZhciBvZmZzZXRZID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQuaGVpZ2h0IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICBvZmZzZXRQYXJlbnRbaGVpZ2h0UHJvcF07XG4gICAgICB5IC09IG9mZnNldFkgLSBwb3BwZXJSZWN0LmhlaWdodDtcbiAgICAgIHkgKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cblxuICAgIGlmIChwbGFjZW1lbnQgPT09IGxlZnQgfHwgKHBsYWNlbWVudCA9PT0gdG9wIHx8IHBsYWNlbWVudCA9PT0gYm90dG9tKSAmJiB2YXJpYXRpb24gPT09IGVuZCkge1xuICAgICAgc2lkZVggPSByaWdodDtcbiAgICAgIHZhciBvZmZzZXRYID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQud2lkdGggOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgIG9mZnNldFBhcmVudFt3aWR0aFByb3BdO1xuICAgICAgeCAtPSBvZmZzZXRYIC0gcG9wcGVyUmVjdC53aWR0aDtcbiAgICAgIHggKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21tb25TdHlsZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgfSwgYWRhcHRpdmUgJiYgdW5zZXRTaWRlcyk7XG5cbiAgdmFyIF9yZWY0ID0gcm91bmRPZmZzZXRzID09PSB0cnVlID8gcm91bmRPZmZzZXRzQnlEUFIoe1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9LCBnZXRXaW5kb3cocG9wcGVyKSkgOiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG5cbiAgeCA9IF9yZWY0Lng7XG4gIHkgPSBfcmVmNC55O1xuXG4gIGlmIChncHVBY2NlbGVyYXRpb24pIHtcbiAgICB2YXIgX09iamVjdCRhc3NpZ247XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24gPSB7fSwgX09iamVjdCRhc3NpZ25bc2lkZVldID0gaGFzWSA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbltzaWRlWF0gPSBoYXNYID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduLnRyYW5zZm9ybSA9ICh3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSA8PSAxID8gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweClcIiA6IFwidHJhbnNsYXRlM2QoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweCwgMClcIiwgX09iamVjdCRhc3NpZ24pKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbjIgPSB7fSwgX09iamVjdCRhc3NpZ24yW3NpZGVZXSA9IGhhc1kgPyB5ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMltzaWRlWF0gPSBoYXNYID8geCArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjIudHJhbnNmb3JtID0gJycsIF9PYmplY3QkYXNzaWduMikpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlU3R5bGVzKF9yZWY1KSB7XG4gIHZhciBzdGF0ZSA9IF9yZWY1LnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWY1Lm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPSBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGdwdUFjY2VsZXJhdCxcbiAgICAgIF9vcHRpb25zJGFkYXB0aXZlID0gb3B0aW9ucy5hZGFwdGl2ZSxcbiAgICAgIGFkYXB0aXZlID0gX29wdGlvbnMkYWRhcHRpdmUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhZGFwdGl2ZSxcbiAgICAgIF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9IG9wdGlvbnMucm91bmRPZmZzZXRzLFxuICAgICAgcm91bmRPZmZzZXRzID0gX29wdGlvbnMkcm91bmRPZmZzZXRzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcm91bmRPZmZzZXRzO1xuICB2YXIgY29tbW9uU3R5bGVzID0ge1xuICAgIHBsYWNlbWVudDogZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHZhcmlhdGlvbjogZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCksXG4gICAgcG9wcGVyOiBzdGF0ZS5lbGVtZW50cy5wb3BwZXIsXG4gICAgcG9wcGVyUmVjdDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIGdwdUFjY2VsZXJhdGlvbjogZ3B1QWNjZWxlcmF0aW9uLFxuICAgIGlzRml4ZWQ6IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCdcbiAgfTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLnBvcHBlciwgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGFkYXB0aXZlOiBhZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMuYXJyb3cgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMuYXJyb3csIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgYWRhcHRpdmU6IGZhbHNlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1wbGFjZW1lbnQnOiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdjb21wdXRlU3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdiZWZvcmVXcml0ZScsXG4gIGZuOiBjb21wdXRlU3R5bGVzLFxuICBkYXRhOiB7fVxufTsiLCAiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldFdpbmRvdy5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciBwYXNzaXZlID0ge1xuICBwYXNzaXZlOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJHNjcm9sbCA9IG9wdGlvbnMuc2Nyb2xsLFxuICAgICAgc2Nyb2xsID0gX29wdGlvbnMkc2Nyb2xsID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkc2Nyb2xsLFxuICAgICAgX29wdGlvbnMkcmVzaXplID0gb3B0aW9ucy5yZXNpemUsXG4gICAgICByZXNpemUgPSBfb3B0aW9ucyRyZXNpemUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyZXNpemU7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coc3RhdGUuZWxlbWVudHMucG9wcGVyKTtcbiAgdmFyIHNjcm9sbFBhcmVudHMgPSBbXS5jb25jYXQoc3RhdGUuc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2UsIHN0YXRlLnNjcm9sbFBhcmVudHMucG9wcGVyKTtcblxuICBpZiAoc2Nyb2xsKSB7XG4gICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgIHNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJlc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgICBzY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH1cbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBmdW5jdGlvbiBmbigpIHt9LFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgZGF0YToge31cbn07IiwgInZhciBoYXNoID0ge1xuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnLFxuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufSIsICJ2YXIgaGFzaCA9IHtcbiAgc3RhcnQ6ICdlbmQnLFxuICBlbmQ6ICdzdGFydCdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59IiwgImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGwobm9kZSkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KG5vZGUpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IHdpbi5wYWdlWE9mZnNldDtcbiAgdmFyIHNjcm9sbFRvcCA9IHdpbi5wYWdlWU9mZnNldDtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wXG4gIH07XG59IiwgImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCkge1xuICAvLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4gIC8vIGluY29ycmVjdCBmb3IgUlRMLlxuICAvLyBQb3BwZXIgMSBpcyBicm9rZW4gaW4gdGhpcyBjYXNlIGFuZCBuZXZlciBoYWQgYSBidWcgcmVwb3J0IHNvIGxldCdzIGFzc3VtZVxuICAvLyBpdCdzIG5vdCBhbiBpc3N1ZS4gSSBkb24ndCB0aGluayBhbnlvbmUgZXZlciBzcGVjaWZpZXMgd2lkdGggb24gPGh0bWw+XG4gIC8vIGFueXdheS5cbiAgLy8gQnJvd3NlcnMgd2hlcmUgdGhlIGxlZnQgc2Nyb2xsYmFyIGRvZXNuJ3QgY2F1c2UgYW4gaXNzdWUgcmVwb3J0IGAwYCBmb3JcbiAgLy8gdGhpcyAoZS5nLiBFZGdlIDIwMTksIElFMTEsIFNhZmFyaSlcbiAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcbn0iLCAiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgaXNMYXlvdXRWaWV3cG9ydCBmcm9tIFwiLi9pc0xheW91dFZpZXdwb3J0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciB2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcbiAgdmFyIHdpZHRoID0gaHRtbC5jbGllbnRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IGh0bWwuY2xpZW50SGVpZ2h0O1xuICB2YXIgeCA9IDA7XG4gIHZhciB5ID0gMDtcblxuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDtcbiAgICB2YXIgbGF5b3V0Vmlld3BvcnQgPSBpc0xheW91dFZpZXdwb3J0KCk7XG5cbiAgICBpZiAobGF5b3V0Vmlld3BvcnQgfHwgIWxheW91dFZpZXdwb3J0ICYmIHN0cmF0ZWd5ID09PSAnZml4ZWQnKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCksXG4gICAgeTogeVxuICB9O1xufSIsICJpbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmltcG9ydCB7IG1heCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7IC8vIEdldHMgdGhlIGVudGlyZSBzaXplIG9mIHRoZSBzY3JvbGxhYmxlIGRvY3VtZW50IGFyZWEsIGV2ZW4gZXh0ZW5kaW5nIG91dHNpZGVcbi8vIG9mIHRoZSBgPGh0bWw+YCBhbmQgYDxib2R5PmAgcmVjdCBib3VuZHMgaWYgaG9yaXpvbnRhbGx5IHNjcm9sbGFibGVcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcblxuICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgdmFyIHdpblNjcm9sbCA9IGdldFdpbmRvd1Njcm9sbChlbGVtZW50KTtcbiAgdmFyIGJvZHkgPSAoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHk7XG4gIHZhciB3aWR0aCA9IG1heChodG1sLnNjcm9sbFdpZHRoLCBodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5zY3JvbGxXaWR0aCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCk7XG4gIHZhciBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5ID8gYm9keS5zY3JvbGxIZWlnaHQgOiAwLCBib2R5ID8gYm9keS5jbGllbnRIZWlnaHQgOiAwKTtcbiAgdmFyIHggPSAtd2luU2Nyb2xsLnNjcm9sbExlZnQgKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpO1xuICB2YXIgeSA9IC13aW5TY3JvbGwuc2Nyb2xsVG9wO1xuXG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKGJvZHkgfHwgaHRtbCkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHggKz0gbWF4KGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCkgLSB3aWR0aDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufSIsICJpbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1Njcm9sbFBhcmVudChlbGVtZW50KSB7XG4gIC8vIEZpcmVmb3ggd2FudHMgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcbiAgdmFyIF9nZXRDb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSxcbiAgICAgIG92ZXJmbG93ID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3csXG4gICAgICBvdmVyZmxvd1ggPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvd1gsXG4gICAgICBvdmVyZmxvd1kgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvd1k7XG5cbiAgcmV0dXJuIC9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbi8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCk7XG59IiwgImltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KG5vZGUpIHtcbiAgaWYgKFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUobm9kZSkpID49IDApIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgaWYgKGlzSFRNTEVsZW1lbnQobm9kZSkgJiYgaXNTY3JvbGxQYXJlbnQobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShub2RlKSk7XG59IiwgImltcG9ydCBnZXRTY3JvbGxQYXJlbnQgZnJvbSBcIi4vZ2V0U2Nyb2xsUGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7XG4vKlxuZ2l2ZW4gYSBET00gZWxlbWVudCwgcmV0dXJuIHRoZSBsaXN0IG9mIGFsbCBzY3JvbGwgcGFyZW50cywgdXAgdGhlIGxpc3Qgb2YgYW5jZXNvcnNcbnVudGlsIHdlIGdldCB0byB0aGUgdG9wIHdpbmRvdyBvYmplY3QuIFRoaXMgbGlzdCBpcyB3aGF0IHdlIGF0dGFjaCBzY3JvbGwgbGlzdGVuZXJzXG50bywgYmVjYXVzZSBpZiBhbnkgb2YgdGhlc2UgcGFyZW50IGVsZW1lbnRzIHNjcm9sbCwgd2UnbGwgbmVlZCB0byByZS1jYWxjdWxhdGUgdGhlXG5yZWZlcmVuY2UgZWxlbWVudCdzIHBvc2l0aW9uLlxuKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGlzdFNjcm9sbFBhcmVudHMoZWxlbWVudCwgbGlzdCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIGlmIChsaXN0ID09PSB2b2lkIDApIHtcbiAgICBsaXN0ID0gW107XG4gIH1cblxuICB2YXIgc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpO1xuICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50ID09PSAoKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5KTtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhzY3JvbGxQYXJlbnQpO1xuICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gW3dpbl0uY29uY2F0KHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSwgaXNTY3JvbGxQYXJlbnQoc2Nyb2xsUGFyZW50KSA/IHNjcm9sbFBhcmVudCA6IFtdKSA6IHNjcm9sbFBhcmVudDtcbiAgdmFyIHVwZGF0ZWRMaXN0ID0gbGlzdC5jb25jYXQodGFyZ2V0KTtcbiAgcmV0dXJuIGlzQm9keSA/IHVwZGF0ZWRMaXN0IDogLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IGlzQm9keSB0ZWxscyB1cyB0YXJnZXQgd2lsbCBiZSBhbiBIVE1MRWxlbWVudCBoZXJlXG4gIHVwZGF0ZWRMaXN0LmNvbmNhdChsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKHRhcmdldCkpKTtcbn0iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVjdFRvQ2xpZW50UmVjdChyZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCByZWN0LCB7XG4gICAgbGVmdDogcmVjdC54LFxuICAgIHRvcDogcmVjdC55LFxuICAgIHJpZ2h0OiByZWN0LnggKyByZWN0LndpZHRoLFxuICAgIGJvdHRvbTogcmVjdC55ICsgcmVjdC5oZWlnaHRcbiAgfSk7XG59IiwgImltcG9ydCB7IHZpZXdwb3J0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0Vmlld3BvcnRSZWN0IGZyb20gXCIuL2dldFZpZXdwb3J0UmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50UmVjdCBmcm9tIFwiLi9nZXREb2N1bWVudFJlY3QuanNcIjtcbmltcG9ydCBsaXN0U2Nyb2xsUGFyZW50cyBmcm9tIFwiLi9saXN0U2Nyb2xsUGFyZW50cy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuL2NvbnRhaW5zLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gXCIuLi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgeyBtYXgsIG1pbiB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGZhbHNlLCBzdHJhdGVneSA9PT0gJ2ZpeGVkJyk7XG4gIHJlY3QudG9wID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgcmVjdC5sZWZ0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LndpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC5oZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC54ID0gcmVjdC5sZWZ0O1xuICByZWN0LnkgPSByZWN0LnRvcDtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkge1xuICByZXR1cm4gY2xpcHBpbmdQYXJlbnQgPT09IHZpZXdwb3J0ID8gcmVjdFRvQ2xpZW50UmVjdChnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpKSA6IGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgPyBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpIDogcmVjdFRvQ2xpZW50UmVjdChnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKSk7XG59IC8vIEEgXCJjbGlwcGluZyBwYXJlbnRcIiBpcyBhbiBvdmVyZmxvd2FibGUgY29udGFpbmVyIHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBvdmVyZmxvd2luZyBlbGVtZW50cyB3aXRoIGEgcG9zaXRpb24gZGlmZmVyZW50IGZyb21cbi8vIGBpbml0aWFsYFxuXG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSB7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbiAgdmFyIGNhbkVzY2FwZUNsaXBwaW5nID0gWydhYnNvbHV0ZScsICdmaXhlZCddLmluZGV4T2YoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbikgPj0gMDtcbiAgdmFyIGNsaXBwZXJFbGVtZW50ID0gY2FuRXNjYXBlQ2xpcHBpbmcgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldE9mZnNldFBhcmVudChlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgaWYgKCFpc0VsZW1lbnQoY2xpcHBlckVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8xNDE0XG5cblxuICByZXR1cm4gY2xpcHBpbmdQYXJlbnRzLmZpbHRlcihmdW5jdGlvbiAoY2xpcHBpbmdQYXJlbnQpIHtcbiAgICByZXR1cm4gaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSAmJiBjb250YWlucyhjbGlwcGluZ1BhcmVudCwgY2xpcHBlckVsZW1lbnQpICYmIGdldE5vZGVOYW1lKGNsaXBwaW5nUGFyZW50KSAhPT0gJ2JvZHknO1xuICB9KTtcbn0gLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgcGFyZW50c1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChlbGVtZW50LCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5LCBzdHJhdGVneSkge1xuICB2YXIgbWFpbkNsaXBwaW5nUGFyZW50cyA9IGJvdW5kYXJ5ID09PSAnY2xpcHBpbmdQYXJlbnRzJyA/IGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBbXS5jb25jYXQobWFpbkNsaXBwaW5nUGFyZW50cywgW3Jvb3RCb3VuZGFyeV0pO1xuICB2YXIgZmlyc3RDbGlwcGluZ1BhcmVudCA9IGNsaXBwaW5nUGFyZW50c1swXTtcbiAgdmFyIGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nUGFyZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY1JlY3QsIGNsaXBwaW5nUGFyZW50KSB7XG4gICAgdmFyIHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpO1xuICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IG1pbihyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcbiAgICBhY2NSZWN0LmJvdHRvbSA9IG1pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGZpcnN0Q2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSk7XG4gIGNsaXBwaW5nUmVjdC53aWR0aCA9IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QuaGVpZ2h0ID0gY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3A7XG4gIGNsaXBwaW5nUmVjdC54ID0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC55ID0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgcmV0dXJuIGNsaXBwaW5nUmVjdDtcbn0iLCAiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4vZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHN0YXJ0LCBlbmQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVPZmZzZXRzKF9yZWYpIHtcbiAgdmFyIHJlZmVyZW5jZSA9IF9yZWYucmVmZXJlbmNlLFxuICAgICAgZWxlbWVudCA9IF9yZWYuZWxlbWVudCxcbiAgICAgIHBsYWNlbWVudCA9IF9yZWYucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudCA/IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA6IG51bGw7XG4gIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQgPyBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA6IG51bGw7XG4gIHZhciBjb21tb25YID0gcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGggLyAyIC0gZWxlbWVudC53aWR0aCAvIDI7XG4gIHZhciBjb21tb25ZID0gcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0IC8gMiAtIGVsZW1lbnQuaGVpZ2h0IC8gMjtcbiAgdmFyIG9mZnNldHM7XG5cbiAgc3dpdGNoIChiYXNlUGxhY2VtZW50KSB7XG4gICAgY2FzZSB0b3A6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSAtIGVsZW1lbnQuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGJvdHRvbTpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSByaWdodDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGxlZnQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCAtIGVsZW1lbnQud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnlcbiAgICAgIH07XG4gIH1cblxuICB2YXIgbWFpbkF4aXMgPSBiYXNlUGxhY2VtZW50ID8gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpIDogbnVsbDtcblxuICBpZiAobWFpbkF4aXMgIT0gbnVsbCkge1xuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgc3dpdGNoICh2YXJpYXRpb24pIHtcbiAgICAgIGNhc2Ugc3RhcnQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gLSAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIGVuZDpcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSArIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldHM7XG59IiwgImltcG9ydCBnZXRDbGlwcGluZ1JlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tIFwiLi9jb21wdXRlT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IHJlY3RUb0NsaWVudFJlY3QgZnJvbSBcIi4vcmVjdFRvQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IHsgY2xpcHBpbmdQYXJlbnRzLCByZWZlcmVuY2UsIHBvcHBlciwgYm90dG9tLCB0b3AsIHJpZ2h0LCBiYXNlUGxhY2VtZW50cywgdmlld3BvcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IG1lcmdlUGFkZGluZ09iamVjdCBmcm9tIFwiLi9tZXJnZVBhZGRpbmdPYmplY3QuanNcIjtcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSBcIi4vZXhwYW5kVG9IYXNoTWFwLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyRwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucyRwbGFjZW1lbnQgPT09IHZvaWQgMCA/IHN0YXRlLnBsYWNlbWVudCA6IF9vcHRpb25zJHBsYWNlbWVudCxcbiAgICAgIF9vcHRpb25zJHN0cmF0ZWd5ID0gX29wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBzdHJhdGVneSA9IF9vcHRpb25zJHN0cmF0ZWd5ID09PSB2b2lkIDAgPyBzdGF0ZS5zdHJhdGVneSA6IF9vcHRpb25zJHN0cmF0ZWd5LFxuICAgICAgX29wdGlvbnMkYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMkYm91bmRhcnkgPT09IHZvaWQgMCA/IGNsaXBwaW5nUGFyZW50cyA6IF9vcHRpb25zJGJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyB2aWV3cG9ydCA6IF9vcHRpb25zJHJvb3RCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJGVsZW1lbnRDb250ZSA9IF9vcHRpb25zLmVsZW1lbnRDb250ZXh0LFxuICAgICAgZWxlbWVudENvbnRleHQgPSBfb3B0aW9ucyRlbGVtZW50Q29udGUgPT09IHZvaWQgMCA/IHBvcHBlciA6IF9vcHRpb25zJGVsZW1lbnRDb250ZSxcbiAgICAgIF9vcHRpb25zJGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IF9vcHRpb25zJGFsdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBwYWRkaW5nID0gX29wdGlvbnMkcGFkZGluZyA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHBhZGRpbmc7XG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbiAgdmFyIGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcmVmZXJlbmNlIDogcG9wcGVyO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG4gIHZhciBjbGlwcGluZ0NsaWVudFJlY3QgPSBnZXRDbGlwcGluZ1JlY3QoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgZ2V0RG9jdW1lbnRFbGVtZW50KHN0YXRlLmVsZW1lbnRzLnBvcHBlciksIGJvdW5kYXJ5LCByb290Qm91bmRhcnksIHN0cmF0ZWd5KTtcbiAgdmFyIHJlZmVyZW5jZUNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qoc3RhdGUuZWxlbWVudHMucmVmZXJlbmNlKTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VDbGllbnRSZWN0LFxuICAgIGVsZW1lbnQ6IHBvcHBlclJlY3QsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSk7XG4gIHZhciBwb3BwZXJDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChPYmplY3QuYXNzaWduKHt9LCBwb3BwZXJSZWN0LCBwb3BwZXJPZmZzZXRzKSk7XG4gIHZhciBlbGVtZW50Q2xpZW50UmVjdCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyBwb3BwZXJDbGllbnRSZWN0IDogcmVmZXJlbmNlQ2xpZW50UmVjdDsgLy8gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgcmVjdFxuICAvLyAwIG9yIG5lZ2F0aXZlID0gd2l0aGluIHRoZSBjbGlwcGluZyByZWN0XG5cbiAgdmFyIG92ZXJmbG93T2Zmc2V0cyA9IHtcbiAgICB0b3A6IGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCxcbiAgICBib3R0b206IGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSxcbiAgICBsZWZ0OiBjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQsXG4gICAgcmlnaHQ6IGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodFxuICB9O1xuICB2YXIgb2Zmc2V0RGF0YSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0OyAvLyBPZmZzZXRzIGNhbiBiZSBhcHBsaWVkIG9ubHkgdG8gdGhlIHBvcHBlciBlbGVtZW50XG5cbiAgaWYgKGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgJiYgb2Zmc2V0RGF0YSkge1xuICAgIHZhciBvZmZzZXQgPSBvZmZzZXREYXRhW3BsYWNlbWVudF07XG4gICAgT2JqZWN0LmtleXMob3ZlcmZsb3dPZmZzZXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBtdWx0aXBseSA9IFtyaWdodCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/IDEgOiAtMTtcbiAgICAgIHZhciBheGlzID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/ICd5JyA6ICd4JztcbiAgICAgIG92ZXJmbG93T2Zmc2V0c1trZXldICs9IG9mZnNldFtheGlzXSAqIG11bHRpcGx5O1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG92ZXJmbG93T2Zmc2V0cztcbn0iLCAiaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCB7IHZhcmlhdGlvblBsYWNlbWVudHMsIGJhc2VQbGFjZW1lbnRzLCBwbGFjZW1lbnRzIGFzIGFsbFBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgX29wdGlvbnMkYWxsb3dlZEF1dG9QID0gX29wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gX29wdGlvbnMkYWxsb3dlZEF1dG9QID09PSB2b2lkIDAgPyBhbGxQbGFjZW1lbnRzIDogX29wdGlvbnMkYWxsb3dlZEF1dG9QO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCk7XG4gIHZhciBwbGFjZW1lbnRzID0gdmFyaWF0aW9uID8gZmxpcFZhcmlhdGlvbnMgPyB2YXJpYXRpb25QbGFjZW1lbnRzIDogdmFyaWF0aW9uUGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gdmFyaWF0aW9uO1xuICB9KSA6IGJhc2VQbGFjZW1lbnRzO1xuICB2YXIgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFsbG93ZWRBdXRvUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCkgPj0gMDtcbiAgfSk7XG5cbiAgaWYgKGFsbG93ZWRQbGFjZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cztcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXTogRmxvdyBzZWVtcyB0byBoYXZlIHByb2JsZW1zIHdpdGggdHdvIGFycmF5IHVuaW9ucy4uLlxuXG5cbiAgdmFyIG92ZXJmbG93cyA9IGFsbG93ZWRQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pW2dldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KV07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmtleXMob3ZlcmZsb3dzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93c1thXSAtIG92ZXJmbG93c1tiXTtcbiAgfSk7XG59IiwgImltcG9ydCBnZXRPcHBvc2l0ZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgY29tcHV0ZUF1dG9QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyBib3R0b20sIHRvcCwgc3RhcnQsIHJpZ2h0LCBsZWZ0LCBhdXRvIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5mdW5jdGlvbiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwbGFjZW1lbnQpIHtcbiAgaWYgKGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0bykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHJldHVybiBbZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSwgb3Bwb3NpdGVQbGFjZW1lbnQsIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KG9wcG9zaXRlUGxhY2VtZW50KV07XG59XG5cbmZ1bmN0aW9uIGZsaXAoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxuICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXG4gICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFsdEF4aXMsXG4gICAgICBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgPSBvcHRpb25zLmZhbGxiYWNrUGxhY2VtZW50cyxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXG4gICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBvcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJGZsaXBWYXJpYXRpbyA9IG9wdGlvbnMuZmxpcFZhcmlhdGlvbnMsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zJGZsaXBWYXJpYXRpbyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGZsaXBWYXJpYXRpbyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IG9wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzO1xuICB2YXIgcHJlZmVycmVkUGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gYmFzZVBsYWNlbWVudCA9PT0gcHJlZmVycmVkUGxhY2VtZW50O1xuICB2YXIgZmFsbGJhY2tQbGFjZW1lbnRzID0gc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIHx8IChpc0Jhc2VQbGFjZW1lbnQgfHwgIWZsaXBWYXJpYXRpb25zID8gW2dldE9wcG9zaXRlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCldIDogZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocHJlZmVycmVkUGxhY2VtZW50KSk7XG4gIHZhciBwbGFjZW1lbnRzID0gW3ByZWZlcnJlZFBsYWNlbWVudF0uY29uY2F0KGZhbGxiYWNrUGxhY2VtZW50cykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0byA/IGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZyxcbiAgICAgIGZsaXBWYXJpYXRpb25zOiBmbGlwVmFyaWF0aW9ucyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50czogYWxsb3dlZEF1dG9QbGFjZW1lbnRzXG4gICAgfSkgOiBwbGFjZW1lbnQpO1xuICB9LCBbXSk7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGNoZWNrc01hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIG1ha2VGYWxsYmFja0NoZWNrcyA9IHRydWU7XG4gIHZhciBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzWzBdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGxhY2VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwbGFjZW1lbnQgPSBwbGFjZW1lbnRzW2ldO1xuXG4gICAgdmFyIF9iYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuXG4gICAgdmFyIGlzU3RhcnRWYXJpYXRpb24gPSBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gc3RhcnQ7XG4gICAgdmFyIGlzVmVydGljYWwgPSBbdG9wLCBib3R0b21dLmluZGV4T2YoX2Jhc2VQbGFjZW1lbnQpID49IDA7XG4gICAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgfSk7XG4gICAgdmFyIG1haW5WYXJpYXRpb25TaWRlID0gaXNWZXJ0aWNhbCA/IGlzU3RhcnRWYXJpYXRpb24gPyByaWdodCA6IGxlZnQgOiBpc1N0YXJ0VmFyaWF0aW9uID8gYm90dG9tIDogdG9wO1xuXG4gICAgaWYgKHJlZmVyZW5jZVJlY3RbbGVuXSA+IHBvcHBlclJlY3RbbGVuXSkge1xuICAgICAgbWFpblZhcmlhdGlvblNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XG4gICAgfVxuXG4gICAgdmFyIGFsdFZhcmlhdGlvblNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XG4gICAgdmFyIGNoZWNrcyA9IFtdO1xuXG4gICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W19iYXNlUGxhY2VtZW50XSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tBbHRBeGlzKSB7XG4gICAgICBjaGVja3MucHVzaChvdmVyZmxvd1ttYWluVmFyaWF0aW9uU2lkZV0gPD0gMCwgb3ZlcmZsb3dbYWx0VmFyaWF0aW9uU2lkZV0gPD0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrcy5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgIHJldHVybiBjaGVjaztcbiAgICB9KSkge1xuICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICAgICAgbWFrZUZhbGxiYWNrQ2hlY2tzID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjaGVja3NNYXAuc2V0KHBsYWNlbWVudCwgY2hlY2tzKTtcbiAgfVxuXG4gIGlmIChtYWtlRmFsbGJhY2tDaGVja3MpIHtcbiAgICAvLyBgMmAgbWF5IGJlIGRlc2lyZWQgaW4gc29tZSBjYXNlcyBcdTIwMTMgcmVzZWFyY2ggbGF0ZXJcbiAgICB2YXIgbnVtYmVyT2ZDaGVja3MgPSBmbGlwVmFyaWF0aW9ucyA/IDMgOiAxO1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoX2kpIHtcbiAgICAgIHZhciBmaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50cy5maW5kKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICAgICAgdmFyIGNoZWNrcyA9IGNoZWNrc01hcC5nZXQocGxhY2VtZW50KTtcblxuICAgICAgICBpZiAoY2hlY2tzKSB7XG4gICAgICAgICAgcmV0dXJuIGNoZWNrcy5zbGljZSgwLCBfaSkuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2s7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZml0dGluZ1BsYWNlbWVudCkge1xuICAgICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBmaXR0aW5nUGxhY2VtZW50O1xuICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBfaSA9IG51bWJlck9mQ2hlY2tzOyBfaSA+IDA7IF9pLS0pIHtcbiAgICAgIHZhciBfcmV0ID0gX2xvb3AoX2kpO1xuXG4gICAgICBpZiAoX3JldCA9PT0gXCJicmVha1wiKSBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUucGxhY2VtZW50ICE9PSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwID0gdHJ1ZTtcbiAgICBzdGF0ZS5wbGFjZW1lbnQgPSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgc3RhdGUucmVzZXQgPSB0cnVlO1xuICB9XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdmbGlwJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IGZsaXAsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J10sXG4gIGRhdGE6IHtcbiAgICBfc2tpcDogZmFsc2VcbiAgfVxufTsiLCAiaW1wb3J0IHsgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5cbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKSB7XG4gIGlmIChwcmV2ZW50ZWRPZmZzZXRzID09PSB2b2lkIDApIHtcbiAgICBwcmV2ZW50ZWRPZmZzZXRzID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0IC0gcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIHJpZ2h0OiBvdmVyZmxvdy5yaWdodCAtIHJlY3Qud2lkdGggKyBwcmV2ZW50ZWRPZmZzZXRzLngsXG4gICAgYm90dG9tOiBvdmVyZmxvdy5ib3R0b20gLSByZWN0LmhlaWdodCArIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aCAtIHByZXZlbnRlZE9mZnNldHMueFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcbiAgcmV0dXJuIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdLnNvbWUoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3dbc2lkZV0gPj0gMDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhpZGUoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgcHJldmVudGVkT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93O1xuICB2YXIgcmVmZXJlbmNlT3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICB9KTtcbiAgdmFyIHBvcHBlckFsdE92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICB9KTtcbiAgdmFyIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHJlZmVyZW5jZU92ZXJmbG93LCByZWZlcmVuY2VSZWN0KTtcbiAgdmFyIHBvcHBlckVzY2FwZU9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhwb3BwZXJBbHRPdmVyZmxvdywgcG9wcGVyUmVjdCwgcHJldmVudGVkT2Zmc2V0cyk7XG4gIHZhciBpc1JlZmVyZW5jZUhpZGRlbiA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMpO1xuICB2YXIgaGFzUG9wcGVyRXNjYXBlZCA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChwb3BwZXJFc2NhcGVPZmZzZXRzKTtcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IHtcbiAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHM6IHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyxcbiAgICBwb3BwZXJFc2NhcGVPZmZzZXRzOiBwb3BwZXJFc2NhcGVPZmZzZXRzLFxuICAgIGlzUmVmZXJlbmNlSGlkZGVuOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICBoYXNQb3BwZXJFc2NhcGVkOiBoYXNQb3BwZXJFc2NhcGVkXG4gIH07XG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAnZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlbic6IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgICdkYXRhLXBvcHBlci1lc2NhcGVkJzogaGFzUG9wcGVyRXNjYXBlZFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2hpZGUnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddLFxuICBmbjogaGlkZVxufTsiLCAiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIHBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCByZWN0cywgb2Zmc2V0KSB7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICB2YXIgaW52ZXJ0RGlzdGFuY2UgPSBbbGVmdCwgdG9wXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyAtMSA6IDE7XG5cbiAgdmFyIF9yZWYgPSB0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gb2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSkpIDogb2Zmc2V0LFxuICAgICAgc2tpZGRpbmcgPSBfcmVmWzBdLFxuICAgICAgZGlzdGFuY2UgPSBfcmVmWzFdO1xuXG4gIHNraWRkaW5nID0gc2tpZGRpbmcgfHwgMDtcbiAgZGlzdGFuY2UgPSAoZGlzdGFuY2UgfHwgMCkgKiBpbnZlcnREaXN0YW5jZTtcbiAgcmV0dXJuIFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8ge1xuICAgIHg6IGRpc3RhbmNlLFxuICAgIHk6IHNraWRkaW5nXG4gIH0gOiB7XG4gICAgeDogc2tpZGRpbmcsXG4gICAgeTogZGlzdGFuY2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gb2Zmc2V0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZjIubmFtZTtcbiAgdmFyIF9vcHRpb25zJG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0LFxuICAgICAgb2Zmc2V0ID0gX29wdGlvbnMkb2Zmc2V0ID09PSB2b2lkIDAgPyBbMCwgMF0gOiBfb3B0aW9ucyRvZmZzZXQ7XG4gIHZhciBkYXRhID0gcGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHN0YXRlLnJlY3RzLCBvZmZzZXQpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgdmFyIF9kYXRhJHN0YXRlJHBsYWNlbWVudCA9IGRhdGFbc3RhdGUucGxhY2VtZW50XSxcbiAgICAgIHggPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueCxcbiAgICAgIHkgPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueCArPSB4O1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy55ICs9IHk7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ29mZnNldCcsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgZm46IG9mZnNldFxufTsiLCAiaW1wb3J0IGNvbXB1dGVPZmZzZXRzIGZyb20gXCIuLi91dGlscy9jb21wdXRlT2Zmc2V0cy5qc1wiO1xuXG5mdW5jdGlvbiBwb3BwZXJPZmZzZXRzKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIC8vIE9mZnNldHMgYXJlIHRoZSBhY3R1YWwgcG9zaXRpb24gdGhlIHBvcHBlciBuZWVkcyB0byBoYXZlIHRvIGJlXG4gIC8vIHByb3Blcmx5IHBvc2l0aW9uZWQgbmVhciBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcbiAgLy8gVGhpcyBpcyB0aGUgbW9zdCBiYXNpYyBwbGFjZW1lbnQsIGFuZCB3aWxsIGJlIGFkanVzdGVkIGJ5XG4gIC8vIHRoZSBtb2RpZmllcnMgaW4gdGhlIG5leHQgc3RlcFxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogc3RhdGUucmVjdHMucmVmZXJlbmNlLFxuICAgIGVsZW1lbnQ6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ3BvcHBlck9mZnNldHMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3JlYWQnLFxuICBmbjogcG9wcGVyT2Zmc2V0cyxcbiAgZGF0YToge31cbn07IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEFsdEF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufSIsICJpbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHN0YXJ0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0QWx0QXhpcyBmcm9tIFwiLi4vdXRpbHMvZ2V0QWx0QXhpcy5qc1wiO1xuaW1wb3J0IHsgd2l0aGluLCB3aXRoaW5NYXhDbGFtcCB9IGZyb20gXCIuLi91dGlscy93aXRoaW4uanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgZ2V0RnJlc2hTaWRlT2JqZWN0IGZyb20gXCIuLi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanNcIjtcbmltcG9ydCB7IG1pbiBhcyBtYXRoTWluLCBtYXggYXMgbWF0aE1heCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIF9vcHRpb25zJHRldGhlciA9IG9wdGlvbnMudGV0aGVyLFxuICAgICAgdGV0aGVyID0gX29wdGlvbnMkdGV0aGVyID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkdGV0aGVyLFxuICAgICAgX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID0gb3B0aW9ucy50ZXRoZXJPZmZzZXQsXG4gICAgICB0ZXRoZXJPZmZzZXQgPSBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQ7XG4gIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5XG4gIH0pO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gIXZhcmlhdGlvbjtcbiAgdmFyIG1haW5BeGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgYWx0QXhpcyA9IGdldEFsdEF4aXMobWFpbkF4aXMpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgdGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gdGV0aGVyT2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSkpIDogdGV0aGVyT2Zmc2V0O1xuICB2YXIgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlID0gdHlwZW9mIHRldGhlck9mZnNldFZhbHVlID09PSAnbnVtYmVyJyA/IHtcbiAgICBtYWluQXhpczogdGV0aGVyT2Zmc2V0VmFsdWUsXG4gICAgYWx0QXhpczogdGV0aGVyT2Zmc2V0VmFsdWVcbiAgfSA6IE9iamVjdC5hc3NpZ24oe1xuICAgIG1haW5BeGlzOiAwLFxuICAgIGFsdEF4aXM6IDBcbiAgfSwgdGV0aGVyT2Zmc2V0VmFsdWUpO1xuICB2YXIgb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0ID8gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXRbc3RhdGUucGxhY2VtZW50XSA6IG51bGw7XG4gIHZhciBkYXRhID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmICghcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclN0YXRlJDtcblxuICAgIHZhciBtYWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICAgIHZhciBhbHRTaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBvZmZzZXQgPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXTtcbiAgICB2YXIgbWluID0gb2Zmc2V0ICsgb3ZlcmZsb3dbbWFpblNpZGVdO1xuICAgIHZhciBtYXggPSBvZmZzZXQgLSBvdmVyZmxvd1thbHRTaWRlXTtcbiAgICB2YXIgYWRkaXRpdmUgPSB0ZXRoZXIgPyAtcG9wcGVyUmVjdFtsZW5dIC8gMiA6IDA7XG4gICAgdmFyIG1pbkxlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gOiBwb3BwZXJSZWN0W2xlbl07XG4gICAgdmFyIG1heExlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyAtcG9wcGVyUmVjdFtsZW5dIDogLXJlZmVyZW5jZVJlY3RbbGVuXTsgLy8gV2UgbmVlZCB0byBpbmNsdWRlIHRoZSBhcnJvdyBpbiB0aGUgY2FsY3VsYXRpb24gc28gdGhlIGFycm93IGRvZXNuJ3QgZ29cbiAgICAvLyBvdXRzaWRlIHRoZSByZWZlcmVuY2UgYm91bmRzXG5cbiAgICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gICAgdmFyIGFycm93UmVjdCA9IHRldGhlciAmJiBhcnJvd0VsZW1lbnQgPyBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCkgOiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgdmFyIGFycm93UGFkZGluZ09iamVjdCA9IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXSA/IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXS5wYWRkaW5nIDogZ2V0RnJlc2hTaWRlT2JqZWN0KCk7XG4gICAgdmFyIGFycm93UGFkZGluZ01pbiA9IGFycm93UGFkZGluZ09iamVjdFttYWluU2lkZV07XG4gICAgdmFyIGFycm93UGFkZGluZ01heCA9IGFycm93UGFkZGluZ09iamVjdFthbHRTaWRlXTsgLy8gSWYgdGhlIHJlZmVyZW5jZSBsZW5ndGggaXMgc21hbGxlciB0aGFuIHRoZSBhcnJvdyBsZW5ndGgsIHdlIGRvbid0IHdhbnRcbiAgICAvLyB0byBpbmNsdWRlIGl0cyBmdWxsIHNpemUgaW4gdGhlIGNhbGN1bGF0aW9uLiBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsXG4gICAgLy8gYW5kIG5lYXIgdGhlIGVkZ2Ugb2YgYSBib3VuZGFyeSwgdGhlIHBvcHBlciBjYW4gb3ZlcmZsb3cgZXZlbiBpZiB0aGVcbiAgICAvLyByZWZlcmVuY2UgaXMgbm90IG92ZXJmbG93aW5nIGFzIHdlbGwgKGUuZy4gdmlydHVhbCBlbGVtZW50cyB3aXRoIG5vXG4gICAgLy8gd2lkdGggb3IgaGVpZ2h0KVxuXG4gICAgdmFyIGFycm93TGVuID0gd2l0aGluKDAsIHJlZmVyZW5jZVJlY3RbbGVuXSwgYXJyb3dSZWN0W2xlbl0pO1xuICAgIHZhciBtaW5PZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gLyAyIC0gYWRkaXRpdmUgLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcyA6IG1pbkxlbiAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzO1xuICAgIHZhciBtYXhPZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyAtcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiArIGFkZGl0aXZlICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXMgOiBtYXhMZW4gKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcbiAgICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdyAmJiBnZXRPZmZzZXRQYXJlbnQoc3RhdGUuZWxlbWVudHMuYXJyb3cpO1xuICAgIHZhciBjbGllbnRPZmZzZXQgPSBhcnJvd09mZnNldFBhcmVudCA/IG1haW5BeGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRUb3AgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudExlZnQgfHwgMCA6IDA7XG4gICAgdmFyIG9mZnNldE1vZGlmaWVyVmFsdWUgPSAoX29mZnNldE1vZGlmaWVyU3RhdGUkID0gb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogb2Zmc2V0TW9kaWZpZXJTdGF0ZVttYWluQXhpc10pICE9IG51bGwgPyBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQgOiAwO1xuICAgIHZhciB0ZXRoZXJNaW4gPSBvZmZzZXQgKyBtaW5PZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlIC0gY2xpZW50T2Zmc2V0O1xuICAgIHZhciB0ZXRoZXJNYXggPSBvZmZzZXQgKyBtYXhPZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlO1xuICAgIHZhciBwcmV2ZW50ZWRPZmZzZXQgPSB3aXRoaW4odGV0aGVyID8gbWF0aE1pbihtaW4sIHRldGhlck1pbikgOiBtaW4sIG9mZnNldCwgdGV0aGVyID8gbWF0aE1heChtYXgsIHRldGhlck1heCkgOiBtYXgpO1xuICAgIHBvcHBlck9mZnNldHNbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0O1xuICAgIGRhdGFbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0IC0gb2Zmc2V0O1xuICB9XG5cbiAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyO1xuXG4gICAgdmFyIF9tYWluU2lkZSA9IG1haW5BeGlzID09PSAneCcgPyB0b3AgOiBsZWZ0O1xuXG4gICAgdmFyIF9hbHRTaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IGJvdHRvbSA6IHJpZ2h0O1xuXG4gICAgdmFyIF9vZmZzZXQgPSBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdO1xuXG4gICAgdmFyIF9sZW4gPSBhbHRBeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICB2YXIgX21pbiA9IF9vZmZzZXQgKyBvdmVyZmxvd1tfbWFpblNpZGVdO1xuXG4gICAgdmFyIF9tYXggPSBfb2Zmc2V0IC0gb3ZlcmZsb3dbX2FsdFNpZGVdO1xuXG4gICAgdmFyIGlzT3JpZ2luU2lkZSA9IFt0b3AsIGxlZnRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJDIgPSBvZmZzZXRNb2RpZmllclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXRNb2RpZmllclN0YXRlW2FsdEF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkMiA6IDA7XG5cbiAgICB2YXIgX3RldGhlck1pbiA9IGlzT3JpZ2luU2lkZSA/IF9taW4gOiBfb2Zmc2V0IC0gcmVmZXJlbmNlUmVjdFtfbGVuXSAtIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzO1xuXG4gICAgdmFyIF90ZXRoZXJNYXggPSBpc09yaWdpblNpZGUgPyBfb2Zmc2V0ICsgcmVmZXJlbmNlUmVjdFtfbGVuXSArIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzIDogX21heDtcblxuICAgIHZhciBfcHJldmVudGVkT2Zmc2V0ID0gdGV0aGVyICYmIGlzT3JpZ2luU2lkZSA/IHdpdGhpbk1heENsYW1wKF90ZXRoZXJNaW4sIF9vZmZzZXQsIF90ZXRoZXJNYXgpIDogd2l0aGluKHRldGhlciA/IF90ZXRoZXJNaW4gOiBfbWluLCBfb2Zmc2V0LCB0ZXRoZXIgPyBfdGV0aGVyTWF4IDogX21heCk7XG5cbiAgICBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldDtcbiAgICBkYXRhW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldCAtIF9vZmZzZXQ7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBwcmV2ZW50T3ZlcmZsb3csXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J11cbn07IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEhUTUxFbGVtZW50U2Nyb2xsKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICB9O1xufSIsICJpbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0SFRNTEVsZW1lbnRTY3JvbGwgZnJvbSBcIi4vZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE5vZGVTY3JvbGwobm9kZSkge1xuICBpZiAobm9kZSA9PT0gZ2V0V2luZG93KG5vZGUpIHx8ICFpc0hUTUxFbGVtZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIGdldFdpbmRvd1Njcm9sbChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0SFRNTEVsZW1lbnRTY3JvbGwobm9kZSk7XG4gIH1cbn0iLCAiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXROb2RlU2Nyb2xsIGZyb20gXCIuL2dldE5vZGVTY3JvbGwuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcblxuZnVuY3Rpb24gaXNFbGVtZW50U2NhbGVkKGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc2NhbGVYID0gcm91bmQocmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDE7XG4gIHZhciBzY2FsZVkgPSByb3VuZChyZWN0LmhlaWdodCkgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxO1xuICByZXR1cm4gc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMTtcbn0gLy8gUmV0dXJucyB0aGUgY29tcG9zaXRlIHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LlxuLy8gQ29tcG9zaXRlIG1lYW5zIGl0IHRha2VzIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zIGFzIHdlbGwgYXMgbGF5b3V0LlxuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbXBvc2l0ZVJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudCwgaXNGaXhlZCkge1xuICBpZiAoaXNGaXhlZCA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgb2Zmc2V0UGFyZW50SXNTY2FsZWQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgaXNFbGVtZW50U2NhbGVkKG9mZnNldFBhcmVudCk7XG4gIHZhciBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudElzU2NhbGVkLCBpc0ZpeGVkKTtcbiAgdmFyIHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICB2YXIgb2Zmc2V0cyA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEwNzhcbiAgICBpc1Njcm9sbFBhcmVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgb2Zmc2V0cyA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQsIHRydWUpO1xuICAgICAgb2Zmc2V0cy54ICs9IG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ICs9IG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54LFxuICAgIHk6IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59IiwgImltcG9ydCB7IG1vZGlmaWVyUGhhc2VzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7IC8vIHNvdXJjZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk4NzUyNTVcblxuZnVuY3Rpb24gb3JkZXIobW9kaWZpZXJzKSB7XG4gIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIG1hcC5zZXQobW9kaWZpZXIubmFtZSwgbW9kaWZpZXIpO1xuICB9KTsgLy8gT24gdmlzaXRpbmcgb2JqZWN0LCBjaGVjayBmb3IgaXRzIGRlcGVuZGVuY2llcyBhbmQgdmlzaXQgdGhlbSByZWN1cnNpdmVseVxuXG4gIGZ1bmN0aW9uIHNvcnQobW9kaWZpZXIpIHtcbiAgICB2aXNpdGVkLmFkZChtb2RpZmllci5uYW1lKTtcbiAgICB2YXIgcmVxdWlyZXMgPSBbXS5jb25jYXQobW9kaWZpZXIucmVxdWlyZXMgfHwgW10sIG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMgfHwgW10pO1xuICAgIHJlcXVpcmVzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhkZXApKSB7XG4gICAgICAgIHZhciBkZXBNb2RpZmllciA9IG1hcC5nZXQoZGVwKTtcblxuICAgICAgICBpZiAoZGVwTW9kaWZpZXIpIHtcbiAgICAgICAgICBzb3J0KGRlcE1vZGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJlc3VsdC5wdXNoKG1vZGlmaWVyKTtcbiAgfVxuXG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmICghdmlzaXRlZC5oYXMobW9kaWZpZXIubmFtZSkpIHtcbiAgICAgIC8vIGNoZWNrIGZvciB2aXNpdGVkIG9iamVjdFxuICAgICAgc29ydChtb2RpZmllcik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb3JkZXJNb2RpZmllcnMobW9kaWZpZXJzKSB7XG4gIC8vIG9yZGVyIGJhc2VkIG9uIGRlcGVuZGVuY2llc1xuICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyKG1vZGlmaWVycyk7IC8vIG9yZGVyIGJhc2VkIG9uIHBoYXNlXG5cbiAgcmV0dXJuIG1vZGlmaWVyUGhhc2VzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwaGFzZSkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgcmV0dXJuIG1vZGlmaWVyLnBoYXNlID09PSBwaGFzZTtcbiAgICB9KSk7XG4gIH0sIFtdKTtcbn0iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVib3VuY2UoZm4pIHtcbiAgdmFyIHBlbmRpbmc7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcGVuZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXNvbHZlKGZuKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwZW5kaW5nO1xuICB9O1xufSIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZUJ5TmFtZShtb2RpZmllcnMpIHtcbiAgdmFyIG1lcmdlZCA9IG1vZGlmaWVycy5yZWR1Y2UoZnVuY3Rpb24gKG1lcmdlZCwgY3VycmVudCkge1xuICAgIHZhciBleGlzdGluZyA9IG1lcmdlZFtjdXJyZW50Lm5hbWVdO1xuICAgIG1lcmdlZFtjdXJyZW50Lm5hbWVdID0gZXhpc3RpbmcgPyBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZywgY3VycmVudCwge1xuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3Rpbmcub3B0aW9ucywgY3VycmVudC5vcHRpb25zKSxcbiAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLmRhdGEsIGN1cnJlbnQuZGF0YSlcbiAgICB9KSA6IGN1cnJlbnQ7XG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfSwge30pOyAvLyBJRTExIGRvZXMgbm90IHN1cHBvcnQgT2JqZWN0LnZhbHVlc1xuXG4gIHJldHVybiBPYmplY3Qua2V5cyhtZXJnZWQpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG1lcmdlZFtrZXldO1xuICB9KTtcbn0iLCAiaW1wb3J0IGdldENvbXBvc2l0ZVJlY3QgZnJvbSBcIi4vZG9tLXV0aWxzL2dldENvbXBvc2l0ZVJlY3QuanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgbGlzdFNjcm9sbFBhcmVudHMgZnJvbSBcIi4vZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBvcmRlck1vZGlmaWVycyBmcm9tIFwiLi91dGlscy9vcmRlck1vZGlmaWVycy5qc1wiO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gXCIuL3V0aWxzL2RlYm91bmNlLmpzXCI7XG5pbXBvcnQgbWVyZ2VCeU5hbWUgZnJvbSBcIi4vdXRpbHMvbWVyZ2VCeU5hbWUuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gIG1vZGlmaWVyczogW10sXG4gIHN0cmF0ZWd5OiAnYWJzb2x1dGUnXG59O1xuXG5mdW5jdGlvbiBhcmVWYWxpZEVsZW1lbnRzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuICFhcmdzLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gIShlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9PT0gJ2Z1bmN0aW9uJyk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9wcGVyR2VuZXJhdG9yKGdlbmVyYXRvck9wdGlvbnMpIHtcbiAgaWYgKGdlbmVyYXRvck9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIGdlbmVyYXRvck9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfZ2VuZXJhdG9yT3B0aW9ucyA9IGdlbmVyYXRvck9wdGlvbnMsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0TW9kaWZpZXJzLFxuICAgICAgZGVmYXVsdE1vZGlmaWVycyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9PT0gdm9pZCAwID8gW10gOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE9wdGlvbnMsXG4gICAgICBkZWZhdWx0T3B0aW9ucyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPT09IHZvaWQgMCA/IERFRkFVTFRfT1BUSU9OUyA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZjI7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgICAgIG9yZGVyZWRNb2RpZmllcnM6IFtdLFxuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBkZWZhdWx0T3B0aW9ucyksXG4gICAgICBtb2RpZmllcnNEYXRhOiB7fSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlLFxuICAgICAgICBwb3BwZXI6IHBvcHBlclxuICAgICAgfSxcbiAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH07XG4gICAgdmFyIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB2YXIgaXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB2YXIgaW5zdGFuY2UgPSB7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBzZXRPcHRpb25zOiBmdW5jdGlvbiBzZXRPcHRpb25zKHNldE9wdGlvbnNBY3Rpb24pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2V0T3B0aW9uc0FjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IHNldE9wdGlvbnNBY3Rpb24oc3RhdGUub3B0aW9ucykgOiBzZXRPcHRpb25zQWN0aW9uO1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHN0YXRlLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgc3RhdGUub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHN0YXRlLnNjcm9sbFBhcmVudHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBpc0VsZW1lbnQocmVmZXJlbmNlKSA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZSkgOiByZWZlcmVuY2UuY29udGV4dEVsZW1lbnQgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpIDogW10sXG4gICAgICAgICAgcG9wcGVyOiBsaXN0U2Nyb2xsUGFyZW50cyhwb3BwZXIpXG4gICAgICAgIH07IC8vIE9yZGVycyB0aGUgbW9kaWZpZXJzIGJhc2VkIG9uIHRoZWlyIGRlcGVuZGVuY2llcyBhbmQgYHBoYXNlYFxuICAgICAgICAvLyBwcm9wZXJ0aWVzXG5cbiAgICAgICAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlck1vZGlmaWVycyhtZXJnZUJ5TmFtZShbXS5jb25jYXQoZGVmYXVsdE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpKSk7IC8vIFN0cmlwIG91dCBkaXNhYmxlZCBtb2RpZmllcnNcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICByZXR1cm4gbS5lbmFibGVkO1xuICAgICAgICB9KTtcbiAgICAgICAgcnVuTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgIH0sXG4gICAgICAvLyBTeW5jIHVwZGF0ZSBcdTIwMTMgaXQgd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQsIGV2ZW4gaWYgbm90IG5lY2Vzc2FyeS4gVGhpc1xuICAgICAgLy8gaXMgdXNlZnVsIGZvciBsb3cgZnJlcXVlbmN5IHVwZGF0ZXMgd2hlcmUgc3luYyBiZWhhdmlvciBzaW1wbGlmaWVzIHRoZVxuICAgICAgLy8gbG9naWMuXG4gICAgICAvLyBGb3IgaGlnaCBmcmVxdWVuY3kgdXBkYXRlcyAoZS5nLiBgcmVzaXplYCBhbmQgYHNjcm9sbGAgZXZlbnRzKSwgYWx3YXlzXG4gICAgICAvLyBwcmVmZXIgdGhlIGFzeW5jIFBvcHBlciN1cGRhdGUgbWV0aG9kXG4gICAgICBmb3JjZVVwZGF0ZTogZnVuY3Rpb24gZm9yY2VVcGRhdGUoKSB7XG4gICAgICAgIGlmIChpc0Rlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfc3RhdGUkZWxlbWVudHMgPSBzdGF0ZS5lbGVtZW50cyxcbiAgICAgICAgICAgIHJlZmVyZW5jZSA9IF9zdGF0ZSRlbGVtZW50cy5yZWZlcmVuY2UsXG4gICAgICAgICAgICBwb3BwZXIgPSBfc3RhdGUkZWxlbWVudHMucG9wcGVyOyAvLyBEb24ndCBwcm9jZWVkIGlmIGByZWZlcmVuY2VgIG9yIGBwb3BwZXJgIGFyZSBub3QgdmFsaWQgZWxlbWVudHNcbiAgICAgICAgLy8gYW55bW9yZVxuXG4gICAgICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gU3RvcmUgdGhlIHJlZmVyZW5jZSBhbmQgcG9wcGVyIHJlY3RzIHRvIGJlIHJlYWQgYnkgbW9kaWZpZXJzXG5cblxuICAgICAgICBzdGF0ZS5yZWN0cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGdldENvbXBvc2l0ZVJlY3QocmVmZXJlbmNlLCBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKSwgc3RhdGUub3B0aW9ucy5zdHJhdGVneSA9PT0gJ2ZpeGVkJyksXG4gICAgICAgICAgcG9wcGVyOiBnZXRMYXlvdXRSZWN0KHBvcHBlcilcbiAgICAgICAgfTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gcmVzZXQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlLiBUaGVcbiAgICAgICAgLy8gbW9zdCBjb21tb24gdXNlIGNhc2UgZm9yIHRoaXMgaXMgdGhlIGBmbGlwYCBtb2RpZmllciBjaGFuZ2luZyB0aGVcbiAgICAgICAgLy8gcGxhY2VtZW50LCB3aGljaCB0aGVuIG5lZWRzIHRvIHJlLXJ1biBhbGwgdGhlIG1vZGlmaWVycywgYmVjYXVzZSB0aGVcbiAgICAgICAgLy8gbG9naWMgd2FzIHByZXZpb3VzbHkgcmFuIGZvciB0aGUgcHJldmlvdXMgcGxhY2VtZW50IGFuZCBpcyB0aGVyZWZvcmVcbiAgICAgICAgLy8gc3RhbGUvaW5jb3JyZWN0XG5cbiAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7IC8vIE9uIGVhY2ggdXBkYXRlIGN5Y2xlLCB0aGUgYG1vZGlmaWVyc0RhdGFgIHByb3BlcnR5IGZvciBlYWNoIG1vZGlmaWVyXG4gICAgICAgIC8vIGlzIGZpbGxlZCB3aXRoIHRoZSBpbml0aWFsIGRhdGEgc3BlY2lmaWVkIGJ5IHRoZSBtb2RpZmllci4gVGhpcyBtZWFuc1xuICAgICAgICAvLyBpdCBkb2Vzbid0IHBlcnNpc3QgYW5kIGlzIGZyZXNoIG9uIGVhY2ggdXBkYXRlLlxuICAgICAgICAvLyBUbyBlbnN1cmUgcGVyc2lzdGVudCBkYXRhLCB1c2UgYCR7bmFtZX0jcGVyc2lzdGVudGBcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLm1vZGlmaWVyc0RhdGFbbW9kaWZpZXIubmFtZV0gPSBPYmplY3QuYXNzaWduKHt9LCBtb2RpZmllci5kYXRhKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0YXRlLm9yZGVyZWRNb2RpZmllcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgaWYgKHN0YXRlLnJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfc3RhdGUkb3JkZXJlZE1vZGlmaWUgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzW2luZGV4XSxcbiAgICAgICAgICAgICAgZm4gPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUuZm4sXG4gICAgICAgICAgICAgIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUub3B0aW9ucyxcbiAgICAgICAgICAgICAgX29wdGlvbnMgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID09PSB2b2lkIDAgPyB7fSA6IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIsXG4gICAgICAgICAgICAgIG5hbWUgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUubmFtZTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN0YXRlID0gZm4oe1xuICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IF9vcHRpb25zLFxuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VcbiAgICAgICAgICAgIH0pIHx8IHN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFzeW5jIGFuZCBvcHRpbWlzdGljYWxseSBvcHRpbWl6ZWQgdXBkYXRlIFx1MjAxMyBpdCB3aWxsIG5vdCBiZSBleGVjdXRlZCBpZlxuICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXG4gICAgICB1cGRhdGU6IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICByZXNvbHZlKHN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgaWYgKCFpc0Rlc3Ryb3llZCAmJiBvcHRpb25zLm9uRmlyc3RVcGRhdGUpIHtcbiAgICAgICAgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSBiZWZvcmUgdGhlIGZpcnN0XG4gICAgLy8gdXBkYXRlIGN5Y2xlIHJ1bnMuIFRoZXkgd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgdXBkYXRlXG4gICAgLy8gY3ljbGUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBtb2RpZmllciBhZGRzIHNvbWUgcGVyc2lzdGVudCBkYXRhIHRoYXRcbiAgICAvLyBvdGhlciBtb2RpZmllcnMgbmVlZCB0byB1c2UsIGJ1dCB0aGUgbW9kaWZpZXIgaXMgcnVuIGFmdGVyIHRoZSBkZXBlbmRlbnRcbiAgICAvLyBvbmUuXG5cbiAgICBmdW5jdGlvbiBydW5Nb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgICAgICBfcmVmJG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zID0gX3JlZiRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkb3B0aW9ucyxcbiAgICAgICAgICAgIGVmZmVjdCA9IF9yZWYuZWZmZWN0O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZWZmZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIGNsZWFudXBGbiA9IGVmZmVjdCh7XG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIG5vb3BGbiA9IGZ1bmN0aW9uIG5vb3BGbigpIHt9O1xuXG4gICAgICAgICAgZWZmZWN0Q2xlYW51cEZucy5wdXNoKGNsZWFudXBGbiB8fCBub29wRm4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgZWZmZWN0Q2xlYW51cEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0pO1xuICAgICAgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcbn1cbmV4cG9ydCB2YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGRldGVjdE92ZXJmbG93IH07IiwgImltcG9ydCB7IHBvcHBlckdlbmVyYXRvciwgZGV0ZWN0T3ZlcmZsb3cgfSBmcm9tIFwiLi9jcmVhdGVQb3BwZXIuanNcIjtcbmltcG9ydCBldmVudExpc3RlbmVycyBmcm9tIFwiLi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanNcIjtcbmltcG9ydCBwb3BwZXJPZmZzZXRzIGZyb20gXCIuL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzLmpzXCI7XG5pbXBvcnQgY29tcHV0ZVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qc1wiO1xuaW1wb3J0IGFwcGx5U3R5bGVzIGZyb20gXCIuL21vZGlmaWVycy9hcHBseVN0eWxlcy5qc1wiO1xuaW1wb3J0IG9mZnNldCBmcm9tIFwiLi9tb2RpZmllcnMvb2Zmc2V0LmpzXCI7XG5pbXBvcnQgZmxpcCBmcm9tIFwiLi9tb2RpZmllcnMvZmxpcC5qc1wiO1xuaW1wb3J0IHByZXZlbnRPdmVyZmxvdyBmcm9tIFwiLi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgYXJyb3cgZnJvbSBcIi4vbW9kaWZpZXJzL2Fycm93LmpzXCI7XG5pbXBvcnQgaGlkZSBmcm9tIFwiLi9tb2RpZmllcnMvaGlkZS5qc1wiO1xudmFyIGRlZmF1bHRNb2RpZmllcnMgPSBbZXZlbnRMaXN0ZW5lcnMsIHBvcHBlck9mZnNldHMsIGNvbXB1dGVTdHlsZXMsIGFwcGx5U3R5bGVzLCBvZmZzZXQsIGZsaXAsIHByZXZlbnRPdmVyZmxvdywgYXJyb3csIGhpZGVdO1xudmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3Ioe1xuICBkZWZhdWx0TW9kaWZpZXJzOiBkZWZhdWx0TW9kaWZpZXJzXG59KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIsIHBvcHBlckdlbmVyYXRvciwgZGVmYXVsdE1vZGlmaWVycywgZGV0ZWN0T3ZlcmZsb3cgfTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIgYXMgY3JlYXRlUG9wcGVyTGl0ZSB9IGZyb20gXCIuL3BvcHBlci1saXRlLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0ICogZnJvbSBcIi4vbW9kaWZpZXJzL2luZGV4LmpzXCI7IiwgIi8vIENyZWRpdHMgZ28gdG8gTGlhbSdzIFBlcmlvZGljIE5vdGVzIFBsdWdpbjogaHR0cHM6Ly9naXRodWIuY29tL2xpYW1jYWluL29ic2lkaWFuLXBlcmlvZGljLW5vdGVzXG4vLyBhbmQgVGVtcGxhdGVyIHBsdWdpbjogaHR0cHM6Ly9naXRodWIuY29tL1NpbGVudFZvaWQxMy9UZW1wbGF0ZXIgd2hlcmUgSSBnb3QgdGhlIGNvZGUgZm9yIHRoZSBzdWdnZXN0ZXJzXG5cbmltcG9ydCB7IFRBYnN0cmFjdEZpbGUsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBUZXh0SW5wdXRTdWdnZXN0IH0gZnJvbSBcIi4vc3VnZ2VzdFwiO1xuaW1wb3J0IHsgZ2V0RmlsZXNGcm9tRm9sZGVyIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XG5pbXBvcnQgRm9sZGVyVGFnUGx1Z2luIGZyb20gXCIuLi8uLi9tYWluXCI7XG5pbXBvcnQgeyBlcnJvcldyYXBwZXJTeW5jIH0gZnJvbSBcIi4uL0Vycm9yXCI7XG5cbmV4cG9ydCBlbnVtIEZpbGVTdWdnZXN0TW9kZSB7XG4gICAgVGVtcGxhdGVGaWxlcyxcbiAgICBTY3JpcHRGaWxlcyxcbn1cblxuZXhwb3J0IGNsYXNzIEZpbGVTdWdnZXN0IGV4dGVuZHMgVGV4dElucHV0U3VnZ2VzdDxURmlsZT4ge1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHB1YmxpYyBpbnB1dEVsOiBIVE1MSW5wdXRFbGVtZW50LFxuICAgICAgICBwcml2YXRlIHBsdWdpbjogRm9sZGVyVGFnUGx1Z2luLFxuICAgICAgICBwcml2YXRlIGZvbGRlcjogc3RyaW5nXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKHBsdWdpbi5hcHAsIGlucHV0RWwpO1xuICAgIH1cblxuICAgIGdldF9lcnJvcl9tc2coKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGBGb2xkZXIgJHt0aGlzLmZvbGRlcn0gZG9lc24ndCBleGlzdGA7XG4gICAgfVxuXG4gICAgZ2V0U3VnZ2VzdGlvbnMoaW5wdXRfc3RyOiBzdHJpbmcpOiBURmlsZVtdIHtcbiAgICAgICAgY29uc3QgYWxsX2ZpbGVzID0gZXJyb3JXcmFwcGVyU3luYyhcbiAgICAgICAgICAgICgpID0+IGdldEZpbGVzRnJvbUZvbGRlcihcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uYXBwLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvbGRlclxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICB0aGlzLmdldF9lcnJvcl9tc2coKVxuICAgICAgICApO1xuICAgICAgICBpZiAoIWFsbF9maWxlcykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmlsZXM6IFRGaWxlW10gPSBbXTtcbiAgICAgICAgY29uc3QgbG93ZXJfaW5wdXRfc3RyID0gaW5wdXRfc3RyLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgYWxsX2ZpbGVzLmZvckVhY2goKGZpbGU6IFRBYnN0cmFjdEZpbGUpID0+IHtcbiAgICAgICAgICAgIGlmIChmaWxlIGluc3RhbmNlb2YgVEZpbGUgJiZcbiAgICAgICAgICAgICAgICBmaWxlLmV4dGVuc2lvbiA9PT0gXCJtZFwiICYmXG4gICAgICAgICAgICAgICAgZmlsZS5wYXRoLnRvTG93ZXJDYXNlKCkuY29udGFpbnMobG93ZXJfaW5wdXRfc3RyKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKGZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZmlsZXMuc2xpY2UoMCwgMTAwMCk7XG4gICAgfVxuXG4gICAgcmVuZGVyU3VnZ2VzdGlvbihmaWxlOiBURmlsZSwgZWw6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgICAgIGVsLnNldFRleHQoZmlsZS5wYXRoKTtcbiAgICB9XG5cbiAgICBzZWxlY3RTdWdnZXN0aW9uKGZpbGU6IFRGaWxlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaW5wdXRFbC52YWx1ZSA9IGZpbGUucGF0aDtcbiAgICAgICAgdGhpcy5pbnB1dEVsLnRyaWdnZXIoXCJpbnB1dFwiKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgZXhwIGZyb20gJ2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IEFwcCwgTW9kYWwsIFNldHRpbmcsIFRBYnN0cmFjdEZpbGUsIFRGaWxlLCBURm9sZGVyLCBWYXVsdCwgc2V0SWNvbiB9IGZyb20gJ29ic2lkaWFuJzsgLy8gQWRkZWQgc2V0SWNvblxyXG5cclxuLy8gRGVmaW5lIHRoZSBzdHJ1Y3R1cmUgZm9yIHRyZWUgbm9kZXNcclxuaW50ZXJmYWNlIFRyZWVOb2RlIHtcclxuICAgIHBhdGg6IHN0cmluZztcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIHR5cGU6IHN0cmluZzsgLy8gJ2ZvbGRlcicgfCAnZmlsZSc7XHJcbiAgICBjaGlsZHJlbj86IFRyZWVOb2RlW107XHJcbiAgICBlbGVtZW50OiBIVE1MRWxlbWVudDsgLy8gUmVmZXJlbmNlIHRvIHRoZSBsaXN0IGl0ZW0gZWxlbWVudCAobGkpXHJcbiAgICBjaGVja2JveDogSFRNTElucHV0RWxlbWVudDtcclxuICAgIGxhYmVsOiBIVE1MTGFiZWxFbGVtZW50O1xyXG4gICAgY29udGFpbmVyOiBIVE1MRWxlbWVudDsgLy8gUmVmZXJlbmNlIHRvIHRoZSBjb250YWluZXIgZGl2IGhvbGRpbmcgY2hlY2tib3ggYW5kIGxhYmVsXHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIERpcmVjdG9yeVNlbGVjdGlvbk1vZGUgPSAnaW5jbHVkZScgfCAnZXhjbHVkZSc7IC8vIERlZmluZSBzZWxlY3Rpb24gbW9kZXNcclxuZXhwb3J0IHR5cGUgRGlyZWN0b3J5RGlzcGxheU1vZGUgPSAnZm9sZGVycycgfCAnZmlsZXMnIHwgJ2ZvbGRlcicgfCAnZmlsZSc7IC8vIERlZmluZSBkaXNwbGF5IG1vZGVzXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGlyZWN0b3J5U2VsZWN0aW9uT3B0aW9ucyB7XHJcbiAgICB0aXRsZT86IHN0cmluZzsgLy8gVGl0bGUgb2YgdGhlIG1vZGFsXHJcbiAgICBzZWxlY3Rpb25Nb2RlOiBEaXJlY3RvcnlTZWxlY3Rpb25Nb2RlOyAvLyAnaW5jbHVkZScgb3IgJ2V4Y2x1ZGUnXHJcbiAgICBkaXNwbGF5TW9kZTogRGlyZWN0b3J5RGlzcGxheU1vZGU7IC8vICdmb2xkZXJzJyBvciAnZmlsZXMnXHJcbiAgICBvcHRpb25TZWxlY3Rpb25Nb2RlOiBib29sZWFuOyAvLyBTaG93IGluY2x1ZGUvZXhjbHVkZSBvcHRpb25cclxuICAgIG9wdGlvblNob3dGaWxlczogYm9vbGVhbjsgLy8gU2hvdyBmaWxlcyBvcHRpb25cclxufVxyXG4vLyBEZWZpbmUgdGhlIHJlc3VsdCBzdHJ1Y3R1cmUgcmV0dXJuZWQgYnkgdGhlIG1vZGFsXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGlyZWN0b3J5U2VsZWN0aW9uUmVzdWx0IHtcclxuICAgIGZvbGRlcnM6IHN0cmluZ1tdO1xyXG4gICAgZmlsZXM6IHN0cmluZ1tdO1xyXG4gICAgbW9kZTogRGlyZWN0b3J5U2VsZWN0aW9uTW9kZTtcclxuICAgIGRpc3BsYXk6IERpcmVjdG9yeURpc3BsYXlNb2RlO1xyXG59XHJcblxyXG4vKipcclxuICogT2JzaWRpYW4gTW9kYWwgZm9yIHNlbGVjdGluZyBkaXJlY3RvcmllcyBhbmQgZmlsZXMgZnJvbSB0aGUgdmF1bHQgc3RydWN0dXJlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIERpcmVjdG9yeVNlbGVjdGlvbk1vZGFsIGV4dGVuZHMgTW9kYWwge1xyXG4gICAgLy8gSW5pdGlhbCBzdGF0ZSBwYXNzZWQgdG8gdGhlIG1vZGFsIChzdG9yZWQgZm9yIHJlc2V0IGZ1bmN0aW9uYWxpdHkpXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IGluaXRpYWxGb2xkZXJzU25hcHNob3Q6IFJlYWRvbmx5U2V0PHN0cmluZz47XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IGluaXRpYWxGaWxlc1NuYXBzaG90OiBSZWFkb25seVNldDxzdHJpbmc+O1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBpbml0aWFsTW9kZVNuYXBzaG90OiBEaXJlY3RvcnlTZWxlY3Rpb25Nb2RlO1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBpbml0aWFsRGlzcGxheVNuYXBzaG90OiBEaXJlY3RvcnlEaXNwbGF5TW9kZTtcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgb3B0aW9uczogRGlyZWN0b3J5U2VsZWN0aW9uT3B0aW9uczsgLy8gT3B0aW9ucyBmb3IgdGhlIG1vZGFsXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IG9rQ2FsbGJhY2s6IChyZXN1bHQ6IERpcmVjdG9yeVNlbGVjdGlvblJlc3VsdCB8IG51bGwpID0+IHZvaWQ7XHJcblxyXG4gICAgLy8gQ3VycmVudCBzdGF0ZSBiZWluZyBtb2RpZmllZCB3aXRoaW4gdGhlIG1vZGFsXHJcbiAgICBwcml2YXRlIGN1cnJlbnRGb2xkZXJzOiBTZXQ8c3RyaW5nPjtcclxuICAgIHByaXZhdGUgY3VycmVudEZpbGVzOiBTZXQ8c3RyaW5nPjtcclxuICAgIHByaXZhdGUgY3VycmVudE1vZGU6IERpcmVjdG9yeVNlbGVjdGlvbk1vZGU7XHJcbiAgICBwcml2YXRlIGN1cnJlbnREaXNwbGF5OiBEaXJlY3RvcnlEaXNwbGF5TW9kZTtcclxuICAgIHByaXZhdGUgaW5jbHVkZUV4Y2x1ZGVTZWxlY3RhYmxlOiBib29sZWFuO1xyXG4gICAgcHJpdmF0ZSBzaG93RmlsZXM6IGJvb2xlYW4gPSBmYWxzZTsgLy8gU3RhdGUgZm9yIHNob3dpbmcgZmlsZXMgaW4gdGhlIHRyZWVcclxuXHJcbiAgICAvLyBVSSBFbGVtZW50c1xyXG4gICAgcHJpdmF0ZSB0cmVlUm9vdEVsZW1lbnQ6IEhUTUxFbGVtZW50OyAvLyBDb250YWluZXIgZm9yIHRoZSB0cmVlIHZpZXdcclxuICAgIHByaXZhdGUgdHJlZU5vZGVzOiBNYXA8c3RyaW5nLCBUcmVlTm9kZT4gPSBuZXcgTWFwKCk7IC8vIE1hcCBwYXRoIHRvIG5vZGUgaW5mbyBmb3IgcXVpY2sgYWNjZXNzXHJcbiAgICBwcml2YXRlIG1vZGVEcm9wZG93bjogU2V0dGluZyB8IG51bGwgPSBudWxsOyAvLyBSZWZlcmVuY2UgdG8gdXBkYXRlIGRyb3Bkb3duIG9uIHJlc2V0XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoZSBEaXJlY3RvcnlTZWxlY3Rpb25Nb2RhbC5cclxuICAgICAqIEBwYXJhbSBhcHAgLSBUaGUgT2JzaWRpYW4gQXBwIGluc3RhbmNlLlxyXG4gICAgICogQHBhcmFtIGluaXRpYWxGb2xkZXJzIC0gQXJyYXkgb2YgaW5pdGlhbGx5IHNlbGVjdGVkIGZvbGRlciBwYXRocy5cclxuICAgICAqIEBwYXJhbSBpbml0aWFsRmlsZXMgLSBBcnJheSBvZiBpbml0aWFsbHkgc2VsZWN0ZWQgZmlsZSBwYXRocy5cclxuICAgICAqIEBwYXJhbSBpbml0aWFsTW9kZSAtIFRoZSBpbml0aWFsIHNlbGVjdGlvbiBtb2RlICgnaW5jbHVkZScgb3IgJ2V4Y2x1ZGUnKS5cclxuICAgICAqIEBwYXJhbSBva0NhbGxiYWNrIC0gRnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBcIk9LXCIuIFJlY2VpdmVzIHRoZSBzZWxlY3Rpb24gcmVzdWx0LlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBhcHA6IEFwcCxcclxuICAgICAgICBpbml0aWFsRm9sZGVyczogc3RyaW5nW10sXHJcbiAgICAgICAgaW5pdGlhbEZpbGVzOiBzdHJpbmdbXSxcclxuICAgICAgICBpbml0aWFsT3B0aW9uczogRGlyZWN0b3J5U2VsZWN0aW9uT3B0aW9ucyxcclxuICAgICAgICBva0NhbGxiYWNrOiAocmVzdWx0OiBEaXJlY3RvcnlTZWxlY3Rpb25SZXN1bHQgfCBudWxsKSA9PiB2b2lkXHJcbiAgICApIHtcclxuICAgICAgICBzdXBlcihhcHApO1xyXG4gICAgICAgIC8vIFN0b3JlIGluaXRpYWwgc3RhdGUgZm9yIHJlc2V0XHJcbiAgICAgICAgdGhpcy5pbml0aWFsRm9sZGVyc1NuYXBzaG90ID0gbmV3IFNldChpbml0aWFsRm9sZGVycyk7XHJcbiAgICAgICAgdGhpcy5pbml0aWFsRmlsZXNTbmFwc2hvdCA9IG5ldyBTZXQoaW5pdGlhbEZpbGVzKTtcclxuICAgICAgICB0aGlzLmluaXRpYWxNb2RlU25hcHNob3QgPSBpbml0aWFsT3B0aW9ucy5zZWxlY3Rpb25Nb2RlO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbERpc3BsYXlTbmFwc2hvdCA9IGluaXRpYWxPcHRpb25zLmRpc3BsYXlNb2RlO1xyXG4gICAgICAgIHRoaXMuc2hvd0ZpbGVzID0gaW5pdGlhbE9wdGlvbnMuZGlzcGxheU1vZGU9PT0nZmlsZXMnIHx8IGluaXRpYWxPcHRpb25zLmRpc3BsYXlNb2RlPT09J2ZpbGUnfHwgaW5pdGlhbEZpbGVzLmxlbmd0aD4wO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGluaXRpYWxPcHRpb25zO1xyXG4gICAgICAgIHRoaXMub2tDYWxsYmFjayA9IG9rQ2FsbGJhY2s7XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgY3VycmVudCBzdGF0ZSBmcm9tIGluaXRpYWwgc3RhdGUgZm9yIGVkaXRpbmdcclxuICAgICAgICB0aGlzLnJlc2V0U2VsZWN0aW9uVG9Jbml0aWFsKCk7IC8vIFVzZSBhIG1ldGhvZCBmb3IgaW5pdGlhbGl6YXRpb24gYW5kIHJlc2V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHN0YXRlIHRvIHRoZSBpbml0aWFsIHN0YXRlIHByb3ZpZGVkIGF0IGNvbnN0cnVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZXNldFNlbGVjdGlvblRvSW5pdGlhbCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRGb2xkZXJzID0gbmV3IFNldCh0aGlzLmluaXRpYWxGb2xkZXJzU25hcHNob3QpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudEZpbGVzID0gbmV3IFNldCh0aGlzLmluaXRpYWxGaWxlc1NuYXBzaG90KTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRNb2RlID0gdGhpcy5pbml0aWFsTW9kZVNuYXBzaG90O1xyXG4gICAgICAgIC8vIE5vdGU6IHNob3dGaWxlcyBpcyBub3QgcmVzZXQgYnkgdGhpcyBhY3Rpb24sIHVzZXIgY2FuIHRvZ2dsZSBpdCBpbmRlcGVuZGVudGx5XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHN0YXRlIHRvIGVtcHR5LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlc2V0U2VsZWN0aW9uVG9FbXB0eSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRGb2xkZXJzID0gbmV3IFNldChbXSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RmlsZXMgPSBuZXcgU2V0KFtdKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRNb2RlID0gdGhpcy5pbml0aWFsTW9kZVNuYXBzaG90O1xyXG4gICAgICAgIC8vIE5vdGU6IHNob3dGaWxlcyBpcyBub3QgcmVzZXQgYnkgdGhpcyBhY3Rpb24sIHVzZXIgY2FuIHRvZ2dsZSBpdCBpbmRlcGVuZGVudGx5XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgbW9kYWwgaXMgb3BlbmVkLiBCdWlsZHMgdGhlIFVJLlxyXG4gICAgICovXHJcbiAgICBvbk9wZW4oKSB7XHJcbiAgICAgICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XHJcbiAgICAgICAgY29udGVudEVsLmVtcHR5KCk7IC8vIENsZWFyIHByZXZpb3VzIGNvbnRlbnRcclxuICAgICAgICBjb250ZW50RWwuYWRkQ2xhc3MoJ2RpcmVjdG9yeS1zZWxlY3Rpb24tbW9kYWwnKTsgXHJcblxyXG4gICAgICAgIC8vIC0tLSBNb2RhbCBUaXRsZSAtLS1cclxuICAgICAgICBpZiAodGhpcy5pbmNsdWRlRXhjbHVkZVNlbGVjdGFibGUpIHtcclxuICAgICAgICAgICAgY29udGVudEVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogdGhpcy5vcHRpb25zLnRpdGxlIHx8ICdJbmNsdWRlIG9yIEV4Y2x1ZGUgRm9sZGVycyBhbmQgRmlsZXMnIH0pOyBcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb250ZW50RWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiB0aGlzLm9wdGlvbnMudGl0bGUgfHwgYCR7dGhpcy5jdXJyZW50TW9kZSA9PT0gJ2V4Y2x1ZGUnID8gJ0V4Y2x1ZGUnIDogJ0luY2x1ZGUnfSBGb2xkZXJzIGFuZCBGaWxlc2AgfSk7IFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gLS0tIFNldHRpbmdzIENvbnRyb2xzIC0tLVxyXG4gICAgICAgIGNvbnN0IGNvbnRyb2xzRWwgPSBjb250ZW50RWwuY3JlYXRlRGl2KHsgY2xzOiAnbW9kYWwtY29udHJvbHMnIH0pO1xyXG4gICAgICAgIHRoaXMuY3JlYXRlTW9kZVNldHRpbmcoY29udHJvbHNFbCk7IC8vIENyZWF0ZSBtb2RlIGRyb3Bkb3duXHJcbiAgICAgICAgdGhpcy5jcmVhdGVTaG93RmlsZXNTZXR0aW5nKGNvbnRyb2xzRWwpOyAvLyBDcmVhdGUgZmlsZSB0b2dnbGVcclxuXHJcbiAgICAgICAgLy8gLS0tIFRyZWUgQ29udGFpbmVyIC0tLVxyXG4gICAgICAgIHRoaXMudHJlZVJvb3RFbGVtZW50ID0gY29udGVudEVsLmNyZWF0ZURpdih7IGNsczogJ3RyZWUtdmlldy1jb250YWluZXInIH0pO1xyXG4gICAgICAgIHRoaXMudHJlZVJvb3RFbGVtZW50LnN0eWxlLm1heEhlaWdodCA9ICc2MDBweCc7XHJcbiAgICAgICAgdGhpcy50cmVlUm9vdEVsZW1lbnQuc3R5bGUub3ZlcmZsb3dZID0gJ2F1dG8nO1xyXG4gICAgICAgIHRoaXMudHJlZVJvb3RFbGVtZW50LnN0eWxlLmJvcmRlciA9ICcxcHggc29saWQgdmFyKC0tYmFja2dyb3VuZC1tb2RpZmllci1ib3JkZXIpJztcclxuICAgICAgICB0aGlzLnRyZWVSb290RWxlbWVudC5zdHlsZS5wYWRkaW5nID0gJzEwcHgnO1xyXG4gICAgICAgIHRoaXMudHJlZVJvb3RFbGVtZW50LnN0eWxlLm1hcmdpblRvcCA9ICcxMHB4JztcclxuICAgICAgICB0aGlzLnRyZWVSb290RWxlbWVudC5zdHlsZS5tYXJnaW5Cb3R0b20gPSAnMTBweCc7XHJcblxyXG4gICAgICAgIC8vIC0tLSBCdWlsZCBhbmQgUmVuZGVyIFRyZWUgLS0tXHJcbiAgICAgICAgaWYgKCF0aGlzLnRyZWVOb2Rlcy5zaXplKSB7IC8vIEVuc3VyZSB0aGUgdHJlZSBpcyBvbmx5IHJlbmRlcmVkIG9uY2VcclxuICAgICAgICAgICAgdGhpcy5idWlsZEFuZFJlbmRlclRyZWUoKTsgLy8gSW5pdGlhbCByZW5kZXJpbmcgYmFzZWQgb24gY3VycmVudCBzdGF0ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gLS0tIEFjdGlvbiBCdXR0b25zIC0tLVxyXG4gICAgICAgIHRoaXMuY3JlYXRlQWN0aW9uQnV0dG9ucyhjb250ZW50RWwpOyAvLyBDcmVhdGUgT0sgYW5kIFJlc2V0IGJ1dHRvbnNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIGRyb3Bkb3duIHNldHRpbmcgZm9yIGNob29zaW5nIHRoZSBzZWxlY3Rpb24gbW9kZS5cclxuICAgICAqIEBwYXJhbSBjb250YWluZXJFbCAtIFRoZSBIVE1MIGVsZW1lbnQgdG8gYXBwZW5kIHRoZSBzZXR0aW5nIHRvLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNyZWF0ZU1vZGVTZXR0aW5nKGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVFeGNsdWRlU2VsZWN0YWJsZSkge1xyXG4gICAgICAgICAgICB0aGlzLm1vZGVEcm9wZG93biA9IG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKSAvLyBTdG9yZSByZWZlcmVuY2VcclxuICAgICAgICAgICAgICAgIC5zZXROYW1lKCdTZWxlY3Rpb24gTW9kZScpIC8vIFNldHRpbmcgTmFtZSBpbiBHZXJtYW5cclxuICAgICAgICAgICAgICAgIC5zZXREZXNjKCdDaG9vc2UgaWYgdGhlIHNlbGVjdGVkIGZpbGVzIGFuZCBmb2xkZXJzIHNob3VsZCBiZSBleGNsdWRlZCBvciBpbmNsdWRlZC4nKSBcclxuICAgICAgICAgICAgICAgIC5hZGREcm9wZG93bihkcm9wZG93biA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHJvcGRvd25cclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZE9wdGlvbignZXhjbHVkZScsICdleGNsdWRlJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZE9wdGlvbignaW5jbHVkZScsICdpbmNsdWRlJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMuY3VycmVudE1vZGUpIC8vIFNldCBpbml0aWFsIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZSh2YWx1ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNb2RlID0gdmFsdWUgYXMgJ2luY2x1ZGUnIHwgJ2V4Y2x1ZGUnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUcmVlQXBwZWFyYW5jZSgpOyAvLyBVcGRhdGUgdHJlZSB2aXN1YWxzIGJhc2VkIG9uIG5ldyBtb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgbW9kZSBkcm9wZG93biBVSSBlbGVtZW50IHRvIHJlZmxlY3QgdGhlIGN1cnJlbnRNb2RlIHN0YXRlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHVwZGF0ZU1vZGVEcm9wZG93bigpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBkcm9wZG93bkNvbXBvbmVudCA9IHRoaXMubW9kZURyb3Bkb3duPy5jb21wb25lbnRzWzBdIGFzIGFueTsgLy8gQWNjZXNzIGRyb3Bkb3duIGNvbXBvbmVudFxyXG4gICAgICAgIGlmIChkcm9wZG93bkNvbXBvbmVudCAmJiB0eXBlb2YgZHJvcGRvd25Db21wb25lbnQuc2V0VmFsdWUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgIGRyb3Bkb3duQ29tcG9uZW50LnNldFZhbHVlKHRoaXMuY3VycmVudE1vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSB0b2dnbGUgc2V0dGluZyBmb3Igc2hvd2luZy9oaWRpbmcgZmlsZXMgaW4gdGhlIHRyZWUuXHJcbiAgICAgKiBAcGFyYW0gY29udGFpbmVyRWwgLSBUaGUgSFRNTCBlbGVtZW50IHRvIGFwcGVuZCB0aGUgc2V0dGluZyB0by5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjcmVhdGVTaG93RmlsZXNTZXR0aW5nKGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMub3B0aW9uU2hvd0ZpbGVzKSB7XHJcbiAgICAgICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAgICAgLnNldE5hbWUoJ1Nob3cgRmlsZXMnKVxyXG4gICAgICAgICAgICAgICAgLnNldERlc2MoJ1Nob3cgRmlsZXMgd2l0aGluIHRoZSBkaXJlY3RvcnkgdHJlZS4nKVxyXG4gICAgICAgICAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5zaG93RmlsZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZSh2YWx1ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dGaWxlcyA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZEFuZFJlbmRlclRyZWUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSBcIk9LXCIgYW5kIFwiUmVzZXRcIiBidXR0b25zLlxyXG4gICAgICogQHBhcmFtIGNvbnRhaW5lckVsIC0gVGhlIEhUTUwgZWxlbWVudCB0byBhcHBlbmQgdGhlIGJ1dHRvbnMgdG8uXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY3JlYXRlQWN0aW9uQnV0dG9ucyhjb250YWluZXJFbDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBidXR0b25zRWwgPSBjb250YWluZXJFbC5jcmVhdGVEaXYoeyBjbHM6ICdtb2RhbC1idXR0b25zJyB9KTtcclxuICAgICAgICBidXR0b25zRWwuc3R5bGUubWFyZ2luVG9wID0gJzE1cHgnO1xyXG4gICAgICAgIGJ1dHRvbnNFbC5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnOyAvLyBVc2UgZmxleCBmb3IgYWxpZ25tZW50XHJcbiAgICAgICAgYnV0dG9uc0VsLnN0eWxlLmp1c3RpZnlDb250ZW50ID0gJ2ZsZXgtZW5kJzsgLy8gQWxpZ24gYnV0dG9ucyB0byB0aGUgcmlnaHRcclxuICAgICAgICBidXR0b25zRWwuc3R5bGUuZ2FwID0gJzEwcHgnOyAvLyBTcGFjZSBiZXR3ZWVuIGJ1dHRvbnNcclxuXHJcbiAgICAgICAgLy8gUmVzZXQgQnV0dG9uIChVbmRvIFx1MjFBQVx1RkUwRilcclxuICAgICAgICBjb25zdCByZXNldEJ1dHRvbiA9IGJ1dHRvbnNFbC5jcmVhdGVFbCgnYnV0dG9uJyk7XHJcbiAgICAgICAgLy8gVXNlIE9ic2lkaWFuJ3Mgc2V0SWNvbiBmb3IgY29uc2lzdGVuY3ksIG9yIHVzZSB0ZXh0XHJcbiAgICAgICAgc2V0SWNvbihyZXNldEJ1dHRvbiwgJ3Jlc2V0Jyk7IC8vIFVzZSBhIHN1aXRhYmxlIGljb24gbGlrZSAncmVzZXQnIG9yICd1bmRvJ1xyXG4gICAgICAgIHJlc2V0QnV0dG9uLmFyaWFMYWJlbCA9ICdSZXNldCBzZWxlY3Rpb24nOyAvLyBBY2Nlc3NpYmlsaXR5XHJcbiAgICAgICAgcmVzZXRCdXR0b24ub25jbGljayA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZXNldFNlbGVjdGlvblRvSW5pdGlhbCgpOyAvLyBSZXNldCBpbnRlcm5hbCBzdGF0ZVxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1vZGVEcm9wZG93bigpOyAvLyBVcGRhdGUgZHJvcGRvd24gVUlcclxuICAgICAgICAgICAgdGhpcy5idWlsZEFuZFJlbmRlclRyZWUoKTsgLy8gUmUtcmVuZGVyIHRyZWUgd2l0aCByZXNldCBzdGF0ZVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIENsZWFyIEJ1dHRvbiAoQ2xlYXIgXHVEODNEXHVERUFFKVxyXG4gICAgICAgIGNvbnN0IGVtcHR5QnV0dG9uID0gYnV0dG9uc0VsLmNyZWF0ZUVsKCdidXR0b24nKTtcclxuICAgICAgICAvLyBVc2UgT2JzaWRpYW4ncyBzZXRJY29uIGZvciBjb25zaXN0ZW5jeSwgb3IgdXNlIHRleHRcclxuICAgICAgICBzZXRJY29uKGVtcHR5QnV0dG9uLCAnZXJhc2VyJyk7IC8vIFVzZSBhIHN1aXRhYmxlIGljb24gbGlrZSAncmVzZXQnIG9yICd1bmRvJ1xyXG4gICAgICAgIGVtcHR5QnV0dG9uLmFyaWFMYWJlbCA9ICdDbGVhciBzZWxlY3Rpb24nOyAvLyBBY2Nlc3NpYmlsaXR5XHJcbiAgICAgICAgZW1wdHlCdXR0b24ub25jbGljayA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZXNldFNlbGVjdGlvblRvRW1wdHkoKTsgLy8gQ2xlYXIgc3RhdGVcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVNb2RlRHJvcGRvd24oKTsgLy8gVXBkYXRlIGRyb3Bkb3duIFVJXHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRBbmRSZW5kZXJUcmVlKCk7IC8vIFJlLXJlbmRlciB0cmVlIHdpdGggcmVzZXQgc3RhdGVcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBjYW5jZWwgQnV0dG9uXHJcbiAgICAgICAgY29uc3QgY2FuY2VsQnV0dG9uID0gYnV0dG9uc0VsLmNyZWF0ZUVsKCdidXR0b24nLCB7IHRleHQ6ICdDYW5jZWwnIH0pO1xyXG4gICAgICAgIGNhbmNlbEJ1dHRvbi5hcmlhTGFiZWwgPSAnY2xvc2UgYW5kIGRpc2NhcmQgY2hhbmdlcyc7IC8vIEFjY2Vzc2liaWxpdHlcclxuICAgICAgICBjYW5jZWxCdXR0b24ub25jbGljayA9ICgpID0+IHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJDYW5jZWwgQ2xpY2tlZCAtIFJldHVybmluZ1wiKTsgLy8gRGVidWcgbG9nXHJcbiAgICAgICAgICAgIHRoaXMub2tDYWxsYmFjayggbnVsbCApOyAvLyBQYXNzIHRoZSBmaW5hbCBzZWxlY3Rpb24gYmFja1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gT0sgQnV0dG9uXHJcbiAgICAgICAgY29uc3Qgb2tCdXR0b24gPSBidXR0b25zRWwuY3JlYXRlRWwoJ2J1dHRvbicsIHsgdGV4dDogJ09LJywgY2xzOiAnbW9kLWN0YScgfSk7XHJcbiAgICAgICAgb2tCdXR0b24uYXJpYUxhYmVsID0gJ2Nsb3NlIGFuZCBzYXZlIGNoYW5nZXMnOyAvLyBBY2Nlc3NpYmlsaXR5XHJcbiAgICAgICAgb2tCdXR0b24ub25jbGljayA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ1aWxkcyB0aGUgbG9naWNhbCB0cmVlIHN0cnVjdHVyZSBkYXRhIGZyb20gdGhlIHZhdWx0J3MgZmlsZXMgYW5kIGZvbGRlcnMuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgcm9vdCBub2RlIG9mIHRoZSB0cmVlIHN0cnVjdHVyZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBidWlsZFRyZWVEYXRhKCk6IFRyZWVOb2RlIHtcclxuICAgICAgICAvLyBDcmVhdGUgYSB2aXJ0dWFsIHJvb3Qgbm9kZSByZXByZXNlbnRpbmcgdGhlIHZhdWx0XHJcbiAgICAgICAgY29uc3QgdmF1bHRSb290Tm9kZTogVHJlZU5vZGUgPSB7XHJcbiAgICAgICAgICAgIHBhdGg6ICcvJywgLy8gUm9vdCBmb2xkZXIgcGF0aFxyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLmFwcC52YXVsdC5nZXROYW1lKCkgfHwgJ1ZhdWx0JywgLy8gVXNlIHZhdWx0IG5hbWUgb3IgZGVmYXVsdFxyXG4gICAgICAgICAgICB0eXBlOiAnZm9sZGVyJyxcclxuICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxyXG4gICAgICAgICAgICAvLyBQbGFjZWhvbGRlciBlbGVtZW50cywgd2lsbCBiZSBhc3NpZ25lZCBkdXJpbmcgcmVuZGVyaW5nXHJcbiAgICAgICAgICAgIGVsZW1lbnQ6IG51bGwhLFxyXG4gICAgICAgICAgICBjaGVja2JveDogbnVsbCEsXHJcbiAgICAgICAgICAgIGxhYmVsOiBudWxsISxcclxuICAgICAgICAgICAgY29udGFpbmVyOiBudWxsISxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBmb2xkZXJOb2RlcyA9IG5ldyBNYXA8c3RyaW5nLCBUcmVlTm9kZT4oKTtcclxuICAgICAgICBmb2xkZXJOb2Rlcy5zZXQoJy8nLCB2YXVsdFJvb3ROb2RlKTsgLy8gQWRkIHJvb3QgdG8gdGhlIG1hcFxyXG5cclxuICAgICAgICAvLyBVc2UgZ2V0RmlsZXMoKSB0byByZXRyaWV2ZSBhbGwgVEZpbGUgb2JqZWN0cyAoTWFya2Rvd24sIGltYWdlcywgcGRmLCBldGMuKVxyXG4gICAgICAgIGNvbnN0IGFsbEZpbGVzID0gdGhpcy5hcHAudmF1bHQuZ2V0RmlsZXMoKTtcclxuXHJcbiAgICAgICAgLy8gLS0tIFN0ZXAgMTogQ3JlYXRlIGFsbCBmb2xkZXIgbm9kZXMgYmFzZWQgb24gZmlsZSBwYXJlbnQgcGF0aHMgLS0tXHJcbiAgICAgICAgYWxsRmlsZXMuZm9yRWFjaChmaWxlID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGFyZW50Rm9sZGVyID0gZmlsZS5wYXJlbnQ7XHJcbiAgICAgICAgICAgIGlmICghcGFyZW50Rm9sZGVyKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBsZXQgY3VycmVudFBhdGggPSAnJztcclxuICAgICAgICAgICAgY29uc3QgcGF0aFBhcnRzID0gcGFyZW50Rm9sZGVyLnBhdGguc3BsaXQoJy8nKS5maWx0ZXIocCA9PiBwLmxlbmd0aCA+IDApO1xyXG5cclxuICAgICAgICAgICAgbGV0IHBhcmVudE5vZGUgPSB2YXVsdFJvb3ROb2RlOyAvLyBTdGFydCBmcm9tIHZhdWx0IHJvb3RcclxuICAgICAgICAgICAgcGF0aFBhcnRzLmZvckVhY2gocGFydCA9PiB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UGF0aCA9IGN1cnJlbnRQYXRoID09PSAnLycgPyBwYXJ0IDogYCR7Y3VycmVudFBhdGh9LyR7cGFydH1gO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmb2xkZXJOb2Rlcy5oYXMoY3VycmVudFBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Rm9sZGVyTm9kZTogVHJlZU5vZGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN1cnJlbnRQYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBwYXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZm9sZGVyJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBudWxsISxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tib3g6IG51bGwhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogbnVsbCEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogbnVsbCEsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBmb2xkZXJOb2Rlcy5zZXQoY3VycmVudFBhdGgsIG5ld0ZvbGRlck5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50Tm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmNoaWxkcmVuID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuY2hpbGRyZW4hLnB1c2gobmV3Rm9sZGVyTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZSA9IG5ld0ZvbGRlck5vZGU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBmb2xkZXJOb2Rlcy5nZXQoY3VycmVudFBhdGgpITtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIC0tLSBTdGVwIDI6IEFkZCBmaWxlIG5vZGVzIGlmICdzaG93RmlsZXMnIGlzIGVuYWJsZWQgLS0tXHJcbiAgICAgICAgaWYgKHRoaXMuc2hvd0ZpbGVzKSB7XHJcbiAgICAgICAgICAgIGFsbEZpbGVzLmZvckVhY2goZmlsZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRGb2xkZXIgPSBmaWxlLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIGlmICghcGFyZW50Rm9sZGVyKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IFwiL1wiICsgcGFyZW50Rm9sZGVyLnBhdGg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gZm9sZGVyTm9kZXMuZ2V0KHBhcmVudFBhdGgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVOb2RlOiBUcmVlTm9kZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBmaWxlLnBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZmlsZS5uYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmaWxlJyxcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBudWxsISxcclxuICAgICAgICAgICAgICAgICAgICBjaGVja2JveDogbnVsbCEsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IG51bGwhLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogbnVsbCEsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnROb2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuY2hpbGRyZW4gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5jaGlsZHJlbiEucHVzaChmaWxlTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gLS0tIFN0ZXAgMzogU29ydCBjaGlsZHJlbiBhbHBoYWJldGljYWxseSAoZm9sZGVycyBmaXJzdCwgdGhlbiBmaWxlcykgLS0tXHJcbiAgICAgICAgY29uc3Qgc29ydE5vZGVzID0gKGE6IFRyZWVOb2RlLCBiOiBUcmVlTm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoYS50eXBlID09PSAnZm9sZGVyJyAmJiBiLnR5cGUgPT09ICdmaWxlJykgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICBpZiAoYS50eXBlID09PSAnZmlsZScgJiYgYi50eXBlID09PSAnZm9sZGVyJykgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIHJldHVybiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGZvbGRlck5vZGVzLmZvckVhY2gobm9kZSA9PiBub2RlLmNoaWxkcmVuPy5zb3J0KHNvcnROb2RlcykpO1xyXG5cclxuICAgICAgICByZXR1cm4gdmF1bHRSb290Tm9kZTsgLy8gUmV0dXJuIHRoZSBwb3B1bGF0ZWQgcm9vdCBub2RlXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyB0aGUgZW50aXJlIHRyZWUgc3RydWN0dXJlIGluIHRoZSBET00gYmFzZWQgb24gdGhlIHRyZWUgZGF0YS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZW5kZXJUcmVlKCkge1xyXG4gICAgICAgICB0aGlzLnRyZWVSb290RWxlbWVudC5lbXB0eSgpOyAvLyBDbGVhciBleGlzdGluZyBET00gZWxlbWVudHNcclxuICAgICAgICAgdGhpcy50cmVlTm9kZXMuY2xlYXIoKTsgLy8gQ2xlYXIgdGhlIG5vZGUgbWFwXHJcblxyXG4gICAgICAgICBjb25zdCB0cmVlRGF0YSA9IHRoaXMuYnVpbGRUcmVlRGF0YSgpOyAvLyBHZXQgdGhlIHN0cnVjdHVyZWQgZGF0YVxyXG5cclxuICAgICAgICAgLy8gQ3JlYXRlIHRoZSB0b3AtbGV2ZWwgbGlzdCBmb3IgdGhlIHZhdWx0IGNvbnRlbnRzXHJcbiAgICAgICAgIGNvbnN0IHJvb3RVbCA9IHRoaXMudHJlZVJvb3RFbGVtZW50LmNyZWF0ZUVsKCd1bCcpO1xyXG4gICAgICAgICByb290VWwuYWRkQ2xhc3MoJ3RyZWUtcm9vdC11bCcpO1xyXG4gICAgICAgICByb290VWwuc3R5bGUubGlzdFN0eWxlID0gJ25vbmUnO1xyXG4gICAgICAgICByb290VWwuc3R5bGUucGFkZGluZ0xlZnQgPSAnMCc7IC8vIFJlbW92ZSBkZWZhdWx0IGxpc3QgaW5kZW50YXRpb25cclxuXHJcbiAgICAgICAgIC8vIFJlbmRlciB0aGUgcm9vdCBmb2xkZXIgaXRzZWxmXHJcbiAgICAgICAgIC8vdGhpcy5yZW5kZXJUcmVlTm9kZSh0cmVlRGF0YSwgcm9vdFVsLCAwLCB0aGlzLmN1cnJlbnRNb2RlID09PSAnaW5jbHVkZScgPyB0aGlzLmN1cnJlbnRGb2xkZXJzIDogdGhpcy5jdXJyZW50RmlsZXMpO1xyXG4gICAgICAgICB0aGlzLnJlbmRlclRyZWVOb2RlKHRyZWVEYXRhLCByb290VWwsIDAsIHRoaXMuY3VycmVudEZvbGRlcnMsIHRoaXMuY3VycmVudEZpbGVzKTsgLy9UT0RPOiBleHBhbmQgdGhpcyB0byBpbmNsdWRlIGZpbGVzIGFzIHdlbGxcclxuXHJcbiAgICAgICAgIC8vIFJlbmRlciBjaGlsZHJlbiBvZiB0aGUgcm9vdCBmb2xkZXJcclxuICAgICAgICAgdHJlZURhdGEuY2hpbGRyZW4/LmZvckVhY2goY2hpbGROb2RlID0+IHtcclxuICAgICAgICAgICAgIC8vdGhpcy5yZW5kZXJUcmVlTm9kZShjaGlsZE5vZGUsIHJvb3RVbCwgMSwgdGhpcy5jdXJyZW50TW9kZSA9PT0gJ2luY2x1ZGUnID8gdGhpcy5jdXJyZW50Rm9sZGVycyA6IHRoaXMuY3VycmVudEZpbGVzKTsgLy8gU3RhcnQgcmVuZGVyaW5nIGF0IGxldmVsIDFcclxuICAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWN1cnNpdmVseSByZW5kZXJzIGEgc2luZ2xlIHRyZWUgbm9kZSBhbmQgaXRzIGNoaWxkcmVuIGluIHRoZSBET00uXHJcbiAgICAgKiBAcGFyYW0gbm9kZSAtIFRoZSBUcmVlTm9kZSBkYXRhIHRvIHJlbmRlci5cclxuICAgICAqIEBwYXJhbSBwYXJlbnRFbGVtZW50IC0gVGhlIEhUTUwgYHVsYCBlbGVtZW50IHRvIGFwcGVuZCB0aGlzIG5vZGUncyBgbGlgIHRvLlxyXG4gICAgICogQHBhcmFtIGxldmVsIC0gVGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVuZGVyVHJlZU5vZGUobm9kZTogVHJlZU5vZGUsIHBhcmVudEVsZW1lbnQ6IEhUTUxFbGVtZW50LCBsZXZlbDogbnVtYmVyLCBzZWxlY3RlZFBhdGhzOiBTZXQ8c3RyaW5nPiwgc2VsZWN0ZWRmaWxlczogU2V0PHN0cmluZz4pIHtcclxuICAgICAgICBjb25zdCBsaSA9IHBhcmVudEVsZW1lbnQuY3JlYXRlRWwoJ2xpJyk7XHJcbiAgICAgICAgbGkuc3R5bGUubWFyZ2luTGVmdCA9IGAke2xldmVsICogMjB9cHhgOyAvLyBBcHBseSBpbmRlbnRhdGlvbiBiYXNlZCBvbiBsZXZlbFxyXG4gICAgICAgIGxpLmFkZENsYXNzKGB0cmVlLW5vZGUtJHtub2RlLnR5cGV9YCk7IC8vIEFkZCBjbGFzcyBmb3IgdHlwZSAoZm9sZGVyL2ZpbGUpXHJcblxyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGxpLmNyZWF0ZURpdih7IGNsczogJ3RyZWUtbm9kZS1jb250YWluZXInIH0pO1xyXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xyXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5hbGlnbkl0ZW1zID0gJ2NlbnRlcic7XHJcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLnBhZGRpbmcgPSAnMnB4IDAnOyAvLyBBZGQgc29tZSB2ZXJ0aWNhbCBwYWRkaW5nXHJcblxyXG4gICAgICAgIC8vIC0tLSBUb2dnbGUgQnV0dG9uIGZvciBGb2xkZXJzIC0tLVxyXG4gICAgICAgIGxldCB0b2dnbGVCdXR0b246IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgbGV0IGlzQ29sbGFwc2VkID0gdHJ1ZTsgLy8gRGVmYXVsdCBzdGF0ZSBpcyBjb2xsYXBzZWRcclxuXHJcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2ZvbGRlcicpIHtcclxuICAgICAgICAgICAgdG9nZ2xlQnV0dG9uID0gY29udGFpbmVyLmNyZWF0ZVNwYW4oeyBjbHM6ICd0cmVlLXRvZ2dsZS1idXR0b24nIH0pO1xyXG4gICAgICAgICAgICB0b2dnbGVCdXR0b24udGV4dENvbnRlbnQgPSAnXHUyNUI2JzsgLy8gUmlnaHQtcG9pbnRpbmcgdHJpYW5nbGVcclxuICAgICAgICAgICAgdG9nZ2xlQnV0dG9uLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcclxuICAgICAgICAgICAgdG9nZ2xlQnV0dG9uLnN0eWxlLm1hcmdpblJpZ2h0ID0gJzVweCc7XHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGZvbGRlciBvciBhbnkgb2YgaXRzIGNoaWxkcmVuIGFyZSBzZWxlY3RlZFxyXG4gICAgICAgICAgICBjb25zdCBzaG91bGRFeHBhbmQgPSB0aGlzLnNob3VsZEV4cGFuZEZvbGRlcihub2RlLCBzZWxlY3RlZFBhdGhzLCBzZWxlY3RlZGZpbGVzKTtcclxuICAgICAgICAgICAgaWYgKHNob3VsZEV4cGFuZCkge1xyXG4gICAgICAgICAgICAgICAgaXNDb2xsYXBzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdG9nZ2xlQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpc0NvbGxhcHNlZCA9ICFpc0NvbGxhcHNlZDtcclxuICAgICAgICAgICAgICAgIGlmICh0b2dnbGVCdXR0b24pIHRvZ2dsZUJ1dHRvbi50ZXh0Q29udGVudCA9IGlzQ29sbGFwc2VkID8gJ1x1MjVCNicgOiAnXHUyNUJDJzsgLy8gVXBkYXRlIHRyaWFuZ2xlIGRpcmVjdGlvblxyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuVWwpIGNoaWxkcmVuVWwuc3R5bGUuZGlzcGxheSA9IGlzQ29sbGFwc2VkID8gJ25vbmUnIDogJ2Jsb2NrJzsgLy8gU2hvdy9oaWRlIGNoaWxkcmVuXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAtLS0gQ2hlY2tib3ggLS0tXHJcbiAgICAgICAgY29uc3QgY2hlY2tib3ggPSBjb250YWluZXIuY3JlYXRlRWwoJ2lucHV0JywgeyB0eXBlOiAnY2hlY2tib3gnIH0pO1xyXG4gICAgICAgIGNoZWNrYm94LmlkID0gYHRyZWUtY2ItJHtub2RlLnBhdGgucmVwbGFjZSgvW15hLXpBLVowLTldL2csICctJyl9YDsgLy8gQ3JlYXRlIGEgc2FmZSBJRFxyXG4gICAgICAgIGNoZWNrYm94LmRhdGFzZXQucGF0aCA9IG5vZGUucGF0aDsgLy8gU3RvcmUgcGF0aCBpbiBkYXRhIGF0dHJpYnV0ZVxyXG4gICAgICAgIGNoZWNrYm94LmRhdGFzZXQudHlwZSA9IG5vZGUudHlwZTsgLy8gU3RvcmUgdHlwZVxyXG5cclxuICAgICAgICAvLyAtLS0gTGFiZWwgLS0tXHJcbiAgICAgICAgY29uc3QgbGFiZWwgPSBjb250YWluZXIuY3JlYXRlRWwoJ2xhYmVsJyk7XHJcbiAgICAgICAgbGFiZWwudGV4dENvbnRlbnQgPSBgJHtub2RlLnR5cGUgPT09ICdmb2xkZXInID8gJ1x1RDgzRFx1RENDMScgOiAnXHVEODNEXHVEQ0M0J30gJHtub2RlLm5hbWV9YDtcclxuICAgICAgICAvLyBsYWJlbC50ZXh0Q29udGVudCA9IG5vZGUubmFtZTtcclxuICAgICAgICBsYWJlbC5odG1sRm9yID0gY2hlY2tib3guaWQ7IC8vIExpbmsgbGFiZWwgdG8gY2hlY2tib3hcclxuICAgICAgICBsYWJlbC5zdHlsZS5tYXJnaW5MZWZ0ID0gJzVweCc7XHJcbiAgICAgICAgbGFiZWwuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xyXG4gICAgICAgIGxhYmVsLnRpdGxlID0gbm9kZS5wYXRoOyAvLyBTaG93IGZ1bGwgcGF0aCBvbiBob3ZlclxyXG5cclxuICAgICAgICAvLyAtLS0gU3RvcmUgcmVmZXJlbmNlcyBpbiB0aGUgbm9kZSBvYmplY3QgYW5kIG1hcCAtLS1cclxuICAgICAgICBub2RlLmVsZW1lbnQgPSBsaTtcclxuICAgICAgICBub2RlLmNoZWNrYm94ID0gY2hlY2tib3g7XHJcbiAgICAgICAgbm9kZS5sYWJlbCA9IGxhYmVsO1xyXG4gICAgICAgIG5vZGUuY29udGFpbmVyID0gY29udGFpbmVyOyAvLyBTdG9yZSBjb250YWluZXIgcmVmZXJlbmNlXHJcbiAgICAgICAgdGhpcy50cmVlTm9kZXMuc2V0KG5vZGUucGF0aCwgbm9kZSk7XHJcblxyXG4gICAgICAgIC8vIC0tLSBTZXQgaW5pdGlhbCBjaGVja2VkIHN0YXRlIGJhc2VkIG9uIGN1cnJlbnQgc2VsZWN0aW9uIC0tLVxyXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdmb2xkZXInKSB7XHJcbiAgICAgICAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSB0aGlzLmN1cnJlbnRGb2xkZXJzLmhhcyhub2RlLnBhdGgpO1xyXG4gICAgICAgIH0gZWxzZSB7IC8vIGZpbGVcclxuICAgICAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9IHRoaXMuY3VycmVudEZpbGVzLmhhcyhub2RlLnBhdGgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gLS0tIEFkZCBldmVudCBsaXN0ZW5lciBmb3IgY2hlY2tib3ggY2hhbmdlcyAtLS1cclxuICAgICAgICBjaGVja2JveC5vbmNoYW5nZSA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICAgICAgY29uc3QgcGF0aCA9IHRhcmdldC5kYXRhc2V0LnBhdGghO1xyXG4gICAgICAgICAgICBjb25zdCB0eXBlID0gdGFyZ2V0LmRhdGFzZXQudHlwZSBhcyAnZm9sZGVyJyB8ICdmaWxlJztcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgY3VycmVudCBzZWxlY3Rpb24gc2V0c1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0LmNoZWNrZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnZm9sZGVyJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXNwbGF5TW9kZSA9PT0gJ2ZvbGRlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Rm9sZGVycy5jbGVhcigpOyAvLyBDbGVhciBwcmV2aW91cyBzZWxlY3Rpb24gaWYgb25seSBvbmUgZm9sZGVyIGNhbiBiZSBzZWxlY3RlZFxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Rm9sZGVycy5hZGQocGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzcGxheU1vZGUgPT09ICdmaWxlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRGaWxlcy5jbGVhcigpOyAvLyBDbGVhciBwcmV2aW91cyBzZWxlY3Rpb24gaWYgb25seSBvbmUgZmlsZSBjYW4gYmUgc2VsZWN0ZWRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RmlsZXMuYWRkKHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdmb2xkZXInKSB0aGlzLmN1cnJlbnRGb2xkZXJzLmRlbGV0ZShwYXRoKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgdGhpcy5jdXJyZW50RmlsZXMuZGVsZXRlKHBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgdmlzdWFsIHN0YXRlIG9mIHRoZSBlbnRpcmUgdHJlZSBhZnRlciBhIGNoYW5nZVxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRyZWVBcHBlYXJhbmNlKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gLS0tIFJlbmRlciBjaGlsZHJlbiByZWN1cnNpdmVseSBpZiBpdCdzIGEgZm9sZGVyIC0tLVxyXG4gICAgICAgIGxldCBjaGlsZHJlblVsOiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsO1xyXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdmb2xkZXInICYmIG5vZGUuY2hpbGRyZW4gJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuVWwgPSBsaS5jcmVhdGVFbCgndWwnKTtcclxuICAgICAgICAgICAgY2hpbGRyZW5VbC5zdHlsZS5saXN0U3R5bGUgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuVWwuc3R5bGUucGFkZGluZ0xlZnQgPSAnMCc7IC8vIFJlc2V0IHBhZGRpbmcgZm9yIG5lc3RlZCBsaXN0XHJcbiAgICAgICAgICAgIGNoaWxkcmVuVWwuc3R5bGUubWFyZ2luTGVmdCA9ICcwJzsgLy8gUHJldmVudCBkb3VibGUgaW5kZW50YXRpb24gZnJvbSBkZWZhdWx0IFVMIHN0eWxlc1xyXG4gICAgICAgICAgICBjaGlsZHJlblVsLnN0eWxlLmRpc3BsYXkgPSBpc0NvbGxhcHNlZCA/ICdub25lJyA6ICdibG9jayc7IC8vIFNob3cvaGlkZSBjaGlsZHJlbiBiYXNlZCBvbiBpbml0aWFsIHN0YXRlXHJcblxyXG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gdGhpcy5yZW5kZXJUcmVlTm9kZShjaGlsZCwgY2hpbGRyZW5VbCEsIGxldmVsICsgMSwgc2VsZWN0ZWRQYXRocywgc2VsZWN0ZWRmaWxlcykpOyAvLyBJbmNyZWFzZSBsZXZlbCBmb3IgY2hpbGRyZW5cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGVscGVyIG1ldGhvZCB0byBkZXRlcm1pbmUgaWYgYSBmb2xkZXIgc2hvdWxkIGJlIGV4cGFuZGVkXHJcbiAgICBwcml2YXRlIHNob3VsZEV4cGFuZEZvbGRlcihub2RlOiBUcmVlTm9kZSwgc2VsZWN0ZWRQYXRoczogU2V0PHN0cmluZz4sIHNlbGVjdGVkRmlsZXM6IFNldDxzdHJpbmc+KTogYm9vbGVhbiB7XHJcbiAgICAgICAgaWYgKHNlbGVjdGVkUGF0aHMuaGFzKG5vZGUucGF0aCkgfHwgc2VsZWN0ZWRGaWxlcy5oYXMobm9kZS5wYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gVGhlIGZvbGRlciBpdHNlbGYgaXMgc2VsZWN0ZWRcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkRXhwYW5kRm9sZGVyKGNoaWxkLCBzZWxlY3RlZFBhdGhzLCBzZWxlY3RlZEZpbGVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBBIGNoaWxkIGlzIHNlbGVjdGVkXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gTmVpdGhlciB0aGUgZm9sZGVyIG5vciBpdHMgY2hpbGRyZW4gYXJlIHNlbGVjdGVkXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgdmlzdWFsIGFwcGVhcmFuY2UgKGVuYWJsZWQvZGlzYWJsZWQvc3R5bGluZykgb2YgYWxsIG5vZGVzXHJcbiAgICAgKiBpbiB0aGUgdHJlZSBiYXNlZCBvbiB0aGUgY3VycmVudCBtb2RlIGFuZCBzZWxlY3Rpb25zLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHVwZGF0ZVRyZWVBcHBlYXJhbmNlKCkge1xyXG4gICAgICAgIHRoaXMudHJlZU5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcclxuICAgICAgICAgICAgbGV0IGlzRGlzYWJsZWQgPSBmYWxzZTsgLy8gU2hvdWxkIHRoZSBub2RlIGFwcGVhciBkaXNhYmxlZCAoZ3JleWVkIG91dCk/XHJcbiAgICAgICAgICAgIGxldCBpc0VmZmVjdGl2ZWx5SW5jbHVkZWQgPSBmYWxzZTsgLy8gSXMgdGhlIG5vZGUgcGFydCBvZiB0aGUgJ2FjdGl2ZScgc2V0IGluIGluY2x1ZGUgbW9kZT9cclxuICAgICAgICAgICAgbGV0IGlzRWZmZWN0aXZlbHlFeGNsdWRlZCA9IGZhbHNlOyAvLyBJcyB0aGUgbm9kZSBwYXJ0IG9mIHRoZSAnaW5hY3RpdmUnIHNldCBpbiBleGNsdWRlIG1vZGU/XHJcblxyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgYW4gYW5jZXN0b3IgRk9MREVSIG9mIHRoaXMgbm9kZSBpcyBzZWxlY3RlZFxyXG4gICAgICAgICAgICBsZXQgYW5jZXN0b3JGb2xkZXJTZWxlY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudFBhdGggPSBub2RlLnBhdGg7XHJcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50UGF0aCAhPT0gJy8nKSB7XHJcbiAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IGN1cnJlbnRQYXRoLnN1YnN0cmluZygwLCBjdXJyZW50UGF0aC5sYXN0SW5kZXhPZignLycpKSB8fCAnLyc7XHJcbiAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudEZvbGRlcnMuaGFzKHBhcmVudFBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIGFuY2VzdG9yRm9sZGVyU2VsZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFBhdGggPT09IGN1cnJlbnRQYXRoKSBicmVhazsgLy8gU2FmZXR5IGJyZWFrIGF0IHJvb3RcclxuICAgICAgICAgICAgICAgICBjdXJyZW50UGF0aCA9IHBhcmVudFBhdGg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBub2RlIGl0c2VsZiBpcyBzZWxlY3RlZFxyXG4gICAgICAgICAgICBjb25zdCBub2RlU2VsZWN0ZWQgPSBub2RlLnR5cGUgPT09ICdmb2xkZXInXHJcbiAgICAgICAgICAgICAgICA/IHRoaXMuY3VycmVudEZvbGRlcnMuaGFzKG5vZGUucGF0aClcclxuICAgICAgICAgICAgICAgIDogdGhpcy5jdXJyZW50RmlsZXMuaGFzKG5vZGUucGF0aCk7XHJcblxyXG4gICAgICAgICAgICAvLyAtLS0gQXBwbHkgTG9naWMgQmFzZWQgb24gTW9kZSAtLS1cclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudE1vZGUgPT09ICdleGNsdWRlJykge1xyXG4gICAgICAgICAgICAgICAgLy8gRVhDTFVERSBNb2RlOiBBIG5vZGUgaXMgY29uc2lkZXJlZCBleGNsdWRlZCBpZiBpdCBPUiBhbiBhbmNlc3RvciBGT0xERVIgaXMgc2VsZWN0ZWQuXHJcbiAgICAgICAgICAgICAgICAvLyBWaXN1YWxseSBkaXNhYmxlIChncmV5IG91dCkgbm9kZXMgdGhhdCBhcmUgZXhjbHVkZWQuXHJcbiAgICAgICAgICAgICAgICBpc0VmZmVjdGl2ZWx5RXhjbHVkZWQgPSBub2RlU2VsZWN0ZWQgfHwgYW5jZXN0b3JGb2xkZXJTZWxlY3RlZDtcclxuICAgICAgICAgICAgICAgIGlzRGlzYWJsZWQgPSBpc0VmZmVjdGl2ZWx5RXhjbHVkZWQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIElOQ0xVREUgTW9kZVxyXG4gICAgICAgICAgICAgICAgLy8gSU5DTFVERSBNb2RlOiBBIG5vZGUgaXMgY29uc2lkZXJlZCBpbmNsdWRlZCBpZiBpdCBPUiBhbiBhbmNlc3RvciBGT0xERVIgaXMgc2VsZWN0ZWQuXHJcbiAgICAgICAgICAgICAgICAvLyBWaXN1YWxseSBkaXNhYmxlIChncmV5IG91dCkgbm9kZXMgdGhhdCBhcmUgTk9UIGluY2x1ZGVkLlxyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2ZvbGRlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICBpc0VmZmVjdGl2ZWx5SW5jbHVkZWQgPSBub2RlU2VsZWN0ZWQgfHwgYW5jZXN0b3JGb2xkZXJTZWxlY3RlZDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIGZpbGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBGaWxlIGluY2x1ZGVkIGlmIHNlbGVjdGVkIE9SIHBhcmVudCBwYXRoIGlzIGluY2x1ZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IG5vZGUucGF0aC5zdWJzdHJpbmcoMCwgbm9kZS5wYXRoLmxhc3RJbmRleE9mKCcvJykpIHx8ICcvJztcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRFZmZlY3RpdmVseUluY2x1ZGVkID0gdGhpcy5pc1BhdGhFZmZlY3RpdmVseUluY2x1ZGVkKHBhcmVudFBhdGgpOyAvLyBDaGVjayBwYXJlbnQgZm9sZGVyIHN0YXR1c1xyXG4gICAgICAgICAgICAgICAgICAgIGlzRWZmZWN0aXZlbHlJbmNsdWRlZCA9IG5vZGVTZWxlY3RlZCB8fCBwYXJlbnRFZmZlY3RpdmVseUluY2x1ZGVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaXNEaXNhYmxlZCA9ICFpc0VmZmVjdGl2ZWx5SW5jbHVkZWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIC0tLSBBcHBseSBWaXN1YWwgU3R5bGVzIC0tLVxyXG4gICAgICAgICAgICAvLyBDaGVja2JveCBpdHNlbGYgc2hvdWxkIGFsd2F5cyBiZSBjbGlja2FibGUgdG8gY2hhbmdlIHNlbGVjdGlvbiBzdGF0ZVxyXG4gICAgICAgICAgICBub2RlLmNoZWNrYm94LmRpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIG5vZGUuY2hlY2tib3guY2hlY2tlZCA9IG5vZGVTZWxlY3RlZDtcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGx5IHN0eWxpbmcgdG8gdGhlIGNvbnRhaW5lciAobGFiZWwsIGljb24pIGJhc2VkIG9uIGRpc2FibGVkIHN0YXRlXHJcbiAgICAgICAgICAgIGlmIChpc0Rpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLmNvbnRhaW5lci5zdHlsZS5vcGFjaXR5ID0gJzAuNSc7XHJcbiAgICAgICAgICAgICAgICBub2RlLmxhYmVsLnN0eWxlLnRleHREZWNvcmF0aW9uID0gJ2xpbmUtdGhyb3VnaCc7IC8vIE1vcmUgcHJvbWluZW50IGRpc2FibGVkIGxvb2tcclxuICAgICAgICAgICAgICAgIG5vZGUuZWxlbWVudC5hZGRDbGFzcygnaXMtZGlzYWJsZWQnKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuY29udGFpbmVyLnN0eWxlLm9wYWNpdHkgPSAnMSc7XHJcbiAgICAgICAgICAgICAgICBub2RlLmxhYmVsLnN0eWxlLnRleHREZWNvcmF0aW9uID0gJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5lbGVtZW50LnJlbW92ZUNsYXNzKCdpcy1kaXNhYmxlZCcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyAtLS0gRklYIGZvciBJbnZhbGlkQ2hhcmFjdGVyRXJyb3IgLS0tXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBjbGFzc2VzIGluZGl2aWR1YWxseVxyXG4gICAgICAgICAgICBub2RlLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnaXMtaW5jbHVkZWQnLCAnaXMtZXhjbHVkZWQnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBzcGVjaWZpYyBjbGFzc2VzIGZvciBzdHlsaW5nIGluY2x1ZGVkL2V4Y2x1ZGVkIHN0YXRlc1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50TW9kZSA9PT0gJ2luY2x1ZGUnICYmIGlzRWZmZWN0aXZlbHlJbmNsdWRlZCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5lbGVtZW50LmFkZENsYXNzKCdpcy1pbmNsdWRlZCcpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudE1vZGUgPT09ICdleGNsdWRlJyAmJiBpc0VmZmVjdGl2ZWx5RXhjbHVkZWQpIHtcclxuICAgICAgICAgICAgICAgICAvLyBBcHBseSBleGNsdWRlZCBjbGFzcyBldmVuIGlmIGl0J3MganVzdCB2aXN1YWxseSBkaXNhYmxlZFxyXG4gICAgICAgICAgICAgICAgIC8vIFRoaXMgYWxsb3dzIHNwZWNpZmljIHN0eWxpbmcgZm9yIGV4Y2x1ZGVkIGl0ZW1zIGJleW9uZCBqdXN0IGdyZXllZCBvdXRcclxuICAgICAgICAgICAgICAgIG5vZGUuZWxlbWVudC5hZGRDbGFzcygnaXMtZXhjbHVkZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiBhIGdpdmVuIHBhdGggaXMgZWZmZWN0aXZlbHkgaW5jbHVkZWRcclxuICAgICAqIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1bmRlciAnaW5jbHVkZScgbW9kZS5cclxuICAgICAqIEEgcGF0aCBpcyBpbmNsdWRlZCBpZiBpdCAoZmlsZSBvciBmb2xkZXIpIGlzIHNlbGVjdGVkLCBvciBpZiBhbnkgb2YgaXRzIGFuY2VzdG9yIEZPTERFUlMgYXJlIHNlbGVjdGVkLlxyXG4gICAgICogQHBhcmFtIHBhdGggLSBUaGUgZm9sZGVyIG9yIGZpbGUgcGF0aCB0byBjaGVjay5cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHBhdGggc2hvdWxkIGJlIGNvbnNpZGVyZWQgaW5jbHVkZWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBpc1BhdGhFZmZlY3RpdmVseUluY2x1ZGVkKHBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgICAgIC8vIFRoaXMgY2hlY2sgaXMgcHJpbWFyaWx5IGZvciAnaW5jbHVkZScgbW9kZSBsb2dpYy5cclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50TW9kZSAhPT0gJ2luY2x1ZGUnKSB7XHJcbiAgICAgICAgICAgICAvLyBJbiAnZXhjbHVkZScgbW9kZSwgY29uY2VwdHVhbGx5IGV2ZXJ5dGhpbmcgaXMgaW5jbHVkZWQgdW5sZXNzIGV4Y2x1ZGVkLlxyXG4gICAgICAgICAgICAgLy8gRm9yIGludGVybmFsIGNoZWNrcywgd2UgbWlnaHQgbmVlZCB0aGUgaW52ZXJzZSBvZiBleGNsdXNpb24uXHJcbiAgICAgICAgICAgICByZXR1cm4gIXRoaXMuaXNQYXRoRWZmZWN0aXZlbHlFeGNsdWRlZChwYXRoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBwYXRoIGl0c2VsZiBpcyBzZWxlY3RlZCAoYXBwbGllcyB0byBib3RoIGZpbGVzIGFuZCBmb2xkZXJzKVxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRGaWxlcy5oYXMocGF0aCkgfHwgdGhpcy5jdXJyZW50Rm9sZGVycy5oYXMocGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiBhbnkgYW5jZXN0b3IgRk9MREVSIGlzIHNlbGVjdGVkXHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBwYXRoO1xyXG4gICAgICAgIHdoaWxlIChjdXJyZW50ICE9PSAnLycpIHtcclxuICAgICAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IGN1cnJlbnQuc3Vic3RyaW5nKDAsIGN1cnJlbnQubGFzdEluZGV4T2YoJy8nKSkgfHwgJy8nO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50Rm9sZGVycy5oYXMocGFyZW50UGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBBbiBhbmNlc3RvciBmb2xkZXIgaXMgc2VsZWN0ZWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocGFyZW50UGF0aCA9PT0gY3VycmVudCkgYnJlYWs7IC8vIFJlYWNoZWQgcm9vdCBvciBlcnJvclxyXG4gICAgICAgICAgICBjdXJyZW50ID0gcGFyZW50UGF0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gTmVpdGhlciB0aGUgcGF0aCBub3IgYW55IGFuY2VzdG9yIGZvbGRlciBpcyBzZWxlY3RlZFxyXG4gICAgfVxyXG5cclxuICAgICAvKipcclxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgaWYgYSBnaXZlbiBwYXRoIGlzIGVmZmVjdGl2ZWx5IGV4Y2x1ZGVkXHJcbiAgICAgKiBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24gdW5kZXIgJ2V4Y2x1ZGUnIG1vZGUuXHJcbiAgICAgKiBBIHBhdGggaXMgZXhjbHVkZWQgaWYgaXQgKGZpbGUgb3IgZm9sZGVyKSBpcyBzZWxlY3RlZCwgb3IgaWYgYW55IG9mIGl0cyBhbmNlc3RvciBGT0xERVJTIGFyZSBzZWxlY3RlZC5cclxuICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIGZvbGRlciBvciBmaWxlIHBhdGggdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBwYXRoIHNob3VsZCBiZSBjb25zaWRlcmVkIGV4Y2x1ZGVkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaXNQYXRoRWZmZWN0aXZlbHlFeGNsdWRlZChwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICAgLy8gVGhpcyBjaGVjayBpcyBwcmltYXJpbHkgZm9yICdleGNsdWRlJyBtb2RlIGxvZ2ljLlxyXG4gICAgICAgICBpZiAodGhpcy5jdXJyZW50TW9kZSAhPT0gJ2V4Y2x1ZGUnKSB7XHJcbiAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgIH1cclxuXHJcbiAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBwYXRoIGl0c2VsZiBpcyBzZWxlY3RlZFxyXG4gICAgICAgICBpZiAodGhpcy5jdXJyZW50RmlsZXMuaGFzKHBhdGgpIHx8IHRoaXMuY3VycmVudEZvbGRlcnMuaGFzKHBhdGgpKSB7XHJcbiAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgfVxyXG5cclxuICAgICAgICAgLy8gQ2hlY2sgaWYgYW55IGFuY2VzdG9yIEZPTERFUiBpcyBzZWxlY3RlZFxyXG4gICAgICAgICBsZXQgY3VycmVudCA9IHBhdGg7XHJcbiAgICAgICAgIHdoaWxlIChjdXJyZW50ICE9PSAnLycpIHtcclxuICAgICAgICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBjdXJyZW50LnN1YnN0cmluZygwLCBjdXJyZW50Lmxhc3RJbmRleE9mKCcvJykpIHx8ICcvJztcclxuICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRGb2xkZXJzLmhhcyhwYXJlbnRQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBBbiBhbmNlc3RvciBmb2xkZXIgaXMgc2VsZWN0ZWRcclxuICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgIGlmIChwYXJlbnRQYXRoID09PSBjdXJyZW50KSBicmVhazsgLy8gUmVhY2hlZCByb290IG9yIGVycm9yXHJcbiAgICAgICAgICAgICBjdXJyZW50ID0gcGFyZW50UGF0aDtcclxuICAgICAgICAgfVxyXG5cclxuICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBOZWl0aGVyIHRoZSBwYXRoIG5vciBhbnkgYW5jZXN0b3IgZm9sZGVyIGlzIHNlbGVjdGVkIGZvciBleGNsdXNpb25cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21iaW5lcyBidWlsZGluZyB0aGUgdHJlZSBkYXRhLCByZW5kZXJpbmcgdGhlIERPTSwgYW5kIGFwcGx5aW5nIGluaXRpYWwgYXBwZWFyYW5jZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBidWlsZEFuZFJlbmRlclRyZWUoKSB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0J1aWxkaW5nIGFuZCByZW5kZXJpbmcgdHJlZS4uLicpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyVHJlZSgpOyAvLyBCdWlsZCBkYXRhIGFuZCByZW5kZXIgRE9NIGVsZW1lbnRzXHJcbiAgICAgICAgdGhpcy51cGRhdGVUcmVlQXBwZWFyYW5jZSgpOyAvLyBBcHBseSBzdHlsZXMgYmFzZWQgb24gY3VycmVudCBtb2RlL3NlbGVjdGlvblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBtb2RhbCBpcyBjbG9zZWQuIENsZWFucyB1cCByZXNvdXJjZXMuXHJcbiAgICAgKi9cclxuICAgIG9uQ2xvc2UoKSB7XHJcbiAgICAgICAgLy8gR2F0aGVyIHRoZSBmaW5hbCBzdGF0ZSBPTkxZIHdoZW4gT0sgaXMgY2xpY2tlZFxyXG4gICAgICAgIGNvbnN0IHJlc3VsdDogRGlyZWN0b3J5U2VsZWN0aW9uUmVzdWx0ID0ge1xyXG4gICAgICAgICAgICBmb2xkZXJzOiBBcnJheS5mcm9tKHRoaXMuY3VycmVudEZvbGRlcnMpLFxyXG4gICAgICAgICAgICBmaWxlczogQXJyYXkuZnJvbSh0aGlzLmN1cnJlbnRGaWxlcyksXHJcbiAgICAgICAgICAgIG1vZGU6IHRoaXMuY3VycmVudE1vZGUsXHJcbiAgICAgICAgICAgIGRpc3BsYXk6IHRoaXMuY3VycmVudERpc3BsYXksXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIk9LIENsaWNrZWQgLSBSZXR1cm5pbmcgUmVzdWx0OlwiLCByZXN1bHQpOyAvLyBEZWJ1ZyBsb2dcclxuICAgICAgICB0aGlzLm9rQ2FsbGJhY2socmVzdWx0KTsgLy8gUGFzcyB0aGUgZmluYWwgc2VsZWN0aW9uIGJhY2tcclxuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcclxuICAgICAgICBjb250ZW50RWwuZW1wdHkoKTsgLy8gQ2xlYXIgdGhlIG1vZGFsJ3MgY29udGVudFxyXG4gICAgICAgIHRoaXMudHJlZU5vZGVzLmNsZWFyKCk7IC8vIENsZWFyIHRoZSBub2RlIG1hcCB0byBmcmVlIG1lbW9yeVxyXG4gICAgICAgIHRoaXMubW9kZURyb3Bkb3duID0gbnVsbDsgLy8gQ2xlYXIgcmVmZXJlbmNlXHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZWFzaWx5IG9wZW4gdGhlIERpcmVjdG9yeSBTZWxlY3Rpb24gTW9kYWwuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcHAgLSBUaGUgT2JzaWRpYW4gQXBwIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gaW5pdGlhbEZvbGRlcnMgLSBBcnJheSBvZiBpbml0aWFsbHkgc2VsZWN0ZWQgZm9sZGVyIHBhdGhzLlxyXG4gKiBAcGFyYW0gaW5pdGlhbEZpbGVzIC0gQXJyYXkgb2YgaW5pdGlhbGx5IHNlbGVjdGVkIGZpbGUgcGF0aHMuXHJcbiAqIEBwYXJhbSBpbml0aWFsTW9kZSAtIFRoZSBpbml0aWFsIHNlbGVjdGlvbiBtb2RlICgnaW5jbHVkZScgb3IgJ2V4Y2x1ZGUnKS5cclxuICogQHBhcmFtIG9rQ2FsbGJhY2sgLSBGdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHVzZXIgY2xpY2tzIFwiT0tcIi4gUmVjZWl2ZXMgdGhlIHNlbGVjdGlvbiByZXN1bHQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gb3BlbkRpcmVjdG9yeVNlbGVjdGlvbk1vZGFsKFxyXG4gICAgYXBwOiBBcHAsXHJcbiAgICBpbml0aWFsRm9sZGVyczogc3RyaW5nW10sXHJcbiAgICBpbml0aWFsRmlsZXM6IHN0cmluZ1tdLFxyXG4gICAgb3B0aW9uczogRGlyZWN0b3J5U2VsZWN0aW9uT3B0aW9ucyxcclxuICAgIG9rQ2FsbGJhY2s6IChyZXN1bHQ6IERpcmVjdG9yeVNlbGVjdGlvblJlc3VsdCB8IG51bGwpID0+IHZvaWRcclxuKTogdm9pZCB7XHJcbiAgICAvLyBDcmVhdGUgYW5kIG9wZW4gdGhlIG1vZGFsIGluc3RhbmNlXHJcbiAgICBuZXcgRGlyZWN0b3J5U2VsZWN0aW9uTW9kYWwoXHJcbiAgICAgICAgYXBwLFxyXG4gICAgICAgIGluaXRpYWxGb2xkZXJzLFxyXG4gICAgICAgIGluaXRpYWxGaWxlcyxcclxuICAgICAgICBvcHRpb25zLFxyXG4gICAgICAgIG9rQ2FsbGJhY2tcclxuICAgICkub3BlbigpO1xyXG59XHJcblxyXG4vKlxyXG4vLyAtLS0gRXhhbXBsZSBVc2FnZSBpbiB5b3VyIFBsdWdpbidzIFNldHRpbmdzIFRhYiAtLS1cclxuLy8gKFBsYWNlIHRoaXMgaW4geW91ciBzZXR0aW5ncyB0YWIgZmlsZSwgZS5nLiwgc2V0dGluZ3MudHMpXHJcblxyXG5pbXBvcnQgeyBBcHAsIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcgfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCB7IG9wZW5EaXJlY3RvcnlTZWxlY3Rpb25Nb2RhbCwgRGlyZWN0b3J5U2VsZWN0aW9uUmVzdWx0IH0gZnJvbSAnLi9EaXJlY3RvcnlTZWxlY3Rpb25Nb2RhbCc7IC8vIEFkanVzdCBwYXRoIGFzIG5lZWRlZFxyXG5pbXBvcnQgWW91clBsdWdpbiBmcm9tICcuL21haW4nOyAvLyBBZGp1c3QgcGF0aCB0byB5b3VyIG1haW4gcGx1Z2luIGZpbGVcclxuXHJcbi8vIC0tLSBFeGFtcGxlIFBsdWdpbiBTZXR0aW5ncyBJbnRlcmZhY2UgKGluIHlvdXIgbWFpbi50cyBvciBzZXR0aW5ncyBmaWxlKSAtLS1cclxuZXhwb3J0IGludGVyZmFjZSBZb3VyUGx1Z2luU2V0dGluZ3Mge1xyXG4gICAgc2VsZWN0ZWRGb2xkZXJzOiBzdHJpbmdbXTtcclxuICAgIHNlbGVjdGVkRmlsZXM6IHN0cmluZ1tdO1xyXG4gICAgc2VsZWN0aW9uTW9kZTogJ2luY2x1ZGUnIHwgJ2V4Y2x1ZGUnO1xyXG4gICAgLy8gLi4uIG90aGVyIHNldHRpbmdzIGZvciB5b3VyIHBsdWdpblxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgREVGQVVMVF9TRVRUSU5HUzogWW91clBsdWdpblNldHRpbmdzID0ge1xyXG4gICAgc2VsZWN0ZWRGb2xkZXJzOiBbXSxcclxuICAgIHNlbGVjdGVkRmlsZXM6IFtdLFxyXG4gICAgc2VsZWN0aW9uTW9kZTogJ2V4Y2x1ZGUnLCAvLyBEZWZhdWx0IG1vZGUgaXMgb2Z0ZW4gJ2V4Y2x1ZGUnXHJcbiAgICAvLyAuLi4gb3RoZXIgZGVmYXVsdCBzZXR0aW5nc1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFlvdXJQbHVnaW5TZXR0aW5nc1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xyXG4gICAgcGx1Z2luOiBZb3VyUGx1Z2luO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IFlvdXJQbHVnaW4pIHtcclxuICAgICAgICBzdXBlcihhcHAsIHBsdWdpbik7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICB9XHJcblxyXG4gICAgZGlzcGxheSgpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XHJcblxyXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ0VpbnN0ZWxsdW5nZW4gZlx1MDBGQ3IgTWVpbiBQbHVnaW4nIH0pOyAvLyBTZXR0aW5ncyBUaXRsZSBpbiBHZXJtYW5cclxuXHJcbiAgICAgICAgLy8gLS0tIEJ1dHRvbiB0byBPcGVuIHRoZSBNb2RhbCAtLS1cclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ1ZlcnplaWNobmlzc2UvRGF0ZWllbiBrb25maWd1cmllcmVuJykgLy8gU2V0dGluZyBOYW1lIGluIEdlcm1hblxyXG4gICAgICAgICAgICAuc2V0RGVzYygnS2xpY2tlIGF1ZiBkZW4gQnV0dG9uLCB1bSBkaWUgQXVzd2FobCB6dSBiZWFyYmVpdGVuLicpIC8vIFNldHRpbmcgRGVzY3JpcHRpb24gaW4gR2VybWFuXHJcbiAgICAgICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IHtcclxuICAgICAgICAgICAgICAgIGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdBdXN3YWhsIFx1MDBGNmZmbmVuJykgLy8gQnV0dG9uIFRleHQgaW4gR2VybWFuXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldEN0YSgpIC8vIE1ha2VzIHRoZSBidXR0b24gbW9yZSBwcm9taW5lbnRcclxuICAgICAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHJpZXZlIGN1cnJlbnQgc2V0dGluZ3MgdG8gcHJlLXBvcHVsYXRlIHRoZSBtb2RhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Rm9sZGVycyA9IHRoaXMucGx1Z2luLnNldHRpbmdzLnNlbGVjdGVkRm9sZGVycyB8fCBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEZpbGVzID0gdGhpcy5wbHVnaW4uc2V0dGluZ3Muc2VsZWN0ZWRGaWxlcyB8fCBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudE1vZGUgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zZWxlY3Rpb25Nb2RlIHx8ICdleGNsdWRlJzsgLy8gVXNlIGRlZmF1bHQgaWYgbm90IHNldFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlbiB0aGUgbW9kYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbkRpcmVjdG9yeVNlbGVjdGlvbk1vZGFsKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rm9sZGVycyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaWxlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNb2RlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgb2tDYWxsYmFjayBmdW5jdGlvbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZXN1bHQ6IERpcmVjdG9yeVNlbGVjdGlvblJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBdXN3YWhsIGJlc3RcdTAwRTR0aWd0OicsIHJlc3VsdCk7IC8vIExvZyByZXN1bHQgaW4gR2VybWFuIGNvbnNvbGVcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLS0tIElNUE9SVEFOVDogU2F2ZSB0aGUgcmVzdWx0cyBiYWNrIHRvIHlvdXIgcGx1Z2luIHNldHRpbmdzIC0tLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnNlbGVjdGVkRm9sZGVycyA9IHJlc3VsdC5mb2xkZXJzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnNlbGVjdGVkRmlsZXMgPSByZXN1bHQuZmlsZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Muc2VsZWN0aW9uTW9kZSA9IHJlc3VsdC5tb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpOyAvLyBQZXJzaXN0IHRoZSBjaGFuZ2VzXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wdGlvbmFsbHksIHJlLXJlbmRlciB0aGUgc2V0dGluZ3MgdGFiIHRvIHNob3cgdGhlIHVwZGF0ZWQgc2VsZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5KCk7IC8vIFJlLXJlbmRlciBzZXR0aW5ncyB0YWJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAvLyAtLS0gRGlzcGxheSBDdXJyZW50IFNlbGVjdGlvbiAoUmVhZC1vbmx5KSAtLS1cclxuICAgICAgICAgY29uc3Qgc2VsZWN0aW9uSW5mb0VsID0gY29udGFpbmVyRWwuY3JlYXRlRGl2KHsgY2xzOiAnc2V0dGluZ3Mtc2VsZWN0aW9uLWluZm8nIH0pO1xyXG4gICAgICAgICBzZWxlY3Rpb25JbmZvRWwuY3JlYXRlRWwoJ2g0JywgeyB0ZXh0OiAnQWt0dWVsbGUgQXVzd2FobDonIH0pOyAvLyBTZWN0aW9uIFRpdGxlIGluIEdlcm1hblxyXG4gICAgICAgICBjb25zdCBtb2RlVGV4dCA9IGBNb2R1czogJHt0aGlzLnBsdWdpbi5zZXR0aW5ncy5zZWxlY3Rpb25Nb2RlIHx8ICdOaWNodCBmZXN0Z2VsZWd0J31gOyAvLyBUZXh0IGluIEdlcm1hblxyXG4gICAgICAgICAvLyBUcnVuY2F0ZSBsb25nIGxpc3RzIGZvciBkaXNwbGF5IGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgICBjb25zdCBmb2xkZXJUZXh0ID0gYEF1c2dld1x1MDBFNGhsdGUgT3JkbmVyOiAkeyh0aGlzLnBsdWdpbi5zZXR0aW5ncy5zZWxlY3RlZEZvbGRlcnM/Lmxlbmd0aCB8fCAwKX0gU3RcdTAwRkNja2A7IC8vIFRleHQgaW4gR2VybWFuXHJcbiAgICAgICAgIGNvbnN0IGZpbGVUZXh0ID0gYEF1c2dld1x1MDBFNGhsdGUgRGF0ZWllbjogJHsodGhpcy5wbHVnaW4uc2V0dGluZ3Muc2VsZWN0ZWRGaWxlcz8ubGVuZ3RoIHx8IDApfSBTdFx1MDBGQ2NrYDsgLy8gVGV4dCBpbiBHZXJtYW5cclxuXHJcbiAgICAgICAgIHNlbGVjdGlvbkluZm9FbC5jcmVhdGVFbCgncCcsIHsgdGV4dDogbW9kZVRleHQgfSk7XHJcbiAgICAgICAgIHNlbGVjdGlvbkluZm9FbC5jcmVhdGVFbCgncCcsIHsgdGV4dDogZm9sZGVyVGV4dCB9KTtcclxuICAgICAgICAgc2VsZWN0aW9uSW5mb0VsLmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiBmaWxlVGV4dCB9KTtcclxuICAgICAgICAgLy8gWW91IGNvdWxkIGFkZCBhIHNtYWxsIGJ1dHRvbi9saW5rIGhlcmUgdG8gdmlldyB0aGUgZnVsbCBsaXN0IGlmIGl0J3MgbG9uZ1xyXG4gICAgfVxyXG59XHJcbiovXHJcbiIsICJpbXBvcnQgeyBEaXJlY3RvcnlEaXNwbGF5TW9kZSwgRGlyZWN0b3J5U2VsZWN0aW9uTW9kZSB9IGZyb20gJy4vZGlyZWN0b3J5U2VsZWN0aW9uTW9kYWwnO1xyXG5cclxuZXhwb3J0IGNvbnN0IHZlcnNpb25TdHJpbmcgPSBcIjAuMC4xOFwiO1xyXG5cclxuZXhwb3J0IHR5cGUgT2JzaWRpYW5Qcm9wZXJ0eVR5cGVzID0gXCJhbGlhc2VzXCJ8XCJjaGVja2JveFwifFwiZGF0ZVwifFwiZGF0ZXRpbWVcInxcIm11bHRpdGV4dFwifFwibnVtYmVyXCJ8XCJ0YWdzXCJ8XCJ0ZXh0XCI7XHJcbmV4cG9ydCB0eXBlIEZyb250bWF0dGVyQXV0b21hdGVFdmVudHMgPSAnY3JlYXRlJyB8ICdyZW5hbWUnIHwgJ2FjdGl2ZS1sZWFmLWNoYW5nZScgfCAnZGVsZXRlJyB8ICdtb2RpZnknIHwgJ3ByZXZpZXcnIHwgJ2FsbCc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEZpbHRlckZpbGVzQW5kRm9sZGVycyB7XHJcbiAgICBzZWxlY3RlZEZvbGRlcnM6IHN0cmluZ1tdLFxyXG4gICAgc2VsZWN0ZWRGaWxlczogc3RyaW5nW10sXHJcbiAgICBtb2RlOiBEaXJlY3RvcnlTZWxlY3Rpb25Nb2RlLFxyXG4gICAgZGlzcGxheTogRGlyZWN0b3J5RGlzcGxheU1vZGVcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfRklMVEVSX0ZJTEVTX0FORF9GT0xERVJTOiBGaWx0ZXJGaWxlc0FuZEZvbGRlcnMgPSB7XHJcbiAgICBzZWxlY3RlZEZvbGRlcnM6IFtdLFxyXG4gICAgc2VsZWN0ZWRGaWxlczogW10sXHJcbiAgICBtb2RlOiAnZXhjbHVkZScsXHJcbiAgICBkaXNwbGF5OiAnZm9sZGVycycsXHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBGb2xkZXJUYWdTZXR0aW5ncyB7XHJcbiAgICB0YWdQcmVmaXg6IHN0cmluZztcclxuICAgIGV4Y2x1ZGVSb290Rm9sZGVyOiBib29sZWFuO1xyXG4gICAgdGFnc1Byb3BlcnR5TmFtZTogc3RyaW5nO1xyXG4gICAgc3BhY2VSZXBsYWNlbWVudDogc3RyaW5nO1xyXG4gICAgc3BlY2lhbENoYXJSZXBsYWNlbWVudDogc3RyaW5nO1xyXG4gICAgbG93ZXJjYXNlVGFnczogYm9vbGVhbjtcclxuICAgIGtub3duUHJvcGVydGllczogUHJvcGVydHlUeXBlSW5mb1tdO1xyXG4gICAgcnVsZXM6IEZvbGRlclRhZ1J1bGVEZWZpbml0aW9uW107XHJcbiAgICBsaXZlUnVsZXM6IEZvbGRlclRhZ1J1bGVEZWZpbml0aW9uW107XHJcbiAgICB1c2VUZXh0QXJlYTogYm9vbGVhbjtcclxuICAgIGV4Y2x1ZGU6IEZpbHRlckZpbGVzQW5kRm9sZGVycztcclxuICAgIGluY2x1ZGU6IEZpbHRlckZpbGVzQW5kRm9sZGVycztcclxuICAgIGNvbmZpZ3VyZWRQcm9wZXJ0aWVzOiBBcnJheTx7IG5hbWU6IHN0cmluZzsgdmFsdWU6IGFueSB9PjtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0VUVElOR1M6IEZvbGRlclRhZ1NldHRpbmdzID0ge1xyXG4gICAgdGFnUHJlZml4OiAnJyxcclxuICAgIGV4Y2x1ZGVSb290Rm9sZGVyOiBmYWxzZSxcclxuICAgIHRhZ3NQcm9wZXJ0eU5hbWU6ICd0YWdzJyxcclxuICAgIHNwYWNlUmVwbGFjZW1lbnQ6ICdfJyxcclxuICAgIHNwZWNpYWxDaGFyUmVwbGFjZW1lbnQ6ICdfJyxcclxuICAgIGxvd2VyY2FzZVRhZ3M6IGZhbHNlLFxyXG4gICAga25vd25Qcm9wZXJ0aWVzOiBbXSxcclxuICAgIHJ1bGVzOiBbXSxcclxuICAgIGxpdmVSdWxlczogW10sXHJcbiAgICB1c2VUZXh0QXJlYTogZmFsc2UsXHJcbiAgICBleGNsdWRlOiB7XHJcbiAgICAgICAgc2VsZWN0ZWRGb2xkZXJzOiBbXSxcclxuICAgICAgICBzZWxlY3RlZEZpbGVzOiBbXSxcclxuICAgICAgICBtb2RlOiAnZXhjbHVkZScsXHJcbiAgICAgICAgZGlzcGxheTogJ2ZvbGRlcnMnLFxyXG4gICAgfSxcclxuICAgIGluY2x1ZGU6IHtcclxuICAgICAgICBzZWxlY3RlZEZvbGRlcnM6IFtdLFxyXG4gICAgICAgIHNlbGVjdGVkRmlsZXM6IFtdLFxyXG4gICAgICAgIG1vZGU6ICdpbmNsdWRlJyxcclxuICAgICAgICBkaXNwbGF5OiAnZm9sZGVycycsXHJcbiAgICB9LFxyXG4gICAgY29uZmlndXJlZFByb3BlcnRpZXM6IFtdXHJcbn07XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEZvbGRlclRhZ1J1bGVEZWZpbml0aW9uIHtcclxuICAgIGlkOiBzdHJpbmc7XHJcbiAgICBhY3RpdmU6IGJvb2xlYW47XHJcbiAgICBhZGRDb250ZW50OiAnb3ZlcndyaXRlJyB8ICdzdGFydCcgfCAnZW5kJztcclxuICAgIGFzTGluazogYm9vbGVhbjtcclxuICAgIHByb3BlcnR5OiBzdHJpbmc7XHJcbiAgICB2YWx1ZTogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbjtcclxuICAgIGN1c3RvbVByb3BlcnR5OiBzdHJpbmc7XHJcbiAgICB0eXBlOiBPYnNpZGlhblByb3BlcnR5VHlwZXM7XHJcbiAgICB0eXBlUHJvcGVydHk6IFByb3BlcnR5VHlwZUluZm8gfCB1bmRlZmluZWQ7XHJcbiAgICBjb250ZW50OiBzdHJpbmc7XHJcbiAgICBidWlsZEluQ29kZTogc3RyaW5nO1xyXG4gICAganNDb2RlOiBzdHJpbmc7XHJcbiAgICBzaG93Q29udGVudDogYm9vbGVhbjtcclxuICAgIGV4Y2x1ZGU6IEZpbHRlckZpbGVzQW5kRm9sZGVycztcclxuICAgIGluY2x1ZGU6IEZpbHRlckZpbGVzQW5kRm9sZGVycztcclxuICAgIHByZWZpeDogc3RyaW5nO1xyXG4gICAgc3BhY2VSZXBsYWNlbWVudDogc3RyaW5nO1xyXG4gICAgc3BlY2lhbENoYXJSZXBsYWNlbWVudDogc3RyaW5nO1xyXG4gICAgbG93ZXJjYXNlVGFnczogYm9vbGVhbjtcclxuICAgIGlucHV0UHJvcGVydHk6IHN0cmluZztcclxuICAgIG9ubHlNb2RpZnk6IGJvb2xlYW47XHJcbiAgICB1c2VDdXN0b21Db2RlOiBib29sZWFuO1xyXG4gICAgb3B0aW9uQ29uZmlnPzp7fTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfUlVMRV9ERUZJTklUSU9OIDogRm9sZGVyVGFnUnVsZURlZmluaXRpb24gPSB7XHJcbiAgICBpZDogJycsXHJcbiAgICBhY3RpdmUgOiB0cnVlLFxyXG4gICAgYXNMaW5rOiBmYWxzZSxcclxuICAgIGFkZENvbnRlbnQ6ICdvdmVyd3JpdGUnLFxyXG4gICAgcHJvcGVydHkgOiAnJyxcclxuICAgIHZhbHVlOiAnJyxcclxuICAgIGN1c3RvbVByb3BlcnR5IDogJycsXHJcbiAgICB0eXBlOiAndGV4dCcsXHJcbiAgICB0eXBlUHJvcGVydHk6IHtuYW1lOicnLHR5cGU6J3RleHQnLCBzb3VyY2U6J3JlZ2lzdGVyZWQnfSxcclxuICAgIGNvbnRlbnQ6ICcnLFxyXG4gICAgYnVpbGRJbkNvZGU6ICcnLFxyXG4gICAganNDb2RlOiAnJyxcclxuICAgIHNob3dDb250ZW50OiBmYWxzZSxcclxuICAgIGV4Y2x1ZGU6IHtcclxuICAgICAgICBzZWxlY3RlZEZvbGRlcnM6IFtdLFxyXG4gICAgICAgIHNlbGVjdGVkRmlsZXM6IFtdLFxyXG4gICAgICAgIG1vZGU6ICdleGNsdWRlJyxcclxuICAgICAgICBkaXNwbGF5OiAnZm9sZGVycycsXHJcbiAgICB9LFxyXG4gICAgaW5jbHVkZToge1xyXG4gICAgICAgIHNlbGVjdGVkRm9sZGVyczogW10sXHJcbiAgICAgICAgc2VsZWN0ZWRGaWxlczogW10sXHJcbiAgICAgICAgbW9kZTogJ2luY2x1ZGUnLFxyXG4gICAgICAgIGRpc3BsYXk6ICdmb2xkZXJzJyxcclxuICAgIH0sXHJcbiAgICBwcmVmaXg6ICcnLFxyXG4gICAgc3BhY2VSZXBsYWNlbWVudDogJycsXHJcbiAgICBzcGVjaWFsQ2hhclJlcGxhY2VtZW50OiAnJyxcclxuICAgIGxvd2VyY2FzZVRhZ3M6IGZhbHNlLFxyXG4gICAgaW5wdXRQcm9wZXJ0eTogJycsXHJcbiAgICBvbmx5TW9kaWZ5OiB0cnVlLFxyXG4gICAgdXNlQ3VzdG9tQ29kZTogZmFsc2UsXHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFByb3BlcnR5SW5mbyA9IHtcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIHR5cGU6IE9ic2lkaWFuUHJvcGVydHlUeXBlcztcclxuICAgIGNvdW50PzogbnVtYmVyO1xyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgUHJvcGVydHlUeXBlSW5mbyA9IHtcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgICAgICB0eXBlOiBPYnNpZGlhblByb3BlcnR5VHlwZXM7XHJcbiAgICBjb3VudD86IG51bWJlcjtcclxuICAgIGlzQXJyYXk/OiBib29sZWFuO1xyXG4gICAgdmFsdWVzPzogc3RyaW5nW107XHJcbiAgICBzb3VyY2U6ICdyZWdpc3RlcmVkJyB8ICdpbmZlcnJlZCc7XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBQcm9wZXJ0eVR5cGUgPSB7XHJcbiAgICB0eXBlOiBzdHJpbmc7XHJcbiAgICBpY29uOiBzdHJpbmc7XHJcbiAgICBqc1R5cGU6IHN0cmluZztcclxufTsiLCAiaW1wb3J0IHsgQXBwLCBQbHVnaW4sIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcsIERyb3Bkb3duQ29tcG9uZW50LCBUZXh0Q29tcG9uZW50LCBCdXR0b25Db21wb25lbnQsIFRvZ2dsZUNvbXBvbmVudCwgc2V0SWNvbiwgYXBpVmVyc2lvbiwgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCB7IG9wZW5EaXJlY3RvcnlTZWxlY3Rpb25Nb2RhbCwgRGlyZWN0b3J5U2VsZWN0aW9uUmVzdWx0IH0gZnJvbSAnLi9kaXJlY3RvcnlTZWxlY3Rpb25Nb2RhbCc7XHJcbmltcG9ydCB7IHZlcnNpb25TdHJpbmcsIEZvbGRlclRhZ1J1bGVEZWZpbml0aW9uLCBERUZBVUxUX1JVTEVfREVGSU5JVElPTiwgUHJvcGVydHlUeXBlSW5mbywgT2JzaWRpYW5Qcm9wZXJ0eVR5cGVzLCBERUZBVUxUX0ZJTFRFUl9GSUxFU19BTkRfRk9MREVSUywgUHJvcGVydHlJbmZvfSBmcm9tICcuL3R5cGVzJztcclxuaW1wb3J0IHsgZ2V0UnVsZUZ1bmN0aW9uQnlJZCwgdXNlUnVsZU9wdGlvbiwgcnVsZUZ1bmN0aW9ucywgUnVsZUZ1bmN0aW9uLCBleGVjdXRlUnVsZSwgY2hlY2tJZkZpbGVBbGxvd2VkIH0gZnJvbSAnLi9ydWxlcyc7XHJcbmltcG9ydCB7IEFsZXJ0TW9kYWwgfSBmcm9tICcuL2FsZXJ0Qm94JztcclxuaW1wb3J0IHsgcmFuZG9tVVVJRCB9IGZyb20gJ2NyeXB0byc7XHJcbmltcG9ydCB7IGNvZGVFZGl0b3JNb2RhbCwgY29kZUVkaXRvck1vZGFsUmVzdWx0LCBvcGVuQ29kZUVkaXRvck1vZGFsIH0gZnJvbSAnLi9lZGl0b3JNb2RhbCc7XHJcbmltcG9ydCB7IGNvcHlGaWxlU3luYyB9IGZyb20gJ2ZzJztcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tICcuL3Rvb2xzJztcclxuaW1wb3J0IHsgdXBkYXRlUHJvcGVydHlJY29uIH0gZnJvbSAnLi91aUVsZW1lbnRzJztcclxuXHJcbmV4cG9ydCBjbGFzcyBSdWxlc1RhYmxlIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XHJcbiAgICBwbHVnaW46IGFueTtcclxuICAgIGtub3duUHJvcGVydGllczogUmVjb3JkPHN0cmluZywgUHJvcGVydHlJbmZvPiA9IHt9OyBcclxuICAgIGNvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQ7XHJcbiAgICBwcm9wZXJ0aWVzTGlzdEVsOiBIVE1MRGl2RWxlbWVudDtcclxuICAgIHNldHRpbmdzUGFyYW1ldGVyOiBzdHJpbmc7XHJcbiAgICB0b29sczogU2NyaXB0aW5nVG9vbHM7XHJcbiAgICBhY3RpdmVGaWxlOiBURmlsZSB8IG51bGwgPSBudWxsO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IGFueSwgY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCwgc2V0dGluZ3NQYXJhbWV0ZXI6IHN0cmluZykge1xyXG4gICAgICAgIHN1cGVyKGFwcCwgcGx1Z2luKTtcclxuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgICAgICB0aGlzLnNldHRpbmdzUGFyYW1ldGVyID0gc2V0dGluZ3NQYXJhbWV0ZXI7XHJcbiAgICAgICAgdGhpcy50b29scyA9IG5ldyBTY3JpcHRpbmdUb29scyhhcHAsIHBsdWdpbik7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVGaWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGVscGVyIHRvIHJlbmRlciBvbmUgcnVsZVxyXG5cclxuICAgIHJlbmRlclByb3BlcnR5Um93KGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCwgcnVsZTogRm9sZGVyVGFnUnVsZURlZmluaXRpb24sIGluZGV4OiBudW1iZXIpIHtcclxuICAgICAgICBcclxuICAgICAgICAvL2NvbnN0IGFjdGl2ZUZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xyXG4gICAgICAgIGNvbnN0IHJ1bGVGbiA9IGdldFJ1bGVGdW5jdGlvbkJ5SWQocnVsZS5jb250ZW50KTtcclxuXHJcbiAgICAgICAgY29uc3Qgcm93RWwgPSBjb250YWluZXJFbC5jcmVhdGVEaXYoeyBjbHM6ICdwcm9wZXJ0eS1zZXR0aW5nLXJvdyBzZXR0aW5nLWl0ZW0nIH0pO1xyXG4gICAgICAgIHJvd0VsLmlkID0gcnVsZS5pZDtcclxuICAgICAgICBjb25zdCBjb250cm9sRWwgPSByb3dFbC5jcmVhdGVEaXYoeyBjbHM6ICdzZXR0aW5nLWl0ZW0tY29udHJvbCcgfSk7IFxyXG4gICAgICAgIGNvbnRyb2xFbC5zdHlsZS5nYXAgPSAnMHB4JztcclxuICAgICAgICBjb25zdCBsZWZ0Q29udGFpbmVyID0gY29udHJvbEVsLmNyZWF0ZURpdih7IGNsczogJ3Byb3BlcnR5LWxlZnQtY29udGFpbmVyJyB9KTtcclxuICAgICAgICBjb25zdCBpY29uRWwgPSBsZWZ0Q29udGFpbmVyLmNyZWF0ZVNwYW4oeyBjbHM6ICdwcm9wZXJ0eS1pY29uIHNldHRpbmctaXRlbS1pY29uJyB9KTsgXHJcbiAgICAgICAgc2V0SWNvbihpY29uRWwsICdoYXNoJyk7IC8vIFN0YW5kYXJkLUljb25cclxuXHJcblxyXG4gICAgICAgIGNvbnN0IHNlYXJjaENvbnRhaW5lciA9IGxlZnRDb250YWluZXIuY3JlYXRlRGl2KHsgY2xzOiAncHJvcGVydHktc2VhcmNoLWNvbnRhaW5lcicgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IG5hbWVJbnB1dCA9IG5ldyBUZXh0Q29tcG9uZW50KHNlYXJjaENvbnRhaW5lcilcclxuICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdTZWxlY3QgcHJvcGVydHkuLi4nKVxyXG4gICAgICAgICAgICAuc2V0VmFsdWUocnVsZS5wcm9wZXJ0eSB8fCAnJylcclxuICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJTZWFyY2hSZXN1bHRzKHNlYXJjaENvbnRhaW5lciwgdmFsdWUsIGluZGV4KTtcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgbmFtZUlucHV0LmlucHV0RWwuc3R5bGUuYm9yZGVyID0gJ25vbmUnOyAvLyBtYWtlIGl0IGludmlzaWJsZVxyXG4gICAgICAgIG5hbWVJbnB1dC5pbnB1dEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclNlYXJjaFJlc3VsdHMoc2VhcmNoQ29udGFpbmVyLCBuYW1lSW5wdXQuZ2V0VmFsdWUoKSwgaW5kZXgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG5hbWVJbnB1dC5pbnB1dEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclNlYXJjaFJlc3VsdHMoc2VhcmNoQ29udGFpbmVyLCBuYW1lSW5wdXQuZ2V0VmFsdWUoKSwgaW5kZXgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG5hbWVJbnB1dC5pbnB1dEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldCBhcyBOb2RlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0c0VsID0gc2VhcmNoQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5wcm9wZXJ0eS1zZWFyY2gtcmVzdWx0cycpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHRzRWwgfHwgIXJlc3VsdHNFbC5jb250YWlucyhyZWxhdGVkVGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJTZWFyY2hSZXN1bHRzKHNlYXJjaENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIDEwMCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRQcm9wZXJ0eUluZm8gPSB0aGlzLmtub3duUHJvcGVydGllc1tydWxlLnByb3BlcnR5XTtcclxuICAgICAgICBpZiAoY3VycmVudFByb3BlcnR5SW5mbykge1xyXG4gICAgICAgICAgICB1cGRhdGVQcm9wZXJ0eUljb24oaWNvbkVsLCBjdXJyZW50UHJvcGVydHlJbmZvLnR5cGUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocnVsZS5wcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICBzZXRJY29uKGljb25FbCwgJ2FsZXJ0LWNpcmNsZScpOyBcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IG1pZGRsZUNvbnRhaW5lciA9IGNvbnRyb2xFbC5jcmVhdGVEaXYoeyBjbHM6ICdwcm9wZXJ0eS1taWRkbGUtY29udGFpbmVyJyB9KTtcclxuICAgICAgICBjb25zdCB2YWx1ZUNvbnRhaW5lciA9IG1pZGRsZUNvbnRhaW5lci5jcmVhdGVEaXYoeyBjbHM6ICdwcm9wZXJ0eS12YWx1ZS1jb250YWluZXInIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUZpbGUpIHtcclxuICAgICAgICAgICAgdGhpcy5hcHAuZmlsZU1hbmFnZXIucHJvY2Vzc0Zyb250TWF0dGVyKHRoaXMuYWN0aXZlRmlsZSwgYXN5bmMgKGZyb250bWF0dGVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBydWxlLnZhbHVlID0gYXdhaXQgZXhlY3V0ZVJ1bGUoJ3ByZXZpZXcnLHRoaXMuYXBwLCB0aGlzLnBsdWdpbi5zZXR0aW5ncywgdGhpcy5hY3RpdmVGaWxlLCAnJywgcnVsZSwgZnJvbnRtYXR0ZXIpO1xyXG4gICAgICAgICAgICB9LHsnbXRpbWUnOnRoaXMuYWN0aXZlRmlsZS5zdGF0Lm10aW1lfSk7IC8vIGRvIG5vdCBjaGFuZ2UgdGhlIG1vZGlmeSB0aW1lLlxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwcmV2aWV3Q29tcG9uZW50ID0gdGhpcy5yZW5kZXJWYWx1ZUlucHV0KHZhbHVlQ29udGFpbmVyLCBjdXJyZW50UHJvcGVydHlJbmZvLCBydWxlLnZhbHVlLCBpbmRleCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHByb3BlcnR5RGV2RHJvcGRvd24gPSAgbmV3IERyb3Bkb3duQ29tcG9uZW50KG1pZGRsZUNvbnRhaW5lcik7XHJcbiAgICAgICAgcHJvcGVydHlEZXZEcm9wZG93bi5zZWxlY3RFbC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywnd2lkdGg6MzUlJyk7XHJcbiAgICAgICAgcHJvcGVydHlEZXZEcm9wZG93bi5hZGRPcHRpb24oXCJcIiwgXCJTZWxlY3QgYSBjb250ZW50XCIpO1xyXG4gICAgICAgIGZvciAobGV0IHJ1bGVGdW5jdGlvbiBvZiBydWxlRnVuY3Rpb25zKSB7XHJcbiAgICAgICAgICAgIGlmIChydWxlRnVuY3Rpb24udHlwZS5jb250YWlucyhydWxlLnR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eURldkRyb3Bkb3duLmFkZE9wdGlvbihydWxlRnVuY3Rpb24uaWQsIHJ1bGVGdW5jdGlvbi5kZXNjcmlwdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvcGVydHlEZXZEcm9wZG93bi5hZGRPcHRpb24oXCJzY3JpcHRcIiwgXCJKYXZhU2NyaXB0IGZ1bmN0aW9uIChhZHZhbmNlZClcIik7XHJcbiAgICAgICAgcHJvcGVydHlEZXZEcm9wZG93bi5zZXRWYWx1ZShydWxlLmNvbnRlbnQpO1xyXG4gICAgICAgIHByb3BlcnR5RGV2RHJvcGRvd24ub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGVGdW5jdGlvbiA9IGdldFJ1bGVGdW5jdGlvbkJ5SWQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChydWxlRnVuY3Rpb24/LnJ1bGVUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2NyaXB0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG9sZE9yaWdpbmFsQ29kZSA9IGdldFJ1bGVGdW5jdGlvbkJ5SWQodmFsdWUpPy5zb3VyY2UgfHwgcnVsZUZ1bmN0aW9uc1swXS5zb3VyY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocnVsZS5idWlsZEluQ29kZSAhPT0gJycpICYmIChydWxlLmJ1aWxkSW5Db2RlICE9PSBvbGRPcmlnaW5hbENvZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRQcm9jZWVkID0gYXdhaXQgbmV3IEFsZXJ0TW9kYWwoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnT3ZlcndyaXRlIGV4aXN0aW5nIGNvZGU/JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0kgc2VlcyBsaWtlIHlvdSBoYXZlIGN1c3RvbSBjb2RlIGZvciB0aGlzIHJ1bGUhIFNob3VsZCB0aGlzIGJlIG92ZXJ3cml0dGVuIGJ5IGRlZmF1bHQgY29kZSBmb3IgdGhpcyBwYXJhbWV0ZXI/JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1llcycsICdObydcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLm9wZW5BbmRHZXRWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkUHJvY2VlZC5wcm9jZWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5idWlsZEluQ29kZSA9IGdldFJ1bGVGdW5jdGlvbkJ5SWQodmFsdWUpPy5zb3VyY2UgfHwgcnVsZUZ1bmN0aW9uc1swXS5zb3VyY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS51c2VDdXN0b21Db2RlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuYnVpbGRJbkNvZGU7IC8vIGtlZXAgdGhlIGV4aXN0aW5nIGNvZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5idWlsZEluQ29kZSA9IGdldFJ1bGVGdW5jdGlvbkJ5SWQodmFsdWUpPy5zb3VyY2UgfHwgcnVsZUZ1bmN0aW9uc1swXS5zb3VyY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLnVzZUN1c3RvbUNvZGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2J1aWxkSW4uaW5wdXRQcm9wZXJ0eSc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYnVpbGRJbic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuYnVpbGRJbkNvZGUgPSBnZXRSdWxlRnVuY3Rpb25CeUlkKHZhbHVlKT8uc291cmNlIHx8IHJ1bGVGdW5jdGlvbnNbMF0uc291cmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLnVzZUN1c3RvbUNvZGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2F1dG9tYXRpb24nOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2F1dG9jb21wbGV0ZS5tb2RhbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJ1bGUuaXNMaXZlUnVsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBydWxlLmNvbnRlbnQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIC8vcnVsZU9wdGlvbnNEaXYuc3R5bGUuZGlzcGxheSA9IGAkeyhydWxlLmNvbnRlbnQgPT09ICdzY3JpcHQnKSA/ICdmbGV4JyA6ICdub25lJ31gO1xyXG4gICAgICAgICAgICAgICAgLy9zaG93SnNGdW5jdGlvbkJ1dHRvbihydWxlLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVByZXZpZXcocnVsZSwgcHJldmlld0NvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclByb3BlcnR5T3B0aW9ucyhvcHRpb25FTCwgcnVsZSwgcHJldmlld0NvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbmV3IEJ1dHRvbkNvbXBvbmVudChtaWRkbGVDb250YWluZXIpXHJcbiAgICAgICAgLnNldEljb24oJ2dlYXInKVxyXG4gICAgICAgIC5zZXRUb29sdGlwKCdvcGVuIHNldHRpbmdzJylcclxuICAgICAgICAuc2V0Q2xhc3MoJ3Byb3BlcnR5LWljb24tYnV0dG9uJylcclxuICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBzZXR0aW5nc0NvbnRhaW5lcnMgPSBjb250YWluZXJFbC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdwcm9wZXJ0eS1vcHRpb25zLWNvbnRhaW5lcicpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBjb250YWluZXIgb2Ygc2V0dGluZ3NDb250YWluZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyLmdldEF0dHJpYnV0ZSgnaWQnKSAhPT0gcnVsZS5pZCkgY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCdkaXNwbGF5OiBub25lOycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUHJvcGVydHlPcHRpb25zKG9wdGlvbkVMLCBydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgb3B0aW9uRUwuc3R5bGUuZGlzcGxheSA9IG9wdGlvbkVMLnN0eWxlLmRpc3BsYXkgPT09ICdibG9jaycgPyAnbm9uZScgOiAnYmxvY2snO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyAtLS0gcmlnaHQgcGFydDogZXJhc2UgcnVsZSAtLS1cclxuICAgICAgICBjb25zdCBkZWxldGVCdXR0b25Db250YWluZXIgPSBjb250cm9sRWwuY3JlYXRlRGl2KHsgY2xzOiAncHJvcGVydHktZGVsZXRlLWJ1dHRvbi1jb250YWluZXInIH0pO1xyXG4gICAgICAgIG5ldyBCdXR0b25Db21wb25lbnQoZGVsZXRlQnV0dG9uQ29udGFpbmVyKVxyXG4gICAgICAgICAgICAuc2V0SWNvbigndHJhc2gtMicpXHJcbiAgICAgICAgICAgIC5zZXRUb29sdGlwKCdyZW1vdmUgdGhpcyBydWxlJylcclxuICAgICAgICAgICAgLnNldENsYXNzKCdtb2Qtc3VidGxlJylcclxuICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3NbdGhpcy5zZXR0aW5nc1BhcmFtZXRlcl0uc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5KCk7IC8vIFJlLXJlbmRlciB0aGUgc2V0dGluZ3MgdGFiXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb250cm9sRWwuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcclxuICAgICAgICBjb250cm9sRWwuc3R5bGUuYWxpZ25JdGVtcyA9ICdjZW50ZXInO1xyXG4gICAgICAgIGNvbnRyb2xFbC5zdHlsZS5qdXN0aWZ5Q29udGVudCA9ICdzcGFjZS1iZXR3ZWVuJztcclxuICAgICAgICBjb250cm9sRWwuc3R5bGUud2lkdGggPSAnMTAwJSc7XHJcblxyXG4gICAgICAgIGxlZnRDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcclxuICAgICAgICBsZWZ0Q29udGFpbmVyLnN0eWxlLmFsaWduSXRlbXMgPSAnY2VudGVyJztcclxuICAgICAgICBsZWZ0Q29udGFpbmVyLnN0eWxlLm1pbldpZHRoID0gJzE1MHB4JzsgXHJcbiAgICAgICAgaWNvbkVsLnN0eWxlLm1hcmdpblJpZ2h0ID0gJzhweCc7XHJcblxyXG4gICAgICAgIHNlYXJjaENvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7IFxyXG4gICAgICAgIHNlYXJjaENvbnRhaW5lci5zdHlsZS5mbGV4R3JvdyA9ICcxJztcclxuXHJcbiAgICAgICAgdmFsdWVDb250YWluZXIuc3R5bGUuZmxleEdyb3cgPSAnMic7IFxyXG5cclxuICAgICAgICBkZWxldGVCdXR0b25Db250YWluZXIuc3R5bGUubWFyZ2luTGVmdCA9ICdhdXRvJzsgXHJcblxyXG4gICAgICAgIGNvbnN0IG9wdGlvbkVMID0gY29udGFpbmVyRWwuY3JlYXRlRGl2KHsgY2xzOiAncHJvcGVydHktb3B0aW9ucy1jb250YWluZXInIH0pOyAvLyBvcHRpb25zIGNvbnRhaW5lclxyXG4gICAgICAgIG9wdGlvbkVMLmlkID0gcnVsZS5pZDtcclxuICAgICAgICBvcHRpb25FTC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlclByb3BlcnR5T3B0aW9ucyhvcHRpb25FTDogSFRNTERpdkVsZW1lbnQsIHJ1bGU6IEZvbGRlclRhZ1J1bGVEZWZpbml0aW9uLCBwcmV2aWV3Q29tcG9uZW50OiBUZXh0Q29tcG9uZW50KSB7XHJcbiAgICAgICAgb3B0aW9uRUwuZW1wdHkoKTsgLy8gY2xlYXIgcHJldmlvdXMgb3B0aW9uc1xyXG4gICAgICAgIGNvbnN0IHJ1bGVGbiA9IGdldFJ1bGVGdW5jdGlvbkJ5SWQocnVsZS5jb250ZW50KTtcclxuICAgICAgICBpZiAodXNlUnVsZU9wdGlvbihydWxlRm4sJ3JlbW92ZUNvbnRlbnQnKSkge1xyXG4gICAgICAgICAgICBjb25zdCByZW1vdmVDb250ZW50QnV0dG9uID0gbmV3IFNldHRpbmcob3B0aW9uRUwpXHJcbiAgICAgICAgICAgICAgICAuc2V0TmFtZSgnUmVtb3ZlIGNvbnRlbnQnKVxyXG4gICAgICAgICAgICAgICAgLnNldERlc2MoYEJlZm9yZSBtYWtpbmcgY2hhbmdlcyB5b3UgbWlnaHQgY29uc2lkZXIgdG8gcmVtb3ZlIGNvbnRlbnQgZ2VuZXJhdGVkIGJ5IHRoaXMgcnVsZWApXHJcbiAgICAgICAgICAgICAgICAuYWRkQnV0dG9uKGJ1dHRvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRXYXJuaW5nKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoJ1JlbW92ZSBDb250ZW50JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldEN0YSgpIC8vIE1ha2VzIHRoZSBidXR0b24gbW9yZSBwcm9taW5lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5wbHVnaW4ucmVtb3ZlRnJvbnRtYXR0ZXJQYXJhbXNGcm9tQWxsRmlsZXMocnVsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b24ucmVtb3ZlQ3RhKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b24uc2V0RGlzYWJsZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDb250ZW50QnV0dG9uLnNldERlc2MoYFJlbW92ZWQgdGhpcyBydWxlIGZyb20gJHtjb3VudC5maWxlc30gZmlsZXMuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVzZVJ1bGVPcHRpb24ocnVsZUZuLCdydWxlQWN0aXZlJykpIHtcclxuICAgICAgICAgICAgbmV3IFNldHRpbmcob3B0aW9uRUwpXHJcbiAgICAgICAgICAgICAgICAuc2V0TmFtZSgnUnVsZSBhY3RpdmUnKVxyXG4gICAgICAgICAgICAgICAgLnNldERlc2MoJ0lmIGVuYWJsZWQsIHRoZSBydWxlIHdpbGwgYmUgZXhlY3V0ZWQnKVxyXG4gICAgICAgICAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHJ1bGUuYWN0aXZlKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5hY3RpdmUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1c2VSdWxlT3B0aW9uKHJ1bGVGbiwnbW9kaWZ5T25seScpKSB7XHJcbiAgICAgICAgICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnTW9kaWZ5IG9ubHknKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnT25seSBtb2RpZnkgZXhpc3RpbmcgcHJvcGVydGllcycpXHJcbiAgICAgICAgICAgIC5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHJ1bGUub25seU1vZGlmeSlcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBydWxlLm9ubHlNb2RpZnkgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVByZXZpZXcocnVsZSwgcHJldmlld0NvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChydWxlLnR5cGUgPT09ICd0ZXh0JyB8fCBydWxlLnR5cGUgPT09ICdtdWx0aXRleHQnIHx8IHJ1bGUudHlwZSA9PT0gJ3RhZ3MnIHx8IHJ1bGUudHlwZSA9PT0gJ2FsaWFzZXMnKSB7XHJcbiAgICAgICAgICAgIGlmICh1c2VSdWxlT3B0aW9uKHJ1bGVGbiwnaW5wdXRQcm9wZXJ0eScpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBydWxlRnVuY3Rpb24gPSBydWxlRnVuY3Rpb25zLmZpbmQoaXRlbSA9PiBpdGVtLmlkID09PSBydWxlLmNvbnRlbnQpXHJcbiAgICAgICAgICAgICAgICBpZiAocnVsZUZ1bmN0aW9uICYmIHJ1bGVGdW5jdGlvbi5pbnB1dFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaW5wdXRQcm9wZXJ0aWVzRHJvcGRvd247XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IFNldHRpbmcob3B0aW9uRUwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXROYW1lKCdJbnB1dCBQcm9wZXJ0eScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXREZXNjKCdTZWxlY3QgYSBwcm9wZXJ0eSBhcyBpbnB1dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGREcm9wZG93bihkcm9wZG93biA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFByb3BlcnRpZXNEcm9wZG93biA9IGRyb3Bkb3duO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJvcGRvd25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShydWxlLmFkZENvbnRlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLmlucHV0UHJvcGVydHkgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUHJldmlldyhydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyh0aGlzLmtub3duUHJvcGVydGllcykuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRQcm9wZXJ0aWVzRHJvcGRvd24uYWRkT3B0aW9uKGl0ZW1bMV0ubmFtZSxpdGVtWzFdLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRQcm9wZXJ0aWVzRHJvcGRvd24uc2V0VmFsdWUocnVsZS5pbnB1dFByb3BlcnR5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodXNlUnVsZU9wdGlvbihydWxlRm4sJ2FkZFByZWZpeCcpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocnVsZS50eXBlID09PSAndGFncycgfHwgcnVsZS50eXBlID09PSAnYWxpYXNlcycpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXcgU2V0dGluZyhvcHRpb25FTClcclxuICAgICAgICAgICAgICAgICAgICAuc2V0TmFtZSgnUHJlZml4JylcclxuICAgICAgICAgICAgICAgICAgICAuc2V0RGVzYygnT3B0aW9uYWwgcHJlZml4IHRvIGFkZCBiZWZvcmUgdGhlIGNvbnRlbnQgKGkuZS4gXCJwcmVmaXgvXCIpJylcclxuICAgICAgICAgICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdubyBwcmVmaXgnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUocnVsZS5wcmVmaXgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUucHJlZml4ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUHJldmlldyhydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh1c2VSdWxlT3B0aW9uKHJ1bGVGbiwnc3BhY2VSZXBsYWNlbWVudCcpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXcgU2V0dGluZyhvcHRpb25FTClcclxuICAgICAgICAgICAgICAgICAgICAuc2V0TmFtZSgnU3BhY2UgcmVwbGFjZW1lbnQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXREZXNjKCdDaGFyYWN0ZXIgdG8gcmVwbGFjZSBzcGFjZXMgaW4gZm9sZGVyIG5hbWVzIChzdWdnZXN0ZWQ6IFwiX1wiKScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignbm8gcmVwbGFjZW1lbnQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUocnVsZS5zcGFjZVJlcGxhY2VtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLnNwYWNlUmVwbGFjZW1lbnQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQcmV2aWV3KHJ1bGUsIHByZXZpZXdDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHVzZVJ1bGVPcHRpb24ocnVsZUZuLCdzcGVjaWFsQ2hhcmFjdGVyUmVwbGFjZW1lbnQnKSkge1xyXG4gICAgICAgICAgICAgICAgbmV3IFNldHRpbmcob3B0aW9uRUwpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldE5hbWUoJ1NwZWNpYWwgY2hhcmFjdGVyIHJlcGxhY2VtZW50JylcclxuICAgICAgICAgICAgICAgICAgICAuc2V0RGVzYygnQ2hhcmFjdGVyIHRvIHJlcGxhY2Ugc3BlY2lhbCBjaGFyYWN0ZXJzIChzdWdnZXN0ZWQ6IFwiLVwiKSAtIHByZXNlcnZlcyBsZXR0ZXJzIHdpdGggZGlhY3JpdGljcycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignbm8gcmVwbGFjZW1lbnQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUocnVsZS5zcGVjaWFsQ2hhclJlcGxhY2VtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLnNwZWNpYWxDaGFyUmVwbGFjZW1lbnQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQcmV2aWV3KHJ1bGUsIHByZXZpZXdDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHVzZVJ1bGVPcHRpb24ocnVsZUZuLCdjb252ZXJ0VG9Mb3dlckNhc2UnKSkge1xyXG4gICAgICAgICAgICAgICAgbmV3IFNldHRpbmcob3B0aW9uRUwpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldE5hbWUoJ0NvbnZlcnQgdG8gbG93ZXJjYXNlJylcclxuICAgICAgICAgICAgICAgICAgICAuc2V0RGVzYygnQ29udmVydCB2YWx1ZXMgdG8gbG93ZXJjYXNlJylcclxuICAgICAgICAgICAgICAgICAgICAuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHJ1bGUubG93ZXJjYXNlVGFncylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5sb3dlcmNhc2VUYWdzID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUHJldmlldyhydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh1c2VSdWxlT3B0aW9uKHJ1bGVGbiwncmVzdWx0QXNMaW5rJykpIHtcclxuICAgICAgICAgICAgICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXROYW1lKCdSZXN1bHQgYXMgTGluaycpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldERlc2MoJ0Zvcm1hdCBSZXN1bHQgYXMgTGluaycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShydWxlLmFzTGluaylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5hc0xpbmsgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQcmV2aWV3KHJ1bGUsIHByZXZpZXdDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJ1bGUudHlwZSA9PT0gJ3RleHQnIHx8IHJ1bGUudHlwZSA9PT0gJ211bHRpdGV4dCcgfHwgcnVsZS50eXBlID09PSAndGFncycgfHwgcnVsZS50eXBlID09PSAnYWxpYXNlcycpIHtcclxuICAgICAgICAgICAgaWYgKHVzZVJ1bGVPcHRpb24ocnVsZUZuLCdhZGRDb250ZW50JykpIHtcclxuICAgICAgICAgICAgICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXROYW1lKCdBZGQgY29udGVudCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldERlc2MoJ3NlbGVjdCBob3cgdGhlIGNvbnRlbnQgc2hvdWxkIGJlIHN0b3JlZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmFkZERyb3Bkb3duKGRyb3Bkb3duID0+IGRyb3Bkb3duXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRPcHRpb24oXCJvdmVyd3JpdGVcIiwgXCJyZXBsYWNlIGNvbnRlbnRcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZE9wdGlvbihcInN0YXJ0XCIsIFwicGxhY2Ugb24gc3RhcnRcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZE9wdGlvbihcImVuZFwiLCBcInBsYWNlIG9uIGVuZFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUocnVsZS5hZGRDb250ZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5hZGRDb250ZW50ID0gdmFsdWUgPT09ICdvdmVyd3JpdGUnID8gJ292ZXJ3cml0ZScgOiB2YWx1ZSA9PT0gJ3N0YXJ0JyA/ICdzdGFydCcgOiAnZW5kJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVByZXZpZXcocnVsZSwgcHJldmlld0NvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodXNlUnVsZU9wdGlvbihydWxlRm4sJ2V4Y2x1ZGVGb2xkZXJzJykpIHtcclxuICAgICAgICAgICAgY29uc3QgZXhjbHVkZUVMID0gbmV3IFNldHRpbmcob3B0aW9uRUwpXHJcbiAgICAgICAgICAgICAgICAuc2V0TmFtZSgnRXhjbHVkZSBGaWxlcyBhbmQgRm9sZGVycyBmcm9tIHRoaXMgcnVsZScpXHJcbiAgICAgICAgICAgICAgICAuc2V0RGVzYyhgQ3VycmVudGx5ICR7cnVsZS5leGNsdWRlPy5zZWxlY3RlZEZvbGRlcnMubGVuZ3RoIHx8IDB9IGZvbGRlcnMgYW5kICR7cnVsZS5leGNsdWRlPy5zZWxlY3RlZEZpbGVzLmxlbmd0aCB8fCAwfSBmaWxlcyB3aWxsIGJlICR7cnVsZS5leGNsdWRlPy5tb2RlIHx8ICdleGNsdWRlJ31kLmApXHJcbiAgICAgICAgICAgICAgICAuYWRkQnV0dG9uKGJ1dHRvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRJY29uKCdmb2xkZXIteCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdFeGNsdWRlJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldEN0YSgpIC8vIE1ha2VzIHRoZSBidXR0b24gbW9yZSBwcm9taW5lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlbkRpcmVjdG9yeVNlbGVjdGlvbk1vZGFsKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuZXhjbHVkZT8uc2VsZWN0ZWRGb2xkZXJzIHx8IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuZXhjbHVkZT8uc2VsZWN0ZWRGaWxlcyB8fCBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25Nb2RlOiAnZXhjbHVkZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlNb2RlOiBydWxlLmV4Y2x1ZGU/LmRpc3BsYXkgfHwgJ2ZvbGRlcnMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25TZWxlY3Rpb25Nb2RlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uU2hvd0ZpbGVzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHJlc3VsdDogRGlyZWN0b3J5U2VsZWN0aW9uUmVzdWx0IHwgbnVsbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJ1bGUuZXhjbHVkZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5leGNsdWRlPU9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfRklMVEVSX0ZJTEVTX0FORF9GT0xERVJTLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA6ICdleGNsdWRlJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuZXhjbHVkZS5zZWxlY3RlZEZvbGRlcnMgPSByZXN1bHQuZm9sZGVycztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5leGNsdWRlLnNlbGVjdGVkRmlsZXMgPSByZXN1bHQuZmlsZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuZXhjbHVkZS5tb2RlID0gJ2V4Y2x1ZGUnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLmV4Y2x1ZGUuZGlzcGxheSA9IHJlc3VsdC5kaXNwbGF5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cocnVsZS5leGNsdWRlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVGaWx0ZXJJbmRpY2F0b3IodGhpcy5hY3RpdmVGaWxlLCB0aGlzLnByb3BlcnRpZXNMaXN0RWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNsdWRlRUwuc2V0RGVzYyhgQ3VycmVudGx5ICR7cnVsZS5leGNsdWRlPy5zZWxlY3RlZEZvbGRlcnMubGVuZ3RoIHx8IDB9IGZvbGRlcnMgYW5kICR7cnVsZS5leGNsdWRlPy5zZWxlY3RlZEZpbGVzLmxlbmd0aCB8fCAwfSBmaWxlcyB3aWxsIGJlICR7cnVsZS5leGNsdWRlPy5tb2RlIHx8ICdleGNsdWRlJ31kLmApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTsgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVzZVJ1bGVPcHRpb24ocnVsZUZuLCdpbmNsdWRlRm9sZGVycycpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluY2x1ZGVFTCA9IG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgICAgICAgICAgLnNldE5hbWUoJ0luY2x1ZGUgRmlsZXMgYW5kIEZvbGRlcnMgZm9yIHRoaXMgcnVsZSAnKVxyXG4gICAgICAgICAgICAgICAgLnNldERlc2MoYEN1cnJlbnRseSAke3J1bGUuaW5jbHVkZT8uc2VsZWN0ZWRGb2xkZXJzLmxlbmd0aCB8fCAwfSBmb2xkZXJzIGFuZCAke3J1bGUuaW5jbHVkZT8uc2VsZWN0ZWRGaWxlcy5sZW5ndGggfHwgMH0gZmlsZXMgd2lsbCBiZSAke3J1bGUuaW5jbHVkZT8ubW9kZSB8fCAnaW5jbHVkZSd9ZCBldmVuIGlmIHRoZXkgYXJlIGV4Y2x1ZGVkIGdsb2JhbGx5LmApXHJcbiAgICAgICAgICAgICAgICAuYWRkQnV0dG9uKGJ1dHRvbiA9PiB7YnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldEljb24oJ2ZvbGRlci1jaGVjaycpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoJ0luY2x1ZGUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRDdGEoKSAvLyBNYWtlcyB0aGUgYnV0dG9uIG1vcmUgcHJvbWluZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuRGlyZWN0b3J5U2VsZWN0aW9uTW9kYWwoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuaW5jbHVkZT8uc2VsZWN0ZWRGb2xkZXJzIHx8IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5pbmNsdWRlPy5zZWxlY3RlZEZpbGVzIHx8IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25Nb2RlOiAnaW5jbHVkZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU1vZGU6IHJ1bGUuaW5jbHVkZT8uZGlzcGxheSB8fCAnZm9sZGVycycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uU2VsZWN0aW9uTW9kZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uU2hvd0ZpbGVzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZXN1bHQ6IERpcmVjdG9yeVNlbGVjdGlvblJlc3VsdCB8IG51bGwpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcnVsZS5pbmNsdWRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuaW5jbHVkZSA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfRklMVEVSX0ZJTEVTX0FORF9GT0xERVJTLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlIDogJ2luY2x1ZGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuaW5jbHVkZS5zZWxlY3RlZEZvbGRlcnMgPSByZXN1bHQuZm9sZGVycztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLmluY2x1ZGUuc2VsZWN0ZWRGaWxlcyA9IHJlc3VsdC5maWxlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLmluY2x1ZGUubW9kZSA9ICdpbmNsdWRlJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLmluY2x1ZGUuZGlzcGxheSA9IHJlc3VsdC5kaXNwbGF5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJ1bGUuaW5jbHVkZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVGaWx0ZXJJbmRpY2F0b3IodGhpcy5hY3RpdmVGaWxlLCB0aGlzLnByb3BlcnRpZXNMaXN0RWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGVFTC5zZXREZXNjKGBDdXJyZW50bHkgJHtydWxlLmluY2x1ZGU/LnNlbGVjdGVkRm9sZGVycy5sZW5ndGggfHwgMH0gZm9sZGVycyBhbmQgJHtydWxlLmluY2x1ZGU/LnNlbGVjdGVkRmlsZXMubGVuZ3RoIHx8IDB9IGZpbGVzIHdpbGwgYmUgJHtydWxlLmluY2x1ZGU/Lm1vZGUgfHwgJ2luY2x1ZGUnfWQuYClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7IFxyXG4gICAgICAgIH0gICAgICBcclxuICAgICAgICBpZiAodXNlUnVsZU9wdGlvbihydWxlRm4sJ3NjcmlwdCcpKSB7XHJcbiAgICAgICAgICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgICAgICAgICAgLnNldE5hbWUoJ1NjcmlwdCcpXHJcbiAgICAgICAgICAgICAgICAuc2V0RGVzYygnZWRpdCB0aGUgc2NyaXB0IGZvciBvd24gbW9kaWZpY2F0aW9ucycpXHJcbiAgICAgICAgICAgICAgICAuYWRkQnV0dG9uKGJ1dHRvbiA9PiB7IGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdKUyBFZGl0b3InKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbkNvZGVFZGl0b3JNb2RhbChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLmNvbnRlbnQgPT09ICdzY3JpcHQnID8gcnVsZS5qc0NvZGUgOiBydWxlLmJ1aWxkSW5Db2RlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS50eXBlUHJvcGVydHk/LnR5cGUgfHwgJ3RleHQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVGaWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVGaWxlID8gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUodGhpcy5hY3RpdmVGaWxlKT8uZnJvbnRtYXR0ZXIgfHwge30gOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZXN1bHQ6IGNvZGVFZGl0b3JNb2RhbFJlc3VsdCB8IG51bGwpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlLmNvbnRlbnQgPT09ICdzY3JpcHQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuanNDb2RlID0gcmVzdWx0LmNvZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUudXNlQ3VzdG9tQ29kZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuYnVpbGRJbkNvZGUgPSByZXN1bHQuY29kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS51c2VDdXN0b21Db2RlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLnNldEN0YSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVByZXZpZXcocnVsZSwgcHJldmlld0NvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUudXNlQ3VzdG9tQ29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b24uc2V0Q3RhKCk7IC8vIE1ha2VzIHRoZSBidXR0b24gbW9yZSBwcm9taW5lbnRcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b24ucmVtb3ZlQ3RhKCk7IC8vIE1ha2VzIHRoZSBidXR0b24gbGVzcyBwcm9taW5lbnRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYWRkIGN1c3RvbSBjb25maWdcclxuICAgICAgICBjb25zdCBydWxlRnVuY3Rpb24gPSBnZXRSdWxlRnVuY3Rpb25CeUlkKHJ1bGUuY29udGVudCk7XHJcbiAgICAgICAgaWYgKHJ1bGVGdW5jdGlvbiAmJiB0eXBlb2YgcnVsZUZ1bmN0aW9uLmNvbmZpZ1RhYiA9PT0nZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJ1bGVGdW5jdGlvbi5jb25maWdUYWIob3B0aW9uRUwsIHJ1bGUsIHRoaXMsIHByZXZpZXdDb21wb25lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXRPcHRpb25Db25maWcocnVsZUlkOnN0cmluZyxwcm9wZXJ0eUlkOnN0cmluZyl7XHJcbiAgICAgICAgY29uc3QgcnVsZSA9IHRoaXMucGx1Z2luLnNldHRpbmdzLnJ1bGVzLmZpbmQoKHJ1bGU6IEZvbGRlclRhZ1J1bGVEZWZpbml0aW9uKSA9PiBydWxlLmlkID09PSBydWxlSWQpO1xyXG4gICAgICAgIGlmIChydWxlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbkNvbmZpZyA9IHJ1bGUub3B0aW9uc0NvbmZpZ1tydWxlSWRdXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25Db25maWdbcHJvcGVydHlJZF0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25Db25maWdbcHJvcGVydHlJZF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBzZXRPcHRpb25Db25maWcocnVsZUlkOnN0cmluZyxwcm9wZXJ0eUlkOnN0cmluZyxjb25maWc6YW55KXtcclxuICAgICAgICBjb25zdCBydWxlID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MucnVsZXMuZmluZCgocnVsZTogRm9sZGVyVGFnUnVsZURlZmluaXRpb24pID0+IHJ1bGUuaWQgPT09IHJ1bGVJZCk7XHJcbiAgICAgICAgaWYgKHJ1bGUpIHtcclxuICAgICAgICAgICAgaWYgKCFydWxlLm9wdGlvbnNDb25maWcpIHJ1bGUub3B0aW9uc0NvbmZpZyA9IHt9XHJcbiAgICAgICAgICAgIGlmICghcnVsZS5vcHRpb25zQ29uZmlnW3J1bGVJZF0pIHJ1bGUub3B0aW9uc0NvbmZpZ1tydWxlSWRdID0ge307XHJcblxyXG4gICAgICAgICAgICBydWxlLm9wdGlvbnNDb25maWdbcnVsZUlkXVtwcm9wZXJ0eUlkXSA9IGNvbmZpZztcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNldE9wdGlvbkNvbmZpZ0RlZmF1bHRzKHJ1bGVJZDpzdHJpbmcsIGRlZmF1bHRzOmFueSl7XHJcbiAgICAgICAgY29uc3QgcnVsZSA9IHRoaXMucGx1Z2luLnNldHRpbmdzLnJ1bGVzLmZpbmQoKHJ1bGU6IEZvbGRlclRhZ1J1bGVEZWZpbml0aW9uKSA9PiBydWxlLmlkID09PSBydWxlSWQpO1xyXG4gICAgICAgIGlmIChydWxlKSB7XHJcbiAgICAgICAgICAgIGlmICghcnVsZS5vcHRpb25zQ29uZmlnKSBydWxlLm9wdGlvbnNDb25maWcgPSB7fVxyXG4gICAgICAgICAgICBydWxlLm9wdGlvbnNDb25maWdbcnVsZUlkXSA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBydWxlLm9wdGlvbnNDb25maWdbcnVsZUlkXSB8fCB7fSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBydWxlLm9wdGlvbnNDb25maWdbcnVsZUlkXTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXJTZWFyY2hSZXN1bHRzKHNlYXJjaENvbnRhaW5lckVsOiBIVE1MRWxlbWVudCwgc2VhcmNoVGVybTogc3RyaW5nLCByb3dJbmRleDogbnVtYmVyKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5jbGVhclNlYXJjaFJlc3VsdHMoc2VhcmNoQ29udGFpbmVyRWwpO1xyXG5cclxuICAgICAgICBjb25zdCBmaWx0ZXJlZFByb3BlcnRpZXMgPSBPYmplY3QuZW50cmllcyh0aGlzLmtub3duUHJvcGVydGllcylcclxuICAgICAgICAgICAgLmZpbHRlcigoW25hbWVdKSA9PiBuYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoc2VhcmNoVGVybS50b0xvd2VyQ2FzZSgpKSk7XHJcblxyXG4gICAgICAgIGlmIChmaWx0ZXJlZFByb3BlcnRpZXMubGVuZ3RoID09PSAwICYmIHNlYXJjaFRlcm0pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmlsdGVyZWRQcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMCAmJiAhc2VhcmNoVGVybSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCByZXN1bHRzRWwgPSBzZWFyY2hDb250YWluZXJFbC5jcmVhdGVEaXYoeyBjbHM6ICdwcm9wZXJ0eS1zZWFyY2gtcmVzdWx0cyBtZW51JyB9KTtcclxuICAgICAgICByZXN1bHRzRWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgIHJlc3VsdHNFbC5zdHlsZS50b3AgPSAnMTAwJSc7XHJcbiAgICAgICAgcmVzdWx0c0VsLnN0eWxlLmxlZnQgPSAnMCc7XHJcbiAgICAgICAgcmVzdWx0c0VsLnN0eWxlLndpZHRoID0gJ2NhbGMoMTAwJSArIDEwMHB4KSc7XHJcbiAgICAgICAgcmVzdWx0c0VsLnN0eWxlLnpJbmRleCA9ICcxMCc7XHJcbiAgICAgICAgcmVzdWx0c0VsLnN0eWxlLm1heEhlaWdodCA9ICcyMDBweCc7XHJcbiAgICAgICAgcmVzdWx0c0VsLnN0eWxlLm92ZXJmbG93WSA9ICdhdXRvJztcclxuXHJcbiAgICAgICAgbGV0IGFjdGl2ZUluZGV4ID0gLTE7XHJcblxyXG4gICAgICAgIGNvbnN0IHVwZGF0ZUFjdGl2ZUl0ZW0gPSAobmV3SW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IHJlc3VsdHNFbC5xdWVyeVNlbGVjdG9yQWxsKCcubWVudS1pdGVtJyk7XHJcbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IG5ld0luZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5hZGRDbGFzcygncHJvcGVydHktc2VhcmNoLWlzLWFjdGl2ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc2Nyb2xsSW50b1ZpZXcoeyBibG9jazogJ25lYXJlc3QnIH0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLnJlbW92ZUNsYXNzKCdwcm9wZXJ0eS1zZWFyY2gtaXMtYWN0aXZlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBhY3RpdmVJbmRleCA9IG5ld0luZGV4O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IHNlbGVjdEFjdGl2ZUl0ZW0gPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChhY3RpdmVJbmRleCA+PSAwICYmIGFjdGl2ZUluZGV4IDwgZmlsdGVyZWRQcm9wZXJ0aWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgW25hbWUsIGluZm9dID0gZmlsdGVyZWRQcm9wZXJ0aWVzW2FjdGl2ZUluZGV4XTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzW3RoaXMuc2V0dGluZ3NQYXJhbWV0ZXJdW3Jvd0luZGV4XS5wcm9wZXJ0eSA9IG5hbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5nc1t0aGlzLnNldHRpbmdzUGFyYW1ldGVyXVtyb3dJbmRleF0udHlwZSA9IGluZm8udHlwZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzW3RoaXMuc2V0dGluZ3NQYXJhbWV0ZXJdW3Jvd0luZGV4XS52YWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclNlYXJjaFJlc3VsdHMoc2VhcmNoQ29udGFpbmVyRWwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5KCk7IC8vIFJlLXJlbmRlclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZmlsdGVyZWRQcm9wZXJ0aWVzLmZvckVhY2goKFtuYW1lLCBpbmZvXSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaXRlbUVsID0gcmVzdWx0c0VsLmNyZWF0ZURpdih7IGNsczogJ21lbnUtaXRlbScgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1JY29uID0gaXRlbUVsLmNyZWF0ZVNwYW4oeyBjbHM6ICdtZW51LWl0ZW0taWNvbicgfSk7XHJcbiAgICAgICAgICAgIHVwZGF0ZVByb3BlcnR5SWNvbihpdGVtSWNvbiwgaW5mby50eXBlKTtcclxuICAgICAgICAgICAgaXRlbUVsLmNyZWF0ZVNwYW4oeyB0ZXh0OiBuYW1lIH0pO1xyXG5cclxuICAgICAgICAgICAgaXRlbUVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGFzeW5jIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBhY3RpdmVJbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgc2VsZWN0QWN0aXZlSXRlbSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc2VhcmNoQ29udGFpbmVyRWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGFzeW5jIChlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gcmVzdWx0c0VsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5tZW51LWl0ZW0nKTtcclxuICAgICAgICAgICAgaWYgKGUua2V5ID09PSAnQXJyb3dEb3duJykge1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlQWN0aXZlSXRlbSgoYWN0aXZlSW5kZXggKyAxKSAlIGl0ZW1zLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5rZXkgPT09ICdBcnJvd1VwJykge1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlQWN0aXZlSXRlbSgoYWN0aXZlSW5kZXggLSAxICsgaXRlbXMubGVuZ3RoKSAlIGl0ZW1zLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5rZXkgPT09ICdFbnRlcicpIHtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHNlbGVjdEFjdGl2ZUl0ZW0oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyU2VhcmNoUmVzdWx0cyhzZWFyY2hDb250YWluZXJFbDogSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICBjb25zdCByZXN1bHRzRWwgPSBzZWFyY2hDb250YWluZXJFbC5xdWVyeVNlbGVjdG9yKCcucHJvcGVydHktc2VhcmNoLXJlc3VsdHMnKTtcclxuICAgICAgICBpZiAocmVzdWx0c0VsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHNFbC5yZW1vdmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyVmFsdWVJbnB1dChjb250YWluZXJFbDogSFRNTEVsZW1lbnQsIHByb3BlcnR5SW5mbzogUHJvcGVydHlJbmZvIHwgdW5kZWZpbmVkLCBjdXJyZW50VmFsdWU6IGFueSwgaW5kZXg6IG51bWJlcikge1xyXG4gICAgICAgIGxldCByZXR1cm5Db21wb25lbnQ7XHJcbiAgICAgICAgY29udGFpbmVyRWwuZW1wdHkoKTsgXHJcblxyXG4gICAgICAgIGlmICghcHJvcGVydHlJbmZvKSB7XHJcbiAgICAgICAgICAgICBjb250YWluZXJFbC5zZXRUZXh0KCcnKTtcclxuICAgICAgICAgICAgIGNvbnRhaW5lckVsLmFkZENsYXNzKCd0ZXh0LW11dGVkJyk7XHJcbiAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0eXBlID0gcHJvcGVydHlJbmZvLnR5cGU7XHJcblxyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50ID0gbmV3IFRleHRDb21wb25lbnQoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdOdW1lcmljIFZhbHVlJylcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUoY3VycmVudFZhbHVlICE9PSB1bmRlZmluZWQgJiYgY3VycmVudFZhbHVlICE9PSBudWxsID8gU3RyaW5nKGN1cnJlbnRWYWx1ZSkgOiAnJylcclxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG51bVZhbHVlID0gdmFsdWUgPT09ICcnID8gdW5kZWZpbmVkIDogcGFyc2VGbG9hdCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzW3RoaXMuc2V0dGluZ3NQYXJhbWV0ZXJdW2luZGV4XS52YWx1ZSA9IGlzTmFOKG51bVZhbHVlIGFzIG51bWJlcikgPyB1bmRlZmluZWQgOiBudW1WYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5Db21wb25lbnQuaW5wdXRFbC50eXBlID0gJ251bWJlcic7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50ID0gY29udGFpbmVyRWwuY3JlYXRlRGl2KHsgY2xzOiAndHJpLXN0YXRlLWNoZWNrYm94IGNsaWNrYWJsZS1pY29uJyB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybkNvbXBvbmVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCAnQ2hlY2tib3ggY2hhbmdlIHN0YXRlJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5Db21wb25lbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2NoZWNrYm94Jyk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlQ2hlY2tib3hWaXN1YWwgPSAoc3RhdGU6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaWNvbk5hbWU6IHN0cmluZztcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYXJpYVN0YXRlOiAndHJ1ZScgfCAnZmFsc2UnIHwgJ21peGVkJztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbk5hbWUgPSAnY2hlY2stc3F1YXJlJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJpYVN0YXRlID0gJ3RydWUnO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb25OYW1lID0gJ3NxdWFyZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyaWFTdGF0ZSA9ICdmYWxzZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gdW5kZWZpbmVkIG9yIG51bGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbk5hbWUgPSAnbWludXMtc3F1YXJlJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJpYVN0YXRlID0gJ21peGVkJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0SWNvbihyZXR1cm5Db21wb25lbnQsIGljb25OYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5Db21wb25lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnLCBhcmlhU3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkNvbXBvbmVudC5kYXRhc2V0LnN0YXRlID0gU3RyaW5nKHN0YXRlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgdXBkYXRlQ2hlY2tib3hWaXN1YWwoY3VycmVudFZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm5Db21wb25lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRTdGF0ZSA9IHJldHVybkNvbXBvbmVudC5kYXRhc2V0LnN0YXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0U3RhdGU6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGUgPT09ICdmYWxzZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gJ3RydWUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZSA9IHVuZGVmaW5lZDsgXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZSA9IGZhbHNlOyBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzW3RoaXMuc2V0dGluZ3NQYXJhbWV0ZXJdW2luZGV4XS52YWx1ZSA9IG5leHRTdGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ2hlY2tib3hWaXN1YWwobmV4dFN0YXRlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcclxuICAgICAgICAgICAgICAgIHJldHVybkNvbXBvbmVudCA9IG5ldyBUZXh0Q29tcG9uZW50KGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignWVlZWS1NTS1ERCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKGN1cnJlbnRWYWx1ZSB8fCAnJylcclxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzW3RoaXMuc2V0dGluZ3NQYXJhbWV0ZXJdW2luZGV4XS52YWx1ZSA9IHZhbHVlIHx8IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5Db21wb25lbnQuaW5wdXRFbC50eXBlID0gJ2RhdGUnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2RhdGV0aW1lJzpcclxuICAgICAgICAgICAgICAgIHJldHVybkNvbXBvbmVudCA9IG5ldyBUZXh0Q29tcG9uZW50KGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignWVlZWS1NTS1ERFRISDptbScpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKGN1cnJlbnRWYWx1ZSB8fCAnJylcclxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzW3RoaXMuc2V0dGluZ3NQYXJhbWV0ZXJdW2luZGV4XS52YWx1ZSA9IHZhbHVlIHx8IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5Db21wb25lbnQuaW5wdXRFbC50eXBlID0gJ2RhdGV0aW1lLWxvY2FsJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdhbGlhc2VzJzpcclxuICAgICAgICAgICAgY2FzZSAndGFncyc6XHJcbiAgICAgICAgICAgIGNhc2UgJ211bHRpdGV4dCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm5Db21wb25lbnQgPSBuZXcgVGV4dENvbXBvbmVudChjb250YWluZXJFbClcclxuICAgICAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ3ZhbHVlcyAoZGl2aWRlZCBieSBjb21tYSknKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShBcnJheS5pc0FycmF5KGN1cnJlbnRWYWx1ZSkgPyBjdXJyZW50VmFsdWUuam9pbignLCAnKSA6IChjdXJyZW50VmFsdWUgfHwgJycpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJyYXlWYWx1ZSA9IHZhbHVlLnNwbGl0KCcsJykubWFwKHMgPT4gcy50cmltKCkpLmZpbHRlcihzID0+IHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5nc1t0aGlzLnNldHRpbmdzUGFyYW1ldGVyXVtpbmRleF0udmFsdWUgPSBhcnJheVZhbHVlLmxlbmd0aCA+IDAgPyBhcnJheVZhbHVlIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICd0ZXh0JzpcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybkNvbXBvbmVudCA9IG5ldyBUZXh0Q29tcG9uZW50KGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcigndmFsdWUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShjdXJyZW50VmFsdWUgfHwgJycpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5nc1t0aGlzLnNldHRpbmdzUGFyYW1ldGVyXVtpbmRleF0udmFsdWUgPSB2YWx1ZSB8fCB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZSAhPT0gJ2NoZWNrYm94Jykge1xyXG4gICAgICAgICAgICByZXR1cm5Db21wb25lbnQuaW5wdXRFbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAndHJhbnNwYXJlbnQnOyAvLyBtYWtlIGl0IGludmlzaWJsZVxyXG4gICAgICAgICAgICByZXR1cm5Db21wb25lbnQuaW5wdXRFbC5zdHlsZS53aWR0aCA9ICcxMDAlJztcclxuICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50LmlucHV0RWwuc3R5bGUuYm9yZGVyID0gJ25vbmUnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0dXJuQ29tcG9uZW50O1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIHVwZGF0ZVByZXZpZXcoIHJ1bGUsIHByZXZpZXdDb21wb25lbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5hY3RpdmVGaWxlKSB7XHJcbiAgICAgICAgICAgIGxldCBydWxlUmVzdWx0O1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC5maWxlTWFuYWdlci5wcm9jZXNzRnJvbnRNYXR0ZXIodGhpcy5hY3RpdmVGaWxlLCBhc3luYyAoZnJvbnRtYXR0ZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIHJ1bGVSZXN1bHQgPSBhd2FpdCBleGVjdXRlUnVsZSgncHJldmlldycsdGhpcy5hcHAsIHRoaXMucGx1Z2luLnNldHRpbmdzLCB0aGlzLmFjdGl2ZUZpbGUsICcnLCBydWxlLCBmcm9udG1hdHRlcik7XHJcbiAgICAgICAgICAgIH0seydtdGltZSc6dGhpcy5hY3RpdmVGaWxlLnN0YXQubXRpbWV9KTsgIFxyXG5cclxuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgcnVsZVJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShydWxlUmVzdWx0KSkgcHJldmlld0NvbXBvbmVudC5pbnB1dEVsLnZhbHVlID0gcnVsZVJlc3VsdC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBwcmV2aWV3Q29tcG9uZW50LmlucHV0RWwudmFsdWUgPSBydWxlUmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjb21wb25lbnRFbC5zZXRUb29sdGlwKGNvbXBvbmVudEVsLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGFzeW5jIGRpc3BsYXkoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyRWwgPSB0aGlzLmNvbnRhaW5lcjtcclxuICAgICAgICBjb250YWluZXJFbC5lbXB0eSgpO1xyXG5cclxuICAgICAgICB0aGlzLmtub3duUHJvcGVydGllcyA9IGF3YWl0IHRoaXMudG9vbHMuZmV0Y2hLbm93blByb3BlcnRpZXModGhpcy5hcHApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMucHJvcGVydGllc0xpc3RFbCA9IGNvbnRhaW5lckVsLmNyZWF0ZURpdigncHJvcGVydGllcy1saXN0Jyk7XHJcblxyXG4gICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnJ1bGVzLmZvckVhY2goKHJ1bGUsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUHJvcGVydHlSb3codGhpcy5wcm9wZXJ0aWVzTGlzdEVsLCBydWxlLCBpbmRleCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGxldCBhY3RpdmVGaWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUZpbHRlckluZGljYXRvcihhY3RpdmVGaWxlLCB0aGlzLnByb3BlcnRpZXNMaXN0RWwpO1xyXG5cclxuICAgICAgICBjb25zdCBhZGRCdG5Db250YWluZXIgPSBjb250YWluZXJFbC5jcmVhdGVEaXYoeyBjbHM6ICdzZXR0aW5nLWl0ZW0tY29udHJvbCcgfSk7XHJcbiAgICAgICAgYWRkQnRuQ29udGFpbmVyLnN0eWxlLmp1c3RpZnlDb250ZW50ID0gJ3JpZ2h0JztcclxuICAgICAgICBuZXcgQnV0dG9uQ29tcG9uZW50KGFkZEJ0bkNvbnRhaW5lcilcclxuICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoJ0FkZCBQcm9wZXJ0eScpXHJcbiAgICAgICAgICAgIC5zZXRJY29uKCdwbHVzLWNpcmNsZScpXHJcbiAgICAgICAgICAgIC5zZXRDdGEoKVxyXG4gICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0TmFtZSA9ICcnOyAvL09iamVjdC5rZXlzKHRoaXMua25vd25Qcm9wZXJ0aWVzKVswXSB8fCAnJztcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMucGx1Z2luLnNldHRpbmdzW3RoaXMuc2V0dGluZ3NQYXJhbWV0ZXJdLnB1c2goeyBuYW1lOiBkZWZhdWx0TmFtZSwgdmFsdWU6IHVuZGVmaW5lZCB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzW3RoaXMuc2V0dGluZ3NQYXJhbWV0ZXJdLnB1c2goT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9SVUxFX0RFRklOSVRJT04sIHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogcmFuZG9tVVVJRCgpLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheSgpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYnV0dG9uRWwuY2xhc3NOYW1lPSdwcm9wZXJ0eS1wbHVzLWJ1dHRvbic7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB1cGRhdGVGaWx0ZXJJbmRpY2F0b3IoYWN0aXZlRmlsZSwgcHJvcGVydGllc0xpc3RFbDogSFRNTERpdkVsZW1lbnQpIHtcclxuICAgICAgICBpZiAoYWN0aXZlRmlsZSkge1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5ydWxlcy5mb3JFYWNoKChydWxlLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHlSb3dFbCA9IHByb3BlcnRpZXNMaXN0RWwuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgncHJvcGVydHktc2V0dGluZy1yb3cnKVtpbmRleF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eUxlZnREaXYgPSBwcm9wZXJ0eVJvd0VsLnF1ZXJ5U2VsZWN0b3IoJy5wcm9wZXJ0eS1sZWZ0LWNvbnRhaW5lcicpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrSWZGaWxlQWxsb3dlZChhY3RpdmVGaWxlLCB0aGlzLnBsdWdpbi5zZXR0aW5ncywgcnVsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eUxlZnREaXY/LmFkZENsYXNzKCdwcm9wZXJ0eS1sZWZ0LWNvbnRhaW5lci1hbGxvd2VkJyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5TGVmdERpdj8ucmVtb3ZlQ2xhc3MoJ3Byb3BlcnR5LWxlZnQtY29udGFpbmVyLWFsbG93ZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsICJcclxuaW1wb3J0IHsgQXBwLCBNb2RhbCwgU2V0dGluZywgVEFic3RyYWN0RmlsZSwgVEZpbGUsIFRGb2xkZXIsIFZhdWx0LCBzZXRJY29uLEJ1dHRvbkNvbXBvbmVudCwgVGV4dENvbXBvbmVudCwgQ29uc3RydWN0b3IgfSBmcm9tICdvYnNpZGlhbic7IC8vIEFkZGVkIHNldEljb25cclxuLy9pbXBvcnQgJ2NvZGVtaXJyb3IvbW9kZS9qYXZhc2NyaXB0L2phdmFzY3JpcHQnO1xyXG5pbXBvcnQgeyBPYnNpZGlhblByb3BlcnR5VHlwZXMgfSBmcm9tICcuL3R5cGVzJztcclxuaW1wb3J0IHsgcGFyc2VKU0NvZGUsIFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSAnLi90b29scyc7XHJcbmltcG9ydCB7IHVwZGF0ZVByb3BlcnR5SWNvbiB9IGZyb20gJy4vdWlFbGVtZW50cyc7XHJcbi8vaW1wb3J0IHsgY2hkaXIgfSBmcm9tICdub2RlOnByb2Nlc3MnO1xyXG4vL2ltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcclxuLy9pbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcclxuXHJcblxyXG4vLyBEZWZpbmUgdGhlIHJlc3VsdCBzdHJ1Y3R1cmUgcmV0dXJuZWQgYnkgdGhlIG1vZGFsXHJcbmV4cG9ydCBpbnRlcmZhY2UgY29kZUVkaXRvck1vZGFsUmVzdWx0IHtcclxuICAgIGNvZGU6IHN0cmluZztcclxuICAgIHR5cGU6IE9ic2lkaWFuUHJvcGVydHlUeXBlcztcclxuICAgIGNoZWNrZWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBPYnNpZGlhbiBNb2RhbCBmb3Igc2VsZWN0aW5nIGRpcmVjdG9yaWVzIGFuZCBmaWxlcyBmcm9tIHRoZSB2YXVsdCBzdHJ1Y3R1cmUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgY29kZUVkaXRvck1vZGFsIGV4dGVuZHMgTW9kYWwge1xyXG4gICAgLy8gSW5pdGlhbCBzdGF0ZSBwYXNzZWQgdG8gdGhlIG1vZGFsIChzdG9yZWQgZm9yIHJlc2V0IGZ1bmN0aW9uYWxpdHkpXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IGluaXRpYWxDb2RlOiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IG9rQ2FsbGJhY2s6IChyZXN1bHQ6IGNvZGVFZGl0b3JNb2RhbFJlc3VsdCB8IG51bGwpID0+IHZvaWQ7XHJcbiAgICBwcml2YXRlIHNjcmlwdGluZ1Rvb2xzOiBTY3JpcHRpbmdUb29scztcclxuICAgIHByaXZhdGUgcGx1Z2luOiBhbnk7XHJcblxyXG4gICAgLy8gQ3VycmVudCBzdGF0ZSBiZWluZyBtb2RpZmllZCB3aXRoaW4gdGhlIG1vZGFsXHJcbiAgICBwcml2YXRlIGN1cnJlbnRDb2RlOiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIGV4cGVjdGVkVHlwZTogT2JzaWRpYW5Qcm9wZXJ0eVR5cGVzO1xyXG4gICAgcHJpdmF0ZSBjdXJyZW50VHlwZTogT2JzaWRpYW5Qcm9wZXJ0eVR5cGVzO1xyXG4gICAgcHJpdmF0ZSBjaGVja2VkU3VjY2Vzc2Z1bGx5IDogYm9vbGVhbjtcclxuICAgIHByaXZhdGUgdXNlVGV4dEFyZWEgOiBib29sZWFuO1xyXG4gICAgcHJpdmF0ZSBhY3RpdmVGaWxlOiBURmlsZSB8IFRGb2xkZXIgfCBudWxsXHJcbiAgICBwcml2YXRlIGZyb250bWF0dGVyOiBhbnk7IC8vIEZyb250bWF0dGVyIGRhdGEgZm9yIHRoZSBhY3RpdmUgZmlsZVxyXG5cclxuICAgIC8vIFVJIEVsZW1lbnRzXHJcbiAgICBwcml2YXRlIGVkaXRvclJvb3RFbGVtZW50OiBIVE1MRWxlbWVudDtcclxuICAgIHByaXZhdGUgZnVuY3Rpb25UZXN0QnV0dG9uOiBCdXR0b25Db21wb25lbnQ7XHJcbiAgICBwcml2YXRlIGZ1bmN0aW9uUmVzdWx0VGV4dENvbXBvbmVudDogVGV4dENvbXBvbmVudCB8IHVuZGVmaW5lZDtcclxuICAgIHByaXZhdGUgY21FZGl0b3I6IENvZGVNaXJyb3IuRWRpdG9yIHwgbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhlIERpcmVjdG9yeVNlbGVjdGlvbk1vZGFsLlxyXG4gICAgICogQHBhcmFtIGFwcCAtIFRoZSBPYnNpZGlhbiBBcHAgaW5zdGFuY2UuXHJcbiAgICAgKiBAcGFyYW0gcGx1Z2luIC0gVGhlIHBsdWdpbiBpbnN0YW5jZS5cclxuICAgICAqIEBwYXJhbSBpbml0aWFsQ29kZSAtIFN0cmluZyB3aXRoIHRoZSBpbml0aWFsIGNvZGUuXHJcbiAgICAgKiBAcGFyYW0gZXhwZWN0ZWRUeXBlIC0gRXhwZWN0ZWQgcmV0dXJuIHR5cGUuXHJcbiAgICAgKiBAcGFyYW0gYWN0aXZlRmlsZSAtIFRoZSBjdXJyZW50bHkgYWN0aXZlIGZpbGUgb3IgZm9sZGVyLlxyXG4gICAgICogQHBhcmFtIGZyb250bWF0dGVyIC0gRnJvbnRtYXR0ZXIgZGF0YSBmb3IgdGhlIGFjdGl2ZSBmaWxlLlxyXG4gICAgICogQHBhcmFtIG9rQ2FsbGJhY2sgLSBGdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHVzZXIgY2xpY2tzIFwiT0tcIi4gUmVjZWl2ZXMgdGhlIHNlbGVjdGlvbiByZXN1bHQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIGFwcDogQXBwLFxyXG4gICAgICAgIHBsdWdpbjogYW55LFxyXG4gICAgICAgIGluaXRpYWxDb2RlOiBzdHJpbmcsXHJcbiAgICAgICAgZXhwZWN0ZWRUeXBlOiBPYnNpZGlhblByb3BlcnR5VHlwZXMsXHJcbiAgICAgICAgYWN0aXZlRmlsZTogVEZpbGUgfCBURm9sZGVyIHwgbnVsbCxcclxuICAgICAgICBmcm9udG1hdHRlcjogYW55LCAgIFxyXG4gICAgICAgIG9rQ2FsbGJhY2s6IChyZXN1bHQ6IGNvZGVFZGl0b3JNb2RhbFJlc3VsdCB8IG51bGwpID0+IHZvaWRcclxuICAgICkge1xyXG4gICAgICAgIHN1cGVyKGFwcCk7XHJcbiAgICAgICAgLy8gU3RvcmUgaW5pdGlhbCBzdGF0ZSBmb3IgcmVzZXRcclxuICAgICAgICB0aGlzLmluaXRpYWxDb2RlID0gaW5pdGlhbENvZGU7XHJcbiAgICAgICAgdGhpcy5leHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGU7XHJcbiAgICAgICAgdGhpcy51c2VUZXh0QXJlYSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY2hlY2tlZFN1Y2Nlc3NmdWxseSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRmlsZSA9IGFjdGl2ZUZpbGU7XHJcbiAgICAgICAgdGhpcy5mcm9udG1hdHRlciA9IGZyb250bWF0dGVyOyAvLyBTdG9yZSBmcm9udG1hdHRlciBkYXRhXHJcbiAgICAgICAgdGhpcy5jdXJyZW50VHlwZSA9IGV4cGVjdGVkVHlwZTsgLy8gSW5pdGlhbGl6ZSBjdXJyZW50IHR5cGUgdG8gZXhwZWN0ZWQgdHlwZVxyXG4gICAgICAgIHRoaXMuY3VycmVudENvZGUgPSBpbml0aWFsQ29kZTsgLy8gSW5pdGlhbGl6ZSBjdXJyZW50IGNvZGUgdG8gaW5pdGlhbCBjb2RlXHJcblxyXG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG4gICAgICAgIHRoaXMuc2NyaXB0aW5nVG9vbHM9IG5ldyBTY3JpcHRpbmdUb29scyhhcHAsIHRoaXMucGx1Z2luLCB0aGlzLmZyb250bWF0dGVyKTtcclxuICAgICAgICB0aGlzLm9rQ2FsbGJhY2sgPSBva0NhbGxiYWNrO1xyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXplIGN1cnJlbnQgc3RhdGUgZnJvbSBpbml0aWFsIHN0YXRlIGZvciBlZGl0aW5nXHJcbiAgICAgICAgdGhpcy5yZXNldFNlbGVjdGlvblRvSW5pdGlhbCgpOyAvLyBVc2UgYSBtZXRob2QgZm9yIGluaXRpYWxpemF0aW9uIGFuZCByZXNldFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBzdGF0ZSB0byB0aGUgaW5pdGlhbCBzdGF0ZSBwcm92aWRlZCBhdCBjb25zdHJ1Y3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVzZXRTZWxlY3Rpb25Ub0luaXRpYWwoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Q29kZSA9IHRoaXMuaW5pdGlhbENvZGU7XHJcbiAgICAgICAgdGhpcy5jbUVkaXRvcj8uc2V0VmFsdWUodGhpcy5jdXJyZW50Q29kZSk7IC8vIFNldCB0aGUgaW5pdGlhbCBjb2RlIGluIHRoZSBlZGl0b3JcclxuICAgICAgICBpZiAodGhpcy5mdW5jdGlvblJlc3VsdFRleHRDb21wb25lbnQpIHRoaXMuZnVuY3Rpb25SZXN1bHRUZXh0Q29tcG9uZW50LnNldFZhbHVlKCcnKTsgLy8gQ2xlYXIgdGhlIHJlc3VsdCB0ZXh0IGNvbXBvbmVudFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBzdGF0ZSB0byBlbXB0eS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZXNldFNlbGVjdGlvblRvRW1wdHkoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Q29kZSA9IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBsZXQgcmVzdWx0ID0gJyc7XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIjtcclxuICAgICAgICB0aGlzLmNtRWRpdG9yPy5zZXRWYWx1ZSh0aGlzLmN1cnJlbnRDb2RlKTsgLy8gU2V0IHRoZSBpbml0aWFsIGNvZGUgaW4gdGhlIGVkaXRvclxyXG4gICAgICAgIGlmICh0aGlzLmZ1bmN0aW9uUmVzdWx0VGV4dENvbXBvbmVudCkgdGhpcy5mdW5jdGlvblJlc3VsdFRleHRDb21wb25lbnQuc2V0VmFsdWUoJycpOyAvLyBDbGVhciB0aGUgcmVzdWx0IHRleHQgY29tcG9uZW50IFxyXG4gICAgfVxyXG5cclxuICAgIGxvYWRDb2RlTWlycm9yTW9kZShtb2RlOiBzdHJpbmcpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgLy8gVmVyd2VuZGUgcmVxdWlyZSAoa1x1MDBGNm5udGUgaW4genVrXHUwMEZDbmZ0aWdlbiBWZXJzaW9uZW4gd2VuaWdlciB6dXZlcmxcdTAwRTRzc2lnIHNlaW4pXHJcbiAgICAgICAgICByZXF1aXJlKGBvYnNpZGlhbi9saWIvY29kZW1pcnJvci9tb2RlLyR7bW9kZX0vJHttb2RlfS5qc2ApO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYENvZGVNaXJyb3IgbW9kZSAnJHttb2RlfScgbG9hZGVkIHN1Y2Nlc3NmdWxseSAodXNpbmcgcmVxdWlyZSkuYCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBsb2FkIENvZGVNaXJyb3IgbW9kZSAnJHttb2RlfScgKHVzaW5nIHJlcXVpcmUpOmAsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBtb2RhbCBpcyBvcGVuZWQuIEJ1aWxkcyB0aGUgVUkuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIG9uT3BlbigpIHtcclxuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcclxuICAgICAgICBpZiAoY29udGVudEVsLnBhcmVudEVsZW1lbnQpIGNvbnRlbnRFbC5wYXJlbnRFbGVtZW50LnN0eWxlLndpZHRoID0gJzkwMHB4JztcclxuICAgICAgICBjb250ZW50RWwuZW1wdHkoKTsgLy8gQ2xlYXIgcHJldmlvdXMgXHJcbiAgICAgICAgY29udGVudEVsLmFkZENsYXNzKCdjb2RlRWRpdG9yLW1vZGFsJyk7IFxyXG5cclxuICAgICAgICAvLyAtLS0gTW9kYWwgVGl0bGUgLS0tXHJcbiAgICAgICAgY29udGVudEVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ0phdmFTY3JpcHQgRWRpdG9yJyB9KTsgICAgXHJcbiAgICAgICAgY29udGVudEVsLmNyZWF0ZUVsKCdib2R5JywgeyB0ZXh0OiBgTWFrZSBzdXJlIHlvdXIgY29kZSByZXN1bHRzOiAke3RoaXMuZXhwZWN0ZWRUeXBlfWAgfSk7IFxyXG5cclxuICAgICAgICAvLyAtLS0gVHJlZSBDb250YWluZXIgLS0tXHJcbiAgICAgICAgdGhpcy5lZGl0b3JSb290RWxlbWVudCA9IGNvbnRlbnRFbC5jcmVhdGVEaXYoeyBjbHM6ICdjb2RlRWRpdG9yLWNvbnRhaW5lcicgfSk7XHJcbiAgICAgICAgLy8gQmFzaWMgc3R5bGluZyBmb3IgdGhlIHNjcm9sbGFibGUgdHJlZSBhcmVhXHJcbiAgICAgICAgLy8gdGhpcy5lZGl0b3JSb290RWxlbWVudC5zdHlsZS53aWR0aCA9ICc2MDBweCc7XHJcbiAgICAgICAgdGhpcy5lZGl0b3JSb290RWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnNjAwcHgnO1xyXG4gICAgICAgIHRoaXMuZWRpdG9yUm9vdEVsZW1lbnQuc3R5bGUub3ZlcmZsb3dZID0gJ2F1dG8nO1xyXG4gICAgICAgIC8vdGhpcy5lZGl0b3JSb290RWxlbWVudC5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkIHZhcigtLWJhY2tncm91bmQtbW9kaWZpZXItYm9yZGVyKSc7XHJcbiAgICAgICAgdGhpcy5lZGl0b3JSb290RWxlbWVudC5zdHlsZS5wYWRkaW5nID0gJzEwcHgnO1xyXG4gICAgICAgIHRoaXMuZWRpdG9yUm9vdEVsZW1lbnQuc3R5bGUubWFyZ2luVG9wID0gJzEwcHgnO1xyXG4gICAgICAgIHRoaXMuZWRpdG9yUm9vdEVsZW1lbnQuc3R5bGUubWFyZ2luQm90dG9tID0gJzEwcHgnO1xyXG5cclxuICAgICAgICB0aGlzLmNtRWRpdG9yID0gbnVsbDtcclxuXHJcbiAgICAgICAgY29uc3QgcnVsZU9wdGlvbnNEaXYgPSBjb250ZW50RWwuY3JlYXRlRGl2KHsgY2xzOiBcImNvZGVFZGl0b3Itb3B0aW9uc1wiIH0pO1xyXG5cclxuICAgICAgICBpZiAodGhpcy51c2VUZXh0QXJlYSkge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlT3B0aW9uc1NldHRpbmdzID0gbmV3IFNldHRpbmcodGhpcy5lZGl0b3JSb290RWxlbWVudClcclxuICAgICAgICAgICAgICAgIC5hZGRUZXh0QXJlYSh0ZXh0QXJlYSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFyZWEuc2V0UGxhY2Vob2xkZXIoJ2VuZGVyIHZhbGlkIEpTIENvZGUnKTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0QXJlYS5pbnB1dEVsLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBgaGVpZ2h0OjE5MHB4OyB3aWR0aDo4MCU7YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFyZWEub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZ1bmN0aW9uVGVzdEJ1dHRvbikgdGhpcy5mdW5jdGlvblRlc3RCdXR0b24uYnV0dG9uRWwuYWRkQ2xhc3MoJ21vZC13YXJuaW5nJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENvZGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICBsZXQgdmlldyA9IG5ldyBFZGl0b3JWaWV3KHtcclxuICAgICAgICAgICAgICAgIHN0YXRlOiBFZGl0b3JTdGF0ZS5jcmVhdGUoe1xyXG4gICAgICAgICAgICAgICAgICBkb2M6IHRoaXMuY3VycmVudENvZGUsICAvLyBvciBzb21lIHN0cmluZyBjb250ZW50c1xyXG4gICAgICAgICAgICAgICAgICBleHRlbnNpb25zOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgRWRpdG9yVmlldy5saW5lV3JhcHBpbmcsIC8vIEFkZCB5b3VyIGV4dGVudGlvbnMgaGVyZVxyXG4gICAgICAgICAgICAgICAgICAgIGphdmFzY3JpcHQoKSxcclxuICAgICAgICAgICAgICAgICAgICAvLyBzY2VuZUd1dHRlciwgLy8gb3IgbGVhdmUgZW1wdHkgZm9yIGJhc2ljIGVkaXRvclxyXG4gICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IHRoaXMuZWRpdG9yUm9vdEVsZW1lbnRcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBDb2RlTWlycm9yIDVcclxuICAgICAgICAgICAgLy8gQ29kZU1pcnJvci1CaWJsaW90aGVrIGFicnVmZW5cclxuICAgICAgICAgICAgY29uc3QgQ29kZU1pcnJvciA9ICh3aW5kb3cgYXMgYW55KS5Db2RlTWlycm9yO1xyXG4gICAgICAgICAgICAvLyBTaWNoZXJzdGVsbGVuLCBkYXNzIENvZGVNaXJyb3IgZ2VsYWRlbiBpc3RcclxuICAgICAgICAgICAgaWYgKENvZGVNaXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIC8vIEphdmFTY3JpcHQtTW9kdXMgbGFkZW4gKGZhbGxzIG5vY2ggbmljaHQgZ2VsYWRlbilcclxuICAgICAgICAgICAgICAgIGlmICghQ29kZU1pcnJvci5tb2Rlcy5qYXZhc2NyaXB0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5sb2FkQ29kZU1pcnJvck1vZGUoJ2phdmFzY3JpcHQnKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnamF2YVNjcmlwdCBzdXBwb3J0IGxvYWRlZCcpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIGxldCBqc0NvZGUgPSB0aGlzLmN1cnJlbnRDb2RlO1xyXG4gICAgICAgICAgICB0aGlzLmNtRWRpdG9yID0gQ29kZU1pcnJvcih0aGlzLmVkaXRvclJvb3RFbGVtZW50LCB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZToganNDb2RlIHx8IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBsZXQgcmVzdWx0ID0gJyc7XFxuICByZXR1cm4gcmVzdWx0OyAvLyByZXR1cm4geW91IHJlc3VsdC5cXG59XCIsXHJcbiAgICAgICAgICAgICAgICBtb2RlOiBcImphdmFzY3JpcHRcIixcclxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXJzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgdGhlbWU6IFwib2JzaWRpYW5cIixcclxuICAgICAgICAgICAgICAgIGluZGVudFVuaXQ6IDQsICBcclxuICAgICAgICAgICAgICAgIGxpbmVXcmFwcGluZzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICByZWFkT25seTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBvdXRlckhlaWdodDogJzYwMHB4JyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAodGhpcy5jbUVkaXRvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbUVkaXRvci5vbignY2hhbmdlJywgKGNtRWRpdG9yOiBDb2RlTWlycm9yLkVkaXRvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZ1bmN0aW9uVGVzdEJ1dHRvbikgdGhpcy5mdW5jdGlvblRlc3RCdXR0b24uYnV0dG9uRWwuYWRkQ2xhc3MoJ21vZC13YXJuaW5nJyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY21FZGl0b3Iub24oJ2JsdXInLCAoY21FZGl0b3I6IENvZGVNaXJyb3IuRWRpdG9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29kZT0gY21FZGl0b3IuZ2V0VmFsdWUoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBBZGQgYSBidXR0b24gdG8gc2F2ZSB0aGUgY29kZVxyXG4gICAgICAgICAgICBuZXcgU2V0dGluZyhydWxlT3B0aW9uc0RpdilcclxuICAgICAgICAgICAgICAgIC5hZGRCdXR0b24oKGJ1dHRvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnVuY3Rpb25UZXN0QnV0dG9uID0gYnV0dG9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRXYXJuaW5nKClcclxuICAgICAgICAgICAgICAgICAgICAuc2V0QnV0dG9uVGV4dChcIlJ1biBDb2RlXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoXCJSdW4gdGhlIGNvZGUgYW5kIGNoZWNrIGZvciBlcnJvcnNcIilcclxuICAgICAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNtRWRpdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQganNDb2RlID0gdGhpcy5jbUVkaXRvci5nZXRWYWx1ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB1c2VyRnVuY3Rpb24gPSAgcGFyc2VKU0NvZGUoanNDb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdXNlckZ1bmN0aW9uID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlcnJvckhpbnQgPSBcIlNlZSBjb25zb2xlIGZvciBkZXRhaWxzIVwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VyRnVuY3Rpb24uY29udGFpbnMoJ1VuZXhwZWN0ZWQgdG9rZW4nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckhpbnQgPSBcIkRpZCB5b3UgbWlzc2VkIGEgc2VtaWNvbG9uICg7KT9cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZnVuY3Rpb25SZXN1bHRUZXh0Q29tcG9uZW50KSB0aGlzLmZ1bmN0aW9uUmVzdWx0VGV4dENvbXBvbmVudC5zZXRWYWx1ZShgU3ludGF4IGVycm9yOiAke3VzZXJGdW5jdGlvbn0hICR7ZXJyb3JIaW50fWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tlZFN1Y2Nlc3NmdWxseSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5idXR0b25FbC5hZGRDbGFzcygnbW9kLXdhcm5pbmcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdXNlckZ1bmN0aW9uKHRoaXMuYXBwLCB0aGlzLmFjdGl2ZUZpbGUsIHRoaXMuc2NyaXB0aW5nVG9vbHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mdW5jdGlvblJlc3VsdFRleHRDb21wb25lbnQpIHRoaXMuZnVuY3Rpb25SZXN1bHRUZXh0Q29tcG9uZW50LnNldFZhbHVlKGAnJHtyZXN1bHQudG9TdHJpbmcoKX0nICgke3R5cGVvZiByZXN1bHR9KWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUeXBlSWNvbnMocmVzdWx0LCB0eXBlc0NvbnRhaW5lciwgdGhpcy5leHBlY3RlZFR5cGUsIHRoaXMuY3VycmVudFR5cGUsIHRoaXMucGx1Z2luLnNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5idXR0b25FbC5yZW1vdmVDbGFzcygnbW9kLXdhcm5pbmcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tlZFN1Y2Nlc3NmdWxseSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZ1bmN0aW9uUmVzdWx0VGV4dENvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnVuY3Rpb25SZXN1bHRUZXh0Q29tcG9uZW50LnNldFZhbHVlKGBTeW50YXggZXJyb3I6ICR7ZS5tZXNzYWdlfSEgU2VlIGNvbnNvbGUgZm9yIGRldGFpbHMhYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiU3ludGF4IGVycm9yLiBcIiwgZSwganNDb2RlLCB1c2VyRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja2VkU3VjY2Vzc2Z1bGx5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b24uYnV0dG9uRWwuYWRkQ2xhc3MoJ21vZC13YXJuaW5nJyk7ICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcInN5bnRheCBlcnJvclwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja2VkU3VjY2Vzc2Z1bGx5ID0gZmFsc2U7ICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYWRkVGV4dCgodGV4dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnVuY3Rpb25SZXN1bHRUZXh0Q29tcG9uZW50ID0gdGV4dDtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdmdW5jdGlvbiByZXN1bHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXREaXNhYmxlZCh0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnVuY3Rpb25SZXN1bHRUZXh0Q29tcG9uZW50LmlucHV0RWwuc3R5bGUud2lkdGggPSAnNTgwcHgnO1xyXG5cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlc0NvbnRhaW5lciA9IHJ1bGVPcHRpb25zRGl2LmNyZWF0ZURpdih7IGNsczogJ3Byb3BlcnR5LWljb25zLWNvbnRhaW5lcicgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIC0tLSBBY3Rpb24gQnV0dG9ucyAtLS1cclxuICAgICAgICB0aGlzLmNyZWF0ZUFjdGlvbkJ1dHRvbnMoY29udGVudEVsKTsgLy8gQ3JlYXRlIE9LIGFuZCBSZXNldCBidXR0b25zXHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlVHlwZUljb25zKHZhbHVlOmFueSwgY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCwgZXhwZWN0ZWRUeXBlOiBPYnNpZGlhblByb3BlcnR5VHlwZXMsIGN1cnJlbnRUeXBlOiBPYnNpZGlhblByb3BlcnR5VHlwZXMsIHNldHRpbmdzOiBhbnkpIHtcclxuICAgICAgICBjb25zdCBuZXdUeXBlID0gdHlwZW9mIHZhbHVlO1xyXG4gICAgICAgIGNvbnN0IHR5cGVJY29uczoge1trZXk6c3RyaW5nXTogT2JzaWRpYW5Qcm9wZXJ0eVR5cGVzW119ID0ge1xyXG4gICAgICAgICAgICAnc3RyaW5nJzogWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnLCdkYXRlJywgJ2RhdGV0aW1lJ10sXHJcbiAgICAgICAgICAgICdudW1iZXInOiBbJ251bWJlciddLFxyXG4gICAgICAgICAgICAnYm9vbGVhbic6IFsnY2hlY2tib3gnXSxcclxuICAgICAgICAgICAgJ29iamVjdCc6IFsndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAobmV3VHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnNjcmlwdGluZ1Rvb2xzLmlzSVNPU3RyaW5nKHZhbHVlLCB7d2l0aERhdGU6IHRydWV9KSkge1xyXG4gICAgICAgICAgICAgICAgdHlwZUljb25zW25ld1R5cGVdLnNwbGljZSh0eXBlSWNvbnNbbmV3VHlwZV0uaW5kZXhPZignZGF0ZScpLCAxKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIGRhdGUgZm9ybWF0OlwiLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLnNjcmlwdGluZ1Rvb2xzLmlzSVNPU3RyaW5nKHZhbHVlLCB7d2l0aERhdGU6IHRydWUsIHdpdGhUaW1lOiB0cnVlfSkpIHtcclxuICAgICAgICAgICAgICAgIHR5cGVJY29uc1tuZXdUeXBlXS5zcGxpY2UodHlwZUljb25zW25ld1R5cGVdLmluZGV4T2YoJ2RhdGV0aW1lJyksIDEpOyBcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIGRhdGUgZm9ybWF0OlwiLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGFpbmVyLmVtcHR5KCk7IC8vIENsZWFyIHRoZSBjb250YWluZXIgYmVmb3JlIGFkZGluZyBuZXcgaWNvbnNcclxuICAgICAgICBmb3IgKGxldCBvYnNpZGlhblR5cGUgb2YgdHlwZUljb25zW25ld1R5cGVdKSB7XHJcbiAgICAgICAgICAgIGlmIChvYnNpZGlhblR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGljb25FbCA9IGNvbnRhaW5lci5jcmVhdGVTcGFuKHsgY2xzOiAncHJvcGVydHktaWNvbiBzZXR0aW5nLWl0ZW0taWNvbicgfSk7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVQcm9wZXJ0eUljb24oaWNvbkVsLCBvYnNpZGlhblR5cGUpOyAvLyBVcGRhdGUgdGhlIGljb24gYmFzZWQgb24gdGhlIHR5cGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIFwiT0tcIiBhbmQgXCJSZXNldFwiIGJ1dHRvbnMuXHJcbiAgICAgKiBAcGFyYW0gY29udGFpbmVyRWwgLSBUaGUgSFRNTCBlbGVtZW50IHRvIGFwcGVuZCB0aGUgYnV0dG9ucyB0by5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjcmVhdGVBY3Rpb25CdXR0b25zKGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGJ1dHRvbnNFbCA9IGNvbnRhaW5lckVsLmNyZWF0ZURpdih7IGNsczogJ21vZGFsLWJ1dHRvbnMnIH0pO1xyXG4gICAgICAgIGJ1dHRvbnNFbC5zdHlsZS5tYXJnaW5Ub3AgPSAnMTVweCc7XHJcbiAgICAgICAgYnV0dG9uc0VsLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7IC8vIFVzZSBmbGV4IGZvciBhbGlnbm1lbnRcclxuICAgICAgICBidXR0b25zRWwuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSAnZmxleC1lbmQnOyAvLyBBbGlnbiBidXR0b25zIHRvIHRoZSByaWdodFxyXG4gICAgICAgIGJ1dHRvbnNFbC5zdHlsZS5nYXAgPSAnMTBweCc7IC8vIFNwYWNlIGJldHdlZW4gYnV0dG9uc1xyXG5cclxuICAgICAgICAvLyBSZXNldCBCdXR0b24gKFVuZG8gXHUyMUFBXHVGRTBGKVxyXG4gICAgICAgIGNvbnN0IHJlc2V0QnV0dG9uID0gYnV0dG9uc0VsLmNyZWF0ZUVsKCdidXR0b24nKTtcclxuICAgICAgICAvLyBVc2UgT2JzaWRpYW4ncyBzZXRJY29uIGZvciBjb25zaXN0ZW5jeSwgb3IgdXNlIHRleHRcclxuICAgICAgICBzZXRJY29uKHJlc2V0QnV0dG9uLCAncmVzZXQnKTsgLy8gVXNlIGEgc3VpdGFibGUgaWNvbiBsaWtlICdyZXNldCcgb3IgJ3VuZG8nXHJcbiAgICAgICAgcmVzZXRCdXR0b24uYXJpYUxhYmVsID0gJ1Jlc2V0IHNlbGVjdGlvbic7IC8vIEFjY2Vzc2liaWxpdHlcclxuICAgICAgICByZXNldEJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlc2V0U2VsZWN0aW9uVG9Jbml0aWFsKCk7IC8vIFJlc2V0IGludGVybmFsIHN0YXRlXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gQ2xlYXIgQnV0dG9uIChDbGVhciBcdUQ4M0RcdURFQUUpXHJcbiAgICAgICAgY29uc3QgZW1wdHlCdXR0b24gPSBidXR0b25zRWwuY3JlYXRlRWwoJ2J1dHRvbicpO1xyXG4gICAgICAgIC8vIFVzZSBPYnNpZGlhbidzIHNldEljb24gZm9yIGNvbnNpc3RlbmN5LCBvciB1c2UgdGV4dFxyXG4gICAgICAgIHNldEljb24oZW1wdHlCdXR0b24sICdlcmFzZXInKTsgLy8gVXNlIGEgc3VpdGFibGUgaWNvbiBsaWtlICdyZXNldCcgb3IgJ3VuZG8nXHJcbiAgICAgICAgZW1wdHlCdXR0b24uYXJpYUxhYmVsID0gJ0NsZWFyIHNlbGVjdGlvbic7IC8vIEFjY2Vzc2liaWxpdHlcclxuICAgICAgICBlbXB0eUJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlc2V0U2VsZWN0aW9uVG9FbXB0eSgpOyAvLyBDbGVhciBzdGF0ZVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIGNhbmNlbCBCdXR0b25cclxuICAgICAgICBjb25zdCBjYW5jZWxCdXR0b24gPSBidXR0b25zRWwuY3JlYXRlRWwoJ2J1dHRvbicsIHsgdGV4dDogJ0NhbmNlbCcgfSk7XHJcbiAgICAgICAgY2FuY2VsQnV0dG9uLmFyaWFMYWJlbCA9ICdjbG9zZSBhbmQgZGlzY2FyZCBjaGFuZ2VzJzsgLy8gQWNjZXNzaWJpbGl0eVxyXG4gICAgICAgIGNhbmNlbEJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNhbmNlbCBDbGlja2VkIC0gUmV0dXJuaW5nXCIpOyAvLyBEZWJ1ZyBsb2dcclxuICAgICAgICAgICAgdGhpcy5va0NhbGxiYWNrKCBudWxsICk7IC8vIFBhc3MgdGhlIGZpbmFsIHNlbGVjdGlvbiBiYWNrXHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBPSyBCdXR0b25cclxuICAgICAgICBjb25zdCBva0J1dHRvbiA9IGJ1dHRvbnNFbC5jcmVhdGVFbCgnYnV0dG9uJywgeyB0ZXh0OiAnT0snLCBjbHM6ICdtb2QtY3RhJyB9KTtcclxuICAgICAgICBjYW5jZWxCdXR0b24uYXJpYUxhYmVsID0gJ2Nsb3NlIGFuZCBzYXZlIGNoYW5nZXMnOyAvLyBBY2Nlc3NpYmlsaXR5XHJcbiAgICAgICAgb2tCdXR0b24ub25jbGljayA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBtb2RhbCBpcyBjbG9zZWQuIENsZWFucyB1cCByZXNvdXJjZXMuXHJcbiAgICAgKi9cclxuICAgIG9uQ2xvc2UoKSB7XHJcbiAgICAgICAgLy8gR2F0aGVyIHRoZSBmaW5hbCBzdGF0ZSBPTkxZIHdoZW4gT0sgaXMgY2xpY2tlZFxyXG4gICAgICAgIGNvbnN0IHJlc3VsdDogY29kZUVkaXRvck1vZGFsUmVzdWx0ID0ge1xyXG4gICAgICAgICAgICBjb2RlOiB0aGlzLmN1cnJlbnRDb2RlLFxyXG4gICAgICAgICAgICBjaGVja2VkOiB0aGlzLmNoZWNrZWRTdWNjZXNzZnVsbHksXHJcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiT0sgQ2xpY2tlZCAtIFJldHVybmluZyBSZXN1bHQ6XCIsIHJlc3VsdCk7IC8vIERlYnVnIGxvZ1xyXG4gICAgICAgIHRoaXMub2tDYWxsYmFjayhyZXN1bHQpOyAvLyBQYXNzIHRoZSBmaW5hbCBzZWxlY3Rpb24gYmFja1xyXG4gICAgICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnRlbnRFbC5lbXB0eSgpOyAvLyBDbGVhciB0aGUgbW9kYWwncyBjb250ZW50XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZWFzaWx5IG9wZW4gdGhlIERpcmVjdG9yeSBTZWxlY3Rpb24gTW9kYWwuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcHAgLSBUaGUgT2JzaWRpYW4gQXBwIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gaW5pdGlhbENvZGUgLSBTdHJpbmcgd2l0aCB0aGUgaW5pdGlhbCBjb2RlLlxyXG4gKiBAcGFyYW0gZXhwZWN0ZWRUeXBlIC0gRXhwZWN0ZWQgcmV0dXJuIHR5cGUuXHJcbiAqIEBwYXJhbSBva0NhbGxiYWNrIC0gRnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBcIk9LXCIuIFJlY2VpdmVzIHRoZSBzZWxlY3Rpb24gcmVzdWx0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG9wZW5Db2RlRWRpdG9yTW9kYWwoXHJcbiAgICBhcHA6IEFwcCxcclxuICAgIHBsdWdpbjogYW55LFxyXG4gICAgaW5pdGlhbENvZGU6IHN0cmluZyxcclxuICAgIGV4cGVjdGVkVHlwZTogT2JzaWRpYW5Qcm9wZXJ0eVR5cGVzLFxyXG4gICAgYWN0aXZlRmlsZTogVEZpbGUgfCBURm9sZGVyIHwgbnVsbCxcclxuICAgIGZyb250bWF0dGVyOiBhbnksXHJcbiAgICBva0NhbGxiYWNrOiAocmVzdWx0OiBjb2RlRWRpdG9yTW9kYWxSZXN1bHQgfCBudWxsKSA9PiB2b2lkXHJcbik6IHZvaWQge1xyXG4gICAgLy8gQ3JlYXRlIGFuZCBvcGVuIHRoZSBtb2RhbCBpbnN0YW5jZVxyXG4gICAgbmV3IGNvZGVFZGl0b3JNb2RhbChcclxuICAgICAgICBhcHAsXHJcbiAgICAgICAgcGx1Z2luLFxyXG4gICAgICAgIGluaXRpYWxDb2RlLFxyXG4gICAgICAgIGV4cGVjdGVkVHlwZSxcclxuICAgICAgICBhY3RpdmVGaWxlLFxyXG4gICAgICAgIGZyb250bWF0dGVyLFxyXG4gICAgICAgIG9rQ2FsbGJhY2tcclxuICAgICkub3BlbigpO1xyXG59Il0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFBLG9CQUE2STs7O0FDQTdJLElBQUFDLG9CQUFrRzs7O0FDQWxHLHNCQUFpRDtBQTBDMUMsU0FBUyxpQ0FBaUMsS0FBOEI7QUFDM0UsTUFBSTtBQUNBLFVBQU0sa0JBQW1CLElBQVk7QUFDckMsWUFBUSxJQUFJLG1CQUFrQixlQUFlO0FBQzdDLFdBQU8sT0FBTyxPQUFPLGdCQUFnQixVQUFVLEVBQUUsSUFBSyxDQUFDLFdBQWdDO0FBQUEsTUFDbkYsTUFBTSxNQUFNO0FBQUEsTUFDWixNQUFNLE1BQU07QUFBQSxNQUNaLE9BQU8sTUFBTTtBQUFBLE1BQ2IsUUFBUTtBQUFBLElBQ1osRUFBRSxFQUFFLEtBQUssQ0FBQyxHQUFHLE1BQU0sRUFBRSxLQUFLLGNBQWMsRUFBRSxJQUFJLENBQUM7QUFBQSxFQUVuRCxTQUFTLEdBQVA7QUFDRSxZQUFRLE1BQU0sb0RBQW9ELENBQUM7QUFDbkUsV0FBTyxDQUFDO0FBQUEsRUFDWjtBQUNKO0FBSU8sU0FBUyw0QkFB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RUFBQztBQUM5QixTQUFLLElBQUksTUFBTSxpQkFBaUIsRUFBRSxRQUFRLFVBQVE7QUFDOUMsWUFBTTtBQUNOLFdBQUssMkJBQTJCLE1BQU0sTUFBTSxLQUFLO0FBQUEsSUFDckQsQ0FBQztBQUNELFdBQU87QUFBQSxFQUNYO0FBQUEsRUFFQSxNQUFNLDJCQUEyQixNQUFhLE1BQStCLE9BQU87QUFDaEYsUUFBSSxDQUFDLG1CQUFtQixNQUFNLEtBQUssVUFBVSxJQUFJO0FBQUc7QUFDcEQsVUFBTSxpQkFBaUIsS0FBSyxjQUFjLEtBQUssTUFBTSxrQkFBa0IsS0FBSyxJQUFJLENBQUM7QUFDakYsUUFBSSxVQUFVLE1BQU0sS0FBSyxJQUFJLE1BQU0sS0FBSyxJQUFJO0FBQzVDLFNBQUssSUFBSSxZQUFZLG1CQUFtQixNQUFNLENBQUMsZ0JBQWdCO0FBQzNELFVBQUksTUFBTSxRQUFRLFlBQVksS0FBSyxRQUFRLENBQUM7QUFBRyxjQUFNLFNBQVMsWUFBWSxLQUFLLFFBQVEsRUFBRTtBQUN6RixrQkFBWSxLQUFLLFFBQVEsSUFBSSxXQUFXLEtBQUssS0FBSyxLQUFLLFVBQVUsTUFBTSxZQUFZLEtBQUssUUFBUSxHQUFHLE1BQU0sV0FBVztBQUNwSCxVQUFJLE1BQU0sUUFBUSxZQUFZLEtBQUssUUFBUSxDQUFDO0FBQUcsY0FBTSxTQUFTLFlBQVksS0FBSyxRQUFRLEVBQUU7QUFBQSxJQUM3RixHQUFFLEVBQUMsU0FBUSxLQUFLLEtBQUssTUFBSyxDQUFDO0FBQzNCLFdBQU87QUFBQSxFQUNYO0FBQ0o7IiwKICAibmFtZXMiOiBbImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJmbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJuYW1lIiwgInN0eWxlIiwgIndpbmRvdyIsICJtaW4iLCAibWF4IiwgInRvUGFkZGluZ09iamVjdCIsICJwb3BwZXJPZmZzZXRzIiwgIm1pbiIsICJtYXgiLCAib2Zmc2V0IiwgImVmZmVjdCIsICJwb3BwZXIiLCAiZWZmZWN0IiwgIndpbmRvdyIsICJoYXNoIiwgImNsaXBwaW5nUGFyZW50cyIsICJyZWZlcmVuY2UiLCAicG9wcGVyT2Zmc2V0cyIsICJvZmZzZXQiLCAicGxhY2VtZW50cyIsICJwbGFjZW1lbnQiLCAicGxhY2VtZW50cyIsICJwbGFjZW1lbnQiLCAiX2xvb3AiLCAiX2kiLCAiY2hlY2tzIiwgIm9mZnNldCIsICJwb3BwZXJPZmZzZXRzIiwgIm9mZnNldCIsICJtaW4iLCAibWF4IiwgImZuIiwgIm1lcmdlZCIsICJkZWZhdWx0TW9kaWZpZXJzIiwgImNyZWF0ZVBvcHBlciIsICJyZWZlcmVuY2UiLCAicG9wcGVyIiwgIm9wdGlvbnMiLCAiZm4iLCAic3RhdGUiLCAiZWZmZWN0IiwgIm5vb3BGbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgInZhbHVlIiwgImZyb250bWF0dGVyIiwgImpzQ29kZSIsICJydWxlIiwgInRleHQiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJqc0NvZGUiLCAicnVsZUZ1bmN0aW9uIiwgIl9hIiwgIl9iIiwgIl9jIiwgInJ1bGUiXQp9Cg==
