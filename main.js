/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FolderTagPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian30 = require("obsidian");

// src/settings.ts
var import_obsidian12 = require("obsidian");

// src/frontmatter-tools.ts
var import_obsidian2 = require("obsidian");

// src/Log.ts
var import_obsidian = require("obsidian");

// src/Error.ts
var ErrorManager = class extends Error {
  constructor(msg, console_msg) {
    super(msg);
    this.console_msg = console_msg;
    this.name = this.constructor.name;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
function errorWrapperSync(fn2, msg) {
  try {
    return fn2();
  } catch (e) {
    if (e instanceof Error) {
      logError(new ErrorManager(msg, e.message));
    } else {
      logError(new ErrorManager(msg, String(e)));
    }
    return null;
  }
}

// src/Log.ts
var LOG = 0;
var ALERT = 1;
var ERROR = 2;
var WARNING = 3;
var INFO = 4;
var DEBUG = 5;
var TRACE = 6;
function logError(e) {
  const notice = new import_obsidian.Notice("", 8e3);
  if (e instanceof ErrorManager && e.console_msg) {
    notice.messageEl.innerHTML = `<b>Frontmatter Automate Error</b>:<br/>${e.message}<br/>Check console for more information`;
    console.error(`Frontmatter Error:`, e.message, "\n", e.console_msg);
  } else {
    notice.messageEl.innerHTML = `<b>Frontmatter Automate Error</b>:<br/>${e.message}`;
  }
}
var Logger = class {
  constructor() {
    this.logLevel = INFO;
  }
  setLevel(level) {
    if (typeof level === "number") {
      this.logLevel = level;
      this.log(LOG, `Log level set to ${this.getLevelName(this.logLevel)}`);
    } else {
      const levelName = level.toUpperCase();
      const levelIndex = this.getLevelNames().indexOf(levelName) + 1;
      if (levelIndex >= 0) {
        this.setLevel(levelIndex);
      } else {
        this.log(WARNING, `Invalid log level name: ${levelName}`);
      }
    }
  }
  getLevel() {
    return this.logLevel;
  }
  getLevelByName(levelName) {
    const levelIndex = this.getLevelNames().indexOf(levelName.toUpperCase()) + 1;
    if (levelIndex >= 0) {
      return levelIndex;
    } else {
      this.log(WARNING, `Invalid log level name: ${levelName}`);
      return INFO;
    }
  }
  getLevelByIndex(levelIndex) {
    if (levelIndex >= ALERT && levelIndex <= TRACE) {
      return levelIndex;
    } else {
      this.log(WARNING, `Invalid log level index: ${levelIndex}`);
      return INFO;
    }
  }
  getLevelByValue(levelValue) {
    if (levelValue >= ALERT && levelValue <= TRACE) {
      return levelValue;
    } else {
      this.log(WARNING, `Invalid log level value: ${levelValue}`);
      return INFO;
    }
  }
  shouldLog(level) {
    if (level === 0)
      return true;
    return level <= this.logLevel;
  }
  getLevelName(level) {
    switch (level) {
      case ALERT:
        return "ALERT";
      case ERROR:
        return "ERROR";
      case WARNING:
        return "WARNING";
      case INFO:
        return "INFO";
      case DEBUG:
        return "DEBUG";
      case TRACE:
        return "TRACE";
      default:
        return "LOG";
    }
  }
  getLevelNames() {
    return [ALERT, ERROR, WARNING, INFO, DEBUG, TRACE].map((level) => this.getLevelName(level));
  }
  log(level, ...msg) {
    if (!this.shouldLog(level))
      return;
    const levelName = this.getLevelName(level);
    let color = "";
    switch (level) {
      case ALERT:
        color = "background: #d32f2f; color: white; font-weight: bold";
        break;
      case ERROR:
        color = "color: #d32f2f; font-weight: bold";
        break;
      case WARNING:
        color = "color: #fbc02d; font-weight: bold";
        break;
      case INFO:
        color = "color: #1976d2; font-weight: bold";
        break;
      case DEBUG:
        color = "color: #388e3c;";
        break;
      case TRACE:
        color = "color: #616161;";
        break;
      default:
        color = "";
        break;
    }
    const prefix = `%c[${levelName}]`;
    const err = new Error();
    let caller = "";
    if (err.stack) {
      const stackLines = err.stack.split("\n");
      if (stackLines.length >= 3) {
        caller = stackLines[2].trim();
      }
    }
    switch (level) {
      case ALERT:
      case ERROR:
        console.groupCollapsed(prefix, color, ...msg);
        console.log("Caller Stack:", err);
        console.groupEnd();
        break;
      case WARNING:
        console.groupCollapsed(prefix, color, ...msg);
        console.log("Caller Stack:", err);
        console.groupEnd();
        break;
      case INFO:
        console.info(prefix, color, ...msg);
        break;
      case DEBUG:
      case TRACE:
      default:
        console.groupCollapsed(prefix, color, ...msg);
        console.log("Caller Stack:", err);
        console.groupEnd();
        break;
    }
    if (level === ALERT || level === ERROR) {
      new import_obsidian.Notice(`<b>Frontmatter Automate ${levelName}</b>:<br/>${msg.join(" ")}`, 8e3);
    }
  }
  groupCollapsed(level, ...msg) {
    if (!this.shouldLog(level))
      return;
    const levelName = this.getLevelName(level);
    let color = "";
    switch (level) {
      case ALERT:
        color = "background: #d32f2f; color: white; font-weight: bold";
        break;
      case ERROR:
        color = "color: #d32f2f; font-weight: bold";
        break;
      case WARNING:
        color = "color: #fbc02d; font-weight: bold";
        break;
      case INFO:
        color = "color: #1976d2; font-weight: bold";
        break;
      case DEBUG:
        color = "color: #388e3c;";
        break;
      case TRACE:
        color = "color: #616161;";
        break;
      default:
        color = "";
        break;
    }
    const prefix = `%c[${levelName}]`;
    console.groupCollapsed(prefix, color, ...msg);
  }
  groupEnd() {
    console.groupEnd();
  }
  logUpdate(msg) {
    new import_obsidian.Notice(`<b>Frontmatter Automate update</b>:<br/>${msg}`, 15e3);
  }
  logError(e) {
    const notice = new import_obsidian.Notice("", 8e3);
    if (e instanceof ErrorManager && e.console_msg) {
      notice.messageEl.innerHTML = `<b>Frontmatter Automate Error</b>:<br/>${e.message}<br/>Check console for more information`;
      logger.log(ERROR, `Frontmatter Error:`, e.message, "\n", e.console_msg);
    } else {
      notice.messageEl.innerHTML = `<b>Frontmatter Automate Error</b>:<br/>${e.message}`;
    }
  }
};
var logger = new Logger();

// src/frontmatter-tools.ts
function getPropertiesFromMetadataManager(app) {
  try {
    const metadataManager = app.metadataTypeManager;
    logger.log(DEBUG, "get properties:", metadataManager);
    return Object.values(metadataManager.properties).map((value) => ({
      name: value.name,
      type: value.type,
      count: value.count,
      source: "registered"
    })).sort((a, b) => a.name.localeCompare(b.name));
  } catch (e) {
    logger.log(ERROR, "Couldn't access properties from Metadata Manager", e);
    return [];
  }
}
function getTypesFromMetadataManager(app) {
  try {
    const metadataManager = app.metadataTypeManager;
    logger.log(DEBUG, "get types:", metadataManager);
    return Object.values(metadataManager.registeredTypeWidgets).map((value, index, array) => ({
      type: value.type,
      icon: value.icon,
      jsType: ""
    })).sort((a, b) => a.type.localeCompare(b.type));
  } catch (e) {
    logger.log(ERROR, "Couldn't access properties from Metadata Manager", e);
    return [];
  }
}

// src/tools.ts
var import_obsidian4 = require("obsidian");

// src/alertBox.ts
var import_obsidian3 = require("obsidian");
var AlertModal = class extends import_obsidian3.Modal {
  constructor(app, title, description, btn1, btn2, askAgainLabel) {
    super(app);
    this.title = title;
    this.description = description;
    this.btn1Text = btn1;
    this.btn2Text = btn2;
    this.askAgainLabel = askAgainLabel;
    this.promise = new Promise((resolve) => {
      this.resolvePromise = resolve;
    });
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: this.title });
    contentEl.createEl("p", { text: this.description });
    const settings = new import_obsidian3.Setting(contentEl);
    if (this.askAgainLabel) {
      const itemInfoDiv = settings.settingEl.getElementsByClassName("setting-item-info")[0];
      if (itemInfoDiv) {
        this.checkboxEl = itemInfoDiv.createEl("input", { type: "checkbox" });
        const label = itemInfoDiv.createEl("label", { text: this.askAgainLabel });
        label.style.marginLeft = "8px";
      }
    }
    settings.addButton((btn) => {
      btn.setButtonText(this.btn1Text).setCta().onClick(() => {
        var _a;
        this.close();
        this.resolvePromise({ proceed: true, data: { askConfirmation: (_a = this.checkboxEl) == null ? void 0 : _a.checked } });
      });
    });
    settings.addButton((btn) => {
      btn.setButtonText(this.btn2Text).onClick(() => {
        var _a;
        this.close();
        this.resolvePromise({ proceed: false, data: { askConfirmation: (_a = this.checkboxEl) == null ? void 0 : _a.checked } });
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  async openAndGetValue() {
    this.open();
    return this.promise;
  }
};

// src/rules/rules.ts
var RulePrototype = class {
  constructor(app, plugin) {
    this.rulesConfigDiv = void 0;
    this.ruleType = "buildIn";
    this.isLiveRule = false;
    // If true, the rule is a live rule and will be executed on file change
    this.type = ["text"];
    // Types that are supported by this rule
    this.configElements = {};
    // Elements that are used to configure the rule
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = ''\n  return result;\n}";
    this.scriptingTools = new ScriptingTools(app, plugin);
  }
  getSource() {
    return this.source;
  }
  fx(app, file, tools, input) {
    if (input === void 0 || input === null)
      input = tools.getCurrentContent();
    return input;
  }
  /**
   * Configures the settings tab for a specific rule in the plugin.
   *
   * @param optionEL - The HTML element where the configuration options will be rendered.
   * @param rule - The settings object for the frontmatter automation rule.
   * @param that - The context or reference to the calling object.
   * @param previewComponent - The component used to render a preview of the rule's effect.
   */
  configTab(optionEL, rule, that, previewComponent) {
    optionEL.empty();
  }
  defaultConfigElements(modifiers) {
    const configElements = {
      removeContent: true,
      ruleActive: true,
      modifyOnly: true,
      inputProperty: false,
      addPrefix: true,
      spaceReplacement: true,
      specialCharacterReplacement: true,
      convertToLowerCase: true,
      resultAsLink: true,
      addContent: true,
      excludeFolders: true,
      includeFolders: true,
      script: true
    };
    return Object.assign({}, configElements, modifiers);
  }
  /**
   * Checks if a specific rule option is enabled.
   *
   * @param {string} option - The name of the rule option to check.
   * @returns {boolean} - Returns true if the option is enabled, false otherwise.
   */
  useRuleOption(option) {
    if (this.configElements[option] === void 0) {
      return false;
    }
    return this.configElements[option] || false;
  }
  /**
   * Checks if the rule has any configuration options.
   *
   * @returns {boolean} - Returns true if the rule has options, false otherwise.
   */
  hasOwnConfigTab() {
    return Object.getPrototypeOf(this).configTab !== RulePrototype.prototype.configTab;
  }
  /**
   * Executes the `fx` function based on the `ruleType`.
   * Handles different function signatures dynamically.
   * 
   * @param {App} app - The Obsidian app instance.
   * @param {any} file - The file to pass to the rule's `fx` function.
   * @param {ScriptingTools} tools - The scripting tools to pass to the rule's `fx` function.
   * @param {any} [input] - Optional input for rules that require it (e.g., `buildIn.inputProperty`).
   * @returns {string} - The result of the `fx` function.
  */
  execute(app, file, tools, input) {
    switch (this.ruleType) {
      case "formatter":
      case "linkFormatter":
        return this.fx(app, file, tools, input);
      case "buildIn.inputProperty":
        return this.fx(app, file, tools, input);
      case "autocomplete.modal":
      case "automation":
        let result = "";
        this.fx(app, file, tools).then((res) => {
          result = res;
        }).catch((err) => {
          logger.log(ERROR, `Error executing async automation rule: ${err}`);
        });
        return result;
      default:
        return this.fx(app, file, tools);
    }
  }
};
var Rules = class {
  constructor(app, plugin) {
    this.app = void 0;
    this.plugin = void 0;
    this.tools = void 0;
    this.plugin = plugin;
    this.app = app;
    this.tools = void 0;
    this.rules = [];
  }
  init(app, plugin, tools) {
    this.app = app;
    this.plugin = plugin;
    this.tools = tools;
  }
  /**
   * Registers a new rule by adding it to the list of existing rules.
   *
   * @param rule - The rule prototype to be registered. This should conform to the `RulePrototype` interface.
   */
  registerRule(rule) {
    this.rules.push(rule);
  }
  /**
   * Retrieves a list of rules filtered by the specified rule type and property type.
   *
   * @param ruleType - The type of rule to filter by.
   * @param propertyType - The property type to filter by within the rule's type array.
   * @returns An array of objects containing the `id` and `name` of each matching rule, sorted alphabetically by name.
   */
  getRulesByType(ruleType, propertyType) {
    return this.rules.filter((rule) => rule.ruleType === ruleType && (!propertyType || rule.type.includes(propertyType))).map((rule) => ({ id: rule.id, name: rule.name })).sort((a, b) => a.name.localeCompare(b.name));
  }
  /**
   * Retrieves a rule object by its unique identifier.
   *
   * @param id - The unique identifier of the rule to retrieve.
   * @returns The rule object matching the provided ID, or `undefined` if no matching rule is found.
   * @throws Logs a warning to the console if the rule with the specified ID is not found.
   */
  getRuleById(id) {
    const ruleObject = this.rules.find((rule) => rule.id === id);
    if (!ruleObject) {
      logger.log(WARNING, `Rule with id "${id}" not found.`);
      return void 0;
    }
    return ruleObject;
  }
  /**
   * Retrieves the source code of a rule by its unique identifier.
   *
   * @param id - The unique identifier of the rule for which to retrieve the source code.
   * @returns The source code of the rule, or `undefined` if the rule is not found.
   */
  getSource(id) {
    const ruleObject = this.getRuleById(id);
    if (!ruleObject) {
      logger.log(WARNING, `Source for rule with id "${id}" not found.`);
      return void 0;
    }
    return ruleObject.getSource();
  }
  /**
   * Executes the `fx` function of a rule matching the given `id` and returns its result.
   * 
   * @param {string} id - The unique identifier of the rule to execute.
   * @param {App} app - The Obsidian app instance.
   * @param {any} file - The file to pass to the rule's `fx` function.
   * @param {ScriptingTools} tools - The scripting tools to pass to the rule's `fx` function.
   * @param {any} [input] - Optional input for rules that require it.
   * @returns {string | null} - The result of the `fx` function, or `null` if the rule is not found.
  */
  executeRuleById(id, ruleSettings, app, file, tools, input) {
    const rule = this.rules.find((rule2) => rule2.id === id);
    if (!rule) {
      logger.log(WARNING, `Rule with id "${id}" not found.`);
      return null;
    }
    return this.executeRule(ruleSettings, rule, app, file, tools, input);
  }
  /**
   * Executes the `fx` function of a given rule and returns its result.
   *
   * @param rule - The rule to execute.
   * @param app - The Obsidian app instance.
   * @param file - The file to pass to the rule's `fx` function.
   * @param tools - The scripting tools to pass to the rule's `fx` function.
   * @param input - Optional input for rules that require it.
   * @returns {string | null} - The result of the `fx` function, or `null` if the rule is not found.
   */
  executeRule(ruleSettings, rule, app, file, tools, input) {
    switch (rule.ruleType) {
      case "formatter":
      case "linkFormatter":
      case "buildIn.inputProperty":
        return rule.execute(app, file, tools, input);
      case "automation":
        return rule.execute(app, file, tools);
      default:
        if (ruleSettings.useCustomCode && ruleSettings.buildInCode && ruleSettings.buildInCode !== "") {
          const code = parseJSCode(ruleSettings.buildInCode);
          if (typeof code === "function") {
            return code(app, file, tools);
          } else {
            logger.log(ERROR, `Invalid custom code for rule "${ruleSettings.content}": ${ruleSettings.buildInCode}`);
            return `Invalid custom code for rule "${ruleSettings.id}"`;
          }
        } else {
          return rule.execute(app, file, tools, input);
        }
    }
  }
  applyFormatOptions(value, rule, activeFile, tools) {
    if (rule.type === "number" || rule.type === "checkbox" || rule.type === "date" || rule.type === "datetime")
      return value;
    switch (typeof value) {
      case "boolean":
      case "number":
        return value;
      case "string":
        if (rule.formatters && rule.formatters.length > 0) {
          rule.formatters.forEach((formatterId) => {
            value = this.executeRuleById(formatterId, rule, this.app, activeFile, tools, value);
          });
        }
        if (rule.linkFormatter && rule.linkFormatter !== "") {
          value = this.executeRuleById(rule.linkFormatter, rule, this.app, activeFile, tools, value);
        }
        return value;
      case "object":
        if (Array.isArray(value)) {
          return value.map((value2) => this.applyFormatOptions(value2, rule, activeFile, tools));
        }
        return value;
    }
    return;
  }
  mergeResult(result, oldResult, returnResult, rule) {
    if (!this.tools) {
      console.warn("Tools are not available for merging results.");
      return result;
    }
    switch (rule.addContent) {
      case "overwrite":
        returnResult = result;
        break;
      case "end":
        if (rule.type === "multitext" || rule.type === "tags" || rule.type === "aliases") {
          if (!result)
            result = [];
          if (typeof result === "string")
            result = [result];
          if (!Array.isArray(returnResult))
            returnResult = [returnResult];
          if (!Array.isArray(oldResult))
            oldResult = [oldResult];
          let filtered = returnResult.filter((value) => !oldResult.includes(value));
          returnResult = this.tools.removeDuplicateStrings(filtered.concat(result));
        } else {
          if (!returnResult)
            returnResult = "";
          returnResult = returnResult.replaceAll(returnResult, oldResult);
          returnResult = returnResult + result;
        }
        break;
      case "start":
        if (rule.type === "multitext" || rule.type === "tags" || rule.type === "aliases") {
          if (!result)
            result = [];
          if (typeof result === "string")
            result = [result];
          if (!Array.isArray(returnResult))
            returnResult = [returnResult];
          if (!Array.isArray(oldResult))
            oldResult = [oldResult];
          let filtered = returnResult.filter((value) => !oldResult.includes(value));
          returnResult = this.tools.removeDuplicateStrings(result.concat(filtered));
        } else {
          if (!returnResult)
            returnResult = "";
          returnResult = returnResult.replaceAll(returnResult, oldResult);
          returnResult = result + returnResult;
        }
        break;
    }
    return returnResult;
  }
  /**
   * Builds the configuration tab for a specific rule by its ID.
   *
   * @param id - The unique identifier of the rule for which the configuration tab is being built.
   * @param optionEL - The HTML element where the configuration tab will be rendered.
   * @param rule - The definition of the rule, containing its properties and settings.
   * @param that - A reference to the current context or object, typically used for maintaining scope.
   * @param previewComponent - A component used to render a preview of the rule's effect or configuration.
   *
   * @remarks
   * If a rule with the specified ID is found, its `configTab` method is invoked to build the configuration tab.
   * If no rule is found, a warning is logged to the console.
   */
  buildConfigTab(id, optionEL, rule, that, previewComponent) {
    const ruleInstance = this.rules.find((rule2) => rule2.id === id);
    if (ruleInstance) {
      ruleInstance.configTab(optionEL, rule, that, previewComponent);
    } else {
      console.warn(`Rule with id "${id}" not found for config tab.`);
    }
  }
};
var rulesManager = new Rules();

// src/tools.ts
function parseJSCode(jsCode) {
  function parseFunction(jsCode2) {
    try {
      jsCode2 = cleanCodeString(jsCode2);
      var funcReg = /function *\(([^()]*)\)[ \n\t]*{(.*)}/gmi;
      var match = funcReg.exec(jsCode2.replace(/\n/g, " "));
      if (!match)
        return void 0;
      var args = match[1].split(",");
      args.push(match[2]);
      return new Function(...args);
    } catch (error) {
      logger.log(ERROR, "error parsing JS function!", error);
      return error.message;
    }
  }
  ;
  return parseFunction(jsCode);
}
function cleanCodeString(codeString) {
  if (typeof codeString !== "string") {
    throw new TypeError("Input must be a string.");
  }
  let inMultiLineComment = false;
  let inSingleLineComment = false;
  let inString = null;
  let inRegExp = false;
  let cleanedCode = "";
  let i = 0;
  while (i < codeString.length) {
    const char = codeString[i];
    const nextChar = codeString[i + 1];
    if (inMultiLineComment) {
      if (char === "*" && nextChar === "/") {
        inMultiLineComment = false;
        i += 2;
        continue;
      } else {
        i++;
        continue;
      }
    }
    if (inSingleLineComment) {
      if (char === "\n" || char === "\r") {
        inSingleLineComment = false;
        cleanedCode += char;
        i++;
        continue;
      } else {
        i++;
        continue;
      }
    }
    if (inString) {
      if (char === inString) {
        inString = null;
      } else if (char === "\\") {
        cleanedCode += char;
        i++;
        if (i < codeString.length) {
          cleanedCode += codeString[i];
        }
        i++;
        continue;
      }
      cleanedCode += char;
      i++;
      continue;
    }
    if (inRegExp) {
      if (char === "/") {
        inRegExp = false;
      } else if (char === "\\") {
        cleanedCode += char;
        i++;
        if (i < codeString.length) {
          cleanedCode += codeString[i];
        }
        i++;
        continue;
      }
      cleanedCode += char;
      i++;
      continue;
    }
    if (char === "/" && nextChar === "*") {
      inMultiLineComment = true;
      i += 2;
      continue;
    }
    if (char === "/" && nextChar === "/") {
      inSingleLineComment = true;
      i += 2;
      continue;
    }
    if (char === '"' || char === "'") {
      inString = char;
      cleanedCode += char;
      i++;
      continue;
    }
    if (char === "/") {
      const prevMeaningfulChar = cleanedCode.trim().slice(-1);
      if (prevMeaningfulChar === "" || ["(", ",", "=", ":", "[", "!", "&", "|", "?", "{", ";", "\n", "\r"].includes(prevMeaningfulChar)) {
        inRegExp = true;
        cleanedCode += char;
        i++;
        continue;
      }
    }
    cleanedCode += char;
    i++;
  }
  return cleanedCode;
}
function resolveFolder(app, folder_str) {
  folder_str = (0, import_obsidian4.normalizePath)(folder_str);
  const folder = app.vault.getAbstractFileByPath(folder_str);
  if (!folder) {
    throw new ErrorManager(`Folder "${folder_str}" doesn't exist`);
  }
  if (!(folder instanceof import_obsidian4.TFolder)) {
    throw new ErrorManager(`${folder_str} is a file, not a folder`);
  }
  return folder;
}
function getFilesFromFolder(app, folder_str) {
  const folder = resolveFolder(app, folder_str);
  const files = [];
  import_obsidian4.Vault.recurseChildren(folder, (file) => {
    if (file instanceof import_obsidian4.TFile) {
      files.push(file);
    }
  });
  files.sort((a, b) => {
    return a.path.localeCompare(b.path);
  });
  return files;
}
var ScriptingTools = class {
  constructor(app, plugin, settings, rule, frontmatter, activeFile) {
    this.knownProperties = {};
    this.app = app;
    this.plugin = plugin;
    this.settings = settings;
    this.rule = rule;
    this.frontmatter = frontmatter;
    this.activeFile = activeFile;
  }
  /**
   * Retrieves the frontmatter object associated with the current instance.
   *
   * @returns The frontmatter data.
   */
  getFrontmatter() {
    return this.frontmatter;
  }
  /**
   * Sets the frontmatter property for the current instance.
   *
   * @param frontmatter - The frontmatter object to assign.
   */
  setFrontmatter(frontmatter) {
    this.frontmatter = frontmatter;
  }
  /**
   * Sets a property in the frontmatter object. If the frontmatter does not exist, it initializes it as an empty object.
   *
   * @param key - The property name to set in the frontmatter.
   * @param value - The value to assign to the specified property.
   */
  setFrontmatterProperty(key, value) {
    if (!this.frontmatter)
      this.frontmatter = {};
    this.frontmatter[key] = value;
  }
  /**
   * Retrieves the value of a specified property from the frontmatter object.
   *
   * @param key - The name of the property to retrieve from the frontmatter.
   * @returns The value associated with the specified key in the frontmatter, or `undefined` if the key does not exist.
   */
  getFrontmatterProperty(key) {
    return this.frontmatter[key];
  }
  /**
   * Sets the currently active file.
   *
   * @param file - The file to set as active. Must be an instance of `TFile`.
   */
  setActiveFile(file) {
    this.activeFile = file;
  }
  /**
   * Returns the currently active file.
   *
   * @returns The active file object, or `undefined` if no file is active.
   */
  getActiveFile() {
    return this.activeFile;
  }
  /**
   * Sets the current rule configuration for the frontmatter automation.
   *
   * @param rule - The rule settings to apply, represented by a `FrontmatterAutomateRuleSettings` object.
   */
  setRule(rule) {
    this.rule = rule;
  }
  /**
   * Retrieves the current rule associated with this instance.
   *
   * @returns The rule object or value stored in the `rule` property.
   */
  getRule() {
    return this.rule;
  }
  /**
   * Retrieves a rule function based on the provided rule settings.
   *
   * @param rule - Optional. The rule settings to use for retrieving the rule function.
   *               If not provided, the method uses the instance's default rule.
   * @returns The rule function associated with the specified rule settings, or `undefined` if no rule is found.
   */
  getRuleFunction(rule) {
    if (!rule)
      rule = this.rule;
    if (rule) {
      return rulesManager.getRuleById(rule.content);
    }
  }
  /**
   * Sets the current content to the provided value.
   *
   * @param content - The content to set as the current content. Can be of any type.
   */
  setCurrentContent(content) {
    this.currentContent = content;
  }
  /**
   * Retrieves the current content stored in the instance.
   *
   * @returns The current content.
   */
  getCurrentContent() {
    return this.currentContent;
  }
  /**
   * Updates the specified frontmatter property of a given file with new content.
   *
   * If no file is provided, the currently active file is used. If neither is available, the method returns early.
   * The method logs the update operation and only supports updating properties with primitive values or arrays.
   * If `newContent` is an object (but not an array), a warning is issued and the update is not performed.
   * The file's modification time (`mtime`) is preserved and not changed during the update.
   *
   * @param property - The frontmatter property to update.
   * @param newContent - The new value to assign to the property. Objects (except arrays) are not supported.
   * @param file - (Optional) The file whose frontmatter should be updated. If omitted, the active file is used.
   */
  updateFrontmatter(property, newContent, file) {
    this.plugin.preventOnMetadataChange = true;
    if (!this.app)
      return;
    if (!file)
      file = this.activeFile;
    if (!file)
      return;
    this.app.fileManager.processFrontMatter(file, (frontmatter) => {
      logger.log(DEBUG, `updateFrontmatter '${file.path}' frontmatter '${property}' to '${newContent.toString()}'`);
      if (typeof newContent === "object" && !Array.isArray(newContent)) {
        logger.log(WARNING, `updateFrontmatter '${file.path}'|'${property}' object not supported!`);
      } else {
        frontmatter[property] = newContent;
      }
    }, { "mtime": file.stat.mtime });
    this.plugin.preventOnMetadataChange = false;
  }
  /**
   * Displays a confirmation dialog with customizable message, title, and button labels.
   *
   * @param message - The message to display in the confirmation dialog.
   * @param title - The title of the dialog window. Defaults to 'Confirm'.
   * @param button1 - The label for the confirmation button. Defaults to 'Yes'.
   * @param button2 - The label for the cancellation button. Defaults to 'No'.
   * @returns A promise that resolves to a boolean indicating whether the user confirmed (true) or cancelled (false).
   */
  async showConfirmDialog(message, title = "Confirm", button1 = "Yes", button2 = "No") {
    const result = await new AlertModal(this.app, title, message, button1, button2).openAndGetValue();
    return result.proceed;
  }
  /**
   * Retrieves a rule from the plugin's settings by its unique identifier.
   *
   * @param ruleId - The unique identifier of the rule to retrieve.
   * @returns The matching {@link FrontmatterAutomateRuleSettings} object if found; otherwise, `undefined`.
   */
  getRuleById(ruleId) {
    if (!this.settings || !this.settings.folderConfig || !this.settings.folderConfig.rows)
      return void 0;
    const row = this.settings.folderConfig.rows.find((row2) => {
      if (row2.payload && row2.payload.id) {
        return row2.payload.id === ruleId;
      }
      return false;
    });
    return row == null ? void 0 : row.payload;
  }
  /**
   * * Get the option config for a specific rule. Optional the specific parameter by providing an option ID.
   *
   * @param {string} ruleId
   * @param {string} [optionId]
   * @return {*} 
   */
  getOptionConfig(ruleId, optionId) {
    if (!ruleId || ruleId === void 0 || !this.settings)
      return void 0;
    const rule = this.getRuleById(ruleId);
    if (rule && rule.hasOwnProperty("optionsConfig")) {
      const optionConfig = rule.optionsConfig[ruleId];
      if (optionConfig) {
        if (optionId) {
          logger.log(TRACE, `getOptionConfig: ${ruleId} option '${optionId}'`, rule, optionConfig[optionId]);
          return optionConfig[optionId];
        } else {
          return optionConfig;
        }
      }
    }
    return void 0;
  }
  /**
   * Retrieves all markdown files in the vault whose paths include the specified matching string.
   *
   * The `matching` parameter is normalized to ensure it ends with a single '/' character,
   * and is used to filter files whose paths contain this substring.
   *
   * @param folderPath - The folder path or substring to match within file paths.
   * @returns An array of `TFile` objects whose paths include the normalized `matching` string.
   */
  getFilesInVault(folderPath) {
    folderPath = folderPath.replace(/^\/|\/$/g, "") + "/";
    const files = this.app.vault.getMarkdownFiles();
    const matchingFiles = files.filter((file) => file instanceof import_obsidian4.TFile && file.path.includes(folderPath));
    return matchingFiles;
  }
  /**
   * Creates a mock `TFile` object from a given file path string.
   *
   * This method parses the provided path to construct a `TFile`-like object,
   * extracting the file name, extension, and base name. The returned object
   * contains placeholder values for file statistics and parent, as these details
   * are unknown. If the input path is empty or undefined, the method returns `undefined`.
   *
   * @param path - The file path string to generate the mock `TFile` from.
   * @returns A mock `TFile` object representing the file at the given path, or `undefined` if the path is invalid.
   */
  getMockFileFromPath(path) {
    if (!path)
      return void 0;
    let oldFile;
    let oldFileParts = path.split("/");
    oldFile = {
      path,
      extension: oldFileParts[oldFileParts.length - 1].split(".")[1],
      name: oldFileParts[oldFileParts.length - 1],
      stat: { mtime: 0, ctime: 0, size: 0 },
      // stats are unknown
      basename: this.removeAllExtensions(oldFileParts[oldFileParts.length - 1]),
      vault: this.app.vault,
      parent: null
      // parent is unknown
    };
    return oldFile;
  }
  /**
   * Retrieves a `TFile` object from a given file path.
   *
   * @param path - The file path to search for. If `undefined`, the function returns `undefined`.
   * @param filesCheck - An optional array of `TFile` objects to search within. If not provided, all markdown files in the vault are used.
   * @returns The matching `TFile` if found; otherwise, `undefined`.
   */
  getTFileFromPath(path, filesCheck = void 0) {
    if (!path)
      return void 0;
    const files = filesCheck ? filesCheck : this.app.vault.getMarkdownFiles();
    const matchingFiles = files.filter(
      (file) => file instanceof import_obsidian4.TFile && file.path.toLocaleLowerCase() === path.toLocaleLowerCase()
    );
    return matchingFiles.length > 0 ? matchingFiles[0] : void 0;
  }
  /**
   * Creates a new file at the specified path using the content from a template file.
   * If the file already exists, returns the existing file instead of creating a new one.
   *
   * @param fileNameWithPath - The full path (including file name) where the new file should be created.
   * @param templateFileWithPath - The full path to the template file whose content will be used.
   * @returns A promise that resolves to the newly created file or the existing file if it already exists.
   * @throws {ErrorManager} If the folder path is invalid, does not exist, or is not a folder.
   */
  async createFileFromPath(fileNameWithPath, templateFileWithPath) {
    const fileName = fileNameWithPath.replace(/^\/|\/$/g, "");
    const templateFile = templateFileWithPath.replace(/^\/|\/$/g, "");
    const folderPath = this.getFolderFromPath(fileName);
    const fileNameOnly = fileName.split("/").pop() || fileName;
    if (!folderPath) {
      throw new ErrorManager(`Invalid folder path: "${folderPath}"`);
    }
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!folder) {
      throw new ErrorManager(`Folder "${folderPath}" doesn't exist`);
    }
    if (!(folder instanceof import_obsidian4.TFolder)) {
      throw new ErrorManager(`${folderPath} is a file, not a folder`);
    }
    const templateContent = await this.app.vault.read(this.app.vault.getAbstractFileByPath(templateFile));
    const fileExists = this.app.vault.getAbstractFileByPath(fileNameWithPath);
    if (!fileExists) {
      return await this.app.vault.create(folder.path + "/" + fileNameOnly, templateContent);
    }
    return fileExists;
  }
  // create the file if it does not exist
  /**
   * * Fetches custom property information from all markdown files in the vault.
   *
   * @return {*} 
   */
  fetchCustomPropertyInfos(app) {
    const propertyInfos = {};
    const files = app.vault.getMarkdownFiles();
    files.forEach((file) => {
      const metadata = app.metadataCache.getFileCache(file);
      if (metadata == null ? void 0 : metadata.frontmatter) {
        Object.keys(metadata.frontmatter).forEach((key) => {
          if (!propertyInfos[key]) {
            propertyInfos[key] = { name: key, type: "text" };
          }
        });
      }
    });
    return propertyInfos;
  }
  /**
   * Fetches known properties from the metadata cache.
   * If the method getAllPropertyInfos is not available, it falls back to fetchCustomPropertyInfos.
   * @param app The Obsidian app instance.
   */
  async fetchKnownProperties(app) {
    let propertyInfos = {};
    if (typeof app.metadataCache.getAllPropertyInfos === "function") {
      propertyInfos = app.metadataCache.getAllPropertyInfos();
    } else {
      propertyInfos = this.fetchCustomPropertyInfos(app);
    }
    propertyInfos = Object.fromEntries(
      Object.entries(propertyInfos).sort(([keyA], [keyB]) => keyA.localeCompare(keyB))
    );
    this.knownProperties = {};
    Object.keys(propertyInfos).forEach((key) => {
      this.knownProperties[propertyInfos[key].name] = propertyInfos[key];
    });
    logger.log(DEBUG, this.knownProperties);
    return this.knownProperties;
  }
  /**
   * Retrieves the known properties, initializing them if they have not been loaded yet.
   * If the properties are not already cached, this method fetches them using `fetchCustomPropertyInfos`
   * and stores them for future access.
   *
   * @returns The cached or newly fetched known properties.
   */
  getKnownProperties() {
    if (!this.knownProperties) {
      this.knownProperties = this.fetchCustomPropertyInfos(this.app);
    }
    return this.knownProperties;
  }
  /**
   * Extracts the path and title from a given link string.
   *
   * The input link is expected to be in the format `[[path|title]]` or `[[path]]`.
   * This function removes square brackets, splits the link by the `|` character,
   * and determines the path and title. If the title is not provided, the path is
   * used as the title.
   *
   * @param link - The link string to extract parts from, typically in the format `[[path|title]]` or `[[path]]`.
   * @returns An object containing the `path` and `title` extracted from the link.
   */
  extractLinkParts(link) {
    const cleanedLink = link.replace(/[\[\]]/g, "");
    const parts = cleanedLink.split("|");
    const path = parts[0].trim();
    const title = parts.length > 1 ? parts[1].trim() : path;
    return { path, title };
  }
  /**
   * Extracts the path, title, and file name from a given file link string.
   *
   * Splits the input string by the "/" character to separate the file name from its path.
   * The title is derived from the file name by removing all extensions and trimming whitespace.
   *
   * @param link - The file link string to extract parts from.
   * @returns An object containing:
   *   - `path`: The directory path portion of the link (excluding the file name).
   *   - `title`: The file name without extensions and trimmed.
   *   - `fileName`: The full file name (with extensions, if any).
   */
  extractPathParts(link) {
    const parts = link.split("/");
    const fileName = parts.pop() || "";
    const title = this.removeAllExtensions(fileName).trim();
    const path = parts.join("/").trim();
    return { path, title, fileName };
  }
  /**
   * Removes one or more leading slashes from the beginning of the given path string.
   *
   * @param path - The input string from which to remove leading slashes.
   * @returns The input string without any leading slashes.
   */
  removeLeadingSlash(path) {
    return path.replace(/^\/+/, "");
  }
  /**
   * Ensures that the given path string starts with a leading slash ('/').
   * If the path already begins with a slash, it is returned unchanged.
   *
   * @param path - The input path string to modify.
   * @returns The path string guaranteed to start with a leading slash.
   */
  addLeadingSlash(path) {
    return path.replace(/^(?!\/)/, "/");
  }
  /**
   * Check if a string complies with ISO Standard
   * 
   * @param str Any string
   * @param options Options to look for
   * @returns 
   */
  isISOString(str, options = {}) {
    const {
      withMilliseconds = false,
      withTimezone = false,
      withTime = true,
      withDate = true
    } = options;
    let dateRegexStr = "^(?:\\d{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[12]\\d|3[01]))";
    let timeRegexStr = "(?:T(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
    if (withMilliseconds) {
      timeRegexStr += "\\.\\d{3}";
    }
    if (withTimezone) {
      timeRegexStr += "(?:Z|[+-](?:[01]\\d|2[0-3]):[0-5]\\d)?)?";
    } else {
      timeRegexStr += ")?";
    }
    let regexStr = "";
    if (withDate && withTime) {
      regexStr = `${dateRegexStr}${timeRegexStr}$`;
    } else if (withDate) {
      regexStr = `${dateRegexStr}$`;
    } else if (withTime) {
      regexStr = `^${timeRegexStr.slice(4)}$`;
    } else {
      return false;
    }
    const regex = new RegExp(regexStr);
    return regex.test(str);
  }
  /**
   * Try to convert Any Types to a specific Type
   * @param input 
   * @param typeString 'string' | 'number' | 'boolean' | 'string[]'
   * @returns 
   */
  tryConvert(input, typeString) {
    switch (typeString) {
      case "string":
        if (typeof input === "string") {
          return input;
        }
        return void 0;
      case "number":
        const num = Number(input);
        if (!isNaN(num)) {
          return num;
        }
        return void 0;
      case "boolean":
        if (typeof input === "boolean") {
          return input;
        }
        if (typeof input === "string") {
          const lowerValue = input.toLowerCase();
          if (lowerValue === "true") {
            return true;
          }
          if (lowerValue === "false") {
            return false;
          }
        }
        if (typeof input === "number") {
          if (input === 1) {
            return true;
          }
          if (input === 0) {
            return false;
          }
        }
        return void 0;
      case "string[]":
        if (Array.isArray(input) && input.every((item) => typeof item === "string")) {
          return input;
        }
        return void 0;
      default:
        return void 0;
    }
  }
  /**
   * Formats a given text string to be safe for use in YAML by replacing special characters.
   *
   * Replaces all characters that are not alphanumeric, dash, underscore, slash, or certain accented characters
   * with a specified replacement string. If no replacement string is provided, it uses the value from settings,
   * or defaults to `'-'`.
   *
   * @param text - The input string to format.
   * @param replaceBy - Optional. The string to replace special characters with. If not provided, uses the value from settings or `'-'`.
   * @returns The formatted string safe for YAML usage.
   */
  formatToYAMLSaveString(text, replaceBy = void 0) {
    let replaceString = "-";
    if (!replaceBy && this.settings) {
      replaceString = this.settings.specialCharReplacement || "-";
    } else {
      if (replaceBy)
        replaceString = replaceBy;
    }
    return text.replace(/[^a-zA-Z0-9\-_\/äöüßÄÖÜáéíóúýÁÉÍÓÚÝàèìòùÀÈÌÒÙâêîôûÂÊÎÔÛãñõÃÑÕ]/g, replaceString);
  }
  /**
   * Converts a string to a YAML-safe format by adding quotes when necessary.
   * @param input The string, boolean, number or array to make YAML-safe
   * @returns The safely quoted string when needed, or the original string if safe
   */
  toYamlSafeString(input) {
    if (Array.isArray(input)) {
      input.forEach((item, index) => {
        input[index] = this.toYamlSafeString(item).toString();
      });
      return input;
    }
    switch (typeof input) {
      case "number":
        return input;
      case "boolean":
        return input ? "true" : "false";
      case "string":
        const trimmed = input.trim();
        if (trimmed === "")
          return '""';
        const needsQuotes = /[:{}\[\],&*#?|<>=!%@`"'\\]|^[-?\n]|[\s\n]|^[yYnN]|^[0-9]|^[+-]|^(true|false|yes|no|on|off)$/i.test(trimmed);
        const isAlreadyQuoted = trimmed.startsWith('"') && trimmed.endsWith('"') || trimmed.startsWith("'") && trimmed.endsWith("'");
        if (!needsQuotes && !isAlreadyQuoted) {
          return trimmed;
        }
        if (!isAlreadyQuoted) {
          return `"${trimmed.replace(/"/g, '\\"')}"`;
        }
        return trimmed;
      default:
        logger.log(ERROR, `toYamlSafeString(${input}) if of type '${typeof input}'`);
        return input;
    }
  }
  /**
   * Converts an input string or array of strings into a Markdown Link format.
   * 
   * @param input - The input to be converted. Can be a string or an array of strings.
   * @param replaceSpaces - Optional parameter to specify a replacement for spaces in the path or title.
   *                        If provided, spaces will be replaced with this value.
   * @returns A string in Markdown Link format if the input is a single string, or a concatenated string
   *          of Markdown Links if the input is an array of strings.
   * 
   * The Markdown Link format is `[title](path)`, where:
   * - `path` is the formatted path of the link.
   * - `title` is the formatted title of the link.
   * 
   * If the input is an array, each element is converted to a WikiLink and joined with a comma.
   */
  toMarkdownLink(input, replaceSpaces) {
    if (Array.isArray(input)) {
      return input.map((item) => this.toWikiLink(item)).join(", ");
    }
    if (typeof input === "string") {
      const { path, title, fileName } = this.extractPathParts(input);
      const formattedPath = this.replaceSpaces(input, replaceSpaces);
      const formattedTitle = this.replaceSpaces(title, replaceSpaces);
      return `[[${formattedPath}|${formattedTitle}]]`;
    }
    return input;
  }
  /**
   * Converts an input string or array of strings into a WikiLink format string or array of strings.
   * 
   * @param input - The input to be converted. Can be a string or an array of strings.
   * @param replaceSpaces - Optional parameter to specify a replacement for spaces in the path or title.
   *                        If provided, spaces will be replaced with this value.
   * @returns A string in WikiLink format if the input is a single string, or a concatenated string
   *          of WikiLinks if the input is an array of strings.
   * 
   * The WikiLink format is `[[fileName]]`, where:
   * - `fileName` is the formatted unique fileName of the link.
   * 
   * If the input is an array, each element is converted to a WikiLink and joined with a comma.
   */
  toWikiLink(input, replaceSpaces = " ") {
    if (Array.isArray(input)) {
      return input.flatMap((item) => this.toWikiLink(item));
    }
    if (typeof input === "string") {
      const { path, title } = this.extractLinkParts(input);
      const formattedTitle = this.replaceSpaces(this.removeAllExtensions(title), replaceSpaces);
      return `[[${formattedTitle}]]`;
    }
    return input;
  }
  /**
   * Replaces all whitespace characters in the given text with a specified replacement string.
   *
   * @param text - The input string in which spaces will be replaced.
   * @param replaceBy - Optional. The string to replace spaces with. If not provided, uses the value from `this.settings.spaceReplacement` or defaults to '_'.
   * @returns The modified string with spaces replaced by the specified replacement string.
   */
  replaceSpaces(text, replaceBy = void 0) {
    let replaceString = "_";
    if (!replaceBy && this.settings) {
      replaceString = this.settings.spaceReplacement || "_";
    } else {
      if (replaceBy)
        replaceString = replaceBy;
    }
    return text.replace(/\s+/g, replaceString);
  }
  /**
   * Removes the ALL file extension(s) from a given file name.
   *
   * @param fileName - The name of the file, including its extension.
   * @returns The file name without its extension.
   */
  removeAllExtensions(fileName) {
    return fileName.split(".")[0];
  }
  /**
   * Removes the last file extension(s) from a given file name.
   *
   * @param fileName - The name of the file, including its extension.
   * @returns The file name without its extension.
   */
  removeExtensions(fileName) {
    const result = fileName.split(".");
    result.pop();
    if (result.length === 0)
      return fileName;
    return result.join(".") || fileName;
  }
  /**
   * Converts a given string to camelCase format.
   *
   * Splits the input text by spaces, lowercases the first word,
   * and capitalizes the first letter of each subsequent word,
   * then joins them together without spaces.
   *
   * @param text - The input string to be converted.
   * @returns The camelCase formatted string.
   */
  formatUpperCamelCase(text) {
    let textParts = text.split(" ");
    let convertedTextParts = [];
    textParts.forEach((text2, index) => {
      let newTextPart = text2.toLowerCase();
      newTextPart = newTextPart.charAt(0).toUpperCase() + newTextPart.slice(1);
      convertedTextParts.push(newTextPart);
    });
    return convertedTextParts.join("");
  }
  /**
   * get the path to a file from a string containing the full parh/name string
   * @param path string
   * @param separator string defaults to '/'
   * @returns string
   */
  getFolderFromPath(path, separator = "/") {
    if (path === null)
      return null;
    if (path === void 0)
      return void 0;
    const currentPathParts = path.split("/");
    currentPathParts.pop();
    return currentPathParts.join(separator);
  }
  /**
   * removes duplicate strings in an array and deletes empty strings
   * @param stringArray 
   * @returns 
   */
  removeDuplicateStrings(stringArray) {
    if (!stringArray)
      return [];
    const uniqueStringsSet = new Set(stringArray);
    uniqueStringsSet.delete("");
    return [...uniqueStringsSet];
  }
};
function getFolderFromPath(path, separator = "/") {
  if (path === null)
    return null;
  if (path === void 0)
    return void 0;
  const currentPathParts = path.split("/");
  currentPathParts.pop();
  return currentPathParts.join(separator);
}

// src/directorySelectionModal.ts
var import_obsidian5 = require("obsidian");
var DirectorySelectionModal = class extends import_obsidian5.Modal {
  // Reference to update dropdown on reset
  /**
   * Creates an instance of the DirectorySelectionModal.
   * @param app - The Obsidian App instance.
   * @param initialFolders - Array of initially selected folder paths.
   * @param initialFiles - Array of initially selected file paths.
   * @param initialMode - The initial selection mode ('include' or 'exclude').
   * @param okCallback - Function to call when the user clicks "OK". Receives the selection result.
   */
  constructor(app, initialFolders, initialFiles, initialOptions, okCallback) {
    super(app);
    this.showFiles = false;
    // Container for the tree view
    this.treeNodes = /* @__PURE__ */ new Map();
    // Map path to node info for quick access
    this.modeDropdown = null;
    this.initialFoldersSnapshot = new Set(initialFolders);
    this.initialFilesSnapshot = new Set(initialFiles);
    this.initialModeSnapshot = initialOptions.selectionMode;
    this.initialDisplaySnapshot = initialOptions.displayMode;
    this.showFiles = initialOptions.displayMode === "files" || initialOptions.displayMode === "file" || initialFiles.length > 0;
    this.options = initialOptions;
    this.okCallback = okCallback;
    this.resetSelectionToInitial();
  }
  /**
   * Resets the current selection state to the initial state provided at construction.
   */
  resetSelectionToInitial() {
    this.currentFolders = new Set(this.initialFoldersSnapshot);
    this.currentFiles = new Set(this.initialFilesSnapshot);
    this.currentMode = this.initialModeSnapshot;
  }
  /**
   * Resets the current selection state to empty.
   */
  resetSelectionToEmpty() {
    this.currentFolders = /* @__PURE__ */ new Set([]);
    this.currentFiles = /* @__PURE__ */ new Set([]);
    this.currentMode = this.initialModeSnapshot;
  }
  /**
   * Called when the modal is opened. Builds the UI.
   */
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("directory-selection-modal");
    if (this.includeExcludeSelectable) {
      contentEl.createEl("h2", { text: this.options.title || "Include or Exclude Folders and Files" });
    } else {
      contentEl.createEl("h2", { text: this.options.title || `${this.currentMode === "exclude" ? "Exclude" : "Include"} Folders and Files` });
    }
    const controlsEl = contentEl.createDiv({ cls: "modal-controls" });
    this.createModeSetting(controlsEl);
    this.createShowFilesSetting(controlsEl);
    this.treeRootElement = contentEl.createDiv({ cls: "tree-view-container" });
    this.treeRootElement.style.maxHeight = "600px";
    this.treeRootElement.style.overflowY = "auto";
    this.treeRootElement.style.border = "1px solid var(--background-modifier-border)";
    this.treeRootElement.style.padding = "10px";
    this.treeRootElement.style.marginTop = "10px";
    this.treeRootElement.style.marginBottom = "10px";
    if (!this.treeNodes.size) {
      this.buildAndRenderTree();
    }
    this.createActionButtons(contentEl);
  }
  /**
   * Creates the dropdown setting for choosing the selection mode.
   * @param containerEl - The HTML element to append the setting to.
   */
  createModeSetting(containerEl) {
    if (this.includeExcludeSelectable) {
      this.modeDropdown = new import_obsidian5.Setting(containerEl).setName("Selection Mode").setDesc("Choose if the selected files and folders should be excluded or included.").addDropdown((dropdown) => {
        dropdown.addOption("exclude", "exclude").addOption("include", "include").setValue(this.currentMode).onChange((value) => {
          this.currentMode = value;
          this.updateTreeAppearance();
        });
      });
    }
  }
  /**
   * Updates the mode dropdown UI element to reflect the currentMode state.
   */
  updateModeDropdown() {
    var _a;
    const dropdownComponent = (_a = this.modeDropdown) == null ? void 0 : _a.components[0];
    if (dropdownComponent && typeof dropdownComponent.setValue === "function") {
      dropdownComponent.setValue(this.currentMode);
    }
  }
  /**
   * Creates the toggle setting for showing/hiding files in the tree.
   * @param containerEl - The HTML element to append the setting to.
   */
  createShowFilesSetting(containerEl) {
    if (this.options.optionShowFiles) {
      new import_obsidian5.Setting(containerEl).setName("Show Files").setDesc("Show Files within the directory tree.").addToggle((toggle) => {
        toggle.setValue(this.showFiles).onChange((value) => {
          this.showFiles = value;
          this.buildAndRenderTree();
        });
      });
    }
  }
  /**
   * Creates the "OK" and "Reset" buttons.
   * @param containerEl - The HTML element to append the buttons to.
   */
  createActionButtons(containerEl) {
    const buttonsEl = containerEl.createDiv({ cls: "modal-buttons" });
    buttonsEl.style.marginTop = "15px";
    buttonsEl.style.display = "flex";
    buttonsEl.style.justifyContent = "flex-end";
    buttonsEl.style.gap = "10px";
    const resetButton = buttonsEl.createEl("button");
    (0, import_obsidian5.setIcon)(resetButton, "reset");
    resetButton.ariaLabel = "Reset selection";
    resetButton.onclick = () => {
      this.resetSelectionToInitial();
      this.updateModeDropdown();
      this.buildAndRenderTree();
    };
    const emptyButton = buttonsEl.createEl("button");
    (0, import_obsidian5.setIcon)(emptyButton, "eraser");
    emptyButton.ariaLabel = "Clear selection";
    emptyButton.onclick = () => {
      this.resetSelectionToEmpty();
      this.updateModeDropdown();
      this.buildAndRenderTree();
    };
    const cancelButton = buttonsEl.createEl("button", { text: "Cancel" });
    cancelButton.ariaLabel = "close and discard changes";
    cancelButton.onclick = () => {
      this.okCallback(null);
      this.close();
    };
    const okButton = buttonsEl.createEl("button", { text: "OK", cls: "mod-cta" });
    okButton.ariaLabel = "close and save changes";
    okButton.onclick = () => {
      this.close();
    };
  }
  /**
   * Builds the logical tree structure data from the vault's files and folders.
   * @returns The root node of the tree structure.
   */
  buildTreeData() {
    const vaultRootNode = {
      path: "/",
      // Root folder path
      name: this.app.vault.getName() || "Vault",
      // Use vault name or default
      type: "folder",
      children: [],
      // Placeholder elements, will be assigned during rendering
      element: null,
      checkbox: null,
      label: null,
      container: null
    };
    const folderNodes = /* @__PURE__ */ new Map();
    folderNodes.set("/", vaultRootNode);
    const allFiles = this.app.vault.getFiles();
    allFiles.forEach((file) => {
      const parentFolder = file.parent;
      if (!parentFolder)
        return;
      let currentPath = "";
      const pathParts = parentFolder.path.split("/").filter((p) => p.length > 0);
      let parentNode = vaultRootNode;
      pathParts.forEach((part) => {
        currentPath = currentPath === "/" ? part : `${currentPath}/${part}`;
        if (!folderNodes.has(currentPath)) {
          const newFolderNode = {
            path: currentPath,
            name: part,
            type: "folder",
            children: [],
            element: null,
            checkbox: null,
            label: null,
            container: null
          };
          folderNodes.set(currentPath, newFolderNode);
          if (!parentNode.children) {
            parentNode.children = [];
          }
          parentNode.children.push(newFolderNode);
          parentNode = newFolderNode;
        } else {
          parentNode = folderNodes.get(currentPath);
        }
      });
    });
    if (this.showFiles) {
      allFiles.forEach((file) => {
        const parentFolder = file.parent;
        let parentPath = "";
        if (parentFolder) {
          parentPath = "/" + (parentFolder.path === "/" ? "" : parentFolder.path);
        }
        const parentNode = folderNodes.get(parentPath);
        const fileNode = {
          path: file.path,
          name: file.name,
          type: "file",
          element: null,
          checkbox: null,
          label: null,
          container: null
        };
        if (parentNode) {
          if (!parentNode.children) {
            parentNode.children = [];
          }
          parentNode.children.push(fileNode);
        }
      });
    }
    const sortNodes = (a, b) => {
      if (a.type === "folder" && b.type === "file")
        return -1;
      if (a.type === "file" && b.type === "folder")
        return 1;
      return a.name.localeCompare(b.name);
    };
    folderNodes.forEach((node) => {
      var _a;
      return (_a = node.children) == null ? void 0 : _a.sort(sortNodes);
    });
    return vaultRootNode;
  }
  /**
   * Renders the entire tree structure in the DOM based on the tree data.
   */
  renderTree() {
    var _a;
    this.treeRootElement.empty();
    this.treeNodes.clear();
    const treeData = this.buildTreeData();
    const rootUl = this.treeRootElement.createEl("ul");
    rootUl.addClass("tree-root-ul");
    rootUl.style.listStyle = "none";
    rootUl.style.paddingLeft = "0";
    this.renderTreeNode(treeData, rootUl, 0, this.currentFolders, this.currentFiles);
    (_a = treeData.children) == null ? void 0 : _a.forEach((childNode) => {
    });
  }
  /**
   * Recursively renders a single tree node and its children in the DOM.
   * @param node - The TreeNode data to render.
   * @param parentElement - The HTML `ul` element to append this node's `li` to.
   * @param level - The current indentation level.
   */
  renderTreeNode(node, parentElement, level, selectedPaths, selectedfiles) {
    const li = parentElement.createEl("li");
    li.style.marginLeft = `${level * 20}px`;
    li.addClass(`tree-node-${node.type}`);
    const container = li.createDiv({ cls: "tree-node-container" });
    container.style.display = "flex";
    container.style.alignItems = "center";
    container.style.padding = "2px 0";
    let toggleButton = null;
    let isCollapsed = true;
    if (node.type === "folder") {
      toggleButton = container.createSpan({ cls: "tree-toggle-button" });
      toggleButton.textContent = "\u25B6";
      toggleButton.style.cursor = "pointer";
      toggleButton.style.marginRight = "5px";
      const shouldExpand = this.shouldExpandFolder(node, selectedPaths, selectedfiles);
      if (shouldExpand) {
        isCollapsed = false;
      }
      toggleButton.onclick = () => {
        isCollapsed = !isCollapsed;
        if (toggleButton)
          toggleButton.textContent = isCollapsed ? "\u25B6" : "\u25BC";
        if (childrenUl)
          childrenUl.style.display = isCollapsed ? "none" : "block";
      };
    }
    const checkbox = container.createEl("input", { type: "checkbox" });
    checkbox.id = `tree-cb-${node.path.replace(/[^a-zA-Z0-9]/g, "-")}`;
    checkbox.dataset.path = node.path;
    checkbox.dataset.type = node.type;
    const label = container.createEl("label");
    label.textContent = `${node.type === "folder" ? "\u{1F4C1}" : "\u{1F4C4}"} ${node.name}`;
    label.htmlFor = checkbox.id;
    label.style.marginLeft = "5px";
    label.style.cursor = "pointer";
    label.title = node.path;
    node.element = li;
    node.checkbox = checkbox;
    node.label = label;
    node.container = container;
    this.treeNodes.set(node.path, node);
    if (node.type === "folder") {
      checkbox.checked = this.currentFolders.has(node.path);
    } else {
      checkbox.checked = this.currentFiles.has(node.path);
    }
    checkbox.onchange = (event) => {
      const target = event.target;
      const path = target.dataset.path;
      const type = target.dataset.type;
      if (target.checked) {
        if (type === "folder") {
          if (this.options.displayMode === "folder") {
            this.currentFolders.clear();
          }
          this.currentFolders.add(path);
        } else {
          if (this.options.displayMode === "file") {
            this.currentFiles.clear();
          }
          this.currentFiles.add(path);
        }
      } else {
        if (type === "folder")
          this.currentFolders.delete(path);
        else
          this.currentFiles.delete(path);
      }
      this.updateTreeAppearance();
    };
    let childrenUl = null;
    if (node.type === "folder" && node.children && node.children.length > 0) {
      childrenUl = li.createEl("ul");
      childrenUl.style.listStyle = "none";
      childrenUl.style.paddingLeft = "0";
      childrenUl.style.marginLeft = "0";
      childrenUl.style.display = isCollapsed ? "none" : "block";
      node.children.forEach((child) => this.renderTreeNode(child, childrenUl, level + 1, selectedPaths, selectedfiles));
    }
  }
  // Helper method to determine if a folder should be expanded
  shouldExpandFolder(node, selectedPaths, selectedFiles) {
    if (selectedPaths.has(node.path) || selectedFiles.has(node.path)) {
      return true;
    }
    if (node.children) {
      for (const child of node.children) {
        if (this.shouldExpandFolder(child, selectedPaths, selectedFiles)) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Updates the visual appearance (enabled/disabled/styling) of all nodes
   * in the tree based on the current mode and selections.
   */
  updateTreeAppearance() {
    this.treeNodes.forEach((node) => {
      let isDisabled = false;
      let isEffectivelyIncluded = false;
      let isEffectivelyExcluded = false;
      let ancestorFolderSelected = false;
      let currentPath = node.path;
      while (currentPath !== "/") {
        const parentPath = currentPath.substring(0, currentPath.lastIndexOf("/")) || "/";
        if (this.currentFolders.has(parentPath)) {
          ancestorFolderSelected = true;
          break;
        }
        if (parentPath === currentPath)
          break;
        currentPath = parentPath;
      }
      const nodeSelected = node.type === "folder" ? this.currentFolders.has(node.path) : this.currentFiles.has(node.path);
      if (this.currentMode === "exclude") {
        isEffectivelyExcluded = nodeSelected || ancestorFolderSelected;
        isDisabled = isEffectivelyExcluded;
      } else {
        if (node.type === "folder") {
          isEffectivelyIncluded = nodeSelected || ancestorFolderSelected;
        } else {
          const parentPath = node.path.substring(0, node.path.lastIndexOf("/")) || "/";
          const parentEffectivelyIncluded = this.isPathEffectivelyIncluded(parentPath);
          isEffectivelyIncluded = nodeSelected || parentEffectivelyIncluded;
        }
        isDisabled = !isEffectivelyIncluded;
      }
      node.checkbox.disabled = false;
      node.checkbox.checked = nodeSelected;
      if (isDisabled) {
        node.element.addClass("is-disabled");
      } else {
        node.element.removeClass("is-disabled");
      }
      node.element.classList.remove("is-included", "is-excluded");
      if (this.currentMode === "include" && isEffectivelyIncluded) {
        node.element.addClass("is-included");
      } else if (this.currentMode === "exclude" && isEffectivelyExcluded) {
        node.element.addClass("is-excluded");
      }
    });
  }
  /**
   * Helper function to determine if a given path is effectively included
   * in the current selection under 'include' mode.
   * A path is included if it (file or folder) is selected, or if any of its ancestor FOLDERS are selected.
   * @param path - The folder or file path to check.
   * @returns True if the path should be considered included, false otherwise.
   */
  isPathEffectivelyIncluded(path) {
    if (this.currentMode !== "include") {
      return !this.isPathEffectivelyExcluded(path);
    }
    if (this.currentFiles.has(path) || this.currentFolders.has(path)) {
      return true;
    }
    let current = path;
    while (current !== "/") {
      const parentPath = current.substring(0, current.lastIndexOf("/")) || "/";
      if (this.currentFolders.has(parentPath)) {
        return true;
      }
      if (parentPath === current)
        break;
      current = parentPath;
    }
    return false;
  }
  /**
  * Helper function to determine if a given path is effectively excluded
  * in the current selection under 'exclude' mode.
  * A path is excluded if it (file or folder) is selected, or if any of its ancestor FOLDERS are selected.
  * @param path - The folder or file path to check.
  * @returns True if the path should be considered excluded, false otherwise.
  */
  isPathEffectivelyExcluded(path) {
    if (this.currentMode !== "exclude") {
      return false;
    }
    if (this.currentFiles.has(path) || this.currentFolders.has(path)) {
      return true;
    }
    let current = path;
    while (current !== "/") {
      const parentPath = current.substring(0, current.lastIndexOf("/")) || "/";
      if (this.currentFolders.has(parentPath)) {
        return true;
      }
      if (parentPath === current)
        break;
      current = parentPath;
    }
    return false;
  }
  /**
   * Combines building the tree data, rendering the DOM, and applying initial appearance.
   */
  buildAndRenderTree() {
    this.renderTree();
    this.updateTreeAppearance();
  }
  /**
   * Called when the modal is closed. Cleans up resources.
   */
  onClose() {
    const result = {
      folders: Array.from(this.currentFolders),
      files: Array.from(this.currentFiles),
      mode: this.currentMode,
      display: this.currentDisplay
    };
    this.okCallback(result);
    const { contentEl } = this;
    contentEl.empty();
    this.treeNodes.clear();
    this.modeDropdown = null;
  }
};
function openDirectorySelectionModal(app, initialFolders, initialFiles, options, okCallback) {
  new DirectorySelectionModal(
    app,
    initialFolders,
    initialFiles,
    options,
    okCallback
  ).open();
}

// src/settings-properties.ts
var import_obsidian11 = require("obsidian");

// src/types.ts
var DEFAULT_FILTER_FILES_AND_FOLDERS = {
  selectedFolders: [],
  selectedFiles: [],
  mode: "exclude",
  display: "folders"
};
var DEFAULT_FRONTMATTER_AUTOMATE_SETTINGS = {
  tagPrefix: "",
  excludeRootFolder: false,
  tagsPropertyName: "tags",
  spaceReplacement: "",
  specialCharReplacement: "",
  lowercaseTags: false,
  knownProperties: [],
  rules: [],
  useTextArea: false,
  exclude: {
    selectedFolders: [],
    selectedFiles: [],
    mode: "exclude",
    display: "folders"
  },
  include: {
    selectedFolders: [],
    selectedFiles: [],
    mode: "include",
    display: "folders"
  },
  configuredProperties: [],
  debugLevel: WARNING,
  delayCreateEvent: 0,
  // default to no delay
  folderConfig: { folders: [], rows: [] }
};
var DEFAULT_RULE_DEFINITION = {
  id: "",
  active: true,
  asLink: false,
  //deprecated
  addContent: "overwrite",
  property: "",
  value: "",
  customProperty: "",
  type: "text",
  typeProperty: { name: "", type: "text", source: "registered" },
  content: "",
  buildInCode: "",
  jsCode: "",
  showContent: false,
  exclude: {
    selectedFolders: [],
    selectedFiles: [],
    mode: "exclude",
    display: "folders"
  },
  include: {
    selectedFolders: [],
    selectedFiles: [],
    mode: "include",
    display: "folders"
  },
  prefix: "",
  spaceReplacement: "",
  specialCharReplacement: "",
  lowercaseTags: false,
  //deprecated
  formatter: "toOriginal",
  //deprecated
  formatters: ["toOriginal"],
  linkFormatter: "toOriginalLink",
  inputProperty: "",
  onlyModify: true,
  useCustomCode: false,
  optionsConfig: void 0
};

// src/rules.ts
function executeRuleObject(event, app, plugin, settings, currentFile, currentContent, rule, frontMatter, oldLocationResults) {
  var _a;
  if (!rule)
    return currentContent;
  if (!rule.active)
    return currentContent;
  if (!currentFile)
    return currentContent;
  if (!checkIfFileAllowed(currentFile, settings, rule))
    return currentContent;
  const tools = new ScriptingTools(app, plugin, settings, rule, frontMatter);
  let result = currentContent;
  let oldResult = void 0;
  tools.setCurrentContent(frontMatter[rule.property]);
  tools.setRule(rule);
  tools.setFrontmatter(frontMatter);
  tools.setActiveFile(currentFile);
  const ruleObject = rulesManager.getRuleById(rule.content);
  if (!ruleObject)
    return currentContent;
  result = rulesManager.executeRule(rule, ruleObject, app, currentFile, tools, frontMatter);
  result = rulesManager.applyFormatOptions(result, rule, currentFile, tools);
  if (oldLocationResults && oldLocationResults.length > 0 && rule.addContent !== "overwrite") {
    oldResult = (_a = oldLocationResults.find((res) => res.ruleId === rule.id)) == null ? void 0 : _a.result;
    if (!oldResult) {
      logger.log(ERROR, `executeRuleObject: Old result for rule ${rule.property}|${rule.content} not found!`, oldLocationResults);
      return result;
    }
    oldResult = rulesManager.applyFormatOptions(oldResult, rule, currentFile, tools);
    logger.log(DEBUG, `executeRuleObject: Merging result for rule ${rule.property}|${rule.content} with old result`, oldResult, result);
    result = rulesManager.mergeResult(result, oldResult, currentContent, rule);
  } else {
    result = rulesManager.mergeResult(result, result, currentContent, rule);
  }
  return result;
}
function filterFile(file, fileList, filterMode, type) {
  let result = false;
  const filterArray = type === "folders" ? fileList[filterMode].selectedFolders : fileList[filterMode].selectedFiles;
  if (filterArray.length === 0)
    return filterMode === "include" ? false : true;
  const filePath = file.path;
  const fileFolder = getFolderFromPath(file.path);
  const fileName = file.basename + "." + file.extension;
  if (type === "files") {
    result = filterArray.includes(filePath);
  }
  if (type === "folders") {
    for (let path of filterArray) {
      result = (fileFolder == null ? void 0 : fileFolder.startsWith(path.slice(1))) || false;
      if (result === true)
        return filterMode === "exclude" ? !result : result;
    }
    ;
  }
  ;
  return filterMode === "exclude" ? !result : result;
}
function checkIfFileAllowed(file, settings, rule) {
  let result = true;
  if (!file)
    return false;
  if (settings) {
    try {
      if (settings.exclude.selectedFiles.length > 0) {
        result = filterFile(file, settings, "exclude", "files");
      }
      if (result && settings.exclude.selectedFolders.length > 0) {
        result = filterFile(file, settings, "exclude", "folders");
      }
      if (!result && settings.include.selectedFiles.length > 0) {
        result = filterFile(file, settings, "include", "files");
      }
      if (!result && settings.include.selectedFolders.length > 0) {
        result = filterFile(file, settings, "include", "folders");
      }
    } catch (error) {
      logger.log(ERROR, `Error filtering file ${file.path} globally: ${error}`);
      return false;
    }
  }
  if (rule) {
    try {
      if (result && rule.exclude.selectedFiles.length > 0) {
        result = filterFile(file, rule, "exclude", "files");
      }
      if (result && rule.exclude.selectedFolders.length > 0) {
        result = filterFile(file, rule, "exclude", "folders");
      }
      if (!result && rule.include.selectedFiles.length > 0) {
        result = filterFile(file, rule, "include", "files");
      }
      if (!result && rule.include.selectedFolders.length > 0) {
        result = filterFile(file, rule, "include", "folders");
      }
    } catch (error) {
      logger.log(ERROR, `Error filtering file ${file.path} by rule ${rule.property}|${rule.content}: ${error}`);
      return false;
    }
  }
  return result;
}

// src/settings-properties.ts
var import_crypto = require("crypto");

// src/editorModal.ts
var import_obsidian7 = require("obsidian");

// src/uiElements.ts
var import_obsidian6 = require("obsidian");
function renderValueInput(containerEl, propertyInfo, currentValue, changeCallback) {
  let returnComponent;
  containerEl.empty();
  if (!propertyInfo) {
    containerEl.setText("");
    containerEl.addClass("text-muted");
    return;
  }
  const type = propertyInfo.type;
  switch (type) {
    case "number":
      returnComponent = new import_obsidian6.TextComponent(containerEl).setPlaceholder("Numeric Value").setValue(currentValue !== void 0 && currentValue !== null ? String(currentValue) : "").onChange(async (value) => {
        const numValue = value === "" ? void 0 : parseFloat(value);
        changeCallback(propertyInfo, isNaN(numValue) ? void 0 : numValue);
      });
      returnComponent.inputEl.type = "number";
      break;
    case "checkbox":
      returnComponent = containerEl.createDiv({ cls: "tri-state-checkbox clickable-icon" });
      returnComponent.setAttribute("aria-label", "Checkbox change state");
      returnComponent.setAttribute("role", "checkbox");
      const updateCheckboxVisual = (state) => {
        let iconName;
        let ariaState;
        if (state === true) {
          iconName = "check-square";
          ariaState = "true";
        } else if (state === false) {
          iconName = "square";
          ariaState = "false";
        } else {
          iconName = "minus-square";
          ariaState = "mixed";
        }
        (0, import_obsidian6.setIcon)(returnComponent, iconName);
        returnComponent.setAttribute("aria-checked", ariaState);
        returnComponent.dataset.state = String(state);
      };
      updateCheckboxVisual(currentValue);
      returnComponent.addEventListener("click", async () => {
        let currentState = returnComponent.dataset.state;
        let nextState;
        if (currentState === "false") {
          nextState = true;
        } else if (currentState === "true") {
          nextState = void 0;
        } else {
          nextState = false;
        }
        changeCallback(propertyInfo, nextState);
        updateCheckboxVisual(nextState);
      });
      break;
    case "date":
      returnComponent = new import_obsidian6.TextComponent(containerEl).setPlaceholder("YYYY-MM-DD").setValue(currentValue || "").onChange(async (value) => {
        changeCallback(propertyInfo, value || void 0);
      });
      returnComponent.inputEl.type = "date";
      break;
    case "datetime":
      returnComponent = new import_obsidian6.TextComponent(containerEl).setPlaceholder("YYYY-MM-DDTHH:mm").setValue(currentValue || "").onChange(async (value) => {
        changeCallback(propertyInfo, value || void 0);
      });
      returnComponent.inputEl.type = "datetime-local";
      break;
    case "aliases":
    case "tags":
    case "multitext":
      returnComponent = new import_obsidian6.TextComponent(containerEl).setPlaceholder("values (divided by comma)").setValue(Array.isArray(currentValue) ? currentValue.join(", ") : currentValue || "").onChange(async (value) => {
        const arrayValue = value.split(",").map((s) => s.trim()).filter((s) => s);
        changeCallback(propertyInfo, arrayValue.length > 0 ? arrayValue : void 0);
      });
      break;
    case "text":
    default:
      returnComponent = new import_obsidian6.TextComponent(containerEl).setPlaceholder("value").setValue(currentValue || "").onChange(async (value) => {
        changeCallback(propertyInfo, value || void 0);
      });
      break;
  }
  if (type !== "checkbox") {
    returnComponent.inputEl.style.backgroundColor = "transparent";
    returnComponent.inputEl.style.width = "100%";
    returnComponent.inputEl.style.border = "none";
  }
  return returnComponent;
}
function updatePropertyIcon(iconEl, type) {
  let iconName = "hash";
  switch (type) {
    case "text":
      iconName = "align-left";
      break;
    case "number":
      iconName = "binary";
      break;
    case "multitext":
      iconName = "list";
      break;
    case "date":
      iconName = "calendar";
      break;
    case "datetime":
      iconName = "clock";
      break;
    case "checkbox":
      iconName = "check-square";
      break;
    case "tags":
      iconName = "tags";
      break;
    case "aliases":
      iconName = "forward";
      break;
    default:
      iconName = "help-circle";
  }
  (0, import_obsidian6.setIcon)(iconEl, iconName);
}

// src/editorModal.ts
var codeEditorModal = class extends import_obsidian7.Modal {
  /**
   * Creates an instance of the DirectorySelectionModal.
   * @param app - The Obsidian App instance.
   * @param plugin - The plugin instance.
   * @param initialCode - String with the initial code.
   * @param expectedType - Expected return type.
   * @param activeFile - The currently active file or folder.
   * @param frontmatter - Frontmatter data for the active file.
   * @param okCallback - Function to call when the user clicks "OK". Receives the selection result.
   */
  constructor(app, plugin, initialCode, expectedType, activeFile, frontmatter, okCallback) {
    super(app);
    this.initialCode = initialCode;
    this.expectedType = expectedType;
    this.useTextArea = false;
    this.checkedSuccessfully = false;
    this.activeFile = activeFile;
    this.frontmatter = frontmatter;
    this.currentType = expectedType;
    this.currentCode = initialCode;
    this.plugin = plugin;
    this.scriptingTools = new ScriptingTools(
      app,
      this.plugin,
      this.plugin.settings,
      void 0,
      this.frontmatter,
      this.activeFile instanceof import_obsidian7.TFile ? this.activeFile : void 0
    );
    this.okCallback = okCallback;
    this.resetSelectionToInitial();
  }
  /**
   * Resets the current selection state to the initial state provided at construction.
   */
  resetSelectionToInitial() {
    var _a;
    this.currentCode = this.initialCode;
    (_a = this.cmEditor) == null ? void 0 : _a.setValue(this.currentCode);
    if (this.functionResultTextComponent)
      this.functionResultTextComponent.setValue("");
  }
  /**
   * Resets the current selection state to empty.
   */
  resetSelectionToEmpty() {
    var _a;
    this.currentCode = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    (_a = this.cmEditor) == null ? void 0 : _a.setValue(this.currentCode);
    if (this.functionResultTextComponent)
      this.functionResultTextComponent.setValue("");
  }
  loadCodeMirrorMode(mode) {
    try {
      require(`obsidian/lib/codemirror/mode/${mode}/${mode}.js`);
      logger.log(DEBUG, `CodeMirror mode '${mode}' loaded successfully (using require).`);
    } catch (error) {
      logger.log(ERROR, `Failed to load CodeMirror mode '${mode}' (using require):`, error);
    }
  }
  /**
   * Called when the modal is opened. Builds the UI.
   */
  async onOpen() {
    const { contentEl } = this;
    if (contentEl.parentElement)
      contentEl.parentElement.style.width = "900px";
    contentEl.empty();
    contentEl.addClass("codeEditor-modal");
    contentEl.createEl("h2", { text: "JavaScript Editor" });
    contentEl.createEl("body", { text: `Make sure your code results: ${this.expectedType}` });
    this.editorRootElement = contentEl.createDiv({ cls: "codeEditor-container" });
    this.editorRootElement.style.height = "600px";
    this.editorRootElement.style.overflowY = "auto";
    this.editorRootElement.style.padding = "10px";
    this.editorRootElement.style.marginTop = "10px";
    this.editorRootElement.style.marginBottom = "10px";
    this.cmEditor = null;
    const ruleOptionsDiv = contentEl.createDiv({ cls: "codeEditor-options" });
    if (this.useTextArea) {
      const ruleOptionsSettings = new import_obsidian7.Setting(this.editorRootElement).addTextArea((textArea) => {
        textArea.setPlaceholder("ender valid JS Code");
        textArea.inputEl.setAttribute("style", `height:190px; width:80%;`);
        textArea.onChange(async (value) => {
          if (this.functionTestButton)
            this.functionTestButton.buttonEl.addClass("mod-warning");
          this.currentCode = value;
        });
      });
    } else {
      const CodeMirror = window.CodeMirror;
      if (CodeMirror) {
        if (!CodeMirror.modes.javascript) {
          await this.loadCodeMirrorMode("javascript");
          logger.log(TRACE, "javaScript support loaded");
        }
      }
      let jsCode = this.currentCode;
      this.cmEditor = CodeMirror(this.editorRootElement, {
        value: jsCode || "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result; // return you result.\n}",
        mode: "javascript",
        lineNumbers: true,
        theme: "obsidian",
        indentUnit: 4,
        lineWrapping: false,
        readOnly: false,
        outerHeight: "600px"
      });
      if (this.cmEditor) {
        this.cmEditor.on("change", (cmEditor) => {
          if (this.functionTestButton)
            this.functionTestButton.buttonEl.addClass("mod-warning");
        });
        this.cmEditor.on("blur", (cmEditor) => {
          this.currentCode = cmEditor.getValue();
        });
      }
      ;
      new import_obsidian7.Setting(ruleOptionsDiv).addButton((button) => {
        this.functionTestButton = button;
        button.setWarning().setButtonText("Run Code").setTooltip("Run the code and check for errors").onClick(async () => {
          if (this.cmEditor) {
            let jsCode2 = this.cmEditor.getValue();
            let userFunction = parseJSCode(jsCode2);
            if (typeof userFunction === "string") {
              let errorHint = "See console for details!";
              if (userFunction.contains("Unexpected token")) {
                errorHint = "Did you missed a semicolon (;)?";
              }
              if (this.functionResultTextComponent)
                this.functionResultTextComponent.setValue(`Syntax error: ${userFunction}! ${errorHint}`);
              this.checkedSuccessfully = false;
              button.buttonEl.addClass("mod-warning");
            } else {
              if (userFunction) {
                try {
                  const result = userFunction(this.app, this.activeFile, this.scriptingTools);
                  if (this.functionResultTextComponent)
                    this.functionResultTextComponent.setValue(`'${result.toString()}' (${typeof result})`);
                  this.updateTypeIcons(result, typesContainer, this.expectedType, this.currentType, this.plugin.settings);
                  button.buttonEl.removeClass("mod-warning");
                  this.checkedSuccessfully = true;
                } catch (e) {
                  if (this.functionResultTextComponent) {
                    const errorMessage = e instanceof Error ? e.message : String(e);
                    this.functionResultTextComponent.setValue(`Syntax error: ${errorMessage}! See console for details!`);
                  }
                  logger.log(ERROR, "Syntax error. ", e, jsCode2, userFunction);
                  this.checkedSuccessfully = false;
                  button.buttonEl.addClass("mod-warning");
                }
              } else {
                logger.log(ERROR, "syntax error");
                this.checkedSuccessfully = false;
              }
            }
          }
        });
      }).addText((text) => {
        this.functionResultTextComponent = text;
        text.setPlaceholder("function result").setDisabled(true);
        this.functionResultTextComponent.inputEl.style.width = "580px";
      });
      const typesContainer = ruleOptionsDiv.createDiv({ cls: "property-icons-container" });
    }
    this.createActionButtons(contentEl);
  }
  updateTypeIcons(value, container, expectedType, currentType, settings) {
    const newType = typeof value;
    const typeIcons = {
      "string": ["text", "tags", "aliases", "multitext", "date", "datetime"],
      "number": ["number"],
      "boolean": ["checkbox"],
      "object": ["tags", "aliases", "multitext"]
    };
    if (newType === "string") {
      if (!this.scriptingTools.isISOString(value, { withDate: true })) {
        typeIcons[newType].splice(typeIcons[newType].indexOf("date"), 1);
      }
      if (!this.scriptingTools.isISOString(value, { withDate: true, withTime: true })) {
        typeIcons[newType].splice(typeIcons[newType].indexOf("datetime"), 1);
      }
    }
    container.empty();
    for (let obsidianType of typeIcons[newType]) {
      if (obsidianType) {
        const iconEl = container.createSpan({ cls: "property-icon setting-item-icon" });
        updatePropertyIcon(iconEl, obsidianType);
      }
    }
  }
  /**
   * Creates the "OK" and "Reset" buttons.
   * @param containerEl - The HTML element to append the buttons to.
   */
  createActionButtons(containerEl) {
    const buttonsEl = containerEl.createDiv({ cls: "modal-buttons" });
    buttonsEl.style.marginTop = "15px";
    buttonsEl.style.display = "flex";
    buttonsEl.style.justifyContent = "flex-end";
    buttonsEl.style.gap = "10px";
    const resetButton = buttonsEl.createEl("button");
    (0, import_obsidian7.setIcon)(resetButton, "reset");
    resetButton.ariaLabel = "Reset selection";
    resetButton.onclick = () => {
      this.resetSelectionToInitial();
    };
    const emptyButton = buttonsEl.createEl("button");
    (0, import_obsidian7.setIcon)(emptyButton, "eraser");
    emptyButton.ariaLabel = "Clear selection";
    emptyButton.onclick = () => {
      this.resetSelectionToEmpty();
    };
    const cancelButton = buttonsEl.createEl("button", { text: "Cancel" });
    cancelButton.ariaLabel = "close and discard changes";
    cancelButton.onclick = () => {
      logger.log(TRACE, "Cancel Clicked - Returning");
      this.okCallback(null);
      this.close();
    };
    const okButton = buttonsEl.createEl("button", { text: "OK", cls: "mod-cta" });
    cancelButton.ariaLabel = "close and save changes";
    okButton.onclick = () => {
      this.close();
    };
  }
  /**
   * Called when the modal is closed. Cleans up resources.
   */
  onClose() {
    const result = {
      code: this.currentCode,
      checked: this.checkedSuccessfully,
      type: "text"
    };
    logger.log(TRACE, "OK Clicked - Returning Result:", result);
    this.okCallback(result);
    const { contentEl } = this;
    contentEl.empty();
  }
};
function openCodeEditorModal(app, plugin, initialCode, expectedType, activeFile, frontmatter, okCallback) {
  new codeEditorModal(
    app,
    plugin,
    initialCode,
    expectedType,
    activeFile,
    frontmatter,
    okCallback
  ).open();
}

// src/uiMultiPropertySetting.ts
var import_obsidian8 = require("obsidian");
var MultiPropertySetting = class {
  constructor(container) {
    this.name = "";
    this.desc = "";
    this.value = [];
    this.onChangeCb = () => {
    };
    this.options = [];
    this.extraButtonCbs = [];
    this.container = container;
    this.settingEl = container.createDiv();
  }
  setName(name) {
    this.name = name;
    return this;
  }
  setDesc(desc) {
    this.desc = desc;
    return this;
  }
  setValue(value) {
    this.value = value.length ? [...value] : [""];
    this.render();
    return this;
  }
  setOptions(options) {
    this.options = options;
    this.render();
    return this;
  }
  onChange(cb) {
    this.onChangeCb = cb;
    return this;
  }
  /**
   * Allows adding extra buttons to each row.
   * The callback receives the Setting and the row index.
   */
  addExtraButton(cb) {
    this.extraButtonCbs.push(cb);
    this.render();
    return this;
  }
  styleDisabled(el, disabled) {
    if (disabled) {
      el.extraSettingsEl.addClass("mod-disabled");
      el.extraSettingsEl.setAttr("aria-disabled", "true");
      el.extraSettingsEl.tabIndex = -1;
      el.extraSettingsEl.removeAttribute("aria-label");
    } else {
      el.extraSettingsEl.removeClass("mod-disabled");
      el.extraSettingsEl.setAttr("aria-disabled", "false");
    }
  }
  render() {
    this.settingEl.empty();
    const arr = this.value;
    arr.forEach((selected, idx) => {
      const setting = new import_obsidian8.Setting(this.settingEl).setName(idx === 0 ? this.name : "").setDesc(idx === 0 ? this.desc : "").addDropdown((dd) => {
        this.options.forEach((item) => {
          if (typeof item === "string") {
            dd.addOption(item, item);
          } else {
            dd.addOption(item.id, item.name);
          }
        });
        dd.setValue(selected || "");
        dd.onChange((value) => {
          arr[idx] = value;
          this.value = arr;
          this.onChangeCb([...arr]);
          this.render();
        });
      });
      if (idx > 0) {
        setting.settingEl.style.borderTop = "none";
        setting.settingEl.style.padding = "0 0 0.75em";
      } else {
        setting.settingEl.style.borderTop = "1px solid var(--background-modifier-border)";
        setting.settingEl.style.padding = "0.75em 0";
      }
      const settingControl = setting.controlEl;
      if (settingControl) {
        settingControl.style.gap = "0.1em";
      }
      setting.addExtraButton((btn) => {
        btn.setIcon("arrow-up").setTooltip("Move up").setDisabled(idx === 0).onClick(() => {
          [arr[idx - 1], arr[idx]] = [arr[idx], arr[idx - 1]];
          this.value = arr;
          this.onChangeCb([...arr]);
          this.render();
        });
        this.styleDisabled(btn, idx === 0);
      });
      setting.addExtraButton((btn) => {
        btn.setIcon("arrow-down").setTooltip("Move down").setDisabled(idx === arr.length - 1).onClick(() => {
          [arr[idx], arr[idx + 1]] = [arr[idx + 1], arr[idx]];
          this.value = arr;
          this.onChangeCb([...arr]);
          this.render();
        });
        this.styleDisabled(btn, idx === arr.length - 1);
      });
      setting.addExtraButton((btn) => {
        btn.setIcon("minus-circle").setTooltip("Remove property").setDisabled(arr.length === 1).onClick(() => {
          arr.splice(idx, 1);
          this.value = arr.length ? arr : [""];
          this.onChangeCb([...this.value]);
          this.render();
        });
        this.styleDisabled(btn, arr.length === 1);
      });
      this.extraButtonCbs.forEach((cb) => cb(setting, idx));
    });
    const plusButton = new import_obsidian8.Setting(this.settingEl).addExtraButton((btn) => {
      btn.setIcon("plus-circle").setTooltip("Add property").setDisabled(arr[arr.length - 1] === "" || !arr[arr.length - 1]).onClick(() => {
        if (arr[arr.length - 1] !== "" && arr[arr.length - 1]) {
          arr.push("");
          this.value = arr;
          this.onChangeCb([...arr]);
          this.render();
        }
      });
      this.styleDisabled(btn, arr[arr.length - 1] === "" || !arr[arr.length - 1]);
    });
    plusButton.settingEl.style.borderTop = "none";
    plusButton.settingEl.style.padding = "0 0 0.75em";
  }
};

// src/uiTreeHierarchySortableSettings.ts
var import_obsidian9 = require("obsidian");
var ROOT_FOLDER = void 0;
var TreeHierarchySortableSettings = class {
  constructor(container, data, rowRenderCb) {
    this.title = "";
    this.description = "";
    this.filter = "";
    this.onChangeCb = () => {
    };
    this.onRowCreatedCb = () => {
    };
    this.onRowDeletedCb = () => {
    };
    this.onDeleteBtCb = () => {
    };
    this.onRenderedCb = () => {
    };
    this.extraButtonCbs = [];
    this.rowMatchesFilterFn = (row, filter) => {
      if (!filter)
        return true;
      return row.keywords.some((k) => k.toLowerCase().includes(filter.toLowerCase()));
    };
    this.container = container;
    this.settingEl = container.createDiv({ cls: "FMA-folder-list-setting" });
    this.data = data || { folders: [], rows: [] };
    this.rowRenderCb = rowRenderCb;
    this.render();
    this.onRenderedCb = () => {
    };
  }
  setTitle(title) {
    this.title = title;
    this.render();
    return this;
  }
  setDescription(description) {
    this.description = description;
    this.render();
    return this;
  }
  addExtraButtonToHeader(cb) {
    this.extraButtonCbs.push(cb);
    this.render();
    return this;
  }
  onDeleteBt(cb) {
    this.onDeleteBtCb = cb;
    return this;
  }
  addRow(folderId, keywords = [], payload) {
    const newRow = {
      id: crypto.randomUUID(),
      folderId,
      keywords,
      disabled: false,
      payload
    };
    if (!folderId) {
      this.data.rows.push(newRow);
      this.onRowCreatedCb(newRow);
      this.onChangeCb(this.data, newRow);
      this.render();
      return this;
    }
    const lastIdx = this.data.rows.map((r) => r.folderId).lastIndexOf(folderId);
    if (lastIdx === -1) {
      this.data.rows.unshift(newRow);
    } else {
      this.data.rows.splice(lastIdx + 1, 0, newRow);
    }
    this.onRowCreatedCb(newRow);
    this.onChangeCb(this.data, newRow);
    this.render();
    return this;
  }
  addFolder(name, parentId) {
    const newFolder = {
      id: crypto.randomUUID(),
      name,
      parentId,
      disabled: false,
      // Default to enabled
      collapsed: false
      // Default to expanded
    };
    this.data.folders.push(newFolder);
    this.onChangeCb(this.data);
    this.render();
    return this;
  }
  setData(data) {
    this.data = data;
    this.render();
    return this;
  }
  onChange(cb) {
    this.onChangeCb = cb;
    return this;
  }
  onRowCreated(cb) {
    this.onRowCreatedCb = cb;
    return this;
  }
  onRowDeleted(cb) {
    this.onRowDeletedCb = cb;
    return this;
  }
  onRendered(cb) {
    this.onRenderedCb = cb;
    return this;
  }
  onFilter(cb) {
    this.rowMatchesFilterFn = cb;
    return this;
  }
  moveRow(rowId, targetRowId) {
    const fromIdx = this.data.rows.findIndex((r) => r.id === rowId);
    if (fromIdx === -1)
      return;
    if (rowId === targetRowId)
      return;
    const moved = this.data.rows[fromIdx];
    const row = this.data.rows[fromIdx];
    this.onRowDeletedCb(row);
    logger.log(TRACE, `removing id${rowId} from ${fromIdx}`, this.data.rows);
    this.data.rows.splice(fromIdx, 1);
    let insertIdx;
    if (targetRowId) {
      insertIdx = this.data.rows.findIndex((r) => r.id === targetRowId);
      if (insertIdx === -1) {
        insertIdx = this.data.rows.length;
      }
      const targetRow = this.data.rows[insertIdx];
      if (fromIdx <= insertIdx && moved.folderId === (targetRow == null ? void 0 : targetRow.folderId))
        insertIdx++;
      moved.folderId = targetRow == null ? void 0 : targetRow.folderId;
    } else {
      insertIdx = this.data.rows.length;
    }
    logger.log(TRACE, `Inserting moved row id${rowId} at ${insertIdx}`, this.data.rows);
    this.data.rows.splice(insertIdx, 0, moved);
    this.onChangeCb(this.data);
    this.render();
  }
  moveRowToFolder(rowId, folderId) {
    const fromIdx = this.data.rows.findIndex((r) => r.id === rowId);
    if (fromIdx === -1)
      return;
    const moved = this.data.rows[fromIdx];
    this.data.rows.splice(fromIdx, 1);
    moved.folderId = folderId;
    this.data.rows.push(moved);
    this.onChangeCb(this.data);
    this.render();
  }
  moveFolderToFolder(folderId, targetFolderId) {
    if (folderId === targetFolderId)
      return;
    const fromIdx = this.data.folders.findIndex((f) => f.id === folderId);
    if (fromIdx === -1)
      return;
    const moved = this.data.folders[fromIdx];
    this.data.folders.splice(fromIdx, 1);
    moved.parentId = targetFolderId;
    this.data.folders.push(moved);
    this.onChangeCb(this.data);
    this.render();
  }
  propagateFolderDisabled(folderId, disabled) {
    for (const folder of this.data.folders) {
      if (folder.parentId === folderId) {
        folder.disabled = disabled;
        this.propagateFolderDisabled(folder.id, disabled);
      }
    }
    for (const row of this.data.rows) {
      if (row.folderId === folderId) {
        row.disabled = disabled;
      }
    }
  }
  render() {
    this.data.rows.forEach((row) => {
      this.onRowCreatedCb(row);
    });
    this.settingEl.empty();
    const headerSetting = new import_obsidian9.Setting(this.settingEl).setClass("FMA-folder-list-root-header");
    headerSetting.settingEl.createSpan({ cls: "FMA-folder-list-drag-handle", text: " " });
    headerSetting.settingEl.style.borderTop = "1px solid var(--background-modifier-border)";
    headerSetting.settingEl.style.padding = "0.75em 0";
    headerSetting.setName(this.title || "");
    headerSetting.setDesc(this.description || "");
    const filterInput = new import_obsidian9.SearchComponent(headerSetting.controlEl).setPlaceholder("Filter folders/rows...").setValue(this.filter).onChange((val) => {
      this.filter = val;
      this.renderList();
    });
    filterInput.inputEl.style.width = "200px";
    headerSetting.addExtraButton((btn) => {
      btn.setIcon("plus-circle").setTooltip("Add row to root").onClick(() => {
        this.addRow(void 0, []);
      });
    });
    headerSetting.addExtraButton((btn) => {
      btn.setIcon("folder").setTooltip("Add folder to root").onClick(() => {
        this.addFolder(this.getNextFolderName(), void 0);
      });
    });
    headerSetting.addExtraButton((btn) => {
      btn.setIcon("trash").setTooltip("Drop here to delete row or folder").onClick(() => {
        this.onDeleteBtCb();
        this.onChangeCb(this.data);
        this.render();
      });
      const binEl = btn.extraSettingsEl;
      binEl.addEventListener("dragover", (e) => {
        e.preventDefault();
        binEl.classList.add("FMA-bin-drop-target");
      });
      binEl.addEventListener("dragleave", (e) => {
        binEl.classList.remove("FMA-bin-drop-target");
      });
      binEl.addEventListener("drop", (e) => {
        var _a;
        e.preventDefault();
        binEl.classList.remove("FMA-bin-drop-target");
        const data = (_a = e.dataTransfer) == null ? void 0 : _a.getData("text/plain");
        if (!data)
          return;
        const { type, id } = JSON.parse(data);
        if (type === "row") {
          this.data.rows = this.data.rows.filter((r) => r.id !== id);
        } else if (type === "folder") {
          this.deleteFolderAndContents(id);
        }
        this.onChangeCb(this.data);
        this.render();
      });
    });
    this.extraButtonCbs.forEach((cb) => {
      cb(headerSetting);
    });
    this.renderList();
  }
  renderList() {
    const oldList = this.settingEl.querySelector(".FMA-folder-list-content");
    if (oldList)
      oldList.remove();
    const listEl = this.settingEl.createDiv({ cls: "FMA-folder-list-content" });
    this.renderFolder(void 0, listEl, 0);
    this.renderRows(void 0, listEl, 0);
    const dropZone = new import_obsidian9.Setting(listEl).setClass("FMA-folder-list-drop-zone");
    dropZone.settingEl.addEventListener("dragover", (e) => this.onDragOver(e, "root", "folder-dropzone"));
    dropZone.settingEl.addEventListener("drop", (e) => {
      var _a;
      e.preventDefault();
      e.stopPropagation();
      const data = (_a = e.dataTransfer) == null ? void 0 : _a.getData("text/plain");
      if (!data)
        return;
      const { type, id } = JSON.parse(data);
      if (type === "row") {
        this.moveRowToFolder(id, void 0);
      } else if (type === "folder") {
        this.moveFolderToFolder(id, void 0);
      }
    });
    dropZone.settingEl.addEventListener("dragenter", (e) => {
      e.preventDefault();
      e.stopPropagation();
      dropZone.settingEl.classList.add("FMA-dropzone-target");
    });
    dropZone.settingEl.addEventListener("dragleave", (e) => {
      e.preventDefault();
      e.stopPropagation();
      dropZone.settingEl.classList.remove("FMA-dropzone-target");
    });
    this.onRenderedCb();
  }
  renderFolder(parentId, parentEl, depth) {
    if (!this.data || !this.data.folders)
      return;
    const folders = this.data.folders.filter((f) => f.parentId === parentId);
    folders.forEach((folder) => {
      const setting = new import_obsidian9.Setting(parentEl).setClass("FMA-folder-list-folder-setting");
      setting.nameEl.empty();
      setting.settingEl.style.marginLeft = `${depth * 20}px`;
      const dragHandle = setting.nameEl.createSpan({ cls: "FMA-folder-list-drag-handle" });
      dragHandle.setText("\u2630");
      dragHandle.draggable = true;
      dragHandle.style.marginRight = "0.5em";
      dragHandle.addEventListener("dragstart", (e) => this.onDragStart(e, "folder", folder.id));
      dragHandle.addEventListener("dragover", (e) => this.onDragOver(e, "folder", folder.id));
      dragHandle.addEventListener("drop", (e) => this.onDrop(e, "folder", folder.id));
      setting.addToggle((toggle) => {
        toggle.setValue(!folder.disabled).onChange((val) => {
          folder.disabled = !val;
          this.propagateFolderDisabled(folder.id, folder.disabled);
          this.onChangeCb(this.data);
          this.renderList();
        });
      }).setTooltip("Disable all rules in this folder and subfolders");
      const nameInput = new import_obsidian9.TextComponent(setting.nameEl);
      nameInput.setValue(folder.name);
      nameInput.inputEl.style.maxWidth = "100%";
      nameInput.inputEl.style.border = "0";
      nameInput.inputEl.style.marginRight = "0.5em";
      nameInput.onChange((val) => {
        folder.name = val;
        this.onChangeCb(this.data);
      });
      setting.addExtraButton((btn) => {
        btn.setIcon("plus-circle").setTooltip("Add row to folder").onClick(() => {
          this.addRow(folder.id, []);
        });
      });
      setting.addExtraButton((btn) => {
        btn.setIcon("folder").setTooltip("Add subfolder").onClick(() => {
          this.addFolder(this.getNextFolderName(), folder.id);
        });
      });
      setting.addExtraButton((btn) => {
        var _a;
        const isCollapsed = (_a = folder.collapsed) != null ? _a : false;
        btn.setIcon(isCollapsed ? "chevron-right" : "chevron-down").setTooltip(isCollapsed ? "Expand" : "Collapse").onClick(() => {
          folder.collapsed = !isCollapsed;
          this.onChangeCb(this.data);
          this.renderList();
        });
      });
      setting.settingEl._dragEnterCount = 0;
      setting.settingEl.addEventListener("dragenter", (e) => {
        setting.settingEl._dragEnterCount++;
        setting.settingEl.classList.add("FMA-drop-target");
      });
      setting.settingEl.addEventListener("dragleave", (e) => {
        setting.settingEl._dragEnterCount--;
        if (setting.settingEl._dragEnterCount <= 0) {
          setting.settingEl.classList.remove("FMA-drop-target");
          setting.settingEl._dragEnterCount = 0;
        }
      });
      setting.settingEl.addEventListener("dragover", (e) => this.onDragOver(e, "folder", folder.id));
      setting.settingEl.addEventListener("drop", (e) => this.onDrop(e, "folder", folder.id));
      setting.settingEl.addEventListener("dragleave", (e) => this.onDragLeave(e));
      if (folder.disabled)
        setting.settingEl.classList.add("FMA-mod-FolderList-disabled");
      if (!folder.collapsed) {
        this.renderFolder(folder.id, parentEl, depth + 1);
        this.renderRows(folder.id, parentEl, depth + 1);
      }
    });
  }
  renderRows(folderId, parentEl, depth) {
    if (!this.data || !this.data.rows)
      return;
    if (this.filter) {
      logger.log(TRACE, `Filtering rows with filter: ${this.filter}`, this.data.rows.filter((r) => {
        logger.log(TRACE, `Row ${r.id} matches filter: ${this.rowMatchesFilterFn(r, this.filter)}`, r.keywords);
      }));
    }
    const rows = this.data.rows.filter((r) => r.folderId === folderId && this.rowMatchesFilterFn(r, this.filter));
    rows.forEach((row) => {
      const setting = new import_obsidian9.Setting(parentEl).setClass("FMA-folder-list-row-setting");
      setting.nameEl.empty();
      setting.settingEl.style.marginLeft = `${depth * 20}px`;
      if (setting.nameEl.parentElement) {
        setting.nameEl.parentElement.style.marginInlineEnd = "0px";
        setting.nameEl.parentElement.style.width = "100%";
        setting.nameEl.parentElement.style.display = "flex";
        setting.nameEl.parentElement.style.flexDirection = "column";
      }
      setting.nameEl.style.display = "flex";
      setting.nameEl.style.width = "100%";
      const dragHandle = setting.nameEl.createSpan({ cls: "FMA-folder-list-drag-handle" });
      dragHandle.setText("\u2261");
      dragHandle.draggable = true;
      dragHandle.style.marginRight = "0.5em";
      dragHandle.addEventListener("dragstart", (e) => this.onDragStart(e, "row", row.id));
      dragHandle.addEventListener("dragover", (e) => this.onDragOver(e, "row", row.id));
      dragHandle.addEventListener("drop", (e) => this.onDrop(e, "row", row.id));
      if (row.disabled)
        setting.settingEl.addClass("FMA-mod-FolderList-disabled");
      this.rowRenderCb(row, setting.nameEl);
      setting.settingEl.addEventListener("dragover", (e) => this.onDragOver(e, "row", row.id));
      setting.settingEl.addEventListener("drop", (e) => this.onDrop(e, "row", row.id));
      setting.settingEl.addEventListener("dragleave", (e) => this.onDragLeave(e));
    });
  }
  // --- Drag & Drop Handlers (simplified, expand as needed) ---
  onDragStart(e, type, id) {
    var _a;
    (_a = e.dataTransfer) == null ? void 0 : _a.setData("text/plain", JSON.stringify({ type, id }));
  }
  onDragOver(e, type, id) {
    var _a;
    e.preventDefault();
    const target = e.currentTarget;
    const data = (_a = e.dataTransfer) == null ? void 0 : _a.getData("text/plain");
    if (type === "row" && data) {
      const { type: dragType } = JSON.parse(data);
      if (dragType === "folder") {
        return;
      }
    }
    if (type === "folder") {
      target.classList.add("FMA-drop-target");
    }
    if (type === "row") {
      target.classList.add("FMA-drop-target");
    }
  }
  onDragLeave(e) {
    const target = e.currentTarget;
    target.classList.remove("FMA-drop-target");
  }
  onDrop(e, type, targetId) {
    var _a;
    e.preventDefault();
    e.stopPropagation();
    const target = e.currentTarget;
    target.classList.remove("FMA-drop-target");
    const data = (_a = e.dataTransfer) == null ? void 0 : _a.getData("text/plain");
    if (!data)
      return;
    const { type: dragType, id: dragId } = JSON.parse(data);
    if (dragType === "row") {
      if (type === "folder") {
        this.moveRowToFolder(dragId, targetId);
        return;
      }
      if (type === "row") {
        this.moveRow(dragId, targetId);
        return;
      }
      if (type === "root" && targetId === "row-dropzone") {
        return;
      }
    }
    if (dragType === "folder") {
      if (type === "folder") {
        this.moveFolderToFolder(dragId, targetId);
        return;
      }
      if (type === "root" && targetId === "folder-dropzone") {
        this.moveFolderToFolder(dragId, void 0);
        return;
      }
    }
  }
  getNextFolderName() {
    let i = 1;
    let name;
    do {
      name = `Folder ${i++}`;
    } while (this.data.folders.some((f) => f.name === name));
    return name;
  }
  deleteFolderAndContents(folderId) {
    const subfolders = this.data.folders.filter((f) => f.parentId === folderId);
    subfolders.forEach((f) => this.deleteFolderAndContents(f.id));
    const rowsToDelete = this.data.rows.filter((r) => r.folderId === folderId);
    rowsToDelete.forEach((row) => this.onRowDeletedCb(row));
    this.data.folders = this.data.folders.filter((f) => f.id !== folderId);
    this.data.rows = this.data.rows.filter((r) => r.folderId !== folderId);
  }
};

// src/uiMarkdownHelpModal.ts
var import_obsidian10 = require("obsidian");
var MarkdownHelpModal = class extends import_obsidian10.Modal {
  constructor(app, plugin, markdown, sourcePath) {
    super(app);
    this.markdown = "";
    this.sourcePath = "";
    this.app = app;
    this.plugin = plugin;
    this.markdown = markdown;
    this.sourcePath = sourcePath;
  }
  async onOpen() {
    const { contentEl, modalEl } = this;
    modalEl.addClass("FMA-markdown-help-modal--wide");
    try {
      this.markdown = await this.readPluginDocFile(this.sourcePath);
    } catch (error) {
      logger.log(ERROR, "Error loading markdown:", error);
      this.markdown = "Could not load documentation file: " + this.sourcePath;
    }
    contentEl.empty();
    await import_obsidian10.MarkdownRenderer.render(this.app, this.markdown, contentEl, this.sourcePath, this);
    contentEl.addEventListener("click", async (evt) => {
      const target = evt.target;
      if (target.tagName === "A") {
        const href = target.getAttribute("href");
        if (href && href.endsWith(".md") && !href.match(/^https?:\/\//) && !href.startsWith("/")) {
          evt.preventDefault();
          try {
            const pluginId = this.plugin.manifest.id;
            const docRoot = `.obsidian/plugins/${pluginId}/doc/`;
            let relativeSource = this.sourcePath.startsWith(docRoot) ? this.sourcePath.slice(docRoot.length) : this.sourcePath;
            let currentDir = relativeSource.split("/").slice(0, -1).join("/");
            let resolvedPath = (currentDir ? currentDir + "/" : "") + href;
            const parts = [];
            for (const part of resolvedPath.split("/")) {
              if (part === "..")
                parts.pop();
              else if (part !== "." && part !== "")
                parts.push(part);
            }
            resolvedPath = parts.join("/");
            const newMarkdown = await this.readPluginDocFile(resolvedPath);
            this.markdown = newMarkdown;
            this.sourcePath = docRoot + resolvedPath;
            contentEl.empty();
            await import_obsidian10.MarkdownRenderer.render(this.app, this.markdown, contentEl, this.sourcePath, this);
          } catch (e) {
            contentEl.empty();
            contentEl.createEl("div", { text: "Could not load: " + href });
          }
        }
      }
    });
  }
  async fetchMarkdownFromGitHub(url) {
    const response = await fetch(url);
    if (!response.ok)
      throw new Error("Could not load file from GitHub");
    return await response.text();
  }
  async readPluginDocFile(filename) {
    const pluginId = this.plugin.manifest.id;
    const cleanFilename = filename.replace(/^\/+/, "");
    const filePath = `.obsidian/plugins/${pluginId}/doc/${cleanFilename}`;
    try {
      return await this.app.vault.adapter.read(filePath);
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      throw new Error(`Failed to read file '${filePath}': ${message}`);
    }
  }
};

// src/settings-properties.ts
var RulesTable = class extends import_obsidian11.PluginSettingTab {
  constructor(app, plugin, container, settings) {
    super(app, plugin);
    this.knownProperties = {};
    this.activeFile = null;
    this.plugin = plugin;
    this.container = container;
    this.settings = settings;
    this.tools = new ScriptingTools(app, plugin);
    this.activeFile = this.app.workspace.getActiveFile();
  }
  // Helper to render one rule
  renderPropertyRow(containerEl, rule) {
    const rowEl = containerEl.createDiv({ cls: "property-setting-row setting-item" });
    rowEl.style.width = "100%";
    rowEl.id = rule.id;
    const controlEl = rowEl.createDiv({ cls: "setting-item-control" });
    controlEl.style.width = "100%";
    controlEl.style.display = "flex";
    controlEl.style.gap = "0px";
    const leftContainer = controlEl.createDiv({ cls: "property-left-container" });
    const iconEl = leftContainer.createSpan({ cls: "property-icon setting-item-icon" });
    (0, import_obsidian11.setIcon)(iconEl, "hash");
    const searchContainer = leftContainer.createDiv({ cls: "property-search-container" });
    const nameInput = new import_obsidian11.TextComponent(searchContainer).setPlaceholder("Select property...").setValue(rule.property || "").onChange(async (value) => {
      this.renderSearchResults(searchContainer, value, rule);
    });
    nameInput.inputEl.style.border = "none";
    nameInput.inputEl.addEventListener("focus", () => {
      this.renderSearchResults(searchContainer, nameInput.getValue(), rule);
    });
    nameInput.inputEl.addEventListener("input", () => {
      this.renderSearchResults(searchContainer, nameInput.getValue(), rule);
    });
    nameInput.inputEl.addEventListener("blur", (event) => {
      setTimeout(() => {
        const relatedTarget = event.relatedTarget;
        const resultsEl = searchContainer.querySelector(".property-search-results");
        if (!resultsEl || !resultsEl.contains(relatedTarget)) {
          this.clearSearchResults(searchContainer);
        }
      }, 100);
    });
    const currentPropertyInfo = this.knownProperties[rule.property];
    if (currentPropertyInfo) {
      updatePropertyIcon(iconEl, currentPropertyInfo.type);
    } else if (rule.property) {
      (0, import_obsidian11.setIcon)(iconEl, "alert-circle");
    }
    const middleContainer = controlEl.createDiv({ cls: "property-middle-container" });
    const valueContainer = middleContainer.createDiv({ cls: "FMA-property-value-container" });
    if (this.activeFile) {
      this.app.fileManager.processFrontMatter(this.activeFile, async (frontmatter) => {
        rule.value = await executeRuleObject("preview", this.app, this, this.plugin.settings, this.activeFile, "", rule, frontmatter);
      }, { "mtime": this.activeFile.stat.mtime });
    }
    const previewComponent = this.renderValueInput(valueContainer, currentPropertyInfo, rule.value, rule);
    this.updatePreview(rule, previewComponent);
    const propertyDevDropdown = new import_obsidian11.DropdownComponent(middleContainer);
    propertyDevDropdown.selectEl.style.minWidth = "35%";
    propertyDevDropdown.selectEl.style.maxWidth = "50%";
    propertyDevDropdown.addOption("", "Select a content");
    rulesManager.getRulesByType("buildIn", rule.type).forEach((rule2) => {
      propertyDevDropdown.addOption(rule2.id, rule2.name);
    });
    rulesManager.getRulesByType("automation", rule.type).forEach((rule2) => {
      propertyDevDropdown.addOption(rule2.id, rule2.name);
    });
    propertyDevDropdown.setValue(rule.content);
    propertyDevDropdown.onChange(async (value) => {
      if (value !== "") {
        const ruleFunction = rulesManager.getRuleById(value);
        switch (ruleFunction == null ? void 0 : ruleFunction.ruleType) {
          case "script":
          case "buildIn.inputProperty":
          case "automation":
          case "buildIn":
            let oldOriginalCode = rulesManager.getSource(value) || rulesManager.getSource("default") || "";
            if (rule.buildInCode !== "" && rule.buildInCode !== oldOriginalCode) {
              const shouldProceed = await new AlertModal(
                this.app,
                "Overwrite existing code?",
                "I sees like you have custom code for this rule! Should this be overwritten by default code for this parameter?",
                "Yes",
                "No"
              ).openAndGetValue();
              if (shouldProceed.proceed) {
                rule.buildInCode = rulesManager.getSource(value) || rulesManager.getSource("default") || "";
                rule.useCustomCode = false;
              } else {
                rule.buildInCode;
              }
              await this.plugin.saveSettings();
            } else {
              rule.buildInCode = rulesManager.getSource(value) || rulesManager.getSource("default") || "";
              rule.useCustomCode = false;
              await this.plugin.saveSettings();
            }
            await this.plugin.saveSettings();
            break;
          case "autocomplete.modal":
            break;
          default:
        }
        rule.content = value;
        await this.plugin.saveSettings();
        this.updatePreview(rule, previewComponent);
        this.renderPropertyOptions(optionEL, rule, previewComponent);
      }
    });
    const leftContainerEl = controlEl.createDiv({ cls: "FMA-property-right-container" });
    new import_obsidian11.ButtonComponent(leftContainerEl).setIcon("gear").setTooltip("open settings").setClass("property-icon-button").onClick(async () => {
      let settingsContainers = containerEl.getElementsByClassName("property-options-container");
      for (let container of settingsContainers) {
        if (container.getAttribute("id") !== rule.id)
          container.setAttribute("style", "display: none;");
      }
      this.renderPropertyOptions(optionEL, rule, previewComponent);
      optionEL.style.display = optionEL.style.display === "block" ? "none" : "block";
    });
    controlEl.style.display = "flex";
    controlEl.style.alignItems = "center";
    controlEl.style.justifyContent = "space-between";
    controlEl.style.width = "100%";
    leftContainer.style.display = "flex";
    leftContainer.style.alignItems = "center";
    leftContainer.style.minWidth = "100px";
    iconEl.style.marginRight = "8px";
    searchContainer.style.position = "relative";
    let optionEL;
    if (containerEl.parentElement) {
      optionEL = containerEl.parentElement.createDiv({ cls: "property-options-container" });
      optionEL.id = rule.id;
      optionEL.style.display = "none";
    } else {
      optionEL = containerEl.createDiv({ cls: "property-options-container" });
      optionEL.id = rule.id;
      optionEL.style.display = "none";
    }
  }
  renderPropertyOptions(optionEL, rule, previewComponent) {
    var _a, _b, _c, _d, _e, _f;
    if (!(previewComponent instanceof import_obsidian11.TextComponent))
      return;
    optionEL.empty();
    const ruleFn = rulesManager.getRuleById(rule.content);
    if (!ruleFn)
      return;
    if (ruleFn.useRuleOption("removeContent")) {
      const removeContentButton = new import_obsidian11.Setting(optionEL).setName("Remove content").setDesc(`Before making changes you might consider to remove content generated by this rule`).addButton(
        (button) => {
          button.setWarning().setButtonText("Remove Content").setCta().onClick(() => {
            let count = this.plugin.removeFrontmatterParamsFromAllFiles(rule);
            button.removeCta();
            button.setDisabled(true);
            removeContentButton.setDesc(`Removed this rule from ${count.files} files.`);
          });
        }
      );
    }
    if (ruleFn.useRuleOption("ruleActive")) {
      new import_obsidian11.Setting(optionEL).setName("Rule active").setDesc("If enabled, the rule will be executed").addToggle(
        (toggle) => toggle.setValue(rule.active).onChange(async (value) => {
          rule.active = value;
          await this.plugin.saveSettings();
        })
      );
    }
    if (ruleFn.useRuleOption("modifyOnly")) {
      new import_obsidian11.Setting(optionEL).setName("Modify only").setDesc("Only modify existing properties").addToggle((toggle) => toggle.setValue(rule.onlyModify).onChange(async (value) => {
        rule.onlyModify = value;
        await this.plugin.saveSettings();
        this.updatePreview(rule, previewComponent);
      }));
    }
    if (rule.type === "text" || rule.type === "multitext" || rule.type === "tags" || rule.type === "aliases") {
      let formatRule = rulesManager.getRuleById(rule.formatter);
      const formatterRules = rulesManager.getRulesByType("formatter") || [];
      let formatOptionsButton;
      if (ruleFn.useRuleOption("convertToLowerCase")) {
        const multiProp = new MultiPropertySetting(optionEL).setName("Format output").setDesc("Format output using selected options.").setOptions(formatterRules).setValue(rule.formatters || ["toOriginal"]).onChange((formatter) => {
          rule.formatters = formatter;
          formatRule = rulesManager.getRuleById(rule.formatter);
          this.updatePreview(rule, previewComponent);
        });
        multiProp.addExtraButton((setting, idx) => {
          setting.addExtraButton((btn) => {
            var _a2, _b2, _c2, _d2, _e2, _f2;
            btn.setIcon("gear").setTooltip("Options").setDisabled(!((_c2 = rulesManager.getRuleById((_b2 = (_a2 = rule == null ? void 0 : rule.formatters) == null ? void 0 : _a2[idx]) != null ? _b2 : "toOriginal")) == null ? void 0 : _c2.hasOwnConfigTab()) || false).onClick(() => {
              var _a3, _b3;
              converterOptionDiv.style.display = "block";
              converterOptionDiv.empty();
              formatRule = rulesManager.getRuleById((_b3 = (_a3 = rule == null ? void 0 : rule.formatters) == null ? void 0 : _a3[idx]) != null ? _b3 : "toOriginal");
              formatRule == null ? void 0 : formatRule.configTab(converterOptionDiv, rule, this, previewComponent);
            });
            multiProp.styleDisabled(btn, !((_f2 = rulesManager.getRuleById((_e2 = (_d2 = rule == null ? void 0 : rule.formatters) == null ? void 0 : _d2[idx]) != null ? _e2 : "toOriginal")) == null ? void 0 : _f2.hasOwnConfigTab()) || false);
          });
        });
      }
      let converterOptionDiv = optionEL.createDiv({ cls: "property-converter-option" });
      converterOptionDiv.style.display = "none";
      converterOptionDiv.style.marginLeft = "20px";
      if (ruleFn.useRuleOption("resultAsLink")) {
        new import_obsidian11.Setting(optionEL).setName("Result as Link").setDesc("Format Result as Link").addDropdown((dropdown) => {
          rulesManager.getRulesByType("linkFormatter").forEach((rule2) => {
            dropdown.addOption(rule2.id, rule2.name);
          });
          dropdown.setValue(rule.linkFormatter || "toOriginalLink");
          dropdown.onChange(async (value) => {
            rule.linkFormatter = value;
            await this.plugin.saveSettings();
            this.updatePreview(rule, previewComponent);
          });
        });
      }
    }
    if (rule.type === "text" || rule.type === "multitext" || rule.type === "tags" || rule.type === "aliases") {
      if (ruleFn.useRuleOption("addContent")) {
        new import_obsidian11.Setting(optionEL).setName("Add content").setDesc("select how the content should be stored").addDropdown(
          (dropdown) => dropdown.addOption("overwrite", "replace content").addOption("start", "place on start").addOption("end", "place on end").setValue(rule.addContent).onChange(async (value) => {
            if (value !== "") {
              rule.addContent = value === "overwrite" ? "overwrite" : value === "start" ? "start" : "end";
              await this.plugin.saveSettings();
              this.updatePreview(rule, previewComponent);
            }
          })
        );
      }
    }
    if (ruleFn.useRuleOption("excludeFolders")) {
      const excludeEL = new import_obsidian11.Setting(optionEL).setName("Exclude Files and Folders from this rule").setDesc(`Currently ${((_a = rule.exclude) == null ? void 0 : _a.selectedFolders.length) || 0} folders and ${((_b = rule.exclude) == null ? void 0 : _b.selectedFiles.length) || 0} files will be ${((_c = rule.exclude) == null ? void 0 : _c.mode) || "exclude"}d.`).addButton((button) => {
        button.setIcon("folder-x").setButtonText("Exclude").setCta().onClick(() => {
          var _a2, _b2, _c2;
          openDirectorySelectionModal(
            this.app,
            ((_a2 = rule.exclude) == null ? void 0 : _a2.selectedFolders) || [],
            ((_b2 = rule.exclude) == null ? void 0 : _b2.selectedFiles) || [],
            {
              selectionMode: "exclude",
              displayMode: ((_c2 = rule.exclude) == null ? void 0 : _c2.display) || "folders",
              optionSelectionMode: false,
              optionShowFiles: true
            },
            (result) => {
              var _a3, _b3, _c3;
              if (!result)
                return;
              if (!rule.exclude) {
                rule.exclude = Object.assign({}, DEFAULT_FILTER_FILES_AND_FOLDERS, {
                  mode: "exclude"
                });
              }
              ;
              rule.exclude.selectedFolders = result.folders;
              rule.exclude.selectedFiles = result.files;
              rule.exclude.mode = "exclude";
              rule.exclude.display = result.display;
              this.plugin.saveSettings();
              logger.log(DEBUG, rule.exclude);
              this.updateFilterIndicator(this.activeFile, this.propertiesListEl);
              excludeEL.setDesc(`Currently ${((_a3 = rule.exclude) == null ? void 0 : _a3.selectedFolders.length) || 0} folders and ${((_b3 = rule.exclude) == null ? void 0 : _b3.selectedFiles.length) || 0} files will be ${((_c3 = rule.exclude) == null ? void 0 : _c3.mode) || "exclude"}d.`);
            }
          );
        });
      });
    }
    if (ruleFn.useRuleOption("includeFolders")) {
      const includeEL = new import_obsidian11.Setting(optionEL).setName("Include Files and Folders for this rule ").setDesc(`Currently ${((_d = rule.include) == null ? void 0 : _d.selectedFolders.length) || 0} folders and ${((_e = rule.include) == null ? void 0 : _e.selectedFiles.length) || 0} files will be ${((_f = rule.include) == null ? void 0 : _f.mode) || "include"}d even if they are excluded globally.`).addButton((button) => {
        button.setIcon("folder-check").setButtonText("Include").setCta().onClick(() => {
          var _a2, _b2, _c2;
          openDirectorySelectionModal(
            this.app,
            ((_a2 = rule.include) == null ? void 0 : _a2.selectedFolders) || [],
            ((_b2 = rule.include) == null ? void 0 : _b2.selectedFiles) || [],
            {
              selectionMode: "include",
              displayMode: ((_c2 = rule.include) == null ? void 0 : _c2.display) || "folders",
              optionSelectionMode: false,
              optionShowFiles: true
            },
            (result) => {
              var _a3, _b3, _c3;
              if (!result)
                return;
              if (!rule.include) {
                rule.include = Object.assign({}, DEFAULT_FILTER_FILES_AND_FOLDERS, {
                  mode: "include"
                });
              }
              ;
              rule.include.selectedFolders = result.folders;
              rule.include.selectedFiles = result.files;
              rule.include.mode = "include";
              rule.include.display = result.display;
              this.plugin.saveSettings();
              logger.log(DEBUG, rule.include);
              this.updateFilterIndicator(this.activeFile, this.propertiesListEl);
              includeEL.setDesc(`Currently ${((_a3 = rule.include) == null ? void 0 : _a3.selectedFolders.length) || 0} folders and ${((_b3 = rule.include) == null ? void 0 : _b3.selectedFiles.length) || 0} files will be ${((_c3 = rule.include) == null ? void 0 : _c3.mode) || "include"}d.`);
            }
          );
        });
      });
    }
    if (ruleFn.useRuleOption("script")) {
      new import_obsidian11.Setting(optionEL).setName("Script").setDesc("edit the script for own modifications").addButton((button) => {
        button.setButtonText("JS Editor").onClick(() => {
          var _a2, _b2, _c2;
          logger.log(
            DEBUG,
            `Opening code editor for rule ${rule.id} with content ${rule.content}, file: ${(_a2 = this.activeFile) == null ? void 0 : _a2.path}`,
            this.activeFile,
            this.activeFile ? this.app.metadataCache.getFileCache(this.activeFile) || {} : {}
          );
          openCodeEditorModal(
            this.app,
            this.plugin,
            rule.buildInCode,
            ((_b2 = rule.typeProperty) == null ? void 0 : _b2.type) || "text",
            this.activeFile,
            this.activeFile ? ((_c2 = this.app.metadataCache.getFileCache(this.activeFile)) == null ? void 0 : _c2.frontmatter) || {} : {},
            (result) => {
              if (!result)
                return;
              rule.buildInCode = result.code;
              rule.useCustomCode = true;
              button.setCta();
              this.plugin.saveSettings();
              this.updatePreview(rule, previewComponent);
            }
          );
        });
        if (rule.useCustomCode) {
          button.setCta();
        } else {
          button.removeCta();
        }
      });
    }
    let ruleOptionDiv = optionEL.createDiv({ cls: "property-rule-option" });
    ruleOptionDiv.style.marginLeft = "20px";
    rulesManager.buildConfigTab(rule.content, ruleOptionDiv, rule, this, previewComponent);
    this.updatePreview(rule, previewComponent);
  }
  /**
   * Retrieves the configuration option for a specific rule and property.
   *
   * @param ruleId - The unique identifier of the rule.
   * @param propertyId - The specific property for which the configuration is being retrieved.
   * @returns The configuration value for the specified property, or undefined if not found.
   */
  getOptionConfig(ruleId, propertyId) {
    const rule = this.getRuleById(ruleId);
    if (rule) {
      const optionConfig = rule.optionsConfig[ruleId];
      if (optionConfig[propertyId]) {
        return optionConfig[propertyId];
      }
    }
    return void 0;
  }
  /**
   * Retrieves a rule from the plugin's settings by its unique identifier.
   *
   * @param ruleId - The unique identifier of the rule to retrieve.
   * @returns The matching {@link FrontmatterAutomateRuleSettings} object if found; otherwise, `undefined`.
   */
  getRuleById(ruleId) {
    const row = this.plugin.settings.folderConfig.rows.find((row2) => {
      if (row2.payload && row2.payload.id) {
        return row2.payload.id === ruleId;
      }
      return false;
    });
    return row == null ? void 0 : row.payload;
  }
  /**
   * Sets the configuration option for a specific rule and property.
   *
   * @param ruleId - The unique identifier of the rule.
   * @param propertyId - The specific property for which the configuration is being set.
   * @param config - The configuration value to be set.
   */
  setOptionConfig(ruleId, propertyId, config) {
    const rule = this.getRuleById(ruleId);
    if (rule) {
      if (!rule.optionsConfig)
        rule.optionsConfig = {};
      if (!rule.optionsConfig[ruleId])
        rule.optionsConfig[ruleId] = {};
      rule.optionsConfig[ruleId][propertyId] = config;
      this.plugin.saveSettings();
    }
  }
  hasOptionConfig(ruleId) {
    const rule = this.getRuleById(ruleId);
    if (rule) {
      if (!rule.optionsConfig)
        rule.optionsConfig = {};
      if (!rule.optionsConfig[ruleId])
        rule.optionsConfig[ruleId] = {};
      return Object.keys(rule.optionsConfig[ruleId]).length > 0;
    }
    return false;
  }
  setOptionConfigDefaults(ruleId, defaults) {
    const rule = this.getRuleById(ruleId);
    if (rule) {
      if (!rule.optionsConfig)
        rule.optionsConfig = {};
      rule.optionsConfig[ruleId] = Object.assign({}, defaults, rule.optionsConfig[ruleId] || {});
      return rule.optionsConfig[ruleId];
    }
    return {};
  }
  renderSearchResults(searchContainerEl, searchTerm, payload) {
    this.clearSearchResults(searchContainerEl);
    const filteredProperties = Object.entries(this.knownProperties).filter(([name]) => name.toLowerCase().includes(searchTerm.toLowerCase()));
    if (filteredProperties.length === 0 && searchTerm) {
      return;
    }
    if (filteredProperties.length === 0 && !searchTerm) {
      return;
    }
    const resultsEl = searchContainerEl.createDiv({ cls: "property-search-results menu" });
    resultsEl.style.position = "absolute";
    resultsEl.style.top = "100%";
    resultsEl.style.left = "0";
    resultsEl.style.width = "calc(100% + 100px)";
    resultsEl.style.zIndex = "10";
    resultsEl.style.maxHeight = "200px";
    resultsEl.style.overflowY = "auto";
    let activeIndex = -1;
    const updateActiveItem = (newIndex) => {
      const items = resultsEl.querySelectorAll(".menu-item");
      items.forEach((item, index) => {
        if (index === newIndex) {
          item.addClass("property-search-is-active");
          item.scrollIntoView({ block: "nearest" });
        } else {
          item.removeClass("property-search-is-active");
        }
      });
      activeIndex = newIndex;
    };
    const selectActiveItem = async () => {
      if (activeIndex >= 0 && activeIndex < filteredProperties.length) {
        const [name, info] = filteredProperties[activeIndex];
        payload.property = name;
        payload.type = info.type;
        payload.value = void 0;
        await this.plugin.saveSettings();
        this.clearSearchResults(searchContainerEl);
        this.display();
      }
    };
    filteredProperties.forEach(([name, info], index) => {
      const itemEl = resultsEl.createDiv({ cls: "menu-item" });
      const itemIcon = itemEl.createSpan({ cls: "menu-item-icon" });
      updatePropertyIcon(itemIcon, info.type);
      itemEl.createSpan({ text: name });
      itemEl.addEventListener("mousedown", async (e) => {
        e.preventDefault();
        activeIndex = index;
        await selectActiveItem();
      });
    });
    searchContainerEl.addEventListener("keydown", async (e) => {
      const items = resultsEl.querySelectorAll(".menu-item");
      if (e.key === "ArrowDown") {
        e.preventDefault();
        updateActiveItem((activeIndex + 1) % items.length);
      } else if (e.key === "ArrowUp") {
        e.preventDefault();
        updateActiveItem((activeIndex - 1 + items.length) % items.length);
      } else if (e.key === "Enter") {
        e.preventDefault();
        await selectActiveItem();
      }
    });
  }
  clearSearchResults(searchContainerEl) {
    const resultsEl = searchContainerEl.querySelector(".property-search-results");
    if (resultsEl) {
      resultsEl.remove();
    }
  }
  renderValueInput(containerEl, propertyInfo, currentValue, payload) {
    let returnComponent;
    if (!propertyInfo) {
      containerEl.setText("");
      containerEl.addClass("text-muted");
      return;
    }
    const type = propertyInfo.type;
    switch (type) {
      case "number":
        returnComponent = new import_obsidian11.TextComponent(containerEl).setPlaceholder("Numeric Value").setValue(currentValue !== void 0 && currentValue !== null ? String(currentValue) : "").onChange(async (value) => {
          const numValue = value === "" ? void 0 : parseFloat(value);
          payload.value = isNaN(numValue) ? void 0 : numValue;
          await this.plugin.saveSettings();
        });
        returnComponent.inputEl.type = "number";
        break;
      case "checkbox":
        returnComponent = containerEl.createDiv({ cls: "FMA-tri-state-checkbox" });
        returnComponent.setAttribute("aria-label", "Checkbox change state");
        returnComponent.setAttribute("role", "checkbox");
        const updateCheckboxVisual = (state) => {
          let iconName;
          let ariaState;
          if (state === true) {
            iconName = "check-square";
            ariaState = "true";
          } else if (state === false) {
            iconName = "square";
            ariaState = "false";
          } else {
            iconName = "minus-square";
            ariaState = "mixed";
          }
          (0, import_obsidian11.setIcon)(returnComponent, iconName);
          returnComponent.setAttribute("aria-checked", ariaState);
          returnComponent.dataset.state = String(state);
        };
        updateCheckboxVisual(currentValue);
        returnComponent.addEventListener("click", async () => {
          let currentState = returnComponent.dataset.state;
          let nextState;
          if (currentState === "false") {
            nextState = true;
          } else if (currentState === "true") {
            nextState = void 0;
          } else {
            nextState = false;
          }
          payload.value = nextState;
          await this.plugin.saveSettings();
          updateCheckboxVisual(nextState);
        });
        break;
      case "date":
        returnComponent = new import_obsidian11.TextComponent(containerEl).setPlaceholder("YYYY-MM-DD").setValue(currentValue || "").onChange(async (value) => {
          payload.value = value || void 0;
          await this.plugin.saveSettings();
        });
        returnComponent.inputEl.type = "date";
        break;
      case "datetime":
        returnComponent = new import_obsidian11.TextComponent(containerEl).setPlaceholder("YYYY-MM-DDTHH:mm").setValue(currentValue || "").onChange(async (value) => {
          payload.value = value || void 0;
          await this.plugin.saveSettings();
        });
        returnComponent.inputEl.type = "datetime-local";
        break;
      case "aliases":
      case "tags":
      case "multitext":
        returnComponent = new import_obsidian11.TextComponent(containerEl).setPlaceholder("values (divided by comma)").setValue(Array.isArray(currentValue) ? currentValue.join(", ") : currentValue || "").onChange(async (value) => {
          const arrayValue = value.split(",").map((s) => s.trim()).filter((s) => s);
          payload.value = arrayValue.length > 0 ? arrayValue : void 0;
          await this.plugin.saveSettings();
        });
        break;
      case "text":
      default:
        returnComponent = new import_obsidian11.TextComponent(containerEl).setPlaceholder("value").setValue(currentValue || "").onChange(async (value) => {
          payload.value = value || void 0;
          await this.plugin.saveSettings();
        });
        break;
    }
    if (type !== "checkbox") {
      returnComponent.inputEl.addClass("FMA-property-value-input");
    } else {
      returnComponent.addClass("FMA-property-value-input");
    }
    return returnComponent;
  }
  async updatePreview(rule, previewComponent) {
    if (this.activeFile) {
      let ruleResult;
      await this.app.fileManager.processFrontMatter(this.activeFile, async (frontmatter) => {
        ruleResult = await executeRuleObject("preview", this.app, this, this.plugin.settings, this.activeFile, "", rule, frontmatter);
      }, { "mtime": this.activeFile.stat.mtime });
      switch (typeof ruleResult) {
        case "object":
          if (Array.isArray(ruleResult))
            previewComponent.inputEl.value = ruleResult.toString();
          break;
        default:
          if (previewComponent == null ? void 0 : previewComponent.inputEl)
            previewComponent.inputEl.value = ruleResult;
          break;
      }
    }
  }
  updateKeywords(row) {
    var _a;
    if ((_a = row == null ? void 0 : row.payload) == null ? void 0 : _a.id) {
      row.payload.keywords = [];
      row.payload.keywords.push(row.payload.content);
      if (Array.isArray(row.payload.Value) && row.payload.Value.length > 0) {
        row.payload.keywords.push(...row.payload.Value);
      } else if (typeof row.payload.Value === "string") {
        row.payload.keywords.push(row.payload.Value);
      }
      const rule = rulesManager.getRuleById(row.payload.content);
      if (rule) {
        row.payload.keywords.push(rule.name);
        row.payload.keywords.push(rule.description);
      }
      logger.log(DEBUG, "Updated keywords for rule", row.payload.id, row.payload.keywords);
    }
  }
  async display() {
    const containerEl = this.container;
    containerEl.empty();
    this.knownProperties = await this.tools.fetchKnownProperties(this.app);
    this.propertiesListEl = containerEl;
    const folderList = new TreeHierarchySortableSettings(
      containerEl,
      this.plugin.settings.folderConfig,
      (row, rowEl) => {
        this.renderPropertyRow(rowEl, row.payload);
      }
    ).setTitle("Rules").setDescription("add rules to selected frontmatter properties").onChange((data, row) => {
      this.plugin.settings.folderConfig = data;
      this.updateFilterIndicator(this.activeFile, this.propertiesListEl);
      this.plugin.saveSettings();
    }).onFilter((row, filter) => {
      if (row == null ? void 0 : row.payload) {
        filter = filter.toLowerCase();
        const ruleSettings = row.payload;
        if (ruleSettings.content.toLowerCase().contains(filter))
          return true;
        if (ruleSettings.value.toString().toLowerCase().contains(filter))
          return true;
        const rule = rulesManager.getRuleById(row.payload.content);
        if (!rule)
          return false;
        if (rule.name.toLowerCase().contains(filter))
          return true;
        if (rule.description.toLowerCase().contains(filter))
          return true;
      }
      return false;
    }).onRendered(() => {
      this.updateFilterIndicator(this.activeFile, this.propertiesListEl);
    }).onRowCreated(async (row) => {
      const defaultName = "";
      if (!row.payload) {
        row.payload = Object.assign({}, DEFAULT_RULE_DEFINITION, {
          id: (0, import_crypto.randomUUID)().toString()
        });
        await this.plugin.saveSettings();
        logger.log(DEBUG, "New rule created", row, this.plugin.settings.folderConfig);
      }
      this.updateKeywords(row);
    }).onDeleteBt(async () => {
      const shouldProceed = await new AlertModal(
        this.app,
        "Erase all Rules?",
        "Do you really like to erase ALL rules?",
        "Yes",
        "No"
      ).openAndGetValue();
      if (shouldProceed.proceed) {
        this.plugin.folderConfig.rows = [];
        this.plugin.saveSettings();
      }
    }).addExtraButtonToHeader((el) => {
      el.addExtraButton(
        (btn) => btn.setIcon("circle-help").onClick(async () => {
          let markdown = "Could not load help from GitHub.";
          new MarkdownHelpModal(this.app, this.plugin, markdown, "README.md").open();
        })
      );
    });
    if (this.plugin.settings.folderConfig.rows.length === 0 && this.plugin.settings.rules.length > 0) {
      this.plugin.settings.rules.forEach((rule) => {
        const keywords = [];
        keywords.push(rule.content);
        folderList.addRow(ROOT_FOLDER, [], rule);
      });
    }
    let activeFile = this.app.workspace.getActiveFile();
    this.updateFilterIndicator(activeFile, this.propertiesListEl);
  }
  updateFilterIndicator(activeFile, propertiesListEl) {
    if (activeFile) {
      this.plugin.settings.folderConfig.rows.forEach((row, index) => {
        const rule = row.payload;
        if (!rule || !rule.id) {
          logger.log(WARNING, `updateFilterIndicator: Rule with id ${rule == null ? void 0 : rule.id} not found in folderConfig rows.`);
          return;
        }
        const propertyRowElements = propertiesListEl.getElementsByClassName("property-setting-row");
        const propertyRowEl = Array.from(propertyRowElements).filter((el) => el.id === rule.id)[0];
        if (!propertyRowEl) {
          return;
        }
        const propertyLeftDiv = propertyRowEl.querySelector(".property-left-container");
        if (checkIfFileAllowed(activeFile, this.plugin.settings, rule)) {
          propertyLeftDiv == null ? void 0 : propertyLeftDiv.addClass("property-left-container-allowed");
        } else {
          propertyLeftDiv == null ? void 0 : propertyLeftDiv.removeClass("property-left-container-allowed");
        }
      });
    }
  }
};

// src/settings.ts
var FolderTagSettingTab = class extends import_obsidian12.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.scriptingTools = new ScriptingTools(app, plugin);
  }
  hide() {
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile && activeFile.extension === "md") {
      this.plugin.updateFrontmatterParameters("active-leaf-change", activeFile, this.plugin.settings.folderConfig);
    }
  }
  display() {
    this.knownProperties = getPropertiesFromMetadataManager(this.app);
    this.knownTypes = getTypesFromMetadataManager(this.app);
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian12.Setting(containerEl).setName(`Front matter automate V${this.plugin.manifest.version} Settings`).setDesc(this.plugin.manifest.description).addButton(
      (button) => button.setIcon("circle-help").setTooltip("Online Help").onClick(async () => {
        let markdown = "Could not load help from GitHub.";
        new MarkdownHelpModal(this.app, this.plugin, markdown, "readme.md").open();
      })
    );
    new import_obsidian12.Setting(containerEl).setName("Exclude Files and Folders globally").setDesc(`Currently ${this.plugin.settings.exclude.selectedFolders.length} folders and ${this.plugin.settings.exclude.selectedFiles.length} files will be ${this.plugin.settings.exclude.mode}d.`).addButton((button) => {
      button.setIcon("folder-x").setButtonText("Exclude").setCta().onClick(() => {
        openDirectorySelectionModal(
          this.app,
          this.plugin.settings.exclude.selectedFolders || [],
          this.plugin.settings.exclude.selectedFiles || [],
          {
            selectionMode: this.plugin.settings.exclude.mode || "exclude",
            displayMode: this.plugin.settings.exclude.display || "folders",
            optionSelectionMode: false,
            optionShowFiles: true
          },
          (result) => {
            if (!result)
              return;
            this.plugin.settings.exclude.selectedFolders = result.folders;
            this.plugin.settings.exclude.selectedFiles = result.files;
            this.plugin.settings.exclude.mode = result.mode;
            this.plugin.settings.exclude.display = result.display;
            this.plugin.saveSettings();
            this.display();
          }
        );
      });
    });
    new import_obsidian12.Setting(containerEl).setName("Include Files and Folders globally").setDesc(`Currently ${this.plugin.settings.include.selectedFolders.length} folders and ${this.plugin.settings.include.selectedFiles.length} files will be ${this.plugin.settings.include.mode}d even if they are excluded.`).addButton((button) => {
      button.setIcon("folder-check").setButtonText("Include").setCta().onClick(() => {
        openDirectorySelectionModal(
          this.app,
          this.plugin.settings.include.selectedFolders || [],
          this.plugin.settings.include.selectedFiles || [],
          {
            selectionMode: this.plugin.settings.include.mode || "include",
            displayMode: this.plugin.settings.include.display || "folders",
            optionSelectionMode: false,
            optionShowFiles: true
          },
          (result) => {
            if (!result)
              return;
            this.plugin.settings.include.selectedFolders = result.folders;
            this.plugin.settings.include.selectedFiles = result.files;
            this.plugin.settings.include.mode = result.mode;
            this.plugin.settings.include.display = result.display;
            this.plugin.saveSettings();
            this.display();
          }
        );
      });
    });
    new import_obsidian12.Setting(containerEl).setName("Debug").setDesc("Select the debug level to show in the console").addDropdown((dropdown) => {
      dropdown.addOptions(
        Object.fromEntries(logger.getLevelNames().map((level) => [level, level]))
      );
      dropdown.setValue(logger.getLevelName(this.plugin.settings.debugLevel));
      dropdown.onChange((value) => {
        this.plugin.settings.debugLevel = logger.getLevelByName(value);
        logger.setLevel(this.plugin.settings.debugLevel);
        this.plugin.saveSettings();
      });
    });
    new import_obsidian12.Setting(containerEl).setName("Delay create event (until better solution is found)").setDesc("Set a delay before triggering the create event to allow for file creation to complete. (in milliseconds)").addText((text) => {
      text.setValue(this.plugin.settings.delayCreateEvent.toString());
      text.onChange(async (value) => {
        this.plugin.settings.delayCreateEvent = parseInt(value) || 0;
        await this.plugin.saveSettings();
      });
    });
    this.rulesContainer = containerEl.createDiv("properties-list");
    const rulesTable = new RulesTable(this.app, this.plugin, this.rulesContainer, this.plugin.settings.folderConfig);
    rulesTable.display();
    new import_obsidian12.Setting(containerEl).setName("Backup & Restore Configuration").setDesc("Export your current config as a JSON file or restore from a backup.").addButton((btn) => {
      btn.setButtonText("Backup").setIcon("download").onClick(() => {
        const dataStr = JSON.stringify(this.plugin.settings, null, 2);
        const blob = new Blob([dataStr], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "frontmatter-automate-backup.json";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      });
    }).addButton((btn) => {
      btn.setButtonText("Restore").setIcon("upload").onClick(() => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".json,application/json";
        input.onchange = async () => {
          if (!input.files || input.files.length === 0)
            return;
          const file = input.files[0];
          const text = await file.text();
          try {
            const data = JSON.parse(text);
            this.plugin.settings = data;
            await this.plugin.saveSettings();
            this.display();
            new import_obsidian12.Notice("Frontmatter Automate\nConfiguration restored from backup.");
          } catch (e) {
            new import_obsidian12.Notice("Frontmatter Automate\nFailed to restore: Invalid JSON file.", 2e3);
          }
        };
        input.click();
      });
    });
  }
};

// src/rules/addPrefix.ts
var import_obsidian13 = require("obsidian");
var RuleAddPrefix = class extends RulePrototype {
  constructor() {
    super();
    this.id = "addPrefix";
    this.name = "Add a Prefix";
    this.description = "Adds a prefix to the input value.";
    this.ruleType = "formatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    var _a;
    const prefix = tools.getOptionConfig((_a = tools.getRule()) == null ? void 0 : _a.id, "prefix");
    return `${prefix}${input}`;
  }
  configTab(optionEL, rule, that, previewComponent) {
    optionEL.empty();
    that.setOptionConfigDefaults(rule.id, {
      prefix: ""
      // Default prefix
    });
    new import_obsidian13.Setting(optionEL).setName("Prefix").setDesc("Enter a prefix to be added at the beginning.").addText(
      (text) => text.setPlaceholder('e.g. "pre-"').setValue(that.getOptionConfig(rule.id, "prefix") || "").onChange(async (value) => {
        that.setOptionConfig(rule.id, "prefix", value);
        that.updatePreview(rule, previewComponent);
      })
    );
  }
};

// src/rules/addSuffix.ts
var import_obsidian14 = require("obsidian");
var RuleAddSuffix = class extends RulePrototype {
  constructor() {
    super();
    this.id = "addSuffix";
    this.name = "Add a Suffix";
    this.description = "Adds a suffix to the input value.";
    this.ruleType = "formatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    var _a;
    const suffix = tools.getOptionConfig((_a = tools.getRule()) == null ? void 0 : _a.id, "suffix");
    return `${input}${suffix}`;
  }
  configTab(optionEL, rule, that, previewComponent) {
    optionEL.empty();
    that.setOptionConfigDefaults(rule.id, {
      suffix: ""
      // Default suffix
    });
    new import_obsidian14.Setting(optionEL).setName("Suffix").setDesc("Enter a suffix to be added at the end.").addText(
      (text) => text.setPlaceholder('e.g. "_done"').setValue(that.getOptionConfig(rule.id, "suffix") || "").onChange(async (value) => {
        that.setOptionConfig(rule.id, "suffix", value);
        that.updatePreview(rule, previewComponent);
      })
    );
  }
};

// src/rules/automationAutoLink.ts
var import_obsidian18 = require("obsidian");

// src/suggesters/FolderSuggester.ts
var import_obsidian16 = require("obsidian");

// src/suggesters/suggest.ts
var import_obsidian15 = require("obsidian");

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect4 = _ref.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});

// src/suggesters/suggest.ts
var wrapAround = (value, size) => {
  return (value % size + size) % size;
};
var Suggest = class {
  constructor(owner, containerEl, scope) {
    this.owner = owner;
    this.containerEl = containerEl;
    containerEl.on(
      "click",
      ".suggestion-item",
      this.onSuggestionClick.bind(this)
    );
    containerEl.on(
      "mousemove",
      ".suggestion-item",
      this.onSuggestionMouseover.bind(this)
    );
    scope.register([], "ArrowUp", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem - 1, true);
        return false;
      }
    });
    scope.register([], "ArrowDown", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem + 1, true);
        return false;
      }
    });
    scope.register([], "Enter", (event) => {
      if (!event.isComposing) {
        this.useSelectedItem(event);
        return false;
      }
    });
  }
  onSuggestionClick(event, el) {
    event.preventDefault();
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
    this.useSelectedItem(event);
  }
  onSuggestionMouseover(_event, el) {
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
  }
  setSuggestions(values) {
    this.containerEl.empty();
    const suggestionEls = [];
    values.forEach((value) => {
      const suggestionEl = this.containerEl.createDiv("suggestion-item");
      this.owner.renderSuggestion(value, suggestionEl);
      suggestionEls.push(suggestionEl);
    });
    this.values = values;
    this.suggestions = suggestionEls;
    this.setSelectedItem(0, false);
  }
  useSelectedItem(event) {
    const currentValue = this.values[this.selectedItem];
    if (currentValue) {
      this.owner.selectSuggestion(currentValue, event);
    }
  }
  setSelectedItem(selectedIndex, scrollIntoView) {
    const normalizedIndex = wrapAround(
      selectedIndex,
      this.suggestions.length
    );
    const prevSelectedSuggestion = this.suggestions[this.selectedItem];
    const selectedSuggestion = this.suggestions[normalizedIndex];
    prevSelectedSuggestion == null ? void 0 : prevSelectedSuggestion.removeClass("is-selected");
    selectedSuggestion == null ? void 0 : selectedSuggestion.addClass("is-selected");
    this.selectedItem = normalizedIndex;
    if (scrollIntoView) {
      selectedSuggestion.scrollIntoView(false);
    }
  }
};
var TextInputSuggest = class {
  constructor(app, inputEl) {
    this.app = app;
    this.inputEl = inputEl;
    this.scope = new import_obsidian15.Scope();
    this.suggestEl = createDiv("suggestion-container");
    const suggestion = this.suggestEl.createDiv("suggestion");
    this.suggest = new Suggest(this, suggestion, this.scope);
    this.scope.register([], "Escape", this.close.bind(this));
    this.inputEl.addEventListener("input", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("focus", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("blur", this.close.bind(this));
    this.suggestEl.on(
      "mousedown",
      ".suggestion-container",
      (event) => {
        event.preventDefault();
      }
    );
  }
  onInputChanged() {
    const inputStr = this.inputEl.value;
    const suggestions = this.getSuggestions(inputStr);
    if (!suggestions) {
      this.close();
      return;
    }
    if (suggestions.length > 0) {
      this.suggest.setSuggestions(suggestions);
      this.open(this.app.dom.appContainerEl, this.inputEl);
    } else {
      this.close();
    }
  }
  open(container, inputEl) {
    this.app.keymap.pushScope(this.scope);
    container.appendChild(this.suggestEl);
    this.popper = createPopper(inputEl, this.suggestEl, {
      placement: "bottom-start",
      modifiers: [
        {
          name: "sameWidth",
          enabled: true,
          fn: ({ state, instance }) => {
            const targetWidth = `${state.rects.reference.width}px`;
            if (state.styles.popper.width === targetWidth) {
              return;
            }
            state.styles.popper.width = targetWidth;
            instance.update();
          },
          phase: "beforeWrite",
          requires: ["computeStyles"]
        }
      ]
    });
  }
  close() {
    this.app.keymap.popScope(this.scope);
    this.suggest.setSuggestions([]);
    if (this.popper)
      this.popper.destroy();
    this.suggestEl.detach();
  }
};

// src/suggesters/FolderSuggester.ts
var FolderSuggest = class extends TextInputSuggest {
  constructor(app, inputEl) {
    super(app, inputEl);
  }
  getSuggestions(inputStr) {
    const abstractFiles = this.app.vault.getAllLoadedFiles();
    const folders = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    abstractFiles.forEach((folder) => {
      if (folder instanceof import_obsidian16.TFolder && folder.path.toLowerCase().contains(lowerCaseInputStr)) {
        folders.push(folder);
      }
    });
    return folders.slice(0, 1e3);
  }
  renderSuggestion(file, el) {
    el.setText(file.path.replace(/^(?!\/)/, "/"));
  }
  selectSuggestion(file) {
    this.inputEl.value = file.path.replace(/^(?!\/)/, "/");
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/suggesters/FileSuggester.ts
var import_obsidian17 = require("obsidian");
var FileSuggest = class extends TextInputSuggest {
  constructor(inputEl, plugin, folder) {
    super(plugin.app, inputEl);
    this.inputEl = inputEl;
    this.plugin = plugin;
    this.folder = folder;
  }
  get_error_msg() {
    return `Folder ${this.folder} doesn't exist`;
  }
  getSuggestions(input_str) {
    const all_files = errorWrapperSync(
      () => getFilesFromFolder(
        this.plugin.app,
        this.folder
      ),
      this.get_error_msg()
    );
    if (!all_files) {
      return [];
    }
    const files = [];
    const lower_input_str = input_str.toLowerCase();
    all_files.forEach((file) => {
      if (file instanceof import_obsidian17.TFile && file.extension === "md" && file.path.toLowerCase().contains(lower_input_str)) {
        files.push(file);
      }
    });
    return files.slice(0, 1e3);
  }
  renderSuggestion(file, el) {
    el.setText(file.path);
  }
  selectSuggestion(file) {
    this.inputEl.value = file.path;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/rules/automationAutoLink.ts
var RuleAutomationAutoLink = class extends RulePrototype {
  constructor() {
    super();
    this.id = "autoLink";
    this.name = "Auto Link (advanced)";
    this.description = "Checks if a link exists in a specified folder. If not, it creates a new file based on a specified template and adds a link to it.";
    this.ruleType = "automation";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "multitext"];
    this.configElements = this.defaultConfigElements({ removeContent: false, inputProperty: false, addPrefix: false, spaceReplacement: false, specialCharacterReplacement: false, convertToLowerCase: false, resultAsLink: false, script: false });
  }
  async createNewFile(app, file, tools) {
  }
  /**
   * Function to create a link to a file. If the file does not exist, it creates a new file based on a template.
   * @param app - The Obsidian app instance.
   * @param file - The current file.
   * @param tools - The scripting tools instance.
   * @returns The new content for the frontmatter property.
   */
  fx(app, file, tools) {
    const currentContent = tools.getCurrentContent();
    let newContent = new Array();
    const rule = tools.getRule();
    if (!rule) {
      logger.log(ERROR, `autoLink: rule not found, returning current content ${currentContent}`);
      return currentContent;
    }
    const options = tools.getOptionConfig(rule.id);
    const filesToCheck = tools.getFilesInVault(options.destinationFolder);
    let links = currentContent || [];
    if (typeof links === "object" && !Array.isArray(links)) {
      links = [];
    } else if (typeof links === "string") {
      links = [links];
    }
    for (const part of links) {
      let link = tools.extractLinkParts(part);
      let linkFile = tools.getTFileFromPath(link.path, filesToCheck);
      if (!linkFile) {
        if (options.askConfirmation) {
          new AlertModal(app, "Create new file", `File ${link.path} does not exist. Do you want to create it?`, "Create", "Cancel", "Don't ask again.").openAndGetValue().then(async (result) => {
            logger.log(DEBUG, `autoLink: user confirmed to create new file "${link.path}"`, result);
            if (!result)
              return;
            if (!result.proceed)
              return;
            options.askConfirmation = !result.data.askConfirmation;
            link.path = options.destinationFolder + "/" + link.title + ".md";
            linkFile = await tools.createFileFromPath(link.path, options.addTemplate ? options.templateFile : void 0);
            newContent.push(`[[${tools.removeLeadingSlash(link.path)}|${link.title}]]`);
            logger.log(DEBUG, `autoLink: returning (after askConfirmation) "${newContent}"`);
            return newContent;
          });
        }
        ;
        link.path = options.destinationFolder + "/" + link.title + ".md";
        logger.log(TRACE, `autoLink: creating new file "${link.path}"`);
        tools.createFileFromPath(link.path, options.addTemplate ? options.templateFile : void 0).then((newFile) => {
          newContent.push(`[[${tools.removeLeadingSlash(newFile.path)}|${newFile.name}]]`);
          logger.log(DEBUG, `autoLink: new file created "${newFile.path}" returning "${newContent}"`);
          return newContent;
        });
      }
      if (linkFile) {
        logger.log(DEBUG, `autoLink: creating Link to existing File "${linkFile.path}"`);
        link.path = linkFile.path;
        newContent.push(`[[${tools.removeLeadingSlash(link.path)}|${link.title}]]`);
      }
    }
    logger.log(DEBUG, `autoLink: returning "${newContent}"`);
    return newContent;
  }
  configTab(optionEL, rule, that, previewComponent) {
    that.setOptionConfigDefaults(rule.id, {
      addTemplate: true,
      askConfirmation: true,
      destinationFolder: "/",
      templateFile: ""
    });
    new import_obsidian18.Setting(optionEL).setName("Add template to new files").setDesc("Automatically add template to new files").addToggle((toggle) => toggle.setValue(that.getOptionConfig(rule.id, "addTemplate") || false).onChange(async (value) => {
      that.setOptionConfig(rule.id, "addTemplate", value);
    }));
    new import_obsidian18.Setting(optionEL).setName("Ask for confirmation").setDesc("Ask for confirmation before creating new files").addToggle((toggle) => toggle.setValue(that.getOptionConfig(rule.id, "askConfirmation") || false).onChange(async (value) => {
      that.setOptionConfig(rule.id, "askConfirmation", value);
    }));
    let destinationFolderEl;
    new import_obsidian18.Setting(optionEL).setName("Destination Folder").setDesc("Folder to place new files").addSearch((cb) => {
      destinationFolderEl = cb;
      new FolderSuggest(that.app, cb.inputEl);
      cb.setPlaceholder("enter folder or browse ...").setValue(that.getOptionConfig(rule.id, "destinationFolder") || "").onChange((newFolder) => {
        newFolder = newFolder.trim();
        newFolder = newFolder.replace(/\/$/, "");
        that.setOptionConfig(rule.id, "destinationFolder", newFolder);
      });
      cb.containerEl.addClass("frontmatter-automate-search");
    }).addExtraButton(
      (button) => button.setIcon("folder-tree").setTooltip("Select template folder").onClick(async () => {
        openDirectorySelectionModal(
          that.app,
          [that.getOptionConfig(rule.id, "destinationFolder")],
          [],
          {
            title: "Select folder to place new files",
            selectionMode: "include",
            displayMode: "folder",
            optionSelectionMode: false,
            optionShowFiles: false
          },
          (result) => {
            if (!result)
              return;
            if (result.folders.length === 0 || !result.folders[0] || typeof result.folders[0] !== "string")
              return;
            let selectedFolder = result.folders[0].trim().replace(/\/$/, "");
            if (selectedFolder === "")
              selectedFolder = "/";
            if (!selectedFolder)
              return;
            destinationFolderEl.setValue(selectedFolder);
            that.setOptionConfig(rule.id, "destinationFolder", selectedFolder);
          }
        );
      })
    );
    let destinationFileEl;
    new import_obsidian18.Setting(optionEL).setName("Template File").setDesc("Select a template file to add to new files").addSearch((cb) => {
      destinationFileEl = cb;
      new FileSuggest(cb.inputEl, that.plugin, "");
      cb.setPlaceholder("enter folder or browse ...").setValue(that.getOptionConfig(rule.id, "templateFile") || "").onChange((newFile) => {
        newFile = newFile.trim();
        newFile = newFile.replace(/\/$/, "");
        that.setOptionConfig(rule.id, "templateFile", newFile);
      });
      cb.containerEl.addClass("frontmatter-automate-search");
    }).addExtraButton(
      (button) => button.setIcon("folder-tree").setTooltip("Select template file").onClick(async () => {
        openDirectorySelectionModal(
          that.app,
          [],
          [that.getOptionConfig(rule.id, "templateFile")],
          {
            title: "Select template for new files",
            selectionMode: "include",
            displayMode: "file",
            optionSelectionMode: false,
            optionShowFiles: true
          },
          (result) => {
            if (!result)
              return;
            if (result.files.length === 0 || !result.files[0] || typeof result.files[0] !== "string")
              return;
            let selectedFile = result.files[0].trim().replace(/\/$/, "");
            if (!selectedFile)
              return;
            destinationFileEl.setValue(selectedFile);
            that.setOptionConfig(rule.id, "templateFile", selectedFile);
          }
        );
      })
    );
  }
};

// src/rules/buildInAutoCompleteModal.ts
var import_obsidian20 = require("obsidian");

// src/autocompleteModal.ts
var import_obsidian19 = require("obsidian");
var AutocompleteModal = class extends import_obsidian19.Modal {
  /**
   * Creates an instance of the DirectorySelectionModal.
   * @param app - The Obsidian App instance.
   * @param plugin - The plugin instance.
   * @param expectedType - Expected return type.
   * @param activeFile - The currently active file or folder.
   * @param frontmatter - Frontmatter data for the active file.
   * @param okCallback - Function to call when the user clicks "OK". Receives the selection result.
   */
  constructor(app, plugin, rule, options, activeFile, frontmatter, okCallback) {
    super(app);
    this.knownProperties = {};
    this.result = {};
    this.changeCallback = (propertyInfo, value) => {
      if (propertyInfo) {
        this.result[propertyInfo.name] = value;
      }
    };
    this.app = app;
    this.tools = new ScriptingTools(app, this.plugin, this.frontmatter);
    this.activeFile = activeFile;
    this.frontmatter = frontmatter;
    this.plugin = plugin;
    this.rule = rule;
    this.options = options;
    this.expectedType = rule.type;
    this.promise = new Promise((resolve) => {
      this.resolvePromise = resolve;
    });
    if (okCallback)
      this.okCallback = okCallback;
    this.resetToInitial();
  }
  /**
   * Resets the current selection state to the initial state provided at construction.
   */
  resetToInitial() {
  }
  /**
   * Resets the current selection state to empty.
   */
  resetToEmpty() {
  }
  /**
   * Called when the modal is opened. Builds the UI.
   */
  async onOpen() {
    var _a;
    this.knownProperties = await this.tools.fetchKnownProperties(this.app);
    const { contentEl } = this;
    if (contentEl.parentElement)
      contentEl.parentElement.style.width = "900px";
    contentEl.empty();
    contentEl.addClass("codeEditor-modal");
    contentEl.createEl("h2", { text: "Please complete the following properties" });
    contentEl.createEl("body", { text: `File: ${(_a = this.activeFile) == null ? void 0 : _a.path}` });
    this.contentRootElement = contentEl.createDiv({ cls: "codeEditor-container" });
    this.contentRootElement.style.overflowY = "auto";
    this.contentRootElement.style.padding = "10px";
    this.contentRootElement.style.marginTop = "10px";
    this.contentRootElement.style.marginBottom = "10px";
    const propertyContainerEl = contentEl.createDiv({ cls: "codeEditor-options" });
    propertyContainerEl.style.flexDirection = "column";
    for (const [key, value] of Object.entries(this.frontmatter)) {
      if (key.startsWith(this.rule.property + this.options.propertyDelimiter)) {
        const rowEl = propertyContainerEl.createDiv({ cls: "property-setting-row setting-item" });
        rowEl.style.width = "100%";
        const controlEl = rowEl.createDiv({ cls: "setting-item-control" });
        controlEl.style.display = "flex";
        controlEl.style.alignItems = "center";
        controlEl.style.justifyContent = "space-between";
        controlEl.style.width = "100%";
        controlEl.style.gap = "0px";
        const leftContainer = controlEl.createDiv({ cls: "property-left-container" });
        leftContainer.style.display = "flex";
        leftContainer.style.alignItems = "center";
        leftContainer.style.minWidth = "250px";
        const iconEl = leftContainer.createSpan({ cls: "property-icon setting-item-icon" });
        iconEl.style.marginRight = "8px";
        updatePropertyIcon(iconEl, this.knownProperties[key].type);
        const searchContainer = leftContainer.createDiv({ cls: "property-search-container" });
        const nameInput = new import_obsidian19.TextComponent(searchContainer).setValue(key).setPlaceholder("Property name").setDisabled(true);
        nameInput.inputEl.style.border = "none";
        const middleContainer = controlEl.createDiv({ cls: "property-middle-container" });
        const valueContainer = middleContainer.createDiv({ cls: "property-value-container" });
        valueContainer.style.width = "100%";
        let previewComponent = renderValueInput(valueContainer, this.knownProperties[key], this.frontmatter[key], this.changeCallback);
        previewComponent.inputEl.style.width = "100%";
        previewComponent.inputEl.style.backgroundColor = "transparent";
        const deleteButtonContainer = controlEl.createDiv({ cls: "property-right-container" });
        deleteButtonContainer.style.marginLeft = "auto";
      }
    }
    this.createActionButtons(contentEl);
  }
  /**
   * Creates the "OK" and "Reset" buttons.
   * @param containerEl - The HTML element to append the buttons to.
   */
  createActionButtons(containerEl) {
    const buttonsEl = containerEl.createDiv({ cls: "modal-buttons" });
    buttonsEl.style.marginTop = "15px";
    buttonsEl.style.display = "flex";
    buttonsEl.style.justifyContent = "flex-end";
    buttonsEl.style.gap = "10px";
    const resetButton = buttonsEl.createEl("button");
    (0, import_obsidian19.setIcon)(resetButton, "reset");
    resetButton.ariaLabel = "Reset selection";
    resetButton.onclick = () => {
      this.resetToInitial();
    };
    const emptyButton = buttonsEl.createEl("button");
    (0, import_obsidian19.setIcon)(emptyButton, "eraser");
    emptyButton.ariaLabel = "Clear selection";
    emptyButton.onclick = () => {
      this.resetToEmpty();
    };
    const cancelButton = buttonsEl.createEl("button", { text: "Cancel" });
    cancelButton.ariaLabel = "close and discard changes";
    cancelButton.onclick = () => {
      logger.log(DEBUG, "Cancel Clicked - Returning");
      this.resolvePromise(null);
      this.close();
    };
    const okButton = buttonsEl.createEl("button", { text: "OK", cls: "mod-cta" });
    cancelButton.ariaLabel = "close and save changes";
    okButton.onclick = () => {
      this.resolvePromise({ values: this.result });
      this.close();
    };
  }
  /**
   * Called when the modal is closed. Cleans up resources.
   */
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  openAndGetValues() {
    this.open();
    return this.promise;
  }
};
async function openAutocompleteModal(app, plugin, rule, options, activeFile, frontmatter) {
  if (!app) {
    logger.log(ERROR, "App is undefined");
    return null;
  }
  const modal = new AutocompleteModal(app, plugin, rule, options, activeFile, frontmatter);
  return await modal.openAndGetValues();
}

// src/rules/buildInAutoCompleteModal.ts
var RuleBuildInAutoCompleteModal = class extends RulePrototype {
  constructor() {
    super();
    this.id = "autoCompleteModal";
    this.ruleType = "autocomplete.modal";
    this.name = "Auto-Complete Modal";
    this.description = "Displays an auto-complete modal for the frontmatter parameter.";
    this.source = "function (app, file, tools) { // do not change this line!\n  const input = tools.getCurrentContent(); // Get the current content of property\n  return input; // Return the input unaltered\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    logger.log(DEBUG, `autocomplete modal, work in progress...`);
    const currentContent = tools.getCurrentContent();
    const rule = tools.getRule();
    if (!rule)
      return currentContent;
    const options = tools.getOptionConfig(rule.id);
    if (!rule)
      return tools.getCurrentContent() || "autocomplete.modal";
    const frontmatter = tools.getFrontmatter();
    const hasAutocompleteProperties = Object.keys(frontmatter).some(
      (key) => key.startsWith(rule.property + options.propertyDelimiter) && (frontmatter[key] === void 0 || frontmatter[key] === null || frontmatter[key] === "")
    );
    if (!hasAutocompleteProperties)
      return tools.getCurrentContent() || "autocomplete.modal";
    openAutocompleteModal(
      tools.app,
      tools.plugin,
      rule,
      options,
      tools.getActiveFile(),
      tools.getFrontmatter()
    ).then((result) => {
      logger.log(DEBUG, "autocomplete modal result", result, tools.getFrontmatter());
      if (result == null ? void 0 : result.values) {
        if (!tools.app) {
          logger.log(ERROR, "App is not defined");
          return tools.getCurrentContent() || "autocomplete.modal Error. See console for details.";
        }
        tools.app.fileManager.processFrontMatter(file, (frontmatter2) => {
          for (const [key, value] of Object.entries(result.values)) {
            frontmatter2[key] = value;
          }
        }, { "mtime": file.stat.mtime });
      }
      return tools.getCurrentContent();
    }).catch((error) => {
      logger.log(ERROR, "Error opening autocomplete modal:", error);
      return tools.getCurrentContent() || "autocomplete.modal Error. See console for details.";
    });
  }
  configTab(optionEL, rule, that, previewComponent) {
    optionEL.empty();
    that.setOptionConfigDefaults(rule.id, {
      propertyDelimiter: "."
    });
    new import_obsidian20.Setting(optionEL).setName("Delimiter").setDesc("Character to determine which property should appear in the modal").addText((text) => text.setValue(that.getOptionConfig(rule.id, "propertyDelimiter") || ".").onChange(async (value) => {
      that.setOptionConfig(rule.id, "propertyDelimiter", value);
    }));
  }
};

// src/rules/buildInConcatProperties.ts
var import_obsidian21 = require("obsidian");
var RuleBuildInConcatProperties = class extends RulePrototype {
  constructor() {
    super();
    this.id = "concatProperties";
    this.ruleType = "buildIn";
    this.name = "Concat Properties";
    this.description = "Concatenates multiple properties from the frontmatter.";
    this.source = "function (app, file, tools) { // do not change this line!\n  const propertyIds = tools.getOptionConfig(tools.getRule()?.id,'inputProperties');\n  if (!Array.isArray(propertyIds) || propertyIds.length === 0) {\n    return 'No properties selected';\n  }\n  const delimiter = tools.getOptionConfig(tools.getRule()?.id,'delimiter');\n  const onlyWhenAllPropertiesExist = tools.getOptionConfig(tools.getRule()?.id, 'onlyWhenAllPropertiesExist') || false;\n  if (onlyWhenAllPropertiesExist) {\n    // Check if all properties exist\n    const allExist = propertyIds.every(id => { \n      if (id === undefined || id === null || id === '') {\n        return true; // Skip empty or undefined property IDs\n      }\n      const propertyValue = tools.getFrontmatterProperty(id);\n      const result = propertyValue !== undefined && propertyValue !== null && propertyValue !== '';\n      return result;\n    });\n    if (!allExist) {\n      return '';\n    }\n  }\n  const result = propertyIds.map(id => {\n    let value = tools.getFrontmatterProperty(id);\n    if (value === undefined || value === null || value === '') {\n      return ''; // Skip empty or undefined properties\n    }\n    return value.toString();\n  }).filter(res => res !== undefined).join(delimiter);\n  return result;\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    var _a, _b, _c;
    const propertyIds = tools.getOptionConfig((_a = tools.getRule()) == null ? void 0 : _a.id, "inputProperties");
    if (!Array.isArray(propertyIds) || propertyIds.length === 0) {
      return "No properties selected";
    }
    const delimiter = tools.getOptionConfig((_b = tools.getRule()) == null ? void 0 : _b.id, "delimiter");
    const onlyWhenAllPropertiesExist = tools.getOptionConfig((_c = tools.getRule()) == null ? void 0 : _c.id, "onlyWhenAllPropertiesExist") || false;
    if (onlyWhenAllPropertiesExist) {
      const allExist = propertyIds.every((id) => {
        if (id === void 0 || id === null || id === "") {
          return true;
        }
        const propertyValue = tools.getFrontmatterProperty(id);
        const result2 = propertyValue !== void 0 && propertyValue !== null && propertyValue !== "";
        return result2;
      });
      if (!allExist) {
        return "";
      }
    }
    const result = propertyIds.map((id) => {
      let value = tools.getFrontmatterProperty(id);
      if (value === void 0 || value === null || value === "") {
        return "";
      }
      return value.toString();
    }).filter((res) => res !== void 0).join(delimiter);
    return result;
  }
  configTab(optionEL, rule, that, previewComponent) {
    that.setOptionConfigDefaults(rule.id, {
      delimiter: " ",
      // Default delimiter for concatenation
      inputProperties: [],
      onlyWhenAllPropertiesExist: true
      // Default to false
    });
    const multiProp = new MultiPropertySetting(optionEL).setName("Input Properties").setDesc("Select properties as input. Use 'Space replacement' as delimiter.").setOptions(Object.keys(that.knownProperties).map((key) => key)).setValue(that.getOptionConfig(rule.id, "inputProperties") || []).onChange((arr) => {
      that.setOptionConfig(rule.id, "inputProperties", arr);
      that.updatePreview(rule, previewComponent);
    });
    new import_obsidian21.Setting(optionEL).setName("Delimiter").setDesc("Specify a delimiter to use when concatenating properties. Default is a space.").addText(
      (text) => text.setValue(that.getOptionConfig(rule.id, "delimiter") || "").setPlaceholder("Enter delimiter").onChange(async (value) => {
        that.setOptionConfig(rule.id, "delimiter", value);
        that.updatePreview(rule, previewComponent);
      })
    );
    new import_obsidian21.Setting(optionEL).setName("Only when all properties exist").setDesc("If enabled, the rule will only return a value if all selected properties exist and not empty.").addToggle(
      (toggle) => toggle.setValue(that.getOptionConfig(rule.id, "onlyWhenAllPropertiesExist")).onChange(async (value) => {
        that.setOptionConfig(rule.id, "onlyWhenAllPropertiesExist", value);
        that.updatePreview(rule, previewComponent);
      })
    );
  }
};

// src/rules/buildInConstant.ts
var import_obsidian22 = require("obsidian");
var RuleBuildInConstant = class extends RulePrototype {
  constructor() {
    super();
    this.id = "constant";
    this.ruleType = "buildIn";
    this.name = "Constant value";
    this.description = "Returns a constant value instead of the frontmatter parameter.";
    this.source = "function (app, file, tools) { // do not change this line!\n  const result = tools.getOptionConfig(tools.getRule()?.id,'constantValue');\n  return result; // Return the constant value\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    var _a;
    const result = tools.getOptionConfig((_a = tools.getRule()) == null ? void 0 : _a.id, "constantValue");
    return result;
  }
  configTab(optionEL, rule, that, previewComponent) {
    optionEL.empty();
    that.setOptionConfigDefaults(rule.id, {
      constantValue: ""
    });
    new import_obsidian22.Setting(optionEL).setName("Constant value").setDesc("Enter a constant value to be used in the rule").addText(
      (text) => text.setValue(that.getOptionConfig(rule.id, "constantValue") || "").onChange(async (value) => {
        that.setOptionConfig(rule.id, "constantValue", value);
        that.updatePreview(rule, previewComponent);
      })
    );
  }
};

// src/rules/buildInDateTimeCreated.ts
var RuleBuildInDateTimeCreated = class extends RulePrototype {
  constructor() {
    super();
    this.id = "dateTimeCreated";
    this.ruleType = "buildIn";
    this.name = "Date (and Time) created";
    this.description = "This rule returns the date and time when the file was created, adjusted for local timezone.";
    this.source = "function(app: App | undefined, file: TFile, tools: ScriptingTools) { // do not change this line! \n const timeOffset = new Date(Date.now()).getTimezoneOffset()*60000; // get local time offset \n const result = new Date(file.stat.ctime-timeOffset); \n return result.toISOString().split('Z')[0]; // remove UTC symbol \n }";
    this.type = ["date", "datetime"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    const timeOffset = new Date(Date.now()).getTimezoneOffset() * 6e4;
    const result = new Date(file.stat.ctime - timeOffset);
    return result.toISOString().split("Z")[0];
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInDateTimeModified.ts
var RuleBuildInDateTimeModified = class extends RulePrototype {
  constructor() {
    super();
    this.id = "dateTimeModified";
    this.ruleType = "buildIn";
    this.name = "Date (and Time) modified";
    this.description = "This rule returns the date and time when the file was last modified, adjusted for local timezone.";
    this.source = "function(app: App | undefined, file: TFile, tools: ScriptingTools) { // do not change this line! \n const timeOffset = new Date(Date.now()).getTimezoneOffset()*60000; // get local time offset \n const result = new Date(file.stat.mtime-timeOffset); \n return result.toISOString().split('Z')[0]; // remove UTC symbol \n }";
    this.type = ["date", "datetime"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    const timeOffset = new Date(Date.now()).getTimezoneOffset() * 6e4;
    const result = new Date(file.stat.mtime - timeOffset);
    return result.toISOString().split("Z")[0];
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInDefault.ts
var RuleBuildInDefault = class extends RulePrototype {
  constructor() {
    super();
    this.id = "default";
    this.ruleType = "buildIn";
    this.name = "Pass parameter unaltered";
    this.description = "Pass the content of the frontmatter parameter unaltered.";
    this.source = "function (app, file, tools) { // do not change this line!\n  const input = tools.getCurrentContent(); // Get the current content of property\n  return input; // Return the input unaltered\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    const input = tools.getCurrentContent();
    return input;
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInFileSizeBytes.ts
var RuleBuildInFileSizeBytes = class extends RulePrototype {
  constructor() {
    super();
    this.id = "fileSizeBytes";
    this.ruleType = "buildIn";
    this.name = "File Size in Bytes";
    this.description = "This rule returns the size of the file in bytes.";
    this.source = "function(app: App | undefined, file: TFile, tools: ScriptingTools) { // do not change this line! \n const result = file.stat.size; \n return result; // return you result. \n }";
    this.type = ["number"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    const result = file.stat.size;
    return result;
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInFileSizeString.ts
var RuleBuildInFileSizeString = class extends RulePrototype {
  constructor() {
    super();
    this.id = "fileSizeString";
    this.ruleType = "buildIn";
    this.name = "File Size as String";
    this.description = "Converts the file size to a human-readable string (e.g., KB, MB, GB) with 2 decimal places precision.";
    this.source = "function(app: App | undefined, file: TFile, tools: ScriptingTools) { // do not change this line! \n let size =file.stat.size; \n const precision = 2; // number of decimal places \n if (size > 1024) { \n   size = size / 1024; \n   if (size > 1024) { \n     size = size / 1024; \n     if (size > 1024) { \n       size = size / 1024; \n       return size.toFixed(precision) + ' GB'; \n     } \n     return size.toFixed(precision) + ' MB'; \n   } \n   return size.toFixed(precision) + ' KB'; \n }   \n return size + ' Bytes'; // return you result. \n }";
    this.type = ["text"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    let size = file.stat.size;
    const precision = 2;
    if (size > 1024) {
      size = size / 1024;
      if (size > 1024) {
        size = size / 1024;
        if (size > 1024) {
          size = size / 1024;
          return size.toFixed(precision) + " GB";
        }
        return size.toFixed(precision) + " MB";
      }
      return size.toFixed(precision) + " KB";
    }
    return size + " Bytes";
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInFolder.ts
var RuleBuildInFolder = class extends RulePrototype {
  constructor() {
    super();
    this.id = "folder";
    this.ruleType = "buildIn";
    this.name = "Parent folder";
    this.description = "Returns the parent folder of the file.";
    this.source = "function (app, file, tools) { // do not change this line!\n  const input = tools.getCurrentContent(); // Get the current content of property\n  return input; // Return the input unaltered\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    const path = file.path;
    const parts = path.split("/");
    let result = "";
    if (parts.length > 1) {
      result = parts[parts.length - 2];
    }
    return result;
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInFolderFolderNotes.ts
var RuleBuildInFolderFolderNotes = class extends RulePrototype {
  constructor() {
    super();
    this.id = "folderFolderNotes";
    this.ruleType = "buildIn";
    this.name = 'Parent Folder (complies with "folder notes")';
    this.description = "Returns the parent folder of the file compatible with Folder Notes.";
    this.source = "function (app, file, tools) { // do not change this line!\n  // acquire file path\n  const path = file.path;const parts = file.path.split('/');\n  let index = parts.length-2; // index of parent folder\n  if (parts[parts.length-2]===file.basename) {\n      index--; // folder note parent is the child\n  }\n  if (index >= 0) {\n    return parts[index]; // file in folder\n  } else {\n    return tools.app?.vault?.getName() || 'Vault'; // file in root = vault\n  }\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    var _a, _b;
    const path = file.path;
    const parts = file.path.split("/");
    let index = parts.length - 2;
    if (parts[parts.length - 2] === file.basename) {
      index--;
    }
    if (index >= 0) {
      return parts[index];
    } else {
      return ((_b = (_a = tools.app) == null ? void 0 : _a.vault) == null ? void 0 : _b.getName()) || "Vault";
    }
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInFolders.ts
var RuleBuildInFolders = class extends RulePrototype {
  constructor() {
    super();
    this.id = "folders";
    this.ruleType = "buildIn";
    this.name = "All folders of the file as a list";
    this.description = "Returns all folders the file is stored in as a list.";
    this.source = "function (app, file, tools) { // do not change this line!\n  // acquire file path\n  const path = file.path;\n  const result = path.split('/');\n  result.pop(); // remove the file name\n  return result;\n}";
    this.type = ["tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    const path = file.path;
    const result = path.split("/");
    result.pop();
    return result;
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInFullPath.ts
var RuleBuildInFullPath = class extends RulePrototype {
  constructor() {
    super();
    this.id = "fullPath";
    this.ruleType = "buildIn";
    this.name = "Full path, filename";
    this.description = "Returns the full path of the file, including the filename.";
    this.source = "function (app, file, tools) { // do not change this line!\n  let parts = file.path.split('/');\n  parts.pop();\n  parts.push(file.basename);\n  return parts.join('/');\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    let parts = file.path.split("/");
    parts.pop();
    parts.push(file.basename);
    return parts.join("/");
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInFullPathExt.ts
var RuleBuildInFullPathExt = class extends RulePrototype {
  constructor() {
    super();
    this.id = "fullPathExt";
    this.ruleType = "buildIn";
    this.name = "Full path, filename and extension";
    this.description = "Returns the full path of the file, including its filename and extension.";
    this.source = "function (app, file, tools) { // do not change this line!\n  return `${file.path}`;\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    return `${file.path}`;
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInFullPathExtFolderNotes.ts
var RuleBuildInFullPathExtFolderNotes = class extends RulePrototype {
  constructor() {
    super();
    this.id = "fullPathExtFolderNotes";
    this.ruleType = "buildIn";
    this.name = 'Full Path with Extension (comply with "folder notes")';
    this.description = "Path with Extensions compatible with folder notes.";
    this.source = "function (app, file, tools) { // do not change this line!\n  let parts = file.path.split('/');\n  parts.pop();\n  if (parts[parts.length-1] === file.basename) parts.pop();\n  parts.push(file.basename);\n  return parts.join('/');\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    let parts = file.path.split("/");
    parts.pop();
    if (parts[parts.length - 1] === file.basename)
      parts.pop();
    parts.push(file.name);
    return parts.join("/");
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInFullPathFolderNotes.ts
var RuleBuildInFullPathFolderNotes = class extends RulePrototype {
  constructor() {
    super();
    this.id = "fullPathFolderNotes";
    this.ruleType = "buildIn";
    this.name = 'Full Path (comply with "folder notes")';
    this.description = "Path compatible compatible with folder notes.";
    this.source = "function (app, file, tools) { // do not change this line!\n  let parts = file.path.split('/');\n  parts.pop();\n  if (parts[parts.length-1] === file.basename) parts.pop();\n  parts.push(file.basename);\n  return parts.join('/');\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    let parts = file.path.split("/");
    parts.pop();
    if (parts[parts.length - 1] === file.basename)
      parts.pop();
    parts.push(file.basename);
    return parts.join("/");
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInGetProperties.ts
var import_obsidian23 = require("obsidian");
var RuleBuildInGetProperties = class extends RulePrototype {
  constructor() {
    super();
    this.id = "getProperties";
    this.ruleType = "buildIn";
    this.name = "Get Properties";
    this.description = "Retrieves multiple frontmatter properties (Multitext, Tags, Aliases).";
    this.source = "function (app, file, tools) { // do not change this line!\n  const propertyIds = tools.getOptionConfig(tools.getRule()?.id,'inputProperties');\n  if (!Array.isArray(propertyIds) || propertyIds.length === 0) {\n    return 'No properties selected';\n  }\n  const delimiter = tools.getOptionConfig(tools.getRule()?.id,'delimiter');\n  const onlyWhenAllPropertiesExist = tools.getOptionConfig(tools.getRule()?.id, 'onlyWhenAllPropertiesExist') || false;\n  if (onlyWhenAllPropertiesExist) {\n    // Check if all properties exist\n    const allExist = propertyIds.every(id => { \n      if (id === undefined || id === null || id === '') {\n        return true; // Skip empty or undefined property IDs\n      }\n      const propertyValue = tools.getFrontmatterProperty(id);\n      const result = propertyValue !== undefined && propertyValue !== null && propertyValue !== '';\n      return result;\n    });\n    if (!allExist) {\n      return '';\n    }\n  }\n  const result = propertyIds.map(id => {\n    let value = tools.getFrontmatterProperty(id);\n    if (value === undefined || value === null || value === '') {\n      return ''; // Skip empty or undefined properties\n    }\n    return value.toString();\n  }).filter(res => res !== undefined).join(delimiter);\n  return result;\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    var _a;
    const rule = tools.getRule();
    if (!rule) {
      logger.log(ERROR, "RuleBuildInGetProperties: No rule found.");
      return tools.getCurrentContent();
    }
    const propertyIds = tools.getOptionConfig(rule.id, "inputProperties");
    if (!Array.isArray(propertyIds) || propertyIds.length === 0) {
      return "No properties selected";
    }
    const onlyWhenAllPropertiesExist = tools.getOptionConfig(rule.id, "onlyWhenAllPropertiesExist") || false;
    if (onlyWhenAllPropertiesExist) {
      const allExist = propertyIds.every((id) => {
        if (id === void 0 || id === null || id === "") {
          return true;
        }
        const propertyValue = tools.getFrontmatterProperty(id);
        const result = propertyValue !== void 0 && propertyValue !== null && propertyValue !== "";
        return result;
      });
      if (!allExist) {
        return [];
      }
    }
    let resultArray = [];
    propertyIds.forEach((id) => {
      let value = tools.getFrontmatterProperty(id);
      if (value === void 0 || value === null || value === "") {
        return;
      }
      resultArray = resultArray.concat(Array.isArray(value) ? value : [value.toString()]);
    });
    switch (rule.type || ((_a = rule.typeProperty) == null ? void 0 : _a.type)) {
      case "text":
        return resultArray.join(tools.getOptionConfig(rule.id, "delimiter"));
      case "tags":
      case "aliases":
      case "multitext":
        return resultArray;
    }
    return resultArray;
  }
  configTab(optionEL, rule, that, previewComponent) {
    that.setOptionConfigDefaults(rule.id, {
      inputProperties: [],
      onlyWhenAllPropertiesExist: false,
      // Default to false
      propertyDelimiter: ""
    });
    const multiProp = new MultiPropertySetting(optionEL).setName("Input Properties").setDesc("Select properties as input. (text, tags, aliases or multitext)").setOptions(Object.keys(that.knownProperties).map((key) => {
      const prop = that.knownProperties[key];
      if (prop.type === "text" || prop.type === "tags" || prop.type === "aliases" || prop.type === "multitext") {
        return key;
      }
      return null;
    }).filter((item) => item !== null)).setValue(that.getOptionConfig(rule.id, "inputProperties") || []).onChange((arr) => {
      that.setOptionConfig(rule.id, "inputProperties", arr);
      that.updatePreview(rule, previewComponent);
    });
    new import_obsidian23.Setting(optionEL).setName("Only when all properties exist").setDesc("If enabled, the rule will only return a value if all selected properties exist and not empty.").addToggle(
      (toggle) => toggle.setValue(that.getOptionConfig(rule.id, "onlyWhenAllPropertiesExist")).onChange(async (value) => {
        that.setOptionConfig(rule.id, "onlyWhenAllPropertiesExist", value);
        that.updatePreview(rule, previewComponent);
      })
    );
    that.setOptionConfigDefaults(rule.id, {
      propertyDelimiter: "."
    });
    new import_obsidian23.Setting(optionEL).setName("Delimiter").setDesc("Character to separate concatenated values if placed into a text property. If empty, no delimiter is used.").addText((text) => text.setValue(that.getOptionConfig(rule.id, "propertyDelimiter") || ".").setPlaceholder('e.g. "." or ","').onChange(async (value) => {
      that.setOptionConfig(rule.id, "propertyDelimiter", value);
    }));
  }
};

// src/rules/buildInGetProperty.ts
var import_obsidian24 = require("obsidian");
var RuleBuildInGetProperty = class extends RulePrototype {
  constructor() {
    super();
    this.id = "getProperty";
    this.ruleType = "buildIn";
    this.name = "Get property";
    this.description = "Gets a property from selected property.";
    this.source = "function(app: App | undefined, file: TFile, tools: ScriptingTools) { // do not change this line! \n const propertyId = tools.getOptionConfig(tools.getRule()?.id,'inputProperty'); \n if (propertyId === undefined || propertyId === '') { \n return 'Property not set'; \n } \n const result = tools.getFrontmatterProperty(propertyId); \n if (result === undefined) { \n return 'Property not found'; \n } \n return result; \n }";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    var _a;
    const propertyId = tools.getOptionConfig((_a = tools.getRule()) == null ? void 0 : _a.id, "inputProperty");
    if (propertyId === void 0 || propertyId === "") {
      return "Property not set";
    }
    const result = tools.getFrontmatterProperty(propertyId);
    if (result === void 0) {
      return "Property not found";
    }
    return result;
  }
  configTab(optionEL, rule, that, previewComponent) {
    that.setOptionConfigDefaults(rule.id, {
      inputProperty: ""
    });
    let inputPropertiesDropdown;
    new import_obsidian24.Setting(optionEL).setName("Input Property").setDesc("Select a property as input").addDropdown((dropdown) => {
      inputPropertiesDropdown = dropdown;
      dropdown.setValue(that.getOptionConfig(rule.id, "inputProperty") || "").onChange(async (value) => {
        if (value !== "") {
          that.setOptionConfig(rule.id, "inputProperty", value);
          that.updatePreview(rule, previewComponent);
        }
      });
    });
    Object.keys(that.knownProperties).forEach((key) => {
      const item = that.knownProperties[key];
      inputPropertiesDropdown.addOption(item.name, item.name);
    });
  }
};

// src/rules/buildInIsRoot.ts
var RuleBuildInIsRoot = class extends RulePrototype {
  constructor() {
    super();
    this.id = "isRoot";
    this.ruleType = "buildIn";
    this.name = "File in Root folder";
    this.description = "Check if the file is in the root folder.";
    this.source = "function (app, file, tools) { // do not change this line!\n  let parts = file.path.split('/');\n  return parts.length === 1;\n};";
    this.type = ["checkbox"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    let parts = file.path.split("/");
    return parts.length === 1;
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInLinkToFile.ts
var import_obsidian25 = require("obsidian");
var RuleBuildInLinkToFile = class extends RulePrototype {
  constructor() {
    super();
    this.id = "linkToFile";
    this.ruleType = "buildIn";
    this.name = "Create link to file";
    this.description = "Create a link to the file in the current vault. Can be configured to include the file extension.";
    this.source = "function (app, file, tools) { // do not change this line!\n  const parts = file.path.split('/');\n  const rule = tools.getRule();\n  if (!rule) return tools.getCurrentContent();\n  const addExtension = tools.getOptionConfig(rule.id,'addExtension') \n  parts.pop();\n  if (parts[parts.length-1] === file.basename) parts.pop();\n  let fileName = addExtension? file.basename + '.' + file.extension : file.basename; \n  return `[[${parts.join('/')}/${fileName}|${file.basename}]]`;\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    const parts = file.path.split("/");
    const rule = tools.getRule();
    if (!rule)
      return tools.getCurrentContent();
    const addExtension = tools.getOptionConfig(rule.id, "addExtension");
    parts.pop();
    if (parts[parts.length - 1] === file.basename)
      parts.pop();
    let fileName = addExtension ? file.basename + "." + file.extension : file.basename;
    return `[[${parts.join("/")}/${fileName}|${file.basename}]]`;
  }
  configTab(optionEL, rule, that, previewComponent) {
    that.setOptionConfigDefaults(rule.id, {
      addExtension: true
    });
    new import_obsidian25.Setting(optionEL).setName("Include file extension").setDesc("Add file extension to pathname").addToggle(
      (toggle) => toggle.setValue(that.getOptionConfig(rule.id, "addExtension") || false).onChange(async (value) => {
        that.setOptionConfig(rule.id, "addExtension", value);
        that.updatePreview(rule, previewComponent);
      })
    );
  }
};

// src/rules/buildInName.ts
var RuleBuildInName = class extends RulePrototype {
  constructor() {
    super();
    this.id = "name";
    this.ruleType = "buildIn";
    this.name = "File name without extension";
    this.description = "Returns the file name without all extensions. I.e. example.note.md => example";
    this.source = "function (app, file, tools) { // do not change this line!\n  // acquire file name\n  const result = tools.removeAllExtensions(file.name);\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    const result = tools.removeAllExtensions(file.name);
    return result;
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInNameExt.ts
var RuleBuildInNameExt = class extends RulePrototype {
  constructor() {
    super();
    this.id = "nameExt";
    this.ruleType = "buildIn";
    this.name = "File name with extension";
    this.description = "Returns the file name with extension.";
    this.source = "function (app, file, tools) { // do not change this line!\n  // acquire file name with extension\n  const result = file.name;\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    const result = file.name;
    return result;
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInPath.ts
var RuleBuildInPath = class extends RulePrototype {
  constructor() {
    super();
    this.id = "path";
    this.ruleType = "buildIn";
    this.name = "Full path";
    this.description = "Returns the folder path the file is stored in.";
    this.source = "function (app, file, tools) { // do not change this line!\n  let parts = file.path.split('/');\n  parts.pop();\n  return parts.join('/');\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    let parts = file.path.split("/");
    parts.pop();
    return parts.join("/");
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInPathFolderNotes.ts
var RuleBuildInPathFolderNotes = class extends RulePrototype {
  constructor() {
    super();
    this.id = "pathFolderNotes";
    this.ruleType = "buildIn";
    this.name = "Path (folder notes)";
    this.description = "Path compatible with folder notes.";
    this.source = "function (app, file, tools) { // do not change this line!\n  let parts = file.path.split('/');\n  parts.pop();\n  if (parts[parts.length-1] === file.basename) parts.pop(); // remove parent folder if same name as the file\n  return parts.join('/');\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    let parts = file.path.split("/");
    parts.pop();
    if (parts[parts.length - 1] === file.basename)
      parts.pop();
    return parts.join("/");
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInRootFolder.ts
var RuleBuildInRootFolder = class extends RulePrototype {
  constructor() {
    super();
    this.id = "rootFolder";
    this.ruleType = "buildIn";
    this.name = "Root folder";
    this.description = "Returns the root folder where the file is stored.";
    this.source = "function (app, file, tools) { // do not change this line!\n  // acquire file path\n  const path = file.path;\n  const parts = path.split('/');\n  return parts.length > 1 ? parts[0] : ''; // return root folder or empty string if in root\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    const path = file.path;
    const parts = path.split("/");
    let result = "";
    if (parts.length > 1) {
      result = parts[0];
    }
    return result;
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/buildInScript.ts
var RuleBuildInScript = class extends RulePrototype {
  constructor() {
    super();
    this.id = "script";
    this.ruleType = "buildIn";
    this.name = "JavaScript function (advanced)";
    this.description = "Implement a JavaScript function to process the input content. The function should return the processed content.";
    this.source = "function (app, file, tools) { // do not change this line!\n  const input = tools.getCurrentContent(); // Get the current content of property\n  return input; // Return the input unaltered\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools) {
    const input = tools.getCurrentContent();
    return input;
  }
  configTab(optionEL, rule, that, previewComponent) {
  }
};

// src/rules/replaceChars.ts
var import_obsidian26 = require("obsidian");
var RuleReplaceChars = class extends RulePrototype {
  constructor() {
    super();
    this.id = "replaceChars";
    this.name = "Replace Characters";
    this.description = "Replaces configurable characters in the input value with a specified text string. Supports text and regex replacements.";
    this.ruleType = "formatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    var _a, _b;
    const replace = tools.getOptionConfig((_a = tools.getRule()) == null ? void 0 : _a.id, "replace");
    if (!replace || replace === "") {
      return input;
    }
    const replaceBy = tools.getOptionConfig((_b = tools.getRule()) == null ? void 0 : _b.id, "replaceBy");
    try {
      const regex = new RegExp(replace, "g");
      return input.replace(regex, replaceBy);
    } catch (e) {
      logger.log(ERROR, `Error in RuleReplaceChars: Invalid regex pattern "${replace}"`, e);
      return input;
    }
  }
  configTab(optionEL, rule, that, previewComponent) {
    optionEL.empty();
    that.setOptionConfigDefaults(rule.id, {
      replace: "",
      // search for this string
      replaceBy: ""
      // replace with this string
    });
    new import_obsidian26.Setting(optionEL).setName("search for").setDesc("Character to search for in the input value (Regex supported)").addText(
      (text) => text.setPlaceholder("search for").setValue(that.getOptionConfig(rule.id, "replace") || "").onChange(async (value) => {
        that.setOptionConfig(rule.id, "replace", value);
        that.updatePreview(rule, previewComponent);
      })
    );
    new import_obsidian26.Setting(optionEL).setName("replace by").setDesc("Character to replace matches").addText(
      (text) => text.setPlaceholder("replace by").setValue(that.getOptionConfig(rule.id, "replaceBy") || "").onChange(async (value) => {
        that.setOptionConfig(rule.id, "replaceBy", value);
        that.updatePreview(rule, previewComponent);
      })
    );
  }
};

// src/rules/replaceSpaces.ts
var import_obsidian27 = require("obsidian");
var RuleReplaceSpaces = class extends RulePrototype {
  constructor() {
    super();
    this.id = "replaceSpaces";
    this.name = "Replace Spaces";
    this.description = "Replaces spaces in the input value with a specified character.";
    this.ruleType = "formatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    var _a;
    const spaceReplacement = tools.getOptionConfig((_a = tools.getRule()) == null ? void 0 : _a.id, "spaceReplacement");
    return input.replace(/\s+/g, spaceReplacement);
  }
  configTab(optionEL, rule, that, previewComponent) {
    optionEL.empty();
    that.setOptionConfigDefaults(rule.id, {
      spaceReplacement: ""
      // Default suffix
    });
    new import_obsidian27.Setting(optionEL).setName("Space replacement").setDesc('Character to replace spaces (suggested: "_")').addText(
      (text) => text.setPlaceholder("will remove spaces").setValue(that.getOptionConfig(rule.id, "spaceReplacement") || "").onChange(async (value) => {
        that.setOptionConfig(rule.id, "spaceReplacement", value);
        that.updatePreview(rule, previewComponent);
      })
    );
  }
};

// src/rules/replaceSpecialChars.ts
var import_obsidian28 = require("obsidian");
var RuleReplaceSpecialChars = class extends RulePrototype {
  constructor() {
    super();
    this.id = "replaceSpecialChars";
    this.name = "Replace Special Characters";
    this.description = 'Character to replace special characters (suggested: "-") - preserves letters with diacritics';
    this.ruleType = "formatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    var _a;
    const specialCharReplacement = tools.getOptionConfig((_a = tools.getRule()) == null ? void 0 : _a.id, "specialCharReplacement");
    return input.replace(/[^a-zA-Z0-9\-_\/äöüßÄÖÜáéíóúýÁÉÍÓÚÝàèìòùÀÈÌÒÙâêîôûÂÊÎÔÛãñõÃÑÕ]/g, specialCharReplacement);
  }
  configTab(optionEL, rule, that, previewComponent) {
    optionEL.empty();
    that.setOptionConfigDefaults(rule.id, {
      specialCharReplacement: ""
      // Default suffix
    });
    new import_obsidian28.Setting(optionEL).setName("Replace Special Characters").setDesc('Character to replace special characters (suggested: "-") - preserves letters with diacritics').addText(
      (text) => text.setPlaceholder("will remove special characters").setValue(that.getOptionConfig(rule.id, "specialCharReplacement") || "").onChange(async (value) => {
        that.setOptionConfig(rule.id, "specialCharReplacement", value);
        that.updatePreview(rule, previewComponent);
      })
    );
  }
};

// src/rules/toCamelCase.ts
var RuleToCamelCase = class extends RulePrototype {
  constructor() {
    super();
    this.id = "toCamelCase";
    this.name = "To Camel Case";
    this.description = "Convert the value to Camel Case.";
    this.ruleType = "formatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    const toCamelCase = (str) => {
      let textParts = str.split(" ");
      let convertedTextParts = [];
      textParts.forEach((text, index) => {
        let newTextPart = text.toLowerCase();
        if (index > 0)
          newTextPart = newTextPart.charAt(0).toUpperCase() + newTextPart.slice(1);
        convertedTextParts.push(newTextPart);
      });
      return convertedTextParts.join("");
    };
    if (typeof input === "string") {
      return toCamelCase(input);
    } else if (Array.isArray(input)) {
      return input.map((item) => toCamelCase(String(item)));
    } else if (input instanceof Date) {
      return toCamelCase(input.toISOString());
    } else if (typeof input === "object") {
      return toCamelCase(JSON.stringify(input));
    }
    return input;
  }
};

// src/rules/toLinkMarkdown.ts
var RuleToLinkMarkdown = class extends RulePrototype {
  constructor() {
    super();
    this.id = "toMarkdownLink";
    this.name = "to markdown link";
    this.description = "Format as a markdown link.";
    this.ruleType = "linkFormatter";
    this.source = "function (input: any, tools: ScriptingTools) { // do not change this line!\n  input = tools.toMarkdownLink(input); // Convert to markdown link format\n  return input;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    input = tools.toMarkdownLink(input);
    return input;
  }
};

// src/rules/toLinkOriginal.ts
var RuleToLinkOriginal = class extends RulePrototype {
  constructor() {
    super();
    this.id = "toOriginalLink";
    this.name = "no change";
    this.description = "Pass the input unaltered.";
    this.ruleType = "linkFormatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    return input;
  }
};

// src/rules/toLinkSimple.ts
var RuleToLinkSimple = class extends RulePrototype {
  constructor() {
    super();
    this.id = "toSimpleLink";
    this.name = "to simple link";
    this.description = "Format as a simple link by adding [[]].";
    this.ruleType = "linkFormatter";
    this.source = "function (app, file, tools, input) { // do not change this line!\n  if (input === undefined || input === null || input === '') {\n    return ''; // Return empty string if input is undefined, null, or empty\n  }\n         input = `[[${input}]]`; // Convert to simple Link\n  return input;\n};";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    if (input === void 0 || input === null || input === "") {
      return "";
    }
    input = `[[${input}]]`;
    return input;
  }
};

// src/rules/toLinkWiki.ts
var RuleToLinkWiki = class extends RulePrototype {
  constructor() {
    super();
    this.id = "toWikiLink";
    this.name = "to wiki link";
    this.description = "Format as a wiki link.";
    this.ruleType = "linkFormatter";
    this.source = "function (input: any, tools: ScriptingTools) { // do not change this line!\n  input = tools.toWikiLink(input); // Convert to wiki link format\n  return input;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    input = tools.toWikiLink(input);
    return input;
  }
};

// src/rules/toLowerCase.ts
var RuleToLowerCase = class extends RulePrototype {
  constructor() {
    super();
    this.id = "toLowerCase";
    this.name = "To Lower Case";
    this.description = "Convert the value to lower case.";
    this.ruleType = "formatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    if (String.isString(input)) {
      return input.toLowerCase();
    } else if (Array.isArray(input)) {
      return input.map((item) => String(item).toLowerCase());
    } else if (input instanceof Date) {
      return input.toISOString().toLowerCase();
    } else if (typeof input === "object") {
      return JSON.stringify(input).toLowerCase();
    }
    return input;
  }
};

// src/rules/toOriginal.ts
var RuleToOriginal = class extends RulePrototype {
  constructor() {
    super();
    this.id = "toOriginal";
    this.name = "no change";
    this.description = "Pass the input unaltered.";
    this.ruleType = "formatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    return input;
  }
};

// src/rules/toPascalCase.ts
var RuleToPascalCase = class extends RulePrototype {
  constructor() {
    super();
    this.id = "toPascalCase";
    this.name = "To Pascal Case";
    this.description = "Convert the value to Pascal Case (Upper Camel Case).";
    this.ruleType = "formatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    const toPascalCase = (str) => {
      return str.replace(
        /(?:^\w|[A-Z]|\b\w|\s+)/g,
        (match) => match.toUpperCase()
      ).replace(/\s+/g, "").replace(/[^a-zA-Z0-9]/g, "");
    };
    if (typeof input === "string") {
      return toPascalCase(input);
    } else if (Array.isArray(input)) {
      return input.map((item) => toPascalCase(String(item)));
    } else if (input instanceof Date) {
      return toPascalCase(input.toISOString());
    } else if (typeof input === "object") {
      return toPascalCase(JSON.stringify(input));
    }
    return input;
  }
};

// src/rules/toTitleCase.ts
var RuleToTitleCase = class extends RulePrototype {
  constructor() {
    super();
    this.id = "toTitleCase";
    this.name = "To Title Case (Simple)";
    this.description = "Convert the value to Title Case.";
    this.ruleType = "formatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    const toTitleCase = (str) => {
      let textParts = str.split(" ");
      let convertedTextParts = [];
      textParts.forEach((text, index) => {
        let newTextPart = text.toLowerCase();
        newTextPart = newTextPart.charAt(0).toUpperCase() + newTextPart.slice(1);
        convertedTextParts.push(newTextPart);
      });
      return convertedTextParts.join(" ");
    };
    if (typeof input === "string") {
      return toTitleCase(input);
    } else if (Array.isArray(input)) {
      return input.map((item) => toTitleCase(String(item)));
    } else if (input instanceof Date) {
      return toTitleCase(input.toISOString());
    } else if (typeof input === "object") {
      return toTitleCase(JSON.stringify(input));
    }
    return input;
  }
};

// src/rules/toTitleCaseDE.ts
var import_obsidian29 = require("obsidian");
var RuleToTitleCaseDE = class extends RulePrototype {
  // Set to true for verbose logging
  constructor() {
    super();
    this.verboseLogging = false;
    this.small = "(der|die|das|den|dem|des|einer|eines|deren|ein|eine|einem|einer|eines|einer|und|oder|aber|denn|sondern|sowie|weder|noch|entweder|oder|dass|weil|obwohl|wenn|als|nachdem|bevor|w\xE4hrend|bis|damit|um|zu|sobald|solange|da|indem|so|dass|ohne|zu|durch|f\xFCr|gegen|ohne|um|bis|aus|au\xDFer|bei|gegen\xFCber|mit|nach|seit|von|zu|anstatt|aufgrund|au\xDFerhalb|innerhalb|trotz|w\xE4hrend|wegen|an|auf|hinter|in|neben|\xFCber|unter|vor|zwischen)";
    this.punctuation = "\\([!\"#$%&'()*+,./:;<=>?@[\\\\\\]^_`{|}~\\-]*\\)";
    this.id = "toTitleCaseDe";
    this.name = "To Title Case (German small words)";
    this.description = "Convert German value to Title Case.";
    this.ruleType = "formatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    const toTitleCase = (str) => {
      var _a;
      const ruleId = (_a = tools.getRule()) == null ? void 0 : _a.id;
      const doNotCapitalizeSmallWords = tools.getOptionConfig(ruleId, "doNotCapitalizeSmallWords");
      return this.titleCaps(str, doNotCapitalizeSmallWords ? tools.getOptionConfig(ruleId, "smallWords") : void 0);
    };
    let result = input;
    if (typeof input === "string") {
      result = toTitleCase(input);
    } else if (Array.isArray(input)) {
      result = input.map((item) => toTitleCase(String(item)));
    } else if (input instanceof Date) {
      result = toTitleCase(input.toISOString());
    } else if (typeof input === "object") {
      result = toTitleCase(JSON.stringify(input));
    }
    logger.log(DEBUG, `RuleToTitleCaseDE.fx - input:'${input}' result:'${result}'`);
    return result;
  }
  configTab(optionEL, rule, that, previewComponent) {
    optionEL.empty();
    that.setOptionConfigDefaults(rule.id, {
      smallWords: "der|die|das|den|dem|des|einer|eines|deren|ein|eine|einem|einer|eines|einer|und|oder|aber|denn|sondern|sowie|weder|noch|entweder|oder|dass|weil|obwohl|wenn|als|nachdem|bevor|w\xE4hrend|bis|damit|um|zu|sobald|solange|da|indem|so|dass|ohne|zu|durch|f\xFCr|gegen|ohne|um|bis|aus|au\xDFer|bei|gegen\xFCber|mit|nach|seit|von|zu|anstatt|aufgrund|au\xDFerhalb|innerhalb|trotz|w\xE4hrend|wegen|an|auf|hinter|in|neben|\xFCber|unter|vor|zwischen",
      doNotCapitalizeSmallWords: true
    });
    new import_obsidian29.Setting(optionEL).setName("Do not capitalize small words").setDesc("If enabled, small words will not be capitalized. If disabled, all words will be capitalized.").addToggle(
      (toggle) => toggle.setValue(that.getOptionConfig(rule.id, "doNotCapitalizeSmallWords") || false).onChange(async (value) => {
        that.setOptionConfig(rule.id, "doNotCapitalizeSmallWords", value);
        that.updatePreview(rule, previewComponent);
      })
    );
    new import_obsidian29.Setting(optionEL).setName("List of small words").setDesc('Enter a list of small words to be excluded from capitalization. Use "|" as separator.').addText(
      (text) => text.setValue(that.getOptionConfig(rule.id, "smallWords") || "").onChange(async (value) => {
        that.setOptionConfig(rule.id, "smallWords", value);
        that.updatePreview(rule, previewComponent);
      })
    );
  }
  titleCaps(title, smallWords) {
    const parts = [];
    const split = new RegExp(`[:.;?!] |(?: |^)["${this.punctuation}]`, "g");
    let index = 0;
    while (true) {
      const m = split.exec(title);
      const substring = title.substring(index, m ? m.index : title.length);
      logger.log(TRACE, "Processing substring:", substring);
      let isFirstWord = true;
      parts.push(
        substring.replace(/([\p{L}\p{M}]+(?:\.[\p{L}\p{M}]+)*)/gu, (all) => {
          logger.log(TRACE, "Matched word:", all);
          if (/[a-z][A-Z]|[A-Z][a-z]/.test(all)) {
            logger.log(TRACE, "Excluding mixed capitalization word:", all);
            isFirstWord = false;
            return all;
          }
          if (/^[A-ZÄÖÜß]+$/.test(all)) {
            logger.log(TRACE, "Excluding fully capitalized word:", all);
            isFirstWord = false;
            return all;
          }
          if (/[^\s]+\.[^\s]+/.test(all)) {
            logger.log(TRACE, "Excluding word with punctuation:", all);
            isFirstWord = false;
            return all;
          }
          const smallRegex = new RegExp(`^(${smallWords})$`, "iu");
          if (isFirstWord) {
            logger.log(TRACE, "Capitalizing first word of sentence:", all);
            isFirstWord = false;
            return this.upperDE(all);
          } else if (smallRegex.test(all)) {
            logger.log(TRACE, "Skipping capitalization for small word:", all);
            return this.lowerDE(all);
          }
          isFirstWord = false;
          return this.upperDE(all);
        })
      );
      index = split.lastIndex;
      if (m)
        parts.push(m[0]);
      else
        break;
    }
    return parts.join("");
  }
  lowerDE(word) {
    logger.log(TRACE, "Lowering:", word);
    return word.toLocaleLowerCase("de");
  }
  upperDE(word) {
    logger.log(TRACE, "Uppering:", word);
    return word.charAt(0).toLocaleUpperCase("de") + word.slice(1).toLocaleLowerCase("de");
  }
};

// src/rules/toTitleCaseEN.ts
var RuleToTitleCaseEN = class extends RulePrototype {
  constructor() {
    super();
    this.small = "(a|an|and|as|at|but|by|en|for|if|in|of|on|or|the|to|v[.]?|via|vs[.]?)";
    this.punctuation = "([!\"#$%&'()*+,./:;<=>?@[\\\\\\]^_`{|}~-]*)";
    this.id = "toTitleCaseEn";
    this.name = "To Title Case (English small words)";
    this.description = "Convert the value to Title Case.";
    this.ruleType = "formatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    const toTitleCase = (str) => {
      return this.titleCaps(str);
    };
    if (typeof input === "string") {
      return toTitleCase(input);
    } else if (Array.isArray(input)) {
      return input.map((item) => toTitleCase(String(item)));
    } else if (input instanceof Date) {
      return toTitleCase(input.toISOString());
    } else if (typeof input === "object") {
      return toTitleCase(JSON.stringify(input));
    }
    return input;
  }
  titleCaps(title) {
    var parts = [], split = /[:.;?!] |(?: |^)["Ò]/g, index = 0;
    while (true) {
      var m = split.exec(title);
      parts.push(title.substring(index, m ? m.index : title.length).replace(/\b([A-Za-z][a-z.'Õ]*)\b/g, (all) => {
        return /[A-Za-z]\.[A-Za-z]/.test(all) ? all : this.upper(all);
      }).replace(RegExp("\\b" + this.small + "\\b", "ig"), this.lower).replace(RegExp("^" + this.punctuation + this.small + "\\b", "ig"), (all, punct, word) => {
        return punct + this.upper(word);
      }).replace(RegExp("\\b" + this.small + this.punctuation + "$", "ig"), this.upper));
      index = split.lastIndex;
      if (m)
        parts.push(m[0]);
      else
        break;
    }
    return parts.join("").replace(/ V(s?)\. /ig, " v$1. ").replace(/(['Õ])S\b/ig, "$1s").replace(/\b(AT&T|Q&A)\b/ig, function(all) {
      return all.toUpperCase();
    });
  }
  lower(word) {
    return word.toLowerCase();
  }
  upper(word) {
    return word.substr(0, 1).toUpperCase() + word.substr(1);
  }
};

// src/rules/toUpperCase.ts
var RuleToUpperCase = class extends RulePrototype {
  constructor() {
    super();
    this.id = "toUpperCase";
    this.name = "To Upper Case";
    this.description = "Convert the value to upper case.";
    this.ruleType = "formatter";
    this.source = "function (app, file, tools) { // do not change this line!\n  let result = '';\n  return result;\n}";
    this.type = ["text", "tags", "aliases", "multitext"];
    this.configElements = this.defaultConfigElements({});
  }
  fx(app, file, tools, input) {
    if (String.isString(input)) {
      return input.toUpperCase();
    } else if (Array.isArray(input)) {
      return input.map((item) => String(item).toUpperCase());
    } else if (input instanceof Date) {
      return input.toISOString().toUpperCase();
    } else if (typeof input === "object") {
      return JSON.stringify(input).toUpperCase();
    }
    return input;
  }
};

// src/rules/index.ts
var ruleClasses = [RuleAddPrefix, RuleAddSuffix, RuleAutomationAutoLink, RuleBuildInAutoCompleteModal, RuleBuildInConcatProperties, RuleBuildInConstant, RuleBuildInDateTimeCreated, RuleBuildInDateTimeModified, RuleBuildInDefault, RuleBuildInFileSizeBytes, RuleBuildInFileSizeString, RuleBuildInFolder, RuleBuildInFolderFolderNotes, RuleBuildInFolders, RuleBuildInFullPath, RuleBuildInFullPathExt, RuleBuildInFullPathExtFolderNotes, RuleBuildInFullPathFolderNotes, RuleBuildInGetProperties, RuleBuildInGetProperty, RuleBuildInIsRoot, RuleBuildInLinkToFile, RuleBuildInName, RuleBuildInNameExt, RuleBuildInPath, RuleBuildInPathFolderNotes, RuleBuildInRootFolder, RuleBuildInScript, RuleReplaceChars, RuleReplaceSpaces, RuleReplaceSpecialChars, RuleToCamelCase, RuleToLinkMarkdown, RuleToLinkOriginal, RuleToLinkSimple, RuleToLinkWiki, RuleToLowerCase, RuleToOriginal, RuleToPascalCase, RuleToTitleCase, RuleToTitleCaseDE, RuleToTitleCaseEN, RuleToUpperCase];
ruleClasses.forEach((RuleClass) => {
  const ruleInstance = new RuleClass();
  rulesManager.registerRule(ruleInstance);
});

// main.ts
var FolderTagPlugin = class extends import_obsidian30.Plugin {
  constructor() {
    super(...arguments);
    this.fileInProgress = null;
    // Track the file currently being processed
    this.preventOnMetadataChange = false;
  }
  // Prevent metadata change events from triggering updates
  //private oldFolderPaths = new Map<string, string | null>();
  async onload() {
    await this.loadSettings();
    logger.log(INFO, `Front Matter Automate ${this.manifest.version} loaded with settings: `, this.settings);
    logger.setLevel(this.settings.debugLevel);
    this.tools = new ScriptingTools(this.app, this);
    rulesManager.init(this.app, this, this.tools);
    let noticeMessage = `Front Matter Automate ${this.manifest.version}
 loading ...`;
    const loadingNotice = new import_obsidian30.Notice(noticeMessage, 0);
    noticeMessage = noticeMessage + "\n register events ...";
    loadingNotice.setMessage(noticeMessage);
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        logger.log(DEBUG, `Event creating file: ${file.path} starting in ${this.settings.delayCreateEvent}ms`);
        if (file instanceof import_obsidian30.TFile && file.extension === "md") {
          this.fileInProgress = file;
          setTimeout(
            () => {
              logger.log(DEBUG, `Event creating file started: `, file.path);
              this.preventOnMetadataChange = true;
              this.updateFrontmatterParameters("create", file, this.settings.folderConfig);
              this.preventOnMetadataChange = false;
              this.fileInProgress = null;
            },
            this.settings.delayCreateEvent
          );
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => {
        if (this.fileInProgress)
          return;
        this.preventOnMetadataChange = true;
        if (file instanceof import_obsidian30.TFile && file.extension === "md") {
          this.updateFrontmatterParameters("rename", file, this.settings.folderConfig, oldPath);
        }
        this.preventOnMetadataChange = false;
      })
    );
    this.registerEvent(
      this.app.metadataCache.on("changed", async (file, data, cache) => {
        if (this.preventOnMetadataChange)
          return;
        if (this.fileInProgress)
          return;
        if (!checkIfFileAllowed(file, this.settings)) {
          logger.log(DEBUG, `file ${file.path} globally rejected!`);
          return;
        }
        if (!(file instanceof import_obsidian30.TFile) || file.extension !== "md") {
          logger.log(DEBUG, `Event metadata changed: ${file.path} not a markdown file!`);
          return;
        }
        this.preventOnMetadataChange = true;
        if (file)
          this.updateFrontmatterParameters("metadata-changed", file, this.settings.folderConfig);
        this.preventOnMetadataChange = false;
      })
    );
    noticeMessage = noticeMessage + "\n initial processing ...";
    loadingNotice.setMessage(noticeMessage);
    noticeMessage = noticeMessage + "\ndone!";
    loadingNotice.setMessage(noticeMessage);
    setTimeout(() => {
      loadingNotice.hide();
    }, 2e3);
    this.addSettingTab(new FolderTagSettingTab(this.app, this));
  }
  async loadSettings() {
    let data = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_FRONTMATTER_AUTOMATE_SETTINGS, data);
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  formatTagName(name) {
    if (name === null)
      return null;
    if (name === void 0)
      return void 0;
    let formatted = name.replace(/\s+/g, this.settings.spaceReplacement);
    formatted = formatted.replace(/[^a-zA-Z0-9\-_\/äöüßÄÖÜáéíóúýÁÉÍÓÚÝàèìòùÀÈÌÒÙâêîôûÂÊÎÔÛãñõÃÑÕ]/g, this.settings.specialCharReplacement);
    if (this.settings.lowercaseTags) {
      formatted = formatted.toLowerCase();
    }
    return formatted;
  }
  formatValue(value, type) {
    switch (type) {
      case "text":
      case "tags":
      case "aliases":
      case "multitext":
        return this.tools.toYamlSafeString(value);
      case "date":
      case "datetime":
        if (typeof value === "number") {
          return new Date(value).toISOString();
        }
        return value.toString();
      case "checkbox":
        return value ? "true" : "false";
      case "number":
        return Number(value);
      default:
        return this.tools.toYamlSafeString(value);
    }
  }
  updateFrontmatterParameters(eventName, file, ruleSettings, oldPath) {
    var _a;
    if (!checkIfFileAllowed(file, this.settings)) {
      logger.log(DEBUG, `file ${file.path} globally rejected!`);
      return;
    }
    const currentPathTag = this.formatTagName(this.tools.getFolderFromPath(file.path));
    const oldPathTag = this.formatTagName(this.tools.getFolderFromPath(oldPath));
    const rules = (_a = ruleSettings == null ? void 0 : ruleSettings.rows.flatMap((row) => {
      if (row.folderId) {
        const folder = ruleSettings.folders.find((folder2) => folder2.id === row.folderId);
        if (!folder) {
          row.folderId = void 0;
          logger.log(ERROR, `Event ${eventName}: Folder with id ${row.folderId} not found for rule ${row.payload.content}!`);
          return [row.payload];
        }
        return !folder.disabled ? [row.payload] : [];
      }
      return [row.payload];
    })) != null ? _a : [];
    if (!rules || rules.length === 0) {
      logger.log(DEBUG, `Event ${eventName}: No rules found for file ${file.path}`);
      return;
    }
    this.app.fileManager.processFrontMatter(file, (frontmatter) => {
      var _a2;
      logger.groupCollapsed(DEBUG, `Event ${eventName}: "${file.path}" ${rules.length}/${ruleSettings == null ? void 0 : ruleSettings.rows.length} active rules. Old file: "${oldPath}"`, frontmatter);
      let oldLocationResults = [];
      if (oldPath && oldPath !== file.path) {
        logger.groupCollapsed(DEBUG, `Event ${eventName}: Collecting results for old file path: "${oldPath}"`);
        for (let rule of rules) {
          if (!rule)
            continue;
          let result = executeRuleObject(eventName, this.app, this, this.settings, this.tools.getMockFileFromPath(oldPath), frontmatter[rule.property], rule, frontmatter);
          oldLocationResults.push({ ruleId: rule.id, result });
        }
        logger.log(DEBUG, `Old file path results:`, oldLocationResults);
        logger.groupEnd();
      }
      for (let rule of rules) {
        if (!rule)
          continue;
        let result = frontmatter[rule.property];
        logger.groupCollapsed(DEBUG, `Execute Rule: ${rule.property}(${rule.content})`, result, rule);
        if (!checkIfFileAllowed(file, this.settings, rule)) {
          logger.log(DEBUG, `file ${file.path} rejected by rule (${rule.property}|${rule.content}) settings`);
          logger.groupEnd();
          continue;
        }
        if (rule.onlyModify && !frontmatter.hasOwnProperty(rule.property)) {
          logger.log(DEBUG, `file "${file.path}" has not "${rule.property}"(Rule:${rule.content}) onlyModify set: skipped`);
          logger.groupEnd();
          continue;
        }
        switch ((_a2 = rulesManager.getRuleById(rule.content)) == null ? void 0 : _a2.ruleType) {
          case "buildIn":
          case "script":
          case "automation":
            result = executeRuleObject(eventName, this.app, this, this.settings, file, frontmatter[rule.property], rule, frontmatter, oldLocationResults);
            break;
          default:
        }
        frontmatter[rule.property] = result;
        logger.groupEnd();
      }
      logger.log(DEBUG, "Frontmatter updated", frontmatter);
      logger.groupEnd();
    }, { "mtime": file.stat.mtime });
  }
  /*
      async removeFrontmatterParamsFromAllFiles(rule: FrontmatterAutomateRuleSettings){
          let count = {files:0, items: 0}
          this.app.vault.getMarkdownFiles().forEach(file => {
              count.files++;
              this.removeFrontmatterParameter(file, rule, count);
          });
          return count;
      }
  
      async removeFrontmatterParameter(file: TFile, rule: FrontmatterAutomateRuleSettings, count) {
          if (!checkIfFileAllowed(file, this.settings, rule)) return;
          const currentPathTag = this.formatTagName(this.tools.getFolderFromPath(file.path));
          let content = await this.app.vault.read(file);
          this.app.fileManager.processFrontMatter(file, (frontmatter) => {
              if (Array.isArray(frontmatter[rule.property])) count.items += frontmatter[rule.property].length;
              frontmatter[rule.property] = removeRule(this.app, this.settings, file, frontmatter[rule.property], rule, frontmatter);
              if (Array.isArray(frontmatter[rule.property])) count.items -= frontmatter[rule.property].length;
          },{'mtime':file.stat.mtime}); // do not change the modify time.
          return count;
      }
      */
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJzcmMvc2V0dGluZ3MudHMiLCAic3JjL2Zyb250bWF0dGVyLXRvb2xzLnRzIiwgInNyYy9Mb2cudHMiLCAic3JjL0Vycm9yLnRzIiwgInNyYy90b29scy50cyIsICJzcmMvYWxlcnRCb3gudHMiLCAic3JjL3J1bGVzL3J1bGVzLnRzIiwgInNyYy9kaXJlY3RvcnlTZWxlY3Rpb25Nb2RhbC50cyIsICJzcmMvc2V0dGluZ3MtcHJvcGVydGllcy50cyIsICJzcmMvdHlwZXMudHMiLCAic3JjL3J1bGVzLnRzIiwgInNyYy9lZGl0b3JNb2RhbC50cyIsICJzcmMvdWlFbGVtZW50cy50cyIsICJzcmMvdWlNdWx0aVByb3BlcnR5U2V0dGluZy50cyIsICJzcmMvdWlUcmVlSGllcmFyY2h5U29ydGFibGVTZXR0aW5ncy50cyIsICJzcmMvdWlNYXJrZG93bkhlbHBNb2RhbC50cyIsICJzcmMvcnVsZXMvYWRkUHJlZml4LnRzIiwgInNyYy9ydWxlcy9hZGRTdWZmaXgudHMiLCAic3JjL3J1bGVzL2F1dG9tYXRpb25BdXRvTGluay50cyIsICJzcmMvc3VnZ2VzdGVycy9Gb2xkZXJTdWdnZXN0ZXIudHMiLCAic3JjL3N1Z2dlc3RlcnMvc3VnZ2VzdC50cyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2VudW1zLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvdy5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21hdGguanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy91c2VyQWdlbnQuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNMYXlvdXRWaWV3cG9ydC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9jb250YWlucy5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzVGFibGVFbGVtZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRQYXJlbnROb2RlLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3dpdGhpbi5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcnJvdy5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldFZhcmlhdGlvbi5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGwuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsQmFyWC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRWaWV3cG9ydFJlY3QuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRSZWN0LmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzU2Nyb2xsUGFyZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFNjcm9sbFBhcmVudC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZU9mZnNldHMuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZXRlY3RPdmVyZmxvdy5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2ZsaXAuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaGlkZS5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9vZmZzZXQuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEFsdEF4aXMuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVTY3JvbGwuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzIiwgIm5vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGVib3VuY2UuanMiLCAibm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZUJ5TmFtZS5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2NyZWF0ZVBvcHBlci5qcyIsICJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3BvcHBlci5qcyIsICJzcmMvc3VnZ2VzdGVycy9GaWxlU3VnZ2VzdGVyLnRzIiwgInNyYy9ydWxlcy9idWlsZEluQXV0b0NvbXBsZXRlTW9kYWwudHMiLCAic3JjL2F1dG9jb21wbGV0ZU1vZGFsLnRzIiwgInNyYy9ydWxlcy9idWlsZEluQ29uY2F0UHJvcGVydGllcy50cyIsICJzcmMvcnVsZXMvYnVpbGRJbkNvbnN0YW50LnRzIiwgInNyYy9ydWxlcy9idWlsZEluRGF0ZVRpbWVDcmVhdGVkLnRzIiwgInNyYy9ydWxlcy9idWlsZEluRGF0ZVRpbWVNb2RpZmllZC50cyIsICJzcmMvcnVsZXMvYnVpbGRJbkRlZmF1bHQudHMiLCAic3JjL3J1bGVzL2J1aWxkSW5GaWxlU2l6ZUJ5dGVzLnRzIiwgInNyYy9ydWxlcy9idWlsZEluRmlsZVNpemVTdHJpbmcudHMiLCAic3JjL3J1bGVzL2J1aWxkSW5Gb2xkZXIudHMiLCAic3JjL3J1bGVzL2J1aWxkSW5Gb2xkZXJGb2xkZXJOb3Rlcy50cyIsICJzcmMvcnVsZXMvYnVpbGRJbkZvbGRlcnMudHMiLCAic3JjL3J1bGVzL2J1aWxkSW5GdWxsUGF0aC50cyIsICJzcmMvcnVsZXMvYnVpbGRJbkZ1bGxQYXRoRXh0LnRzIiwgInNyYy9ydWxlcy9idWlsZEluRnVsbFBhdGhFeHRGb2xkZXJOb3Rlcy50cyIsICJzcmMvcnVsZXMvYnVpbGRJbkZ1bGxQYXRoRm9sZGVyTm90ZXMudHMiLCAic3JjL3J1bGVzL2J1aWxkSW5HZXRQcm9wZXJ0aWVzLnRzIiwgInNyYy9ydWxlcy9idWlsZEluR2V0UHJvcGVydHkudHMiLCAic3JjL3J1bGVzL2J1aWxkSW5Jc1Jvb3QudHMiLCAic3JjL3J1bGVzL2J1aWxkSW5MaW5rVG9GaWxlLnRzIiwgInNyYy9ydWxlcy9idWlsZEluTmFtZS50cyIsICJzcmMvcnVsZXMvYnVpbGRJbk5hbWVFeHQudHMiLCAic3JjL3J1bGVzL2J1aWxkSW5QYXRoLnRzIiwgInNyYy9ydWxlcy9idWlsZEluUGF0aEZvbGRlck5vdGVzLnRzIiwgInNyYy9ydWxlcy9idWlsZEluUm9vdEZvbGRlci50cyIsICJzcmMvcnVsZXMvYnVpbGRJblNjcmlwdC50cyIsICJzcmMvcnVsZXMvcmVwbGFjZUNoYXJzLnRzIiwgInNyYy9ydWxlcy9yZXBsYWNlU3BhY2VzLnRzIiwgInNyYy9ydWxlcy9yZXBsYWNlU3BlY2lhbENoYXJzLnRzIiwgInNyYy9ydWxlcy90b0NhbWVsQ2FzZS50cyIsICJzcmMvcnVsZXMvdG9MaW5rTWFya2Rvd24udHMiLCAic3JjL3J1bGVzL3RvTGlua09yaWdpbmFsLnRzIiwgInNyYy9ydWxlcy90b0xpbmtTaW1wbGUudHMiLCAic3JjL3J1bGVzL3RvTGlua1dpa2kudHMiLCAic3JjL3J1bGVzL3RvTG93ZXJDYXNlLnRzIiwgInNyYy9ydWxlcy90b09yaWdpbmFsLnRzIiwgInNyYy9ydWxlcy90b1Bhc2NhbENhc2UudHMiLCAic3JjL3J1bGVzL3RvVGl0bGVDYXNlLnRzIiwgInNyYy9ydWxlcy90b1RpdGxlQ2FzZURFLnRzIiwgInNyYy9ydWxlcy90b1RpdGxlQ2FzZUVOLnRzIiwgInNyYy9ydWxlcy90b1VwcGVyQ2FzZS50cyIsICJzcmMvcnVsZXMvaW5kZXgudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImltcG9ydCB7IEFwcCwgRWRpdG9yLCBQbHVnaW4sIE1hcmtkb3duVmlldywgTWFya2Rvd25Qb3N0UHJvY2Vzc29yLCBQbHVnaW5NYW5pZmVzdCwgVEZpbGUsIFRGb2xkZXIsIFZhdWx0LCBwYXJzZUZyb250TWF0dGVyVGFncywgTm90aWNlfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBGb2xkZXJUYWdTZXR0aW5nVGFiIH0gZnJvbSAnLi9zcmMvc2V0dGluZ3MnO1xuLy9pbXBvcnQgeyBGb2xkZXJUYWdTZXR0aW5nVGFiIH0gZnJvbSAnLi9zcmMvc2V0dGluZ3MtcHJvcGVydGllcyc7XG5pbXBvcnQgeyBjaGVja0lmRmlsZUFsbG93ZWQsIGV4ZWN1dGVSdWxlT2JqZWN0IH0gZnJvbSAnLi9zcmMvcnVsZXMnO1xuaW1wb3J0IHsgcGFyc2VKU0NvZGUsIFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSAnLi9zcmMvdG9vbHMnO1xuaW1wb3J0IHsgdmVyc2lvblN0cmluZywgRnJvbnRtYXR0ZXJBdXRvbWF0ZVNldHRpbmdzLCBERUZBVUxUX0ZST05UTUFUVEVSX0FVVE9NQVRFX1NFVFRJTkdTLCBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCBQcm9wZXJ0eVR5cGVJbmZvfSBmcm9tICcuL3NyYy90eXBlcydcbmltcG9ydCBcIi4vc3JjL3J1bGVzL2luZGV4XCI7XG5pbXBvcnQgeyBydWxlc01hbmFnZXIgfSBmcm9tICcuL3NyYy9ydWxlcy9ydWxlcyc7XG5pbXBvcnQgeyBERUJVRywgRVJST1IsIElORk8sIGxvZ2dlciB9IGZyb20gJy4vc3JjL0xvZyc7XG5pbXBvcnQgeyBsb2cgfSBmcm9tICdjb25zb2xlJztcbmltcG9ydCB7IFRyZWVIaWVyYXJjaHlEYXRhIH0gZnJvbSAnLi9zcmMvdWlUcmVlSGllcmFyY2h5U29ydGFibGVTZXR0aW5ncyc7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGb2xkZXJUYWdQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuICAgIHNldHRpbmdzITogRnJvbnRtYXR0ZXJBdXRvbWF0ZVNldHRpbmdzO1xuICAgIHByaXZhdGUgdG9vbHMhOiBTY3JpcHRpbmdUb29scztcbiAgICBmaWxlSW5Qcm9ncmVzczogVEZpbGUgfCBudWxsID0gbnVsbDsgLy8gVHJhY2sgdGhlIGZpbGUgY3VycmVudGx5IGJlaW5nIHByb2Nlc3NlZFxuICAgIHByZXZlbnRPbk1ldGFkYXRhQ2hhbmdlOiBib29sZWFuID0gZmFsc2U7IC8vIFByZXZlbnQgbWV0YWRhdGEgY2hhbmdlIGV2ZW50cyBmcm9tIHRyaWdnZXJpbmcgdXBkYXRlc1xuICAgIC8vcHJpdmF0ZSBvbGRGb2xkZXJQYXRocyA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmcgfCBudWxsPigpO1xuXG4gICAgYXN5bmMgb25sb2FkKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuICAgICAgICBsb2dnZXIubG9nKElORk8sYEZyb250IE1hdHRlciBBdXRvbWF0ZSAke3RoaXMubWFuaWZlc3QudmVyc2lvbn0gbG9hZGVkIHdpdGggc2V0dGluZ3M6IGAsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICBsb2dnZXIuc2V0TGV2ZWwodGhpcy5zZXR0aW5ncy5kZWJ1Z0xldmVsKTtcbiAgICAgICAgdGhpcy50b29scyA9IG5ldyBTY3JpcHRpbmdUb29scyh0aGlzLmFwcCwgdGhpcyk7XG4gICAgICAgIHJ1bGVzTWFuYWdlci5pbml0KHRoaXMuYXBwLCB0aGlzLCB0aGlzLnRvb2xzKTtcbiAgICAgICAgbGV0IG5vdGljZU1lc3NhZ2UgPSBgRnJvbnQgTWF0dGVyIEF1dG9tYXRlICR7dGhpcy5tYW5pZmVzdC52ZXJzaW9ufVxcbiBsb2FkaW5nIC4uLmA7XG4gICAgICAgIGNvbnN0IGxvYWRpbmdOb3RpY2UgPSBuZXcgTm90aWNlKG5vdGljZU1lc3NhZ2UsMClcblxuICAgICAgICBub3RpY2VNZXNzYWdlID0gbm90aWNlTWVzc2FnZSArICdcXG4gcmVnaXN0ZXIgZXZlbnRzIC4uLic7XG4gICAgICAgIGxvYWRpbmdOb3RpY2Uuc2V0TWVzc2FnZShub3RpY2VNZXNzYWdlKTtcbiAgICAgICAgLy8gRmlsZSBjcmVhdGlvbiBoYW5kbGVyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJFdmVudChcbiAgICAgICAgICAgIHRoaXMuYXBwLnZhdWx0Lm9uKCdjcmVhdGUnLCAoZmlsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coREVCVUcsYEV2ZW50IGNyZWF0aW5nIGZpbGU6ICR7ZmlsZS5wYXRofSBzdGFydGluZyBpbiAke3RoaXMuc2V0dGluZ3MuZGVsYXlDcmVhdGVFdmVudH1tc2ApO1xuICAgICAgICAgICAgICAgIGlmIChmaWxlIGluc3RhbmNlb2YgVEZpbGUgJiYgZmlsZS5leHRlbnNpb24gPT09ICdtZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWxlSW5Qcm9ncmVzcyA9IGZpbGU7IC8vIFNldCB0aGUgZmlsZSBpbiBwcm9ncmVzc1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coREVCVUcsYEV2ZW50IGNyZWF0aW5nIGZpbGUgc3RhcnRlZDogYCwgZmlsZS5wYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJldmVudE9uTWV0YWRhdGFDaGFuZ2UgPSB0cnVlOyAvLyBQcmV2ZW50IGZ1cnRoZXIgbWV0YWRhdGEgY2hhbmdlIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVGcm9udG1hdHRlclBhcmFtZXRlcnMoJ2NyZWF0ZScsIGZpbGUsIHRoaXMuc2V0dGluZ3MuZm9sZGVyQ29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJldmVudE9uTWV0YWRhdGFDaGFuZ2UgPSBmYWxzZTsgLy8gQWxsb3cgZnVydGhlciBtZXRhZGF0YSBjaGFuZ2UgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbGVJblByb2dyZXNzID0gbnVsbDsgLy8gQ2xlYXIgdGhlIGZpbGUgaW4gcHJvZ3Jlc3MgYWZ0ZXIgcHJvY2Vzc2luZ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICwgdGhpcy5zZXR0aW5ncy5kZWxheUNyZWF0ZUV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEZpbGUgcmVuYW1lL21vdmUgaGFuZGxlclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRXZlbnQoXG4gICAgICAgICAgICB0aGlzLmFwcC52YXVsdC5vbigncmVuYW1lJywgKGZpbGUsIG9sZFBhdGgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maWxlSW5Qcm9ncmVzcykgcmV0dXJuOyAvLyBJZ25vcmUgaWYgZmlsZSBpcyBpbiBwcm9ncmVzc1xuICAgICAgICAgICAgICAgIHRoaXMucHJldmVudE9uTWV0YWRhdGFDaGFuZ2UgPSB0cnVlOyAvLyBQcmV2ZW50IGZ1cnRoZXIgbWV0YWRhdGEgY2hhbmdlIGV2ZW50c1xuICAgICAgICAgICAgICAgIGlmIChmaWxlIGluc3RhbmNlb2YgVEZpbGUgJiYgZmlsZS5leHRlbnNpb24gPT09ICdtZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVGcm9udG1hdHRlclBhcmFtZXRlcnMoJ3JlbmFtZScsIGZpbGUsIHRoaXMuc2V0dGluZ3MuZm9sZGVyQ29uZmlnLCBvbGRQYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2ZW50T25NZXRhZGF0YUNoYW5nZSA9IGZhbHNlOyAvLyBBbGxvdyBmdXJ0aGVyIG1ldGFkYXRhIGNoYW5nZSBldmVudHNcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gRmlsZSBjbG9zZSBoYW5kbGVyXG4gICAgICAgIC8qXG4gICAgICAgIHRoaXMucmVnaXN0ZXJFdmVudChcbiAgICAgICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5vbignYWN0aXZlLWxlYWYtY2hhbmdlJywgKGxlYWYpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobGVhZj8udmlldyBpbnN0YW5jZW9mIE1hcmtkb3duVmlldykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY3RpdmVGaWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhERUJVRyxgRXZlbnQgYWN0aXZlLWxlYWYtY2hhbmdlIGZpbGU6IGAsIGFjdGl2ZUZpbGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlRmlsZSkgdGhpcy51cGRhdGVGcm9udG1hdHRlclBhcmFtZXRlcnMoJ2FjdGl2ZS1sZWFmLWNoYW5nZScsIGFjdGl2ZUZpbGUsIHRoaXMuc2V0dGluZ3MucnVsZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgICovXG4gICAgICAgIC8vIE1ldGFkYXRhIGNoYW5nZWQgaGFuZGxlclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRXZlbnQoXG4gICAgICAgICAgICB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLm9uKCdjaGFuZ2VkJywgYXN5bmMgKGZpbGUsIGRhdGEsIGNhY2hlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldmVudE9uTWV0YWRhdGFDaGFuZ2UpIHJldHVybjsgLy8gUHJldmVudCBwcm9jZXNzaW5nIGR1cmluZyBtZXRhZGF0YSBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlsZUluUHJvZ3Jlc3MpIHJldHVybjsgLy8gSWdub3JlIGlmIGZpbGUgaXMgaW4gcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrSWZGaWxlQWxsb3dlZChmaWxlLCB0aGlzLnNldHRpbmdzKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKERFQlVHLGBmaWxlICR7ZmlsZS5wYXRofSBnbG9iYWxseSByZWplY3RlZCFgKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkgfHwgZmlsZS5leHRlbnNpb24gIT09ICdtZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhERUJVRyxgRXZlbnQgbWV0YWRhdGEgY2hhbmdlZDogJHtmaWxlLnBhdGh9IG5vdCBhIG1hcmtkb3duIGZpbGUhYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2ZW50T25NZXRhZGF0YUNoYW5nZSA9IHRydWU7IC8vIFByZXZlbnQgZnVydGhlciBtZXRhZGF0YSBjaGFuZ2UgZXZlbnRzXG4gICAgICAgICAgICAgICAgaWYgKGZpbGUpIHRoaXMudXBkYXRlRnJvbnRtYXR0ZXJQYXJhbWV0ZXJzKCdtZXRhZGF0YS1jaGFuZ2VkJywgZmlsZSwgdGhpcy5zZXR0aW5ncy5mb2xkZXJDb25maWcpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJldmVudE9uTWV0YWRhdGFDaGFuZ2UgPSBmYWxzZTsgLy8gQWxsb3cgZnVydGhlciBtZXRhZGF0YSBjaGFuZ2UgZXZlbnRzXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICAgICAgXG4gICAgICAgIG5vdGljZU1lc3NhZ2UgPSBub3RpY2VNZXNzYWdlICsgJ1xcbiBpbml0aWFsIHByb2Nlc3NpbmcgLi4uJztcbiAgICAgICAgbG9hZGluZ05vdGljZS5zZXRNZXNzYWdlKG5vdGljZU1lc3NhZ2UpO1xuICAgICAgICBub3RpY2VNZXNzYWdlID0gbm90aWNlTWVzc2FnZSArICdcXG5kb25lISc7XG4gICAgICAgIGxvYWRpbmdOb3RpY2Uuc2V0TWVzc2FnZShub3RpY2VNZXNzYWdlKTtcbiAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgbG9hZGluZ05vdGljZS5oaWRlKCk7XG4gICAgICAgIH0sMjAwMClcblxuICAgICAgICAvLyBBZGQgc2V0dGluZ3MgdGFiXG4gICAgICAgIHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgRm9sZGVyVGFnU2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcykpO1xuICAgIH1cblxuICAgIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBhd2FpdCB0aGlzLmxvYWREYXRhKCk7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0ZST05UTUFUVEVSX0FVVE9NQVRFX1NFVFRJTkdTLCBkYXRhKTtcbiAgICB9XG4gICAgXG4gICAgYXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuICAgICAgICBhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZm9ybWF0VGFnTmFtZShuYW1lOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZHtcbiAgICAgICAgaWYgKG5hbWUgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBcbiAgICAgICAgLy8gRmlyc3QgcmVwbGFjZSBzcGFjZXMgYWNjb3JkaW5nIHRvIHNldHRpbmdzXG4gICAgICAgIGxldCBmb3JtYXR0ZWQgPSBuYW1lLnJlcGxhY2UoL1xccysvZywgdGhpcy5zZXR0aW5ncy5zcGFjZVJlcGxhY2VtZW50KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRoZW4gcmVwbGFjZSBzcGVjaWFsIGNoYXJhY3RlcnMgKHByZXNlcnZpbmcgbGV0dGVycyB3aXRoIGRpYWNyaXRpY3MpXG4gICAgICAgIGZvcm1hdHRlZCA9IGZvcm1hdHRlZC5yZXBsYWNlKC9bXmEtekEtWjAtOVxcLV9cXC9cdTAwRTRcdTAwRjZcdTAwRkNcdTAwREZcdTAwQzRcdTAwRDZcdTAwRENcdTAwRTFcdTAwRTlcdTAwRURcdTAwRjNcdTAwRkFcdTAwRkRcdTAwQzFcdTAwQzlcdTAwQ0RcdTAwRDNcdTAwREFcdTAwRERcdTAwRTBcdTAwRThcdTAwRUNcdTAwRjJcdTAwRjlcdTAwQzBcdTAwQzhcdTAwQ0NcdTAwRDJcdTAwRDlcdTAwRTJcdTAwRUFcdTAwRUVcdTAwRjRcdTAwRkJcdTAwQzJcdTAwQ0FcdTAwQ0VcdTAwRDRcdTAwREJcdTAwRTNcdTAwRjFcdTAwRjVcdTAwQzNcdTAwRDFcdTAwRDVdL2csIHRoaXMuc2V0dGluZ3Muc3BlY2lhbENoYXJSZXBsYWNlbWVudCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDb252ZXJ0IHRvIGxvd2VyY2FzZSBpZiBjb25maWd1cmVkXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmxvd2VyY2FzZVRhZ3MpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZCA9IGZvcm1hdHRlZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkO1xuICAgIH1cblxuICAgIGZvcm1hdFZhbHVlKHZhbHVlOmFueSwgdHlwZTpzdHJpbmcpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgIGNhc2UgJ3RhZ3MnOlxuICAgICAgICAgICAgY2FzZSAnYWxpYXNlcyc6XG4gICAgICAgICAgICBjYXNlICdtdWx0aXRleHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvb2xzLnRvWWFtbFNhZmVTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICBjYXNlICdkYXRldGltZSc6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9vbHMudG9ZYW1sU2FmZVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVGcm9udG1hdHRlclBhcmFtZXRlcnMoZXZlbnROYW1lOiAnY3JlYXRlJyB8ICdyZW5hbWUnIHwgJ2FjdGl2ZS1sZWFmLWNoYW5nZScgfCAnbWV0YWRhdGEtY2hhbmdlZCcsIGZpbGU6IFRGaWxlLCBydWxlU2V0dGluZ3M6IFRyZWVIaWVyYXJjaHlEYXRhLCBvbGRQYXRoPzogc3RyaW5nKSB7XG4gICAgICAgIGlmICghY2hlY2tJZkZpbGVBbGxvd2VkKGZpbGUsIHRoaXMuc2V0dGluZ3MpKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKERFQlVHLGBmaWxlICR7ZmlsZS5wYXRofSBnbG9iYWxseSByZWplY3RlZCFgKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQYXRoVGFnID0gdGhpcy5mb3JtYXRUYWdOYW1lKHRoaXMudG9vbHMuZ2V0Rm9sZGVyRnJvbVBhdGgoZmlsZS5wYXRoKSk7XG4gICAgICAgIGNvbnN0IG9sZFBhdGhUYWcgPSB0aGlzLmZvcm1hdFRhZ05hbWUodGhpcy50b29scy5nZXRGb2xkZXJGcm9tUGF0aChvbGRQYXRoKSlcbiAgICAgICAgY29uc3QgcnVsZXMgPSBydWxlU2V0dGluZ3M/LnJvd3MuZmxhdE1hcCgocm93KSA9PiB7XG4gICAgICAgICAgICBpZiAocm93LmZvbGRlcklkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9sZGVyID0gcnVsZVNldHRpbmdzLmZvbGRlcnMuZmluZCgoZm9sZGVyKSA9PiBmb2xkZXIuaWQgPT09IHJvdy5mb2xkZXJJZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFmb2xkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93LmZvbGRlcklkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKEVSUk9SLGBFdmVudCAke2V2ZW50TmFtZX06IEZvbGRlciB3aXRoIGlkICR7cm93LmZvbGRlcklkfSBub3QgZm91bmQgZm9yIHJ1bGUgJHtyb3cucGF5bG9hZC5jb250ZW50fSFgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtyb3cucGF5bG9hZCBhcyBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICFmb2xkZXIuZGlzYWJsZWQgPyBbcm93LnBheWxvYWQgYXMgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5nc10gOiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbcm93LnBheWxvYWQgYXMgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5nc107XG4gICAgICAgIH0pID8/IFtdO1xuICAgICAgICBpZiAoIXJ1bGVzIHx8IHJ1bGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhERUJVRyxgRXZlbnQgJHtldmVudE5hbWV9OiBObyBydWxlcyBmb3VuZCBmb3IgZmlsZSAke2ZpbGUucGF0aH1gKTtcbiAgICAgICAgICAgIHJldHVybjsgLy8gTm8gcnVsZXMgdG8gYXBwbHlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYXBwLmZpbGVNYW5hZ2VyLnByb2Nlc3NGcm9udE1hdHRlcihmaWxlLCAoZnJvbnRtYXR0ZXIpID0+IHtcbiAgICAgICAgICAgIC8vIGFwcGx5IGFsbCBydWxlcyB0byBmcm9udG1hdHRlclxuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKERFQlVHLGBFdmVudCAke2V2ZW50TmFtZX06IFwiJHtmaWxlLnBhdGh9XCIgJHtydWxlcy5sZW5ndGh9LyR7cnVsZVNldHRpbmdzPy5yb3dzLmxlbmd0aH0gYWN0aXZlIHJ1bGVzLiBPbGQgZmlsZTogXCIke29sZFBhdGh9XCJgLGZyb250bWF0dGVyKTtcbiAgICAgICAgICAgIGxldCBvbGRMb2NhdGlvblJlc3VsdHM6IHtydWxlSWQ6IHN0cmluZywgcmVzdWx0OiBhbnl9W10gPSBbXTtcblxuICAgICAgICAgICAgaWYgKG9sZFBhdGggJiYgb2xkUGF0aCAhPT0gZmlsZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKERFQlVHLGBFdmVudCAke2V2ZW50TmFtZX06IENvbGxlY3RpbmcgcmVzdWx0cyBmb3Igb2xkIGZpbGUgcGF0aDogXCIke29sZFBhdGh9XCJgKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBydWxlIG9mIHJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcnVsZSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBleGVjdXRlUnVsZU9iamVjdChldmVudE5hbWUsIHRoaXMuYXBwLCB0aGlzLCB0aGlzLnNldHRpbmdzLCB0aGlzLnRvb2xzLmdldE1vY2tGaWxlRnJvbVBhdGgob2xkUGF0aCksIGZyb250bWF0dGVyW3J1bGUucHJvcGVydHldLCBydWxlLCBmcm9udG1hdHRlcik7XG4gICAgICAgICAgICAgICAgICAgIG9sZExvY2F0aW9uUmVzdWx0cy5wdXNoKHsgcnVsZUlkOiBydWxlLmlkLCByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coREVCVUcsYE9sZCBmaWxlIHBhdGggcmVzdWx0czpgLCBvbGRMb2NhdGlvblJlc3VsdHMpO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgcnVsZSBvZiBydWxlcykge1xuICAgICAgICAgICAgICAgIGlmICghcnVsZSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGZyb250bWF0dGVyW3J1bGUucHJvcGVydHldO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChERUJVRyxgRXhlY3V0ZSBSdWxlOiAke3J1bGUucHJvcGVydHl9KCR7cnVsZS5jb250ZW50fSlgLHJlc3VsdCwgcnVsZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGVja0lmRmlsZUFsbG93ZWQoZmlsZSwgdGhpcy5zZXR0aW5ncywgcnVsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhERUJVRyxgZmlsZSAke2ZpbGUucGF0aH0gcmVqZWN0ZWQgYnkgcnVsZSAoJHtydWxlLnByb3BlcnR5fXwke3J1bGUuY29udGVudH0pIHNldHRpbmdzYCk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gb25seSBtb2RpZnkgaWYgZmlsZSBpcyBhbGxvd2VkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChydWxlLm9ubHlNb2RpZnkgJiYgIWZyb250bWF0dGVyLmhhc093blByb3BlcnR5KHJ1bGUucHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coREVCVUcsYGZpbGUgXCIke2ZpbGUucGF0aH1cIiBoYXMgbm90IFwiJHtydWxlLnByb3BlcnR5fVwiKFJ1bGU6JHtydWxlLmNvbnRlbnR9KSBvbmx5TW9kaWZ5IHNldDogc2tpcHBlZGApO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIG9ubHkgbW9kaWZ5IGlmIHByb3BlcnR5IGV4aXN0c1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJ1bGVzTWFuYWdlci5nZXRSdWxlQnlJZChydWxlLmNvbnRlbnQpPy5ydWxlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdidWlsZEluJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2NyaXB0JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXV0b21hdGlvbic6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBleGVjdXRlUnVsZU9iamVjdChldmVudE5hbWUsIHRoaXMuYXBwLCB0aGlzLCB0aGlzLnNldHRpbmdzLCBmaWxlLCBmcm9udG1hdHRlcltydWxlLnByb3BlcnR5XSwgcnVsZSwgZnJvbnRtYXR0ZXIsIG9sZExvY2F0aW9uUmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnJvbnRtYXR0ZXJbcnVsZS5wcm9wZXJ0eV0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIubG9nKERFQlVHLCdGcm9udG1hdHRlciB1cGRhdGVkJyxmcm9udG1hdHRlcik7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgfSx7J210aW1lJzpmaWxlLnN0YXQubXRpbWV9KTsgLy8gZG8gbm90IGNoYW5nZSB0aGUgbW9kaWZ5IHRpbWUuXG4gICAgfVxuICAgIC8qXG4gICAgYXN5bmMgcmVtb3ZlRnJvbnRtYXR0ZXJQYXJhbXNGcm9tQWxsRmlsZXMocnVsZTogRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyl7XG4gICAgICAgIGxldCBjb3VudCA9IHtmaWxlczowLCBpdGVtczogMH1cbiAgICAgICAgdGhpcy5hcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICAgICAgICBjb3VudC5maWxlcysrO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVGcm9udG1hdHRlclBhcmFtZXRlcihmaWxlLCBydWxlLCBjb3VudCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuXG4gICAgYXN5bmMgcmVtb3ZlRnJvbnRtYXR0ZXJQYXJhbWV0ZXIoZmlsZTogVEZpbGUsIHJ1bGU6IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIGNvdW50KSB7XG4gICAgICAgIGlmICghY2hlY2tJZkZpbGVBbGxvd2VkKGZpbGUsIHRoaXMuc2V0dGluZ3MsIHJ1bGUpKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQYXRoVGFnID0gdGhpcy5mb3JtYXRUYWdOYW1lKHRoaXMudG9vbHMuZ2V0Rm9sZGVyRnJvbVBhdGgoZmlsZS5wYXRoKSk7XG4gICAgICAgIGxldCBjb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChmaWxlKTtcbiAgICAgICAgdGhpcy5hcHAuZmlsZU1hbmFnZXIucHJvY2Vzc0Zyb250TWF0dGVyKGZpbGUsIChmcm9udG1hdHRlcikgPT4ge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZnJvbnRtYXR0ZXJbcnVsZS5wcm9wZXJ0eV0pKSBjb3VudC5pdGVtcyArPSBmcm9udG1hdHRlcltydWxlLnByb3BlcnR5XS5sZW5ndGg7XG4gICAgICAgICAgICBmcm9udG1hdHRlcltydWxlLnByb3BlcnR5XSA9IHJlbW92ZVJ1bGUodGhpcy5hcHAsIHRoaXMuc2V0dGluZ3MsIGZpbGUsIGZyb250bWF0dGVyW3J1bGUucHJvcGVydHldLCBydWxlLCBmcm9udG1hdHRlcik7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmcm9udG1hdHRlcltydWxlLnByb3BlcnR5XSkpIGNvdW50Lml0ZW1zIC09IGZyb250bWF0dGVyW3J1bGUucHJvcGVydHldLmxlbmd0aDtcbiAgICAgICAgfSx7J210aW1lJzpmaWxlLnN0YXQubXRpbWV9KTsgLy8gZG8gbm90IGNoYW5nZSB0aGUgbW9kaWZ5IHRpbWUuXG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gICAgKi9cbn1cbiIsICJpbXBvcnQgeyBBcHAsIEJ1dHRvbkNvbXBvbmVudCwgRHJvcGRvd25Db21wb25lbnQsIE5vdGljZSwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZywgVGV4dENvbXBvbmVudCwgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCAqIGFzIGZtVG9vbHMgZnJvbSAnLi9mcm9udG1hdHRlci10b29scyc7XHJcbmltcG9ydCB7IHBhcnNlSlNDb2RlLCBTY3JpcHRpbmdUb29scyB9IGZyb20gJy4vdG9vbHMnO1xyXG5pbXBvcnQgeyB2ZXJzaW9uU3RyaW5nLCBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCBERUZBVUxUX1JVTEVfREVGSU5JVElPTiwgUHJvcGVydHlUeXBlSW5mbywgT2JzaWRpYW5Qcm9wZXJ0eVR5cGVzfSBmcm9tICcuL3R5cGVzJztcclxuaW1wb3J0IHsgQWxlcnRNb2RhbCB9IGZyb20gJy4vYWxlcnRCb3gnO1xyXG5pbXBvcnQgeyBvcGVuRGlyZWN0b3J5U2VsZWN0aW9uTW9kYWwsIERpcmVjdG9yeVNlbGVjdGlvblJlc3VsdCB9IGZyb20gJy4vZGlyZWN0b3J5U2VsZWN0aW9uTW9kYWwnO1xyXG5pbXBvcnQgeyByYW5kb21VVUlEIH0gZnJvbSAnY3J5cHRvJztcclxuaW1wb3J0IHsgUnVsZXNUYWJsZSB9IGZyb20gJy4vc2V0dGluZ3MtcHJvcGVydGllcyc7XHJcbmltcG9ydCB7IFNvcnRhYmxlTGlzdENvbXBvbmVudCB9IGZyb20gJy4vU29ydGFibGVMaXN0Q29tcG9uZW50JztcclxuaW1wb3J0IHsgcnVsZXNNYW5hZ2VyIH0gZnJvbSAnLi9ydWxlcy9ydWxlcyc7XHJcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4vTG9nJztcclxuaW1wb3J0IHsgbG9nIH0gZnJvbSAnY29uc29sZSc7XHJcbmltcG9ydCB7IE1hcmtkb3duSGVscE1vZGFsIH0gZnJvbSAnLi91aU1hcmtkb3duSGVscE1vZGFsJztcclxuXHJcbmV4cG9ydCBjbGFzcyBGb2xkZXJUYWdTZXR0aW5nVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XHJcbiAgICBwbHVnaW46IGFueTsgLy9Gb2xkZXJUYWdQbHVnaW47XHJcbiAgICBydWxlc0RpdiE6IEhUTUxEaXZFbGVtZW50O1xyXG4gICAgcnVsZXNDb250YWluZXIhOiBIVE1MRGl2RWxlbWVudDtcclxuICAgIHJ1bGVzQ29udHJvbCE6IEhUTUxEaXZFbGVtZW50O1xyXG4gICAga25vd25Qcm9wZXJ0aWVzITogUHJvcGVydHlUeXBlSW5mb1tdO1xyXG4gICAga25vd25UeXBlcyE6IGFueTtcclxuICAgIHNjcmlwdGluZ1Rvb2xzITogU2NyaXB0aW5nVG9vbHM7XHJcblxyXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogYW55IC8qRm9sZGVyVGFnUGx1Z2luKi8pIHtcclxuICAgICAgICBzdXBlcihhcHAsIHBsdWdpbik7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICAgICAgdGhpcy5zY3JpcHRpbmdUb29scyA9IG5ldyBTY3JpcHRpbmdUb29scyhhcHAsIHBsdWdpbik7XHJcbiAgICB9XHJcbiAgICBoaWRlKCk6IHZvaWQge1xyXG4gICAgICAgIC8vIHVwZGF0ZSBhY3RpdmUgZmlsZSBpZiBpdCBpcyBvcGVuXHJcbiAgICAgICAgY29uc3QgYWN0aXZlRmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XHJcbiAgICAgICAgaWYgKGFjdGl2ZUZpbGUgJiYgYWN0aXZlRmlsZS5leHRlbnNpb24gPT09ICdtZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4udXBkYXRlRnJvbnRtYXR0ZXJQYXJhbWV0ZXJzKCdhY3RpdmUtbGVhZi1jaGFuZ2UnLCBhY3RpdmVGaWxlLCB0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJDb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRpc3BsYXkoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5rbm93blByb3BlcnRpZXMgPSBmbVRvb2xzLmdldFByb3BlcnRpZXNGcm9tTWV0YWRhdGFNYW5hZ2VyKHRoaXMuYXBwKTtcclxuICAgICAgICB0aGlzLmtub3duVHlwZXMgPSBmbVRvb2xzLmdldFR5cGVzRnJvbU1ldGFkYXRhTWFuYWdlcih0aGlzLmFwcCk7XHJcbiAgICAgICAgY29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcclxuXHJcbiAgICAgICAgY29udGFpbmVyRWwuZW1wdHkoKTtcclxuXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKGBGcm9udCBtYXR0ZXIgYXV0b21hdGUgViR7dGhpcy5wbHVnaW4ubWFuaWZlc3QudmVyc2lvbn0gU2V0dGluZ3NgKVxyXG4gICAgICAgICAgICAuc2V0RGVzYyh0aGlzLnBsdWdpbi5tYW5pZmVzdC5kZXNjcmlwdGlvbilcclxuICAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAuc2V0SWNvbihcImNpcmNsZS1oZWxwXCIpXHJcbiAgICAgICAgICAgICAgICAuc2V0VG9vbHRpcChcIk9ubGluZSBIZWxwXCIpXHJcbiAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hcmtkb3duID0gXCJDb3VsZCBub3QgbG9hZCBoZWxwIGZyb20gR2l0SHViLlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBNYXJrZG93bkhlbHBNb2RhbCh0aGlzLmFwcCwgdGhpcy5wbHVnaW4sIG1hcmtkb3duLCBcInJlYWRtZS5tZFwiKS5vcGVuKCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAuc2V0TmFtZSgnRXhjbHVkZSBGaWxlcyBhbmQgRm9sZGVycyBnbG9iYWxseScpXHJcbiAgICAgICAgLnNldERlc2MoYEN1cnJlbnRseSAke3RoaXMucGx1Z2luLnNldHRpbmdzLmV4Y2x1ZGUuc2VsZWN0ZWRGb2xkZXJzLmxlbmd0aH0gZm9sZGVycyBhbmQgJHt0aGlzLnBsdWdpbi5zZXR0aW5ncy5leGNsdWRlLnNlbGVjdGVkRmlsZXMubGVuZ3RofSBmaWxlcyB3aWxsIGJlICR7dGhpcy5wbHVnaW4uc2V0dGluZ3MuZXhjbHVkZS5tb2RlfWQuYClcclxuICAgICAgICAuYWRkQnV0dG9uKGJ1dHRvbiA9PiB7XHJcbiAgICAgICAgICAgIGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgLnNldEljb24oJ2ZvbGRlci14JylcclxuICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdFeGNsdWRlJylcclxuICAgICAgICAgICAgICAgIC5zZXRDdGEoKSAvLyBNYWtlcyB0aGUgYnV0dG9uIG1vcmUgcHJvbWluZW50XHJcbiAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlbkRpcmVjdG9yeVNlbGVjdGlvbk1vZGFsKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZXhjbHVkZS5zZWxlY3RlZEZvbGRlcnMgfHwgW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmV4Y2x1ZGUuc2VsZWN0ZWRGaWxlcyB8fCBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbk1vZGU6IHRoaXMucGx1Z2luLnNldHRpbmdzLmV4Y2x1ZGUubW9kZSB8fCAnZXhjbHVkZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TW9kZTogdGhpcy5wbHVnaW4uc2V0dGluZ3MuZXhjbHVkZS5kaXNwbGF5IHx8ICdmb2xkZXJzJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvblNlbGVjdGlvbk1vZGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uU2hvd0ZpbGVzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAocmVzdWx0OiBEaXJlY3RvcnlTZWxlY3Rpb25SZXN1bHQgfCBudWxsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZXhjbHVkZS5zZWxlY3RlZEZvbGRlcnMgPSByZXN1bHQuZm9sZGVycztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmV4Y2x1ZGUuc2VsZWN0ZWRGaWxlcyA9IHJlc3VsdC5maWxlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmV4Y2x1ZGUubW9kZSA9IHJlc3VsdC5tb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZXhjbHVkZS5kaXNwbGF5ID0gcmVzdWx0LmRpc3BsYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTsgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTsgIFxyXG5cclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAuc2V0TmFtZSgnSW5jbHVkZSBGaWxlcyBhbmQgRm9sZGVycyBnbG9iYWxseScpXHJcbiAgICAgICAgLnNldERlc2MoYEN1cnJlbnRseSAke3RoaXMucGx1Z2luLnNldHRpbmdzLmluY2x1ZGUuc2VsZWN0ZWRGb2xkZXJzLmxlbmd0aH0gZm9sZGVycyBhbmQgJHt0aGlzLnBsdWdpbi5zZXR0aW5ncy5pbmNsdWRlLnNlbGVjdGVkRmlsZXMubGVuZ3RofSBmaWxlcyB3aWxsIGJlICR7dGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5jbHVkZS5tb2RlfWQgZXZlbiBpZiB0aGV5IGFyZSBleGNsdWRlZC5gKVxyXG4gICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IHtcclxuICAgICAgICAgICAgYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAuc2V0SWNvbignZm9sZGVyLWNoZWNrJylcclxuICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdJbmNsdWRlJylcclxuICAgICAgICAgICAgICAgIC5zZXRDdGEoKSAvLyBNYWtlcyB0aGUgYnV0dG9uIG1vcmUgcHJvbWluZW50XHJcbiAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlbkRpcmVjdG9yeVNlbGVjdGlvbk1vZGFsKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5jbHVkZS5zZWxlY3RlZEZvbGRlcnMgfHwgW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmluY2x1ZGUuc2VsZWN0ZWRGaWxlcyB8fCBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbk1vZGU6IHRoaXMucGx1Z2luLnNldHRpbmdzLmluY2x1ZGUubW9kZSB8fCAnaW5jbHVkZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TW9kZTogdGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5jbHVkZS5kaXNwbGF5IHx8ICdmb2xkZXJzJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvblNlbGVjdGlvbk1vZGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uU2hvd0ZpbGVzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAocmVzdWx0OiBEaXJlY3RvcnlTZWxlY3Rpb25SZXN1bHQgfCBudWxsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5jbHVkZS5zZWxlY3RlZEZvbGRlcnMgPSByZXN1bHQuZm9sZGVycztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmluY2x1ZGUuc2VsZWN0ZWRGaWxlcyA9IHJlc3VsdC5maWxlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmluY2x1ZGUubW9kZSA9IHJlc3VsdC5tb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5jbHVkZS5kaXNwbGF5ID0gcmVzdWx0LmRpc3BsYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTsgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTsgICAgXHJcbiAgICAgICAgXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdEZWJ1ZycpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdTZWxlY3QgdGhlIGRlYnVnIGxldmVsIHRvIHNob3cgaW4gdGhlIGNvbnNvbGUnKVxyXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oKGRyb3Bkb3duOiBEcm9wZG93bkNvbXBvbmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZHJvcGRvd24uYWRkT3B0aW9ucyhcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZnJvbUVudHJpZXMobG9nZ2VyLmdldExldmVsTmFtZXMoKS5tYXAobGV2ZWwgPT4gW2xldmVsLCBsZXZlbF0pKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGRyb3Bkb3duLnNldFZhbHVlKGxvZ2dlci5nZXRMZXZlbE5hbWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZGVidWdMZXZlbCkpO1xyXG4gICAgICAgICAgICAgICAgZHJvcGRvd24ub25DaGFuZ2UoKHZhbHVlOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZWJ1Z0xldmVsID0gbG9nZ2VyLmdldExldmVsQnlOYW1lKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuc2V0TGV2ZWwodGhpcy5wbHVnaW4uc2V0dGluZ3MuZGVidWdMZXZlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9KVxyXG4gIFxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnRGVsYXkgY3JlYXRlIGV2ZW50ICh1bnRpbCBiZXR0ZXIgc29sdXRpb24gaXMgZm91bmQpJykgLy9UT0RPOiByZW1vdmUgdGhpcyBzZXR0aW5nIHdoZW4gYSBiZXR0ZXIgc29sdXRpb24gaXMgZm91bmRcclxuICAgICAgICAgICAgLnNldERlc2MoJ1NldCBhIGRlbGF5IGJlZm9yZSB0cmlnZ2VyaW5nIHRoZSBjcmVhdGUgZXZlbnQgdG8gYWxsb3cgZm9yIGZpbGUgY3JlYXRpb24gdG8gY29tcGxldGUuIChpbiBtaWxsaXNlY29uZHMpJylcclxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmRlbGF5Q3JlYXRlRXZlbnQudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICB0ZXh0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmRlbGF5Q3JlYXRlRXZlbnQgPSBwYXJzZUludCh2YWx1ZSkgfHwgMDsgLy8gRW5zdXJlIGl0J3MgYSBudW1iZXJcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnJ1bGVzQ29udGFpbmVyID0gY29udGFpbmVyRWwuY3JlYXRlRGl2KCdwcm9wZXJ0aWVzLWxpc3QnKTtcclxuICAgICAgICBjb25zdCBydWxlc1RhYmxlID0gbmV3IFJ1bGVzVGFibGUodGhpcy5hcHAsIHRoaXMucGx1Z2luLHRoaXMucnVsZXNDb250YWluZXIsdGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9sZGVyQ29uZmlnKTtcclxuICAgICAgICBydWxlc1RhYmxlLmRpc3BsYXkoKTtcclxuXHJcbiAgICAgICAgLy8gLS0tIEJhY2t1cCBhbmQgUmVzdG9yZSBCdXR0b25zIC0tLVxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZShcIkJhY2t1cCAmIFJlc3RvcmUgQ29uZmlndXJhdGlvblwiKVxyXG4gICAgICAgICAgICAuc2V0RGVzYyhcIkV4cG9ydCB5b3VyIGN1cnJlbnQgY29uZmlnIGFzIGEgSlNPTiBmaWxlIG9yIHJlc3RvcmUgZnJvbSBhIGJhY2t1cC5cIilcclxuICAgICAgICAgICAgLmFkZEJ1dHRvbihidG4gPT4ge1xyXG4gICAgICAgICAgICAgICAgYnRuLnNldEJ1dHRvblRleHQoXCJCYWNrdXBcIilcclxuICAgICAgICAgICAgICAgICAgICAuc2V0SWNvbihcImRvd25sb2FkXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhU3RyID0gSlNPTi5zdHJpbmdpZnkodGhpcy5wbHVnaW4uc2V0dGluZ3MsIG51bGwsIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2RhdGFTdHJdLCB7IHR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhLmhyZWYgPSB1cmw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuZG93bmxvYWQgPSBcImZyb250bWF0dGVyLWF1dG9tYXRlLWJhY2t1cC5qc29uXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuY2xpY2soKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYWRkQnV0dG9uKGJ0biA9PiB7XHJcbiAgICAgICAgICAgICAgICBidG4uc2V0QnV0dG9uVGV4dChcIlJlc3RvcmVcIilcclxuICAgICAgICAgICAgICAgICAgICAuc2V0SWNvbihcInVwbG9hZFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LnR5cGUgPSBcImZpbGVcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuYWNjZXB0ID0gXCIuanNvbixhcHBsaWNhdGlvbi9qc29uXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0Lm9uY2hhbmdlID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5maWxlcyB8fCBpbnB1dC5maWxlcy5sZW5ndGggPT09IDApIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBpbnB1dC5maWxlc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCBmaWxlLnRleHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UodGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW9uYWxseSB2YWxpZGF0ZSBkYXRhIGhlcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncyA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShcIkZyb250bWF0dGVyIEF1dG9tYXRlXFxuQ29uZmlndXJhdGlvbiByZXN0b3JlZCBmcm9tIGJhY2t1cC5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShcIkZyb250bWF0dGVyIEF1dG9tYXRlXFxuRmFpbGVkIHRvIHJlc3RvcmU6IEludmFsaWQgSlNPTiBmaWxlLlwiLDIwMDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5jbGljaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcbn0iLCAiaW1wb3J0IHsgQXBwLCBOb3RpY2UsIFN1Z2dlc3RNb2RhbCwgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCB7IFByb3BlcnR5VHlwZUluZm8sIFByb3BlcnR5VHlwZSwgT2JzaWRpYW5Qcm9wZXJ0eVR5cGVzfSBmcm9tICcuL3R5cGVzJztcclxuaW1wb3J0IHsgREVCVUcsIEVSUk9SLCBsb2dnZXIgfSBmcm9tICcuL0xvZyc7XHJcblxyXG5leHBvcnQgY29uc3QgREVGQVVMVF9QUk9QRVJUWV9UWVBFX0lORk86IFByb3BlcnR5VHlwZUluZm8gPSB7XHJcbiAgICBuYW1lIDogXCJcIixcclxuICAgIHR5cGUgOiAndGV4dCcsXHJcbiAgICBpc0FycmF5OiBmYWxzZSxcclxuICAgIHZhbHVlczogW10sXHJcbiAgICBzb3VyY2U6ICdyZWdpc3RlcmVkJyxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIGFsbCBhdmFpbGFibGUgcHJvcGVydGllcyB3aXRoIHRoZWlyIHR5cGUgaW5mb3JtYXRpb25cclxuICogQHBhcmFtIGFwcCBUaGUgT2JzaWRpYW4gQXBwIGluc3RhbmNlXHJcbiAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhcnJheSBvZiBQcm9wZXJ0eVR5cGVJbmZvXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxsUHJvcGVydGllc1dpdGhUeXBlcyhhcHA6IEFwcCk6IFByb21pc2U8UHJvcGVydHlUeXBlSW5mb1tdPiB7XHJcbiAgICAvLyBUcnkgdG8gZ2V0IHJlZ2lzdGVyZWQgcHJvcGVydGllcyAoZmFsbGJhY2sgdG8gZW1wdHkgYXJyYXkgaWYgQVBJIGNoYW5nZWQpXHJcbiAgICBjb25zdCByZWdpc3RlcmVkUHJvcHMgPSBhd2FpdCBnZXRSZWdpc3RlcmVkUHJvcGVydGllc1NhZmUoYXBwKTtcclxuICAgIFxyXG4gICAgLy8gR2V0IGFkZGl0aW9uYWwgcHJvcGVydGllcyBmb3VuZCBpbiBub3Rlc1xyXG4gICAgY29uc3QgZmlsZVByb3BzID0gYXdhaXQgZ2V0UHJvcGVydGllc0Zyb21GaWxlcyhhcHApO1xyXG4gICAgXHJcbiAgICAvLyBDb21iaW5lIHJlc3VsdHMgKGZhdm9yIHJlZ2lzdGVyZWQgcHJvcGVydGllcyB3aGVuIGR1cGxpY2F0ZXMgZXhpc3QpXHJcbiAgICBjb25zdCBjb21iaW5lZCA9IG5ldyBNYXA8c3RyaW5nLCBQcm9wZXJ0eVR5cGVJbmZvPigpO1xyXG4gICAgXHJcbiAgICAvLyBBZGQgcHJvcGVydGllcyBmb3VuZCBpbiBmaWxlcyBmaXJzdFxyXG4gICAgZmlsZVByb3BzLmZvckVhY2gocHJvcCA9PiB7XHJcbiAgICAgICAgY29tYmluZWQuc2V0KHByb3AubmFtZSwgcHJvcCk7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gVGhlbiBvdmVycmlkZSB3aXRoIHJlZ2lzdGVyZWQgcHJvcGVydGllcyAod2hpY2ggaGF2ZSBtb3JlIGNvbXBsZXRlIHR5cGUgaW5mbylcclxuICAgIHJlZ2lzdGVyZWRQcm9wcy5mb3JFYWNoKHByb3AgPT4ge1xyXG4gICAgICAgIGNvbWJpbmVkLnNldChwcm9wLm5hbWUsIHByb3ApO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiBBcnJheS5mcm9tKGNvbWJpbmVkLnZhbHVlcygpKS5zb3J0KChhLCBiKSA9PiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBQcm9wZXJ0aWVzIGZyb20gTWV0YWRhdGFNYW5hZ2VyXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvcGVydGllc0Zyb21NZXRhZGF0YU1hbmFnZXIoYXBwOiBBcHApOiBQcm9wZXJ0eVR5cGVJbmZvW10ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBtZXRhZGF0YU1hbmFnZXIgPSAoYXBwIGFzIGFueSkubWV0YWRhdGFUeXBlTWFuYWdlcjtcclxuICAgICAgICBsb2dnZXIubG9nKERFQlVHLFwiZ2V0IHByb3BlcnRpZXM6XCIsbWV0YWRhdGFNYW5hZ2VyKTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhtZXRhZGF0YU1hbmFnZXIucHJvcGVydGllcykubWFwKCAodmFsdWU6YW55KTpQcm9wZXJ0eVR5cGVJbmZvID0+ICh7XHJcbiAgICAgICAgICAgIG5hbWU6IHZhbHVlLm5hbWUsXHJcbiAgICAgICAgICAgIHR5cGU6IHZhbHVlLnR5cGUsXHJcbiAgICAgICAgICAgIGNvdW50OiB2YWx1ZS5jb3VudCxcclxuICAgICAgICAgICAgc291cmNlOiAncmVnaXN0ZXJlZCdcclxuICAgICAgICB9KSkuc29ydCgoYSwgYikgPT4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKSk7XHJcblxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGxvZ2dlci5sb2coRVJST1IsXCJDb3VsZG4ndCBhY2Nlc3MgcHJvcGVydGllcyBmcm9tIE1ldGFkYXRhIE1hbmFnZXJcIiwgZSk7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBHZXQgVHlwZXMgZnJvbSBNZXRhZGF0YU1hbmFnZXJcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRUeXBlc0Zyb21NZXRhZGF0YU1hbmFnZXIoYXBwOiBBcHApOiBhbnkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBtZXRhZGF0YU1hbmFnZXIgPSAoYXBwIGFzIGFueSkubWV0YWRhdGFUeXBlTWFuYWdlcjtcclxuICAgICAgICBsb2dnZXIubG9nKERFQlVHLFwiZ2V0IHR5cGVzOlwiLG1ldGFkYXRhTWFuYWdlcik7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMobWV0YWRhdGFNYW5hZ2VyLnJlZ2lzdGVyZWRUeXBlV2lkZ2V0cykubWFwKCAodmFsdWU6YW55LCBpbmRleCwgYXJyYXkpOlByb3BlcnR5VHlwZSAgPT4gKHtcclxuICAgICAgICAgICAgdHlwZTogdmFsdWUudHlwZSxcclxuICAgICAgICAgICAgaWNvbjogdmFsdWUuaWNvbixcclxuICAgICAgICAgICAganNUeXBlOiAnJyxcclxuICAgICAgICB9KSkuc29ydCgoYSwgYikgPT4gYS50eXBlLmxvY2FsZUNvbXBhcmUoYi50eXBlKSk7XHJcblxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGxvZ2dlci5sb2coRVJST1IsXCJDb3VsZG4ndCBhY2Nlc3MgcHJvcGVydGllcyBmcm9tIE1ldGFkYXRhIE1hbmFnZXJcIiwgZSk7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTYWZlIG1ldGhvZCB0byBnZXQgcmVnaXN0ZXJlZCBwcm9wZXJ0aWVzIHRoYXQgd29uJ3QgdGhyb3cgaWYgQVBJIGNoYW5nZXNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGdldFJlZ2lzdGVyZWRQcm9wZXJ0aWVzU2FmZShhcHA6IEFwcCk6IFByb21pc2U8UHJvcGVydHlUeXBlSW5mb1tdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhTWFuYWdlciA9IChhcHAgYXMgYW55KS5tZXRhZGF0YVR5cGVNYW5hZ2VyO1xyXG4gICAgICAgIGxvZ2dlci5sb2coREVCVUcsbWV0YWRhdGFNYW5hZ2VyKTtcclxuICAgICAgICBpZiAoIW1ldGFkYXRhTWFuYWdlcikgcmV0dXJuIFtdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFRyeSBkaWZmZXJlbnQgd2F5cyB0byBnZXQgcHJvcGVydGllcyBiYXNlZCBvbiBPYnNpZGlhbiB2ZXJzaW9uXHJcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRhZGF0YU1hbmFnZXIuZ2V0QWxsRnJvbnRtYXR0ZXJUeXBlcyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAvLyBPbGRlciBPYnNpZGlhbiB2ZXJzaW9uc1xyXG4gICAgICAgICAgICBjb25zdCBmcm9udG1hdHRlclR5cGVzID0gbWV0YWRhdGFNYW5hZ2VyLmdldEFsbEZyb250bWF0dGVyVHlwZXMoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZyb250bWF0dGVyVHlwZXMubWFwKChuYW1lOiBzdHJpbmcpID0+ICh7XHJcbiAgICAgICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLCAvLyBEZWZhdWx0IHR5cGUgaWYgd2UgY2FuJ3QgZ2V0IG1vcmUgaW5mb1xyXG4gICAgICAgICAgICAgICAgc291cmNlOiAncmVnaXN0ZXJlZCdcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1ldGFkYXRhTWFuYWdlci5nZXRQcm9wZXJ0aWVzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIC8vIE5ld2VyIE9ic2lkaWFuIHZlcnNpb25zIG1pZ2h0IHVzZSB0aGlzXHJcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBtZXRhZGF0YU1hbmFnZXIuZ2V0UHJvcGVydGllcygpO1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMocHJvcGVydGllcykubWFwKChbbmFtZSwgdHlwZV06IFtzdHJpbmcsIGFueV0pID0+ICh7XHJcbiAgICAgICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgICAgIHNvdXJjZTogJ3JlZ2lzdGVyZWQnXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhFUlJPUixcIkNvdWxkbid0IGFjY2VzcyByZWdpc3RlcmVkIHByb3BlcnRpZXM6XCIsIGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtdO1xyXG59XHJcblxyXG4vKipcclxuICogU2NhbnMgZmlsZXMgZm9yIGFkZGl0aW9uYWwgcHJvcGVydGllcyB3aXRoIHR5cGUgaW5mZXJlbmNlXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBnZXRQcm9wZXJ0aWVzRnJvbUZpbGVzKGFwcDogQXBwKTogUHJvbWlzZTxQcm9wZXJ0eVR5cGVJbmZvW10+IHtcclxuICAgIGNvbnN0IGZpbGVzID0gYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKTtcclxuICAgIGNvbnN0IHByb3BlcnR5TWFwID0gbmV3IE1hcDxzdHJpbmcsIHsgdmFsdWVzOiBTZXQ8YW55PiwgdHlwZXM6IFNldDxzdHJpbmc+IH0+KCk7XHJcbiAgICBcclxuICAgIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcy5zbGljZSgwLCAxMDAwKSkgeyAvLyBMaW1pdCB0byAxMDAwIGZpbGVzIGZvciBwZXJmb3JtYW5jZVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGU/LmZyb250bWF0dGVyKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhjYWNoZS5mcm9udG1hdHRlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAncG9zaXRpb24nKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3BlcnR5TWFwLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5TWFwLnNldChrZXksIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogbmV3IFNldCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXM6IG5ldyBTZXQoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcERhdGEgPSBwcm9wZXJ0eU1hcC5nZXQoa2V5KSE7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcERhdGEudmFsdWVzLmFkZCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcERhdGEudHlwZXMuYWRkKGluZmVyVHlwZUZyb21WYWx1ZSh2YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmxvZyhFUlJPUixgRXJyb3IgcHJvY2Vzc2luZyBmaWxlICR7ZmlsZS5wYXRofTpgLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gQXJyYXkuZnJvbShwcm9wZXJ0eU1hcC5lbnRyaWVzKCkpLm1hcCgoW25hbWUsIGRhdGFdKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGRldGVybWluZVByaW1hcnlUeXBlKGRhdGEudHlwZXMpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgIGlzQXJyYXk6IGRhdGEudHlwZXMuaGFzKCdhcnJheScpLFxyXG4gICAgICAgICAgICB2YWx1ZXM6IGRhdGEudmFsdWVzLnNpemUgPiAwID8gQXJyYXkuZnJvbShkYXRhLnZhbHVlcykubWFwKFN0cmluZykgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHNvdXJjZTogJ2luZmVycmVkJ1xyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERldGVybWluZXMgdGhlIHByaW1hcnkgdHlwZSBmcm9tIGEgU2V0IG9mIG9ic2VydmVkIHR5cGVzXHJcbiAqIEBwYXJhbSB0eXBlcyBTZXQgb2Ygb2JzZXJ2ZWQgdHlwZXMgZm9yIGEgcHJvcGVydHlcclxuICogQHJldHVybnMgVGhlIG1vc3Qgc3BlY2lmaWMgdHlwZSB3ZSBjYW4gZGV0ZXJtaW5lXHJcbiAqL1xyXG5mdW5jdGlvbiBkZXRlcm1pbmVQcmltYXJ5VHlwZSh0eXBlczogU2V0PHN0cmluZz4pOiBPYnNpZGlhblByb3BlcnR5VHlwZXMge1xyXG4gICAgLy8gSGFuZGxlIGVtcHR5IGNhc2UgKHNob3VsZG4ndCBoYXBwZW4gYnV0IFR5cGVTY3JpcHQgd2FudHMgdXMgdG8gY2hlY2spXHJcbiAgICBpZiAodHlwZXMuc2l6ZSA9PT0gMCkgcmV0dXJuICd0ZXh0JztcclxuICAgIFxyXG4gICAgLy8gSWYgb25seSBvbmUgdHlwZSBvYnNlcnZlZCwgdXNlIHRoYXRcclxuICAgIGlmICh0eXBlcy5zaXplID09PSAxKSB7XHJcbiAgICAgICAgY29uc3Qgb25seVR5cGUgPSB0eXBlcy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIChvbmx5VHlwZSAhPT0gdW5kZWZpbmVkID8gb25seVR5cGUgOiAndGV4dCcpIGFzIE9ic2lkaWFuUHJvcGVydHlUeXBlcztcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gUHJpb3JpdHkgb3JkZXIgZm9yIHR5cGUgcmVzb2x1dGlvblxyXG4gICAgY29uc3QgdHlwZVByaW9yaXR5OiBPYnNpZGlhblByb3BlcnR5VHlwZXNbXSA9IFtcclxuICAgICAgICAnZGF0ZScsXHJcbiAgICAgICAgJ2RhdGV0aW1lJyxcclxuICAgICAgICAnY2hlY2tib3gnLFxyXG4gICAgICAgICdudW1iZXInLFxyXG4gICAgICAgICd0YWdzJyxcclxuICAgICAgICAnYWxpYXNlcycsXHJcbiAgICAgICAgJ211bHRpdGV4dCcsXHJcbiAgICAgICAgJ3RleHQnIC8vIGZhbGxiYWNrXHJcbiAgICBdO1xyXG4gICAgXHJcbiAgICAvLyBSZXR1cm4gdGhlIGhpZ2hlc3QgcHJpb3JpdHkgdHlwZSB3ZSBmaW5kXHJcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdHlwZVByaW9yaXR5KSB7XHJcbiAgICAgICAgaWYgKHR5cGVzLmhhcyh0eXBlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEZpbmFsIGZhbGxiYWNrXHJcbiAgICByZXR1cm4gJ3RleHQnO1xyXG59XHJcblxyXG4vKipcclxuICogRW5oYW5jZWQgdHlwZSBpbmZlcmVuY2Ugd2l0aCBiZXR0ZXIgZGF0ZSBkZXRlY3Rpb25cclxuICovXHJcbmZ1bmN0aW9uIGluZmVyVHlwZUZyb21WYWx1ZSh2YWx1ZTogYW55KTogc3RyaW5nIHtcclxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuICdudWxsJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQ2hlY2sgYXJyYXkgZmlyc3RcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGFycmF5IGVsZW1lbnQgdHlwZXNcclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudFR5cGVzID0gbmV3IFNldCh2YWx1ZS5tYXAoaW5mZXJUeXBlRnJvbVZhbHVlKSk7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50VHlwZXMuc2l6ZSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGBhcnJheTwke2VsZW1lbnRUeXBlcy52YWx1ZXMoKS5uZXh0KCkudmFsdWV9PmA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICdhcnJheSc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIENoZWNrIGJhc2ljIHR5cGVzXHJcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xyXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOiByZXR1cm4gJ2Jvb2xlYW4nO1xyXG4gICAgICAgIGNhc2UgJ251bWJlcic6IHJldHVybiAnbnVtYmVyJztcclxuICAgICAgICBjYXNlICdvYmplY3QnOiByZXR1cm4gJ29iamVjdCc7IC8vIGZvciBmdXR1cmUgZXhwYW5zaW9uXHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIE11c3QgYmUgc3RyaW5nIGF0IHRoaXMgcG9pbnQgLSBjaGVjayBmb3Igc3BlY2lhbCBzdHJpbmcgZm9ybWF0c1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAvLyBJU08gRGF0ZSAoWVlZWS1NTS1ERClcclxuICAgICAgICBpZiAoL15cXGR7NH0tXFxkezJ9LVxcZHsyfSQvLnRlc3QodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnZGF0ZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIElTTyBEYXRlVGltZVxyXG4gICAgICAgIGlmICgvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9W1QgXVxcZHsyfTpcXGR7Mn06XFxkezJ9Ly50ZXN0KHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2RhdGV0aW1lJztcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gT2JzaWRpYW4gdGFnXHJcbiAgICAgICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJyMnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3RhZyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBEZWZhdWx0IHRvIHN0cmluZ1xyXG4gICAgcmV0dXJuICdzdHJpbmcnO1xyXG59XHJcblxyXG5mdW5jdGlvbiB2YWx1ZSh2YWx1ZTogdW5rbm93biwgaW5kZXg6IG51bWJlciwgYXJyYXk6IHVua25vd25bXSk6IHVua25vd24ge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQuJyk7XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBTZWxlY3RQcm9wZXJ0eSBleHRlbmRzIFN1Z2dlc3RNb2RhbDxQcm9wZXJ0eVR5cGVJbmZvPiB7XHJcbiAgICBwcml2YXRlIG9uU3VibWl0OiAocmVzdWx0OiBQcm9wZXJ0eVR5cGVJbmZvKSA9PiB2b2lkO1xyXG4gICAgcHJvcGVydHk6IFByb3BlcnR5VHlwZUluZm8gfCB1bmRlZmluZWQ7XHJcbiAgICBrbm93blByb3BlcnRpZXM6UHJvcGVydHlUeXBlSW5mb1tdO1xyXG4gICAgdHlwZWRUZXh0OiBzdHJpbmc7XHJcbiAgICBuZXdUZXh0RmxhZzogQm9vbGVhbjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvciAoYXBwOkFwcCwga25vd25Qcm9wZXJ0aWVzOlByb3BlcnR5VHlwZUluZm9bXSwgcHJvcGVydHk6IFByb3BlcnR5VHlwZUluZm8gfCB1bmRlZmluZWQsIG9uU3VibWl0OiAocmVzdWx0OiBQcm9wZXJ0eVR5cGVJbmZvKSA9PiB2b2lkKSB7XHJcbiAgICAgICAgc3VwZXIoYXBwKTtcclxuICAgICAgICB0aGlzLm9uU3VibWl0ID0gb25TdWJtaXQ7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xyXG4gICAgICAgIHRoaXMudHlwZWRUZXh0ID0gJyc7XHJcbiAgICAgICAgdGhpcy5uZXdUZXh0RmxhZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5rbm93blByb3BlcnRpZXMgPSBrbm93blByb3BlcnRpZXM7XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIGFsbCBhdmFpbGFibGUgc3VnZ2VzdGlvbnMuXHJcbiAgICBnZXRTdWdnZXN0aW9ucyhxdWVyeTogc3RyaW5nKTogUHJvcGVydHlUeXBlSW5mb1tdIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmtub3duUHJvcGVydGllcy5maWx0ZXIoKHByb3BlcnR5KSA9PiBwcm9wZXJ0eS5uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocXVlcnkudG9Mb3dlckNhc2UoKSkpO1xyXG4gICAgICAgIHRoaXMubmV3VGV4dEZsYWcgPSAocmVzdWx0Lmxlbmd0aCA9PT0gMCk7XHJcbiAgICAgICAgdGhpcy50eXBlZFRleHQgPSBxdWVyeTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgb25PcGVuKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLnByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UGxhY2Vob2xkZXIodGhpcy5wcm9wZXJ0eS5uYW1lKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnNldFBsYWNlaG9sZGVyKCdubyBwcm9wZXJ0eSBzZWxlY3RlZCEnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRUaXRsZSgnU2VsZWN0IG9yIHR5cGUgYSBwcm9wZXJ0eSBuYW1lJyk7XHJcbiAgICB9XHJcbiAgICAvLyBSZW5kZXJzIGVhY2ggc3VnZ2VzdGlvbiBpdGVtLlxyXG4gICAgcmVuZGVyU3VnZ2VzdGlvbihwcm9wZXJ0eTogUHJvcGVydHlUeXBlSW5mbywgZWw6IEhUTUxFbGVtZW50KSB7XHJcbiAgICAgIGVsLmNyZWF0ZUVsKCdkaXYnLCB7IHRleHQ6IHByb3BlcnR5Lm5hbWUgfSk7XHJcbiAgICAgIGVsLmNyZWF0ZUVsKCdzbWFsbCcsIHsgdGV4dDogcHJvcGVydHkudHlwZSB9KTtcclxuICAgIH1cclxuICAgIG9uQ2xvc2UoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMubmV3VGV4dEZsYWcgJiYgdGhpcy5wcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnR5Lm5hbWUgPSB0aGlzLnR5cGVkVGV4dDtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eS50eXBlID0gJ3RleHQnO1xyXG4gICAgICAgICAgICB0aGlzLm9uU3VibWl0KHRoaXMucHJvcGVydHkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBQZXJmb3JtIGFjdGlvbiBvbiB0aGUgc2VsZWN0ZWQgc3VnZ2VzdGlvbi5cclxuICAgIG9uQ2hvb3NlU3VnZ2VzdGlvbihwcm9wZXJ0eTogUHJvcGVydHlUeXBlSW5mbywgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xyXG4gICAgICAgIGlmIChldnQgaW5zdGFuY2VvZiBLZXlib2FyZEV2ZW50KSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5sb2coREVCVUcsYGtleWJvYXJkICR7dGhpcy50eXBlZFRleHR9ICR7dGhpcy5uZXdUZXh0RmxhZ31gLCBwcm9wZXJ0eSlcclxuICAgICAgICB9XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhERUJVRywnb25DaG9vc2VTdWdnZXN0aW9uJywgZXZ0KVxyXG4gICAgICAgIHRoaXMub25TdWJtaXQocHJvcGVydHkpO1xyXG4gICAgfVxyXG4gIH1cclxuIiwgImltcG9ydCB7IE5vdGljZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgRXJyb3JNYW5hZ2VyIH0gZnJvbSBcIi4vRXJyb3JcIjtcblxuLy8gTnVtZXJpYyBsb2cgbGV2ZWxzIGZvciBlYXN5IGNvbXBhcmlzb24gYW5kIHVzYWdlXG5leHBvcnQgY29uc3QgTE9HID0gMDtcbmV4cG9ydCBjb25zdCBBTEVSVCA9IDE7XG5leHBvcnQgY29uc3QgRVJST1IgPSAyO1xuZXhwb3J0IGNvbnN0IFdBUk5JTkcgPSAzO1xuZXhwb3J0IGNvbnN0IElORk8gPSA0O1xuZXhwb3J0IGNvbnN0IERFQlVHID0gNTtcbmV4cG9ydCBjb25zdCBUUkFDRSA9IDY7XG5cbmV4cG9ydCB0eXBlIExvZ0xldmVsID0gMCB8IDEgfCAyIHwgMyB8IDQgfCA1IHwgNjtcblxuZXhwb3J0IGVudW0gTG9nRGV2aWNlcyB7XG4gICAgQ09OU09MRSA9IFwiY29uc29sZVwiLFxuICAgIE5PVElGSUNBVElPTiA9IFwibm90aWZpY2F0aW9uXCIsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2dVcGRhdGUobXNnOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBub3RpY2UgPSBuZXcgTm90aWNlKFwiXCIsIDE1MDAwKTtcbiAgICBub3RpY2UubWVzc2FnZUVsLmlubmVySFRNTCA9IGA8Yj5Gcm9udG1hdHRlciBBdXRvbWF0ZSB1cGRhdGU8L2I+Ojxici8+JHttc2d9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZ0Vycm9yKGU6IEVycm9yIHwgRXJyb3JNYW5hZ2VyKTogdm9pZCB7XG4gICAgY29uc3Qgbm90aWNlID0gbmV3IE5vdGljZShcIlwiLCA4MDAwKTtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yTWFuYWdlciAmJiBlLmNvbnNvbGVfbXNnKSB7XG4gICAgICAgIG5vdGljZS5tZXNzYWdlRWwuaW5uZXJIVE1MID0gYDxiPkZyb250bWF0dGVyIEF1dG9tYXRlIEVycm9yPC9iPjo8YnIvPiR7ZS5tZXNzYWdlfTxici8+Q2hlY2sgY29uc29sZSBmb3IgbW9yZSBpbmZvcm1hdGlvbmA7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZyb250bWF0dGVyIEVycm9yOmAsIGUubWVzc2FnZSwgXCJcXG5cIiwgZS5jb25zb2xlX21zZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbm90aWNlLm1lc3NhZ2VFbC5pbm5lckhUTUwgPSBgPGI+RnJvbnRtYXR0ZXIgQXV0b21hdGUgRXJyb3I8L2I+Ojxici8+JHtlLm1lc3NhZ2V9YDtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBMb2dnZXIge1xuICAgIHByaXZhdGUgbG9nTGV2ZWw6IExvZ0xldmVsID0gSU5GTztcblxuICAgIHNldExldmVsKGxldmVsOiBzdHJpbmcgfCBudW1iZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5sb2dMZXZlbCA9IGxldmVsIGFzIExvZ0xldmVsO1xuICAgICAgICAgICAgdGhpcy5sb2coTE9HLCBgTG9nIGxldmVsIHNldCB0byAke3RoaXMuZ2V0TGV2ZWxOYW1lKHRoaXMubG9nTGV2ZWwpfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbGV2ZWxOYW1lID0gbGV2ZWwudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IGxldmVsSW5kZXggPSB0aGlzLmdldExldmVsTmFtZXMoKS5pbmRleE9mKGxldmVsTmFtZSkgKyAxIGFzIExvZ0xldmVsO1xuICAgICAgICAgICAgaWYgKGxldmVsSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TGV2ZWwobGV2ZWxJbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKFdBUk5JTkcsYEludmFsaWQgbG9nIGxldmVsIG5hbWU6ICR7bGV2ZWxOYW1lfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0TGV2ZWwoKTogTG9nTGV2ZWwge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2dMZXZlbDtcbiAgICB9XG5cbiAgICBnZXRMZXZlbEJ5TmFtZShsZXZlbE5hbWU6IHN0cmluZyk6IExvZ0xldmVsIHtcbiAgICAgICAgY29uc3QgbGV2ZWxJbmRleCA9IHRoaXMuZ2V0TGV2ZWxOYW1lcygpLmluZGV4T2YobGV2ZWxOYW1lLnRvVXBwZXJDYXNlKCkpICsgMTtcbiAgICAgICAgaWYgKGxldmVsSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGxldmVsSW5kZXggYXMgTG9nTGV2ZWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhXQVJOSU5HLGBJbnZhbGlkIGxvZyBsZXZlbCBuYW1lOiAke2xldmVsTmFtZX1gKTtcbiAgICAgICAgICAgIHJldHVybiBJTkZPOyAvLyBEZWZhdWx0IHRvIElORk8gaWYgaW52YWxpZFxuICAgICAgICB9XG4gICAgfVxuICAgIGdldExldmVsQnlJbmRleChsZXZlbEluZGV4OiBudW1iZXIpOiBMb2dMZXZlbCB7XG4gICAgICAgIGlmIChsZXZlbEluZGV4ID49IEFMRVJUICYmIGxldmVsSW5kZXggPD0gVFJBQ0UpIHtcbiAgICAgICAgICAgIHJldHVybiBsZXZlbEluZGV4IGFzIExvZ0xldmVsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2coV0FSTklORyxgSW52YWxpZCBsb2cgbGV2ZWwgaW5kZXg6ICR7bGV2ZWxJbmRleH1gKTtcbiAgICAgICAgICAgIHJldHVybiBJTkZPOyAvLyBEZWZhdWx0IHRvIElORk8gaWYgaW52YWxpZFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0TGV2ZWxCeVZhbHVlKGxldmVsVmFsdWU6IG51bWJlcik6IExvZ0xldmVsIHtcbiAgICAgICAgaWYgKGxldmVsVmFsdWUgPj0gQUxFUlQgJiYgbGV2ZWxWYWx1ZSA8PSBUUkFDRSkge1xuICAgICAgICAgICAgcmV0dXJuIGxldmVsVmFsdWUgYXMgTG9nTGV2ZWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhXQVJOSU5HLGBJbnZhbGlkIGxvZyBsZXZlbCB2YWx1ZTogJHtsZXZlbFZhbHVlfWApO1xuICAgICAgICAgICAgcmV0dXJuIElORk87IC8vIERlZmF1bHQgdG8gSU5GTyBpZiBpbnZhbGlkXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHNob3VsZExvZyhsZXZlbDogTG9nTGV2ZWwpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKGxldmVsID09PSAwKSByZXR1cm4gdHJ1ZTsgLy8gQWx3YXlzIGxvZyBsZXZlbCAwXG4gICAgICAgIHJldHVybiBsZXZlbCA8PSB0aGlzLmxvZ0xldmVsO1xuICAgIH1cblxuICAgIGdldExldmVsTmFtZShsZXZlbDogTG9nTGV2ZWwpOiBzdHJpbmcge1xuICAgICAgICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgICAgICAgICBjYXNlIEFMRVJUOiByZXR1cm4gXCJBTEVSVFwiO1xuICAgICAgICAgICAgY2FzZSBFUlJPUjogcmV0dXJuIFwiRVJST1JcIjtcbiAgICAgICAgICAgIGNhc2UgV0FSTklORzogcmV0dXJuIFwiV0FSTklOR1wiO1xuICAgICAgICAgICAgY2FzZSBJTkZPOiByZXR1cm4gXCJJTkZPXCI7XG4gICAgICAgICAgICBjYXNlIERFQlVHOiByZXR1cm4gXCJERUJVR1wiO1xuICAgICAgICAgICAgY2FzZSBUUkFDRTogcmV0dXJuIFwiVFJBQ0VcIjtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBcIkxPR1wiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0TGV2ZWxOYW1lcygpOiBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiAoW0FMRVJULCBFUlJPUiwgV0FSTklORywgSU5GTywgREVCVUcsIFRSQUNFXSBhcyBMb2dMZXZlbFtdKS5tYXAobGV2ZWwgPT4gdGhpcy5nZXRMZXZlbE5hbWUobGV2ZWwpKTtcbiAgICB9XG4gICAgXG4gICAgbG9nKGxldmVsOiBMb2dMZXZlbCwgLi4ubXNnOiBhbnlbXSk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuc2hvdWxkTG9nKGxldmVsKSkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IGxldmVsTmFtZSA9IHRoaXMuZ2V0TGV2ZWxOYW1lKGxldmVsKTtcbiAgICAgICAgbGV0IGNvbG9yID0gXCJcIjtcbiAgICAgICAgc3dpdGNoIChsZXZlbCkge1xuICAgICAgICAgICAgY2FzZSBBTEVSVDogICBjb2xvciA9IFwiYmFja2dyb3VuZDogI2QzMmYyZjsgY29sb3I6IHdoaXRlOyBmb250LXdlaWdodDogYm9sZFwiOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRVJST1I6ICAgY29sb3IgPSBcImNvbG9yOiAjZDMyZjJmOyBmb250LXdlaWdodDogYm9sZFwiOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgV0FSTklORzogY29sb3IgPSBcImNvbG9yOiAjZmJjMDJkOyBmb250LXdlaWdodDogYm9sZFwiOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgSU5GTzogICAgY29sb3IgPSBcImNvbG9yOiAjMTk3NmQyOyBmb250LXdlaWdodDogYm9sZFwiOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgREVCVUc6ICAgY29sb3IgPSBcImNvbG9yOiAjMzg4ZTNjO1wiOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVFJBQ0U6ICAgY29sb3IgPSBcImNvbG9yOiAjNjE2MTYxO1wiOyBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6ICAgICAgY29sb3IgPSBcIlwiOyBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmVmaXggPSBgJWNbJHtsZXZlbE5hbWV9XWA7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBjYWxsZXIgbGluZSAoc3RhY2sgbGluZSAyKVxuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgbGV0IGNhbGxlciA9IFwiXCI7XG4gICAgICAgIGlmIChlcnIuc3RhY2spIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YWNrTGluZXMgPSBlcnIuc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICBpZiAoc3RhY2tMaW5lcy5sZW5ndGggPj0gMykge1xuICAgICAgICAgICAgICAgIGNhbGxlciA9IHN0YWNrTGluZXNbMl0udHJpbSgpOyAvLyAwOkVycm9yLCAxOnRoaXMgZnVuY3Rpb24sIDI6Y2FsbGVyXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbmx5IHN0eWxlIHRoZSBwcmVmaXgsIG5vdCB0aGUgY2FsbGVyXG4gICAgICAgIHN3aXRjaCAobGV2ZWwpIHtcbiAgICAgICAgICAgIGNhc2UgQUxFUlQ6XG4gICAgICAgICAgICBjYXNlIEVSUk9SOlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQocHJlZml4LCBjb2xvciwgLi4ubXNnKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNhbGxlciBTdGFjazpcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdBUk5JTkc6XG4gICAgICAgICAgICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZChwcmVmaXgsIGNvbG9yLCAuLi5tc2cpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ2FsbGVyIFN0YWNrOlwiLCBlcnIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgSU5GTzpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8ocHJlZml4LCBjb2xvciwgLi4ubXNnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgREVCVUc6XG4gICAgICAgICAgICBjYXNlIFRSQUNFOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKHByZWZpeCwgY29sb3IsIC4uLm1zZyk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDYWxsZXIgU3RhY2s6XCIsIGVycik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZXZlbCA9PT0gQUxFUlQgfHwgbGV2ZWwgPT09IEVSUk9SKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKGA8Yj5Gcm9udG1hdHRlciBBdXRvbWF0ZSAke2xldmVsTmFtZX08L2I+Ojxici8+JHttc2cuam9pbihcIiBcIil9YCwgODAwMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBncm91cENvbGxhcHNlZChsZXZlbDogTG9nTGV2ZWwsIC4uLm1zZzogYW55W10pOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLnNob3VsZExvZyhsZXZlbCkpIHJldHVybjtcbiAgICAgICAgY29uc3QgbGV2ZWxOYW1lID0gdGhpcy5nZXRMZXZlbE5hbWUobGV2ZWwpO1xuICAgICAgICBsZXQgY29sb3IgPSBcIlwiO1xuICAgICAgICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgICAgICAgICBjYXNlIEFMRVJUOiAgIGNvbG9yID0gXCJiYWNrZ3JvdW5kOiAjZDMyZjJmOyBjb2xvcjogd2hpdGU7IGZvbnQtd2VpZ2h0OiBib2xkXCI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBFUlJPUjogICBjb2xvciA9IFwiY29sb3I6ICNkMzJmMmY7IGZvbnQtd2VpZ2h0OiBib2xkXCI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBXQVJOSU5HOiBjb2xvciA9IFwiY29sb3I6ICNmYmMwMmQ7IGZvbnQtd2VpZ2h0OiBib2xkXCI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBJTkZPOiAgICBjb2xvciA9IFwiY29sb3I6ICMxOTc2ZDI7IGZvbnQtd2VpZ2h0OiBib2xkXCI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBERUJVRzogICBjb2xvciA9IFwiY29sb3I6ICMzODhlM2M7XCI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBUUkFDRTogICBjb2xvciA9IFwiY29sb3I6ICM2MTYxNjE7XCI7IGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDogICAgICBjb2xvciA9IFwiXCI7IGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGAlY1ske2xldmVsTmFtZX1dYDtcbiAgICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZChwcmVmaXgsIGNvbG9yLCAuLi5tc2cpO1xuICAgIH1cblxuICAgIGdyb3VwRW5kKCk6IHZvaWQge1xuICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgfVxuXG4gICAgbG9nVXBkYXRlKG1zZzogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIG5ldyBOb3RpY2UoYDxiPkZyb250bWF0dGVyIEF1dG9tYXRlIHVwZGF0ZTwvYj46PGJyLz4ke21zZ31gLCAxNTAwMCk7XG4gICAgfVxuXG4gICAgbG9nRXJyb3IoZTogRXJyb3IgfCBFcnJvck1hbmFnZXIpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgbm90aWNlID0gbmV3IE5vdGljZShcIlwiLCA4MDAwKTtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvck1hbmFnZXIgJiYgZS5jb25zb2xlX21zZykge1xuICAgICAgICAgICAgbm90aWNlLm1lc3NhZ2VFbC5pbm5lckhUTUwgPSBgPGI+RnJvbnRtYXR0ZXIgQXV0b21hdGUgRXJyb3I8L2I+Ojxici8+JHtlLm1lc3NhZ2V9PGJyLz5DaGVjayBjb25zb2xlIGZvciBtb3JlIGluZm9ybWF0aW9uYDtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coRVJST1IsYEZyb250bWF0dGVyIEVycm9yOmAsIGUubWVzc2FnZSwgXCJcXG5cIiwgZS5jb25zb2xlX21zZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub3RpY2UubWVzc2FnZUVsLmlubmVySFRNTCA9IGA8Yj5Gcm9udG1hdHRlciBBdXRvbWF0ZSBFcnJvcjwvYj46PGJyLz4ke2UubWVzc2FnZX1gO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBFeHBvcnQgYSBzaW5nbGV0b24gbG9nZ2VyIGluc3RhbmNlIGFuZCB0aGUgbG9nIGxldmVsIGNvbnN0YW50c1xuZXhwb3J0IGNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoKTsiLCAiaW1wb3J0IHsgbG9nRXJyb3IgfSBmcm9tIFwiLi9Mb2dcIjtcblxuZXhwb3J0IGNsYXNzIEVycm9yTWFuYWdlciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihtc2c6IHN0cmluZywgcHVibGljIGNvbnNvbGVfbXNnPzogc3RyaW5nKSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVycm9yV3JhcHBlcjxUPihcbiAgICBmbjogKCkgPT4gUHJvbWlzZTxUPixcbiAgICBtc2c6IHN0cmluZ1xuKTogUHJvbWlzZTxUPiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGZuKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgRXJyb3JNYW5hZ2VyKSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gKGUgJiYgdHlwZW9mIGUgPT09IFwib2JqZWN0XCIgJiYgXCJtZXNzYWdlXCIgaW4gZSkgPyAoZSBhcyB7IG1lc3NhZ2U6IHN0cmluZyB9KS5tZXNzYWdlIDogU3RyaW5nKGUpO1xuICAgICAgICAgICAgbG9nRXJyb3IobmV3IEVycm9yTWFuYWdlcihtc2csIGVycm9yTWVzc2FnZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGwgYXMgVDtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcnJvcldyYXBwZXJTeW5jPFQ+KGZuOiAoKSA9PiBULCBtc2c6IHN0cmluZyk6IFQge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgbG9nRXJyb3IobmV3IEVycm9yTWFuYWdlcihtc2csIGUubWVzc2FnZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nRXJyb3IobmV3IEVycm9yTWFuYWdlcihtc2csIFN0cmluZyhlKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsIGFzIFQ7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IEFwcCwgbm9ybWFsaXplUGF0aCwgVEFic3RyYWN0RmlsZSwgVEZpbGUsIFRGb2xkZXIsIFZhdWx0IH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQgeyBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCBGcm9udG1hdHRlckF1dG9tYXRlU2V0dGluZ3MsIFByb3BlcnR5SW5mbywgUHJvcGVydHlUeXBlSW5mbyB9IGZyb20gJy4vdHlwZXMnXHJcbmltcG9ydCB7IEVycm9yTWFuYWdlciB9IGZyb20gXCIuL0Vycm9yXCI7XHJcbmltcG9ydCB7IEFsZXJ0TW9kYWwgfSBmcm9tICcuL2FsZXJ0Qm94JztcclxuaW1wb3J0IHsgZGVsaW1pdGVyIH0gZnJvbSAncGF0aCc7XHJcbmltcG9ydCB7IHJ1bGVzTWFuYWdlciB9IGZyb20gJy4vcnVsZXMvcnVsZXMnO1xyXG5pbXBvcnQgeyBERUJVRywgRVJST1IsIGxvZ2dlciwgVFJBQ0UsIFdBUk5JTkcgfSBmcm9tICcuL0xvZyc7XHJcbmltcG9ydCB7IFRyZWVIaWVyYXJjaHlSb3cgfSBmcm9tICcuL3VpVHJlZUhpZXJhcmNoeVNvcnRhYmxlU2V0dGluZ3MnO1xyXG4vKipcclxuICogUGFyc2UgYSBKYXZhU2NyaXB0IGZ1bmN0aW9uLCBjbGVhbiBjb21tZW50cyBhbmQgZGVmaW5lIHRoZSBmdW5jdGlvbiBcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGpzQ29kZVxyXG4gKiBAcmV0dXJuIHsqfSAgeyhGdW5jdGlvbiB8IHN0cmluZyB8IHVuZGVmaW5lZCl9XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VKU0NvZGUoanNDb2RlOnN0cmluZyk6IEZ1bmN0aW9uIHwgc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuICAgIGZ1bmN0aW9uIHBhcnNlRnVuY3Rpb24gKGpzQ29kZTogc3RyaW5nKTogRnVuY3Rpb24gfCBzdHJpbmcgfCB1bmRlZmluZWQge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAganNDb2RlID0gY2xlYW5Db2RlU3RyaW5nKGpzQ29kZSk7XHJcbiAgICAgICAgdmFyIGZ1bmNSZWcgPSAvZnVuY3Rpb24gKlxcKChbXigpXSopXFwpWyBcXG5cXHRdKnsoLiopfS9nbWk7XHJcbiAgICAgICAgdmFyIG1hdGNoID0gZnVuY1JlZy5leGVjKGpzQ29kZS5yZXBsYWNlKC9cXG4vZywgJyAnKSk7XHJcbiAgICAgICAgaWYgKCFtYXRjaCkgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB2YXIgYXJncyA9IG1hdGNoWzFdLnNwbGl0KCcsJyk7XHJcbiAgICAgICAgYXJncy5wdXNoKG1hdGNoWzJdKTtcclxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKC4uLmFyZ3MpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5sb2coRVJST1IsJ2Vycm9yIHBhcnNpbmcgSlMgZnVuY3Rpb24hJywgZXJyb3IpO1xyXG4gICAgICAgICAgICByZXR1cm4gKGVycm9yIGFzIEVycm9yKS5tZXNzYWdlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gcGFyc2VGdW5jdGlvbihqc0NvZGUpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2xlYW5zIGEgSmF2YVNjcmlwdC9UeXBlU2NyaXB0IGNvZGUgc3RyaW5nIGJ5IHJlbW92aW5nIGNvbW1lbnRzLlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGhhbmRsZXMgYm90aCBzaW5nbGUtbGluZSBjb21tZW50cyAoYC8vIC4uLmApIGFuZFxyXG4gKiBtdWx0aS1saW5lIGNvbW1lbnRzIChgLyogLi4uICpcXC9gKS4gSXQgYWxzbyBjb3JyZWN0bHkgaGFuZGxlc1xyXG4gKiBjb21tZW50cyB3aXRoaW4gc3RyaW5ncyBhbmQgcmVndWxhciBleHByZXNzaW9ucy5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGVTdHJpbmcgVGhlIGNvZGUgc3RyaW5nIHRvIGNsZWFuLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY2xlYW5lZCBjb2RlIHN0cmluZyB3aXRoIGNvbW1lbnRzIHJlbW92ZWQuXHJcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGhlIGlucHV0IGlzIG5vdCBhIHN0cmluZy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGVhbkNvZGVTdHJpbmcoY29kZVN0cmluZzogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIC8vIEVuc3VyZSB0aGUgaW5wdXQgaXMgYSBzdHJpbmdcclxuICAgIGlmICh0eXBlb2YgY29kZVN0cmluZyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5wdXQgbXVzdCBiZSBhIHN0cmluZy4nKTtcclxuICAgIH1cclxuICBcclxuICAgIC8vIEZsYWdzIHRvIHRyYWNrIHRoZSBjdXJyZW50IHBhcnNpbmcgY29udGV4dFxyXG4gICAgbGV0IGluTXVsdGlMaW5lQ29tbWVudDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgbGV0IGluU2luZ2xlTGluZUNvbW1lbnQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIGxldCBpblN0cmluZzogJ1wiJyB8IFwiJ1wiIHwgbnVsbCA9IG51bGw7IC8vIFRyYWNrcyBpZiBpbnNpZGUgc2luZ2xlIG9yIGRvdWJsZSBxdW90ZXNcclxuICAgIGxldCBpblJlZ0V4cDogYm9vbGVhbiA9IGZhbHNlOyAvLyBUcmFja3MgaWYgaW5zaWRlIGEgcmVndWxhciBleHByZXNzaW9uIGxpdGVyYWxcclxuICBcclxuICAgIC8vIFRoZSByZXN1bHRpbmcgc3RyaW5nIHdpdGhvdXQgY29tbWVudHNcclxuICAgIGxldCBjbGVhbmVkQ29kZTogc3RyaW5nID0gJyc7XHJcbiAgICAvLyBDdXJyZW50IGluZGV4IGluIHRoZSBpbnB1dCBzdHJpbmdcclxuICAgIGxldCBpOiBudW1iZXIgPSAwO1xyXG4gIFxyXG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBpbnB1dCBzdHJpbmcgY2hhcmFjdGVyIGJ5IGNoYXJhY3RlclxyXG4gICAgd2hpbGUgKGkgPCBjb2RlU3RyaW5nLmxlbmd0aCkge1xyXG4gICAgICBjb25zdCBjaGFyOiBzdHJpbmcgPSBjb2RlU3RyaW5nW2ldO1xyXG4gICAgICBjb25zdCBuZXh0Q2hhcjogc3RyaW5nIHwgdW5kZWZpbmVkID0gY29kZVN0cmluZ1tpICsgMV07IC8vIFVzZSB1bmRlZmluZWQgZm9yIHBvdGVudGlhbCBlbmQgb2Ygc3RyaW5nXHJcbiAgXHJcbiAgICAgIC8vIC0tLSBTdGF0ZTogSW5zaWRlIGEgbXVsdGktbGluZSBjb21tZW50IC0tLVxyXG4gICAgICBpZiAoaW5NdWx0aUxpbmVDb21tZW50KSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBlbmQgb2YgdGhlIG11bHRpLWxpbmUgY29tbWVudCAnKi8nXHJcbiAgICAgICAgaWYgKGNoYXIgPT09ICcqJyAmJiBuZXh0Q2hhciA9PT0gJy8nKSB7XHJcbiAgICAgICAgICBpbk11bHRpTGluZUNvbW1lbnQgPSBmYWxzZTtcclxuICAgICAgICAgIGkgKz0gMjsgLy8gU2tpcCB0aGUgJyovJ1xyXG4gICAgICAgICAgY29udGludWU7IC8vIE1vdmUgdG8gdGhlIG5leHQgaXRlcmF0aW9uXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGkrKzsgLy8gU2tpcCB0aGUgY2hhcmFjdGVyIGluc2lkZSB0aGUgY29tbWVudFxyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIC8vIC0tLSBTdGF0ZTogSW5zaWRlIGEgc2luZ2xlLWxpbmUgY29tbWVudCAtLS1cclxuICAgICAgaWYgKGluU2luZ2xlTGluZUNvbW1lbnQpIHtcclxuICAgICAgICAvLyBDaGVjayBmb3IgdGhlIGVuZCBvZiB0aGUgbGluZSAobmV3bGluZSBvciBjYXJyaWFnZSByZXR1cm4pXHJcbiAgICAgICAgaWYgKGNoYXIgPT09ICdcXG4nIHx8IGNoYXIgPT09ICdcXHInKSB7XHJcbiAgICAgICAgICBpblNpbmdsZUxpbmVDb21tZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICBjbGVhbmVkQ29kZSArPSBjaGFyOyAvLyBLZWVwIHRoZSBuZXdsaW5lIGNoYXJhY3RlclxyXG4gICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGkrKzsgLy8gU2tpcCB0aGUgY2hhcmFjdGVyIGluc2lkZSB0aGUgY29tbWVudFxyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIC8vIC0tLSBTdGF0ZTogSW5zaWRlIGEgc3RyaW5nIGxpdGVyYWwgLS0tXHJcbiAgICAgIGlmIChpblN0cmluZykge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IGNoYXJhY3RlciBjbG9zZXMgdGhlIHN0cmluZ1xyXG4gICAgICAgIGlmIChjaGFyID09PSBpblN0cmluZykge1xyXG4gICAgICAgICAgaW5TdHJpbmcgPSBudWxsOyAvLyBFeGl0IHN0cmluZyBzdGF0ZVxyXG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJ1xcXFwnKSB7XHJcbiAgICAgICAgICAvLyBIYW5kbGUgZXNjYXBlZCBjaGFyYWN0ZXJzIHdpdGhpbiBzdHJpbmdzIChlLmcuLCBcIml0XFwnc1wiKVxyXG4gICAgICAgICAgY2xlYW5lZENvZGUgKz0gY2hhcjsgLy8gQWRkIHRoZSBiYWNrc2xhc2hcclxuICAgICAgICAgIGkrKzsgLy8gTW92ZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgKHRoZSBlc2NhcGVkIG9uZSlcclxuICAgICAgICAgIGlmIChpIDwgY29kZVN0cmluZy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgIGNsZWFuZWRDb2RlICs9IGNvZGVTdHJpbmdbaV07IC8vIEFkZCB0aGUgZXNjYXBlZCBjaGFyYWN0ZXJcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGkrKztcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBZGQgdGhlIGNoYXJhY3RlciB0byB0aGUgcmVzdWx0IGlmIGl0J3MgcGFydCBvZiB0aGUgc3RyaW5nXHJcbiAgICAgICAgY2xlYW5lZENvZGUgKz0gY2hhcjtcclxuICAgICAgICBpKys7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgIC8vIC0tLSBTdGF0ZTogSW5zaWRlIGEgcmVndWxhciBleHByZXNzaW9uIGxpdGVyYWwgLS0tXHJcbiAgICAgICBpZiAoaW5SZWdFeHApIHtcclxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IGNoYXJhY3RlciBjbG9zZXMgdGhlIHJlZ2V4IGxpdGVyYWxcclxuICAgICAgICAgIC8vIE5vdGU6IFRoaXMgZG9lc24ndCBoYW5kbGUgcmVnZXggZmxhZ3MgcGVyZmVjdGx5IGJ1dCBjb3ZlcnMgYmFzaWMgY2FzZXMuXHJcbiAgICAgICAgICBpZiAoY2hhciA9PT0gJy8nKSB7XHJcbiAgICAgICAgICAgICAgaW5SZWdFeHAgPSBmYWxzZTsgLy8gRXhpdCByZWdleCBzdGF0ZVxyXG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnXFxcXCcpIHtcclxuICAgICAgICAgICAgICAvLyBIYW5kbGUgZXNjYXBlZCBjaGFyYWN0ZXJzIHdpdGhpbiByZWdleCAoZS5nLiwgL1xcLy8pXHJcbiAgICAgICAgICAgICAgY2xlYW5lZENvZGUgKz0gY2hhcjsgLy8gQWRkIHRoZSBiYWNrc2xhc2hcclxuICAgICAgICAgICAgICBpKys7IC8vIE1vdmUgdG8gdGhlIG5leHQgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgICAgaWYgKGkgPCBjb2RlU3RyaW5nLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgIGNsZWFuZWRDb2RlICs9IGNvZGVTdHJpbmdbaV07IC8vIEFkZCB0aGUgZXNjYXBlZCBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gQWRkIHRoZSBjaGFyYWN0ZXIgdG8gdGhlIHJlc3VsdCBpZiBpdCdzIHBhcnQgb2YgdGhlIHJlZ2V4XHJcbiAgICAgICAgICBjbGVhbmVkQ29kZSArPSBjaGFyO1xyXG4gICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICB9XHJcbiAgXHJcbiAgICAgIC8vIC0tLSBEZWZhdWx0IFN0YXRlOiBDaGVjayBmb3IgY29tbWVudC9zdHJpbmcvcmVnZXggc3RhcnRzIC0tLVxyXG4gIFxyXG4gICAgICAvLyBDaGVjayBmb3IgdGhlIHN0YXJ0IG9mIGEgbXVsdGktbGluZSBjb21tZW50ICcvKidcclxuICAgICAgaWYgKGNoYXIgPT09ICcvJyAmJiBuZXh0Q2hhciA9PT0gJyonKSB7XHJcbiAgICAgICAgaW5NdWx0aUxpbmVDb21tZW50ID0gdHJ1ZTtcclxuICAgICAgICBpICs9IDI7IC8vIFNraXAgdGhlICcvKidcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvLyBDaGVjayBmb3IgdGhlIHN0YXJ0IG9mIGEgc2luZ2xlLWxpbmUgY29tbWVudCAnLy8nXHJcbiAgICAgIGlmIChjaGFyID09PSAnLycgJiYgbmV4dENoYXIgPT09ICcvJykge1xyXG4gICAgICAgIGluU2luZ2xlTGluZUNvbW1lbnQgPSB0cnVlO1xyXG4gICAgICAgIGkgKz0gMjsgLy8gU2tpcCB0aGUgJy8vJ1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIC8vIENoZWNrIGZvciB0aGUgc3RhcnQgb2YgYSBzdHJpbmcgbGl0ZXJhbCAoJyBvciBcIilcclxuICAgICAgaWYgKGNoYXIgPT09ICdcIicgfHwgY2hhciA9PT0gXCInXCIpIHtcclxuICAgICAgICBpblN0cmluZyA9IGNoYXI7IC8vIEVudGVyIHN0cmluZyBzdGF0ZSwgcmVtZW1iZXJpbmcgdGhlIHF1b3RlIHR5cGVcclxuICAgICAgICBjbGVhbmVkQ29kZSArPSBjaGFyOyAvLyBBZGQgdGhlIG9wZW5pbmcgcXVvdGVcclxuICAgICAgICBpKys7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBzdGFydCBvZiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsICcvJ1xyXG4gICAgICAvLyBCYXNpYyBjaGVjazogYXNzdW1lcyAnLycgaW5kaWNhdGVzIGEgcmVnZXggc3RhcnQgaWYgbm90IHByZWNlZGVkIGJ5IG9wZXJhdG9ycy9rZXl3b3Jkc1xyXG4gICAgICAvLyBBIG1vcmUgcm9idXN0IHNvbHV0aW9uIHdvdWxkIHJlcXVpcmUgbW9yZSBjb21wbGV4IHBhcnNpbmcuXHJcbiAgICAgIGlmIChjaGFyID09PSAnLycpIHtcclxuICAgICAgICAgIC8vIFZlcnkgYmFzaWMgY2hlY2sgdG8gZGlmZmVyZW50aWF0ZSBkaXZpc2lvbiBmcm9tIHJlZ2V4IHN0YXJ0LlxyXG4gICAgICAgICAgLy8gVGhpcyBtaWdodCBuZWVkIHJlZmluZW1lbnQgZm9yIGNvbXBsZXggY2FzZXMuXHJcbiAgICAgICAgICBjb25zdCBwcmV2TWVhbmluZ2Z1bENoYXIgPSBjbGVhbmVkQ29kZS50cmltKCkuc2xpY2UoLTEpO1xyXG4gICAgICAgICAgaWYgKHByZXZNZWFuaW5nZnVsQ2hhciA9PT0gJycgfHwgWycoJywgJywnLCAnPScsICc6JywgJ1snLCAnIScsICcmJywgJ3wnLCAnPycsICd7JywgJzsnLCAnXFxuJywgJ1xcciddLmluY2x1ZGVzKHByZXZNZWFuaW5nZnVsQ2hhcikpIHtcclxuICAgICAgICAgICAgICBpblJlZ0V4cCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgY2xlYW5lZENvZGUgKz0gY2hhcjtcclxuICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgLy8gSWYgbm9uZSBvZiB0aGUgYWJvdmUsIGl0J3MgcmVndWxhciBjb2RlOyBhZGQgaXQgdG8gdGhlIHJlc3VsdFxyXG4gICAgICBjbGVhbmVkQ29kZSArPSBjaGFyO1xyXG4gICAgICBpKys7XHJcbiAgICB9XHJcbiAgXHJcbiAgICAvLyBSZXR1cm4gdGhlIGFjY3VtdWxhdGVkIGNsZWFuZWQgY29kZSBzdHJpbmdcclxuICAgIHJldHVybiBjbGVhbmVkQ29kZTtcclxuICB9XHJcbiAgZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVGb2xkZXIoYXBwOiBBcHAsIGZvbGRlcl9zdHI6IHN0cmluZyk6IFRGb2xkZXIge1xyXG4gICAgZm9sZGVyX3N0ciA9IG5vcm1hbGl6ZVBhdGgoZm9sZGVyX3N0cik7XHJcblxyXG4gICAgY29uc3QgZm9sZGVyID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChmb2xkZXJfc3RyKTtcclxuICAgIGlmICghZm9sZGVyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yTWFuYWdlcihgRm9sZGVyIFwiJHtmb2xkZXJfc3RyfVwiIGRvZXNuJ3QgZXhpc3RgKTtcclxuICAgIH1cclxuICAgIGlmICghKGZvbGRlciBpbnN0YW5jZW9mIFRGb2xkZXIpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yTWFuYWdlcihgJHtmb2xkZXJfc3RyfSBpcyBhIGZpbGUsIG5vdCBhIGZvbGRlcmApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmb2xkZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlRmlsZShhcHA6IEFwcCwgZmlsZV9zdHI6IHN0cmluZyk6IFRGaWxlIHtcclxuICAgIGZpbGVfc3RyID0gbm9ybWFsaXplUGF0aChmaWxlX3N0cik7XHJcblxyXG4gICAgY29uc3QgZmlsZSA9IGFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZmlsZV9zdHIpO1xyXG4gICAgaWYgKCFmaWxlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yTWFuYWdlcihgRmlsZSBcIiR7ZmlsZV9zdHJ9XCIgZG9lc24ndCBleGlzdGApO1xyXG4gICAgfVxyXG4gICAgaWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvck1hbmFnZXIoYCR7ZmlsZV9zdHJ9IGlzIGEgZm9sZGVyLCBub3QgYSBmaWxlYCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZpbGU7XHJcbn1cclxuICBleHBvcnQgZnVuY3Rpb24gZ2V0RmlsZXNGcm9tRm9sZGVyKFxyXG4gICAgYXBwOiBBcHAsXHJcbiAgICBmb2xkZXJfc3RyOiBzdHJpbmdcclxuICApOiBBcnJheTxURmlsZT4ge1xyXG4gICAgY29uc3QgZm9sZGVyID0gcmVzb2x2ZUZvbGRlcihhcHAsIGZvbGRlcl9zdHIpO1xyXG5cclxuICAgIGNvbnN0IGZpbGVzOiBBcnJheTxURmlsZT4gPSBbXTtcclxuICAgIFZhdWx0LnJlY3Vyc2VDaGlsZHJlbihmb2xkZXIsIChmaWxlOiBUQWJzdHJhY3RGaWxlKSA9PiB7XHJcbiAgICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xyXG4gICAgICAgICAgICBmaWxlcy5wdXNoKGZpbGUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGZpbGVzLnNvcnQoKGEsIGIpID0+IHsgIFxyXG4gICAgICAgIHJldHVybiBhLnBhdGgubG9jYWxlQ29tcGFyZShiLnBhdGgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGZpbGVzO1xyXG59XHJcbiAgZXhwb3J0IGNsYXNzIFNjcmlwdGluZ1Rvb2xzIHtcclxuICAgIGFwcDogQXBwIHwgdW5kZWZpbmVkO1xyXG4gICAgcGx1Z2luOiBhbnk7IC8vRm9sZGVyVGFnUGx1Z2luO1xyXG4gICAgc2V0dGluZ3M6IEZyb250bWF0dGVyQXV0b21hdGVTZXR0aW5ncyB8IHVuZGVmaW5lZDtcclxuICAgIHJ1bGU6IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MgfCB1bmRlZmluZWQ7XHJcbiAgICBmcm9udG1hdHRlcjogYW55O1xyXG4gICAgY3VycmVudENvbnRlbnQ6IGFueTtcclxuICAgIGFjdGl2ZUZpbGU6IFRGaWxlIHwgdW5kZWZpbmVkO1xyXG4gICAga25vd25Qcm9wZXJ0aWVzOiBSZWNvcmQ8c3RyaW5nLCBQcm9wZXJ0eUluZm8+ID0ge307XHJcblxyXG4gICAgY29uc3RydWN0b3IoYXBwPzpBcHAsIHBsdWdpbj86YW55LCBzZXR0aW5ncz86RnJvbnRtYXR0ZXJBdXRvbWF0ZVNldHRpbmdzLCBydWxlPzogRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgZnJvbnRtYXR0ZXI/OiBhbnksIGFjdGl2ZUZpbGU/OiBURmlsZSkge1xyXG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xyXG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5nc1xyXG4gICAgICAgIHRoaXMucnVsZSA9IHJ1bGU7XHJcbiAgICAgICAgdGhpcy5mcm9udG1hdHRlciA9IGZyb250bWF0dGVyO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRmlsZSA9IGFjdGl2ZUZpbGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgZnJvbnRtYXR0ZXIgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZnJvbnRtYXR0ZXIgZGF0YS5cclxuICAgICAqL1xyXG4gICAgZ2V0RnJvbnRtYXR0ZXIoKSB7IFxyXG4gICAgICByZXR1cm4gdGhpcy5mcm9udG1hdHRlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZnJvbnRtYXR0ZXIgcHJvcGVydHkgZm9yIHRoZSBjdXJyZW50IGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmcm9udG1hdHRlciAtIFRoZSBmcm9udG1hdHRlciBvYmplY3QgdG8gYXNzaWduLlxyXG4gICAgICovXHJcbiAgICBzZXRGcm9udG1hdHRlcihmcm9udG1hdHRlcjphbnkpIHtcclxuICAgICAgICB0aGlzLmZyb250bWF0dGVyID0gZnJvbnRtYXR0ZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYSBwcm9wZXJ0eSBpbiB0aGUgZnJvbnRtYXR0ZXIgb2JqZWN0LiBJZiB0aGUgZnJvbnRtYXR0ZXIgZG9lcyBub3QgZXhpc3QsIGl0IGluaXRpYWxpemVzIGl0IGFzIGFuIGVtcHR5IG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIHByb3BlcnR5IG5hbWUgdG8gc2V0IGluIHRoZSBmcm9udG1hdHRlci5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBhc3NpZ24gdG8gdGhlIHNwZWNpZmllZCBwcm9wZXJ0eS5cclxuICAgICAqL1xyXG4gICAgc2V0RnJvbnRtYXR0ZXJQcm9wZXJ0eShrZXk6c3RyaW5nLCB2YWx1ZTphbnkpIHtcclxuICAgICAgaWYgKCF0aGlzLmZyb250bWF0dGVyKSB0aGlzLmZyb250bWF0dGVyID0ge307XHJcbiAgICAgIHRoaXMuZnJvbnRtYXR0ZXJba2V5XSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHZhbHVlIG9mIGEgc3BlY2lmaWVkIHByb3BlcnR5IGZyb20gdGhlIGZyb250bWF0dGVyIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHJldHJpZXZlIGZyb20gdGhlIGZyb250bWF0dGVyLlxyXG4gICAgICogQHJldHVybnMgVGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSBpbiB0aGUgZnJvbnRtYXR0ZXIsIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBrZXkgZG9lcyBub3QgZXhpc3QuXHJcbiAgICAgKi9cclxuICAgIGdldEZyb250bWF0dGVyUHJvcGVydHkoa2V5OnN0cmluZykge1xyXG4gICAgICByZXR1cm4gdGhpcy5mcm9udG1hdHRlcltrZXldXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGN1cnJlbnRseSBhY3RpdmUgZmlsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZmlsZSAtIFRoZSBmaWxlIHRvIHNldCBhcyBhY3RpdmUuIE11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgYFRGaWxlYC5cclxuICAgICAqL1xyXG4gICAgc2V0QWN0aXZlRmlsZShmaWxlOlRGaWxlKSB7XHJcbiAgICAgIHRoaXMuYWN0aXZlRmlsZSA9IGZpbGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnRseSBhY3RpdmUgZmlsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgYWN0aXZlIGZpbGUgb2JqZWN0LCBvciBgdW5kZWZpbmVkYCBpZiBubyBmaWxlIGlzIGFjdGl2ZS5cclxuICAgICAqL1xyXG4gICAgZ2V0QWN0aXZlRmlsZSgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlRmlsZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgY3VycmVudCBydWxlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBmcm9udG1hdHRlciBhdXRvbWF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBydWxlIC0gVGhlIHJ1bGUgc2V0dGluZ3MgdG8gYXBwbHksIHJlcHJlc2VudGVkIGJ5IGEgYEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3NgIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgc2V0UnVsZShydWxlOkZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MpIHtcclxuICAgICAgdGhpcy5ydWxlID0gcnVsZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IHJ1bGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5zdGFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIHJ1bGUgb2JqZWN0IG9yIHZhbHVlIHN0b3JlZCBpbiB0aGUgYHJ1bGVgIHByb3BlcnR5LlxyXG4gICAgICovXHJcbiAgICBnZXRSdWxlKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5ydWxlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYSBydWxlIGZ1bmN0aW9uIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBydWxlIHNldHRpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBydWxlIC0gT3B0aW9uYWwuIFRoZSBydWxlIHNldHRpbmdzIHRvIHVzZSBmb3IgcmV0cmlldmluZyB0aGUgcnVsZSBmdW5jdGlvbi5cclxuICAgICAqICAgICAgICAgICAgICAgSWYgbm90IHByb3ZpZGVkLCB0aGUgbWV0aG9kIHVzZXMgdGhlIGluc3RhbmNlJ3MgZGVmYXVsdCBydWxlLlxyXG4gICAgICogQHJldHVybnMgVGhlIHJ1bGUgZnVuY3Rpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQgcnVsZSBzZXR0aW5ncywgb3IgYHVuZGVmaW5lZGAgaWYgbm8gcnVsZSBpcyBmb3VuZC5cclxuICAgICAqL1xyXG4gICAgZ2V0UnVsZUZ1bmN0aW9uKHJ1bGU/OkZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MpIHtcclxuICAgICAgaWYgKCFydWxlKSBydWxlID0gdGhpcy5ydWxlO1xyXG4gICAgICBpZiAocnVsZSkge1xyXG4gICAgICAgIHJldHVybiBydWxlc01hbmFnZXIuZ2V0UnVsZUJ5SWQocnVsZS5jb250ZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IGNvbnRlbnQgdG8gdGhlIHByb3ZpZGVkIHZhbHVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb250ZW50IC0gVGhlIGNvbnRlbnQgdG8gc2V0IGFzIHRoZSBjdXJyZW50IGNvbnRlbnQuIENhbiBiZSBvZiBhbnkgdHlwZS5cclxuICAgICAqL1xyXG4gICAgc2V0Q3VycmVudENvbnRlbnQoY29udGVudDphbnkpIHtcclxuICAgICAgdGhpcy5jdXJyZW50Q29udGVudCA9IGNvbnRlbnQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBjb250ZW50IHN0b3JlZCBpbiB0aGUgaW5zdGFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIGN1cnJlbnQgY29udGVudC5cclxuICAgICAqL1xyXG4gICAgZ2V0Q3VycmVudENvbnRlbnQoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRDb250ZW50O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBzcGVjaWZpZWQgZnJvbnRtYXR0ZXIgcHJvcGVydHkgb2YgYSBnaXZlbiBmaWxlIHdpdGggbmV3IGNvbnRlbnQuXHJcbiAgICAgKlxyXG4gICAgICogSWYgbm8gZmlsZSBpcyBwcm92aWRlZCwgdGhlIGN1cnJlbnRseSBhY3RpdmUgZmlsZSBpcyB1c2VkLiBJZiBuZWl0aGVyIGlzIGF2YWlsYWJsZSwgdGhlIG1ldGhvZCByZXR1cm5zIGVhcmx5LlxyXG4gICAgICogVGhlIG1ldGhvZCBsb2dzIHRoZSB1cGRhdGUgb3BlcmF0aW9uIGFuZCBvbmx5IHN1cHBvcnRzIHVwZGF0aW5nIHByb3BlcnRpZXMgd2l0aCBwcmltaXRpdmUgdmFsdWVzIG9yIGFycmF5cy5cclxuICAgICAqIElmIGBuZXdDb250ZW50YCBpcyBhbiBvYmplY3QgKGJ1dCBub3QgYW4gYXJyYXkpLCBhIHdhcm5pbmcgaXMgaXNzdWVkIGFuZCB0aGUgdXBkYXRlIGlzIG5vdCBwZXJmb3JtZWQuXHJcbiAgICAgKiBUaGUgZmlsZSdzIG1vZGlmaWNhdGlvbiB0aW1lIChgbXRpbWVgKSBpcyBwcmVzZXJ2ZWQgYW5kIG5vdCBjaGFuZ2VkIGR1cmluZyB0aGUgdXBkYXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eSAtIFRoZSBmcm9udG1hdHRlciBwcm9wZXJ0eSB0byB1cGRhdGUuXHJcbiAgICAgKiBAcGFyYW0gbmV3Q29udGVudCAtIFRoZSBuZXcgdmFsdWUgdG8gYXNzaWduIHRvIHRoZSBwcm9wZXJ0eS4gT2JqZWN0cyAoZXhjZXB0IGFycmF5cykgYXJlIG5vdCBzdXBwb3J0ZWQuXHJcbiAgICAgKiBAcGFyYW0gZmlsZSAtIChPcHRpb25hbCkgVGhlIGZpbGUgd2hvc2UgZnJvbnRtYXR0ZXIgc2hvdWxkIGJlIHVwZGF0ZWQuIElmIG9taXR0ZWQsIHRoZSBhY3RpdmUgZmlsZSBpcyB1c2VkLlxyXG4gICAgICovXHJcbiAgICB1cGRhdGVGcm9udG1hdHRlcihwcm9wZXJ0eTpzdHJpbmcsIG5ld0NvbnRlbnQ6YW55LCBmaWxlPzpURmlsZSkge1xyXG4gICAgICB0aGlzLnBsdWdpbi5wcmV2ZW50T25NZXRhZGF0YUNoYW5nZSA9IHRydWU7IC8vIHByZXZlbnQgdGhlIG9uTWV0YWRhdGFDaGFuZ2UgZXZlbnQgdG8gYmUgdHJpZ2dlcmVkXHJcbiAgICAgIGlmICghdGhpcy5hcHApIHJldHVybjtcclxuICAgICAgaWYgKCFmaWxlKSBmaWxlID0gdGhpcy5hY3RpdmVGaWxlO1xyXG4gICAgICBpZiAoIWZpbGUpIHJldHVybjtcclxuICAgICAgdGhpcy5hcHAuZmlsZU1hbmFnZXIucHJvY2Vzc0Zyb250TWF0dGVyKGZpbGUsIChmcm9udG1hdHRlcikgPT4ge1xyXG4gICAgICAgIGxvZ2dlci5sb2coREVCVUcsYHVwZGF0ZUZyb250bWF0dGVyICcke2ZpbGUucGF0aH0nIGZyb250bWF0dGVyICcke3Byb3BlcnR5fScgdG8gJyR7bmV3Q29udGVudC50b1N0cmluZygpfSdgKTtcclxuICAgICAgICBpZiAodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG5ld0NvbnRlbnQpKSB7XHJcbiAgICAgICAgICBsb2dnZXIubG9nKFdBUk5JTkcsYHVwZGF0ZUZyb250bWF0dGVyICcke2ZpbGUucGF0aH0nfCcke3Byb3BlcnR5fScgb2JqZWN0IG5vdCBzdXBwb3J0ZWQhYCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGZyb250bWF0dGVyW3Byb3BlcnR5XSA9IG5ld0NvbnRlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LHsnbXRpbWUnOmZpbGUuc3RhdC5tdGltZX0pOyAvLyBkbyBub3QgY2hhbmdlIHRoZSBtb2RpZnkgdGltZS5cclxuICAgICAgdGhpcy5wbHVnaW4ucHJldmVudE9uTWV0YWRhdGFDaGFuZ2UgPSBmYWxzZTsgLy8gYWxsb3cgdGhlIG9uTWV0YWRhdGFDaGFuZ2UgZXZlbnQgdG8gYmUgdHJpZ2dlcmVkIGFnYWluXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERpc3BsYXlzIGEgY29uZmlybWF0aW9uIGRpYWxvZyB3aXRoIGN1c3RvbWl6YWJsZSBtZXNzYWdlLCB0aXRsZSwgYW5kIGJ1dHRvbiBsYWJlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBkaXNwbGF5IGluIHRoZSBjb25maXJtYXRpb24gZGlhbG9nLlxyXG4gICAgICogQHBhcmFtIHRpdGxlIC0gVGhlIHRpdGxlIG9mIHRoZSBkaWFsb2cgd2luZG93LiBEZWZhdWx0cyB0byAnQ29uZmlybScuXHJcbiAgICAgKiBAcGFyYW0gYnV0dG9uMSAtIFRoZSBsYWJlbCBmb3IgdGhlIGNvbmZpcm1hdGlvbiBidXR0b24uIERlZmF1bHRzIHRvICdZZXMnLlxyXG4gICAgICogQHBhcmFtIGJ1dHRvbjIgLSBUaGUgbGFiZWwgZm9yIHRoZSBjYW5jZWxsYXRpb24gYnV0dG9uLiBEZWZhdWx0cyB0byAnTm8nLlxyXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgdXNlciBjb25maXJtZWQgKHRydWUpIG9yIGNhbmNlbGxlZCAoZmFsc2UpLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBzaG93Q29uZmlybURpYWxvZyhtZXNzYWdlOnN0cmluZywgdGl0bGU6c3RyaW5nID0gJ0NvbmZpcm0nLCBidXR0b24xOnN0cmluZyA9ICdZZXMnLCBidXR0b24yOnN0cmluZyA9ICdObycpIHtcclxuICAgICAgY29uc3QgcmVzdWx0ID0gIGF3YWl0IG5ldyBBbGVydE1vZGFsKHRoaXMuYXBwISwgdGl0bGUsIG1lc3NhZ2UsIGJ1dHRvbjEsIGJ1dHRvbjIpLm9wZW5BbmRHZXRWYWx1ZSgpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0LnByb2NlZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyBhIHJ1bGUgZnJvbSB0aGUgcGx1Z2luJ3Mgc2V0dGluZ3MgYnkgaXRzIHVuaXF1ZSBpZGVudGlmaWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBydWxlSWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHJ1bGUgdG8gcmV0cmlldmUuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbWF0Y2hpbmcge0BsaW5rIEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3N9IG9iamVjdCBpZiBmb3VuZDsgb3RoZXJ3aXNlLCBgdW5kZWZpbmVkYC5cclxuICAgICAqL1xyXG4gICAgZ2V0UnVsZUJ5SWQocnVsZUlkOnN0cmluZyk6IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MgfCB1bmRlZmluZWQge1xyXG4gICAgICAgIGlmICghdGhpcy5zZXR0aW5ncyB8fCAhdGhpcy5zZXR0aW5ncy5mb2xkZXJDb25maWcgfHwgIXRoaXMuc2V0dGluZ3MuZm9sZGVyQ29uZmlnLnJvd3MpIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5zZXR0aW5ncy5mb2xkZXJDb25maWcucm93cy5maW5kKChyb3c6VHJlZUhpZXJhcmNoeVJvdykgPT4ge1xyXG4gICAgICAgICAgICBpZiAocm93LnBheWxvYWQgJiYgcm93LnBheWxvYWQuaWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByb3cucGF5bG9hZC5pZCA9PT0gcnVsZUlkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcm93Py5wYXlsb2FkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAqIEdldCB0aGUgb3B0aW9uIGNvbmZpZyBmb3IgYSBzcGVjaWZpYyBydWxlLiBPcHRpb25hbCB0aGUgc3BlY2lmaWMgcGFyYW1ldGVyIGJ5IHByb3ZpZGluZyBhbiBvcHRpb24gSUQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJ1bGVJZFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25JZF1cclxuICAgICAqIEByZXR1cm4geyp9IFxyXG4gICAgICovXHJcbiAgICBnZXRPcHRpb25Db25maWcocnVsZUlkOnN0cmluZ3x1bmRlZmluZWQsIG9wdGlvbklkPzpzdHJpbmcpe1xyXG4gICAgICBpZiAoIXJ1bGVJZCB8fCBydWxlSWQgPT09IHVuZGVmaW5lZCB8fCAhdGhpcy5zZXR0aW5ncyApIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIGNvbnN0IHJ1bGUgPSB0aGlzLmdldFJ1bGVCeUlkKHJ1bGVJZCk7XHJcbiAgICAgIGlmIChydWxlICYmIHJ1bGUuaGFzT3duUHJvcGVydHkoJ29wdGlvbnNDb25maWcnKSkge1xyXG4gICAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgICBjb25zdCBvcHRpb25Db25maWcgPSBydWxlLm9wdGlvbnNDb25maWdbcnVsZUlkXVxyXG4gICAgICAgICAgaWYgKG9wdGlvbkNvbmZpZykge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9uSWQpIHtcclxuICAgICAgICAgICAgICBsb2dnZXIubG9nKFRSQUNFLGBnZXRPcHRpb25Db25maWc6ICR7cnVsZUlkfSBvcHRpb24gJyR7b3B0aW9uSWR9J2AsIHJ1bGUsIG9wdGlvbkNvbmZpZ1tvcHRpb25JZF0pO1xyXG4gICAgICAgICAgICAgIHJldHVybiBvcHRpb25Db25maWdbb3B0aW9uSWRdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJldHVybiBvcHRpb25Db25maWc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYWxsIG1hcmtkb3duIGZpbGVzIGluIHRoZSB2YXVsdCB3aG9zZSBwYXRocyBpbmNsdWRlIHRoZSBzcGVjaWZpZWQgbWF0Y2hpbmcgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBgbWF0Y2hpbmdgIHBhcmFtZXRlciBpcyBub3JtYWxpemVkIHRvIGVuc3VyZSBpdCBlbmRzIHdpdGggYSBzaW5nbGUgJy8nIGNoYXJhY3RlcixcclxuICAgICAqIGFuZCBpcyB1c2VkIHRvIGZpbHRlciBmaWxlcyB3aG9zZSBwYXRocyBjb250YWluIHRoaXMgc3Vic3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmb2xkZXJQYXRoIC0gVGhlIGZvbGRlciBwYXRoIG9yIHN1YnN0cmluZyB0byBtYXRjaCB3aXRoaW4gZmlsZSBwYXRocy5cclxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGBURmlsZWAgb2JqZWN0cyB3aG9zZSBwYXRocyBpbmNsdWRlIHRoZSBub3JtYWxpemVkIGBtYXRjaGluZ2Agc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBnZXRGaWxlc0luVmF1bHQoZm9sZGVyUGF0aDogc3RyaW5nKTogVEZpbGVbXSB7XHJcbiAgICAgICAgZm9sZGVyUGF0aCA9IGZvbGRlclBhdGgucmVwbGFjZSgvXlxcL3xcXC8kL2csIFwiXCIpICsgJy8nOyAvLyBFbnN1cmUgaXQgZW5kcyB3aXRoIGEgJy8nXHJcbiAgICAgICAgY29uc3QgZmlsZXMgPSB0aGlzLmFwcCEudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpOyAvLyBSZXRyaWV2ZSBhbGwgbWFya2Rvd24gZmlsZXNcclxuICAgICAgICBjb25zdCBtYXRjaGluZ0ZpbGVzID0gZmlsZXMuZmlsdGVyKGZpbGUgPT4gZmlsZSBpbnN0YW5jZW9mIFRGaWxlICYmIGZpbGUucGF0aC5pbmNsdWRlcyhmb2xkZXJQYXRoKSk7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoaW5nRmlsZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBtb2NrIGBURmlsZWAgb2JqZWN0IGZyb20gYSBnaXZlbiBmaWxlIHBhdGggc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIHBhcnNlcyB0aGUgcHJvdmlkZWQgcGF0aCB0byBjb25zdHJ1Y3QgYSBgVEZpbGVgLWxpa2Ugb2JqZWN0LFxyXG4gICAgICogZXh0cmFjdGluZyB0aGUgZmlsZSBuYW1lLCBleHRlbnNpb24sIGFuZCBiYXNlIG5hbWUuIFRoZSByZXR1cm5lZCBvYmplY3RcclxuICAgICAqIGNvbnRhaW5zIHBsYWNlaG9sZGVyIHZhbHVlcyBmb3IgZmlsZSBzdGF0aXN0aWNzIGFuZCBwYXJlbnQsIGFzIHRoZXNlIGRldGFpbHNcclxuICAgICAqIGFyZSB1bmtub3duLiBJZiB0aGUgaW5wdXQgcGF0aCBpcyBlbXB0eSBvciB1bmRlZmluZWQsIHRoZSBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBmaWxlIHBhdGggc3RyaW5nIHRvIGdlbmVyYXRlIHRoZSBtb2NrIGBURmlsZWAgZnJvbS5cclxuICAgICAqIEByZXR1cm5zIEEgbW9jayBgVEZpbGVgIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGZpbGUgYXQgdGhlIGdpdmVuIHBhdGgsIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBwYXRoIGlzIGludmFsaWQuXHJcbiAgICAgKi9cclxuICAgIGdldE1vY2tGaWxlRnJvbVBhdGgocGF0aDogc3RyaW5nfHVuZGVmaW5lZCk6IFRGaWxlIHx1bmRlZmluZWQge1xyXG4gICAgICBpZiAoIXBhdGgpIHJldHVybiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICBsZXQgb2xkRmlsZTpURmlsZTtcclxuICAgICAgbGV0IG9sZEZpbGVQYXJ0cyA9IHBhdGguc3BsaXQoJy8nKTtcclxuICAgICAgb2xkRmlsZSA9IHtcclxuICAgICAgICBwYXRoOiBwYXRoLFxyXG4gICAgICAgIGV4dGVuc2lvbjogb2xkRmlsZVBhcnRzW29sZEZpbGVQYXJ0cy5sZW5ndGgtMV0uc3BsaXQoJy4nKVsxXSxcclxuICAgICAgICBuYW1lOiBvbGRGaWxlUGFydHNbb2xkRmlsZVBhcnRzLmxlbmd0aC0xXSxcclxuICAgICAgICBzdGF0OiB7bXRpbWU6IDAsIGN0aW1lOiAwLCBzaXplOiAwfSwgLy8gc3RhdHMgYXJlIHVua25vd25cclxuICAgICAgICBiYXNlbmFtZTogdGhpcy5yZW1vdmVBbGxFeHRlbnNpb25zKG9sZEZpbGVQYXJ0c1tvbGRGaWxlUGFydHMubGVuZ3RoLTFdKSxcclxuICAgICAgICB2YXVsdDogdGhpcy5hcHAhLnZhdWx0LFxyXG4gICAgICAgIHBhcmVudDogbnVsbCAvLyBwYXJlbnQgaXMgdW5rbm93blxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gb2xkRmlsZVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYSBgVEZpbGVgIG9iamVjdCBmcm9tIGEgZ2l2ZW4gZmlsZSBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIGZpbGUgcGF0aCB0byBzZWFyY2ggZm9yLiBJZiBgdW5kZWZpbmVkYCwgdGhlIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAuXHJcbiAgICAgKiBAcGFyYW0gZmlsZXNDaGVjayAtIEFuIG9wdGlvbmFsIGFycmF5IG9mIGBURmlsZWAgb2JqZWN0cyB0byBzZWFyY2ggd2l0aGluLiBJZiBub3QgcHJvdmlkZWQsIGFsbCBtYXJrZG93biBmaWxlcyBpbiB0aGUgdmF1bHQgYXJlIHVzZWQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbWF0Y2hpbmcgYFRGaWxlYCBpZiBmb3VuZDsgb3RoZXJ3aXNlLCBgdW5kZWZpbmVkYC5cclxuICAgICAqL1xyXG4gICAgZ2V0VEZpbGVGcm9tUGF0aChwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQsIGZpbGVzQ2hlY2s6IFRGaWxlW10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQpIHtcclxuICAgICAgaWYgKCFwYXRoKSByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICBjb25zdCBmaWxlcyA9IGZpbGVzQ2hlY2sgPyBmaWxlc0NoZWNrIDogdGhpcy5hcHAhLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKTsgLy8gUmV0cmlldmUgYWxsIG1hcmtkb3duIGZpbGVzXHJcbiAgICAgIGNvbnN0IG1hdGNoaW5nRmlsZXMgPSBmaWxlcy5maWx0ZXIoZmlsZSA9PiBcclxuICAgICAgICBmaWxlIGluc3RhbmNlb2YgVEZpbGUgJiYgXHJcbiAgICAgICAgZmlsZS5wYXRoLnRvTG9jYWxlTG93ZXJDYXNlKCkgPT09IHBhdGgudG9Mb2NhbGVMb3dlckNhc2UoKVxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gbWF0Y2hpbmdGaWxlcy5sZW5ndGggPiAwID8gbWF0Y2hpbmdGaWxlc1swXSA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBmaWxlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aCB1c2luZyB0aGUgY29udGVudCBmcm9tIGEgdGVtcGxhdGUgZmlsZS5cclxuICAgICAqIElmIHRoZSBmaWxlIGFscmVhZHkgZXhpc3RzLCByZXR1cm5zIHRoZSBleGlzdGluZyBmaWxlIGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgb25lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmaWxlTmFtZVdpdGhQYXRoIC0gVGhlIGZ1bGwgcGF0aCAoaW5jbHVkaW5nIGZpbGUgbmFtZSkgd2hlcmUgdGhlIG5ldyBmaWxlIHNob3VsZCBiZSBjcmVhdGVkLlxyXG4gICAgICogQHBhcmFtIHRlbXBsYXRlRmlsZVdpdGhQYXRoIC0gVGhlIGZ1bGwgcGF0aCB0byB0aGUgdGVtcGxhdGUgZmlsZSB3aG9zZSBjb250ZW50IHdpbGwgYmUgdXNlZC5cclxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBuZXdseSBjcmVhdGVkIGZpbGUgb3IgdGhlIGV4aXN0aW5nIGZpbGUgaWYgaXQgYWxyZWFkeSBleGlzdHMuXHJcbiAgICAgKiBAdGhyb3dzIHtFcnJvck1hbmFnZXJ9IElmIHRoZSBmb2xkZXIgcGF0aCBpcyBpbnZhbGlkLCBkb2VzIG5vdCBleGlzdCwgb3IgaXMgbm90IGEgZm9sZGVyLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBjcmVhdGVGaWxlRnJvbVBhdGgoZmlsZU5hbWVXaXRoUGF0aDpzdHJpbmcsIHRlbXBsYXRlRmlsZVdpdGhQYXRoOnN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gZmlsZU5hbWVXaXRoUGF0aC5yZXBsYWNlKC9eXFwvfFxcLyQvZywgXCJcIik7IC8vIFJlbW92ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzXHJcbiAgICAgICAgY29uc3QgdGVtcGxhdGVGaWxlID0gdGVtcGxhdGVGaWxlV2l0aFBhdGgucmVwbGFjZSgvXlxcL3xcXC8kL2csIFwiXCIpOyAvLyBSZW1vdmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlc1xyXG4gICAgICAgIGNvbnN0IGZvbGRlclBhdGggPSB0aGlzLmdldEZvbGRlckZyb21QYXRoKGZpbGVOYW1lKTtcclxuICAgICAgICBjb25zdCBmaWxlTmFtZU9ubHkgPSBmaWxlTmFtZS5zcGxpdCgnLycpLnBvcCgpIHx8IGZpbGVOYW1lOyAvLyBHZXQgdGhlIGxhc3QgcGFydCBvZiB0aGUgcGF0aCBhcyB0aGUgZmlsZSBuYW1lXHJcbiAgICAgICAgaWYgKCFmb2xkZXJQYXRoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvck1hbmFnZXIoYEludmFsaWQgZm9sZGVyIHBhdGg6IFwiJHtmb2xkZXJQYXRofVwiYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZvbGRlciA9IHRoaXMuYXBwIS52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZm9sZGVyUGF0aCkgYXMgVEZvbGRlcjtcclxuICAgICAgICBpZiAoIWZvbGRlcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JNYW5hZ2VyKGBGb2xkZXIgXCIke2ZvbGRlclBhdGh9XCIgZG9lc24ndCBleGlzdGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIShmb2xkZXIgaW5zdGFuY2VvZiBURm9sZGVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JNYW5hZ2VyKGAke2ZvbGRlclBhdGh9IGlzIGEgZmlsZSwgbm90IGEgZm9sZGVyYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRlbXBsYXRlQ29udGVudCA9IGF3YWl0IHRoaXMuYXBwIS52YXVsdC5yZWFkKHRoaXMuYXBwIS52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGVtcGxhdGVGaWxlKSBhcyBURmlsZSk7XHJcbiAgICAgICAgY29uc3QgZmlsZUV4aXN0cyA9IHRoaXMuYXBwIS52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZmlsZU5hbWVXaXRoUGF0aCkgYXMgVEZpbGU7XHJcbiAgICAgICAgaWYgKCFmaWxlRXhpc3RzKSB7XHJcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5hcHAhLnZhdWx0LmNyZWF0ZShmb2xkZXIucGF0aCArICcvJyArIGZpbGVOYW1lT25seSwgdGVtcGxhdGVDb250ZW50KTsgLy8gY3JlYXRlIHRoZSBmaWxlIGZyb20gdGhlIHRlbXBsYXRlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmaWxlRXhpc3RzOyAvLyByZXR1cm4gdGhlIGZpbGUgaWYgaXQgYWxyZWFkeSBleGlzdHNcclxuICAgIH07IC8vIGNyZWF0ZSB0aGUgZmlsZSBpZiBpdCBkb2VzIG5vdCBleGlzdFxyXG4gICAgLyoqXHJcbiAgICAgKiAqIEZldGNoZXMgY3VzdG9tIHByb3BlcnR5IGluZm9ybWF0aW9uIGZyb20gYWxsIG1hcmtkb3duIGZpbGVzIGluIHRoZSB2YXVsdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHsqfSBcclxuICAgICAqL1xyXG4gICAgZmV0Y2hDdXN0b21Qcm9wZXJ0eUluZm9zKGFwcDpBcHApOiBSZWNvcmQ8c3RyaW5nLCBQcm9wZXJ0eUluZm8+IHtcclxuICAgICAgICBjb25zdCBwcm9wZXJ0eUluZm9zOiBSZWNvcmQ8c3RyaW5nLCBQcm9wZXJ0eUluZm8+ID0ge307XHJcblxyXG4gICAgICAgIGNvbnN0IGZpbGVzID0gYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKTsgLy8gUmV0cmlldmUgYWxsIG1hcmtkb3duIGZpbGVzXHJcbiAgICAgICAgZmlsZXMuZm9yRWFjaChmaWxlID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk7XHJcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YT8uZnJvbnRtYXR0ZXIpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG1ldGFkYXRhLmZyb250bWF0dGVyKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wZXJ0eUluZm9zW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlJbmZvc1trZXldID0geyBuYW1lOiBrZXksIHR5cGU6ICd0ZXh0JyB9OyAvLyBEZWZhdWx0IHR5cGUgYXMgJ3RleHQnXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5SW5mb3M7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZldGNoZXMga25vd24gcHJvcGVydGllcyBmcm9tIHRoZSBtZXRhZGF0YSBjYWNoZS5cclxuICAgICAqIElmIHRoZSBtZXRob2QgZ2V0QWxsUHJvcGVydHlJbmZvcyBpcyBub3QgYXZhaWxhYmxlLCBpdCBmYWxscyBiYWNrIHRvIGZldGNoQ3VzdG9tUHJvcGVydHlJbmZvcy5cclxuICAgICAqIEBwYXJhbSBhcHAgVGhlIE9ic2lkaWFuIGFwcCBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZmV0Y2hLbm93blByb3BlcnRpZXMoYXBwOkFwcCkge1xyXG4gICAgICBsZXQgcHJvcGVydHlJbmZvczogUmVjb3JkPHN0cmluZywgUHJvcGVydHlJbmZvPiA9IHt9O1xyXG4gICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgIGlmICh0eXBlb2YgYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0QWxsUHJvcGVydHlJbmZvcyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgcHJvcGVydHlJbmZvcyA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEFsbFByb3BlcnR5SW5mb3MoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwcm9wZXJ0eUluZm9zID0gdGhpcy5mZXRjaEN1c3RvbVByb3BlcnR5SW5mb3MoYXBwKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBzb3J0IHRoZSBwcm9wZXJ0aWVzIGJ5IG5hbWVcclxuICAgICAgcHJvcGVydHlJbmZvcyA9IE9iamVjdC5mcm9tRW50cmllcyhcclxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHByb3BlcnR5SW5mb3MpLnNvcnQoKFtrZXlBXSwgW2tleUJdKSA9PiBrZXlBLmxvY2FsZUNvbXBhcmUoa2V5QikpXHJcbiAgICAgICk7XHJcbiAgICAgIC8vIHJlc3RvcmUgdG8ga2VlcCBwcm9wZXJ0aWVzIHRvIGNhc2Ugc2Vuc2l0aXZlXHJcbiAgICAgIHRoaXMua25vd25Qcm9wZXJ0aWVzID0ge307XHJcbiAgICAgIE9iamVjdC5rZXlzKHByb3BlcnR5SW5mb3MpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICB0aGlzLmtub3duUHJvcGVydGllc1twcm9wZXJ0eUluZm9zW2tleV0ubmFtZV0gPSBwcm9wZXJ0eUluZm9zW2tleV07XHJcbiAgICAgIH0pO1xyXG4gICAgICBsb2dnZXIubG9nKERFQlVHLHRoaXMua25vd25Qcm9wZXJ0aWVzKTtcclxuICAgICAgcmV0dXJuIHRoaXMua25vd25Qcm9wZXJ0aWVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGtub3duIHByb3BlcnRpZXMsIGluaXRpYWxpemluZyB0aGVtIGlmIHRoZXkgaGF2ZSBub3QgYmVlbiBsb2FkZWQgeWV0LlxyXG4gICAgICogSWYgdGhlIHByb3BlcnRpZXMgYXJlIG5vdCBhbHJlYWR5IGNhY2hlZCwgdGhpcyBtZXRob2QgZmV0Y2hlcyB0aGVtIHVzaW5nIGBmZXRjaEN1c3RvbVByb3BlcnR5SW5mb3NgXHJcbiAgICAgKiBhbmQgc3RvcmVzIHRoZW0gZm9yIGZ1dHVyZSBhY2Nlc3MuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIGNhY2hlZCBvciBuZXdseSBmZXRjaGVkIGtub3duIHByb3BlcnRpZXMuXHJcbiAgICAgKi9cclxuICAgIGdldEtub3duUHJvcGVydGllcygpIHtcclxuICAgICAgICBpZiAoIXRoaXMua25vd25Qcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMua25vd25Qcm9wZXJ0aWVzID0gdGhpcy5mZXRjaEN1c3RvbVByb3BlcnR5SW5mb3ModGhpcy5hcHAhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMua25vd25Qcm9wZXJ0aWVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRyYWN0cyB0aGUgcGF0aCBhbmQgdGl0bGUgZnJvbSBhIGdpdmVuIGxpbmsgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBpbnB1dCBsaW5rIGlzIGV4cGVjdGVkIHRvIGJlIGluIHRoZSBmb3JtYXQgYFtbcGF0aHx0aXRsZV1dYCBvciBgW1twYXRoXV1gLlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiByZW1vdmVzIHNxdWFyZSBicmFja2V0cywgc3BsaXRzIHRoZSBsaW5rIGJ5IHRoZSBgfGAgY2hhcmFjdGVyLFxyXG4gICAgICogYW5kIGRldGVybWluZXMgdGhlIHBhdGggYW5kIHRpdGxlLiBJZiB0aGUgdGl0bGUgaXMgbm90IHByb3ZpZGVkLCB0aGUgcGF0aCBpc1xyXG4gICAgICogdXNlZCBhcyB0aGUgdGl0bGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxpbmsgLSBUaGUgbGluayBzdHJpbmcgdG8gZXh0cmFjdCBwYXJ0cyBmcm9tLCB0eXBpY2FsbHkgaW4gdGhlIGZvcm1hdCBgW1twYXRofHRpdGxlXV1gIG9yIGBbW3BhdGhdXWAuXHJcbiAgICAgKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgYHBhdGhgIGFuZCBgdGl0bGVgIGV4dHJhY3RlZCBmcm9tIHRoZSBsaW5rLlxyXG4gICAgICovXHJcbiAgICBleHRyYWN0TGlua1BhcnRzKGxpbms6IHN0cmluZyk6IHsgcGF0aDogc3RyaW5nOyB0aXRsZTogc3RyaW5nIH0ge1xyXG4gICAgICAvLyBSZW1vdmUgYWxsIHNxdWFyZSBicmFja2V0cyBmcm9tIHRoZSBzdHJpbmdcclxuICAgICAgY29uc3QgY2xlYW5lZExpbmsgPSBsaW5rLnJlcGxhY2UoL1tcXFtcXF1dL2csIFwiXCIpO1xyXG4gIFxyXG4gICAgICAvLyBTcGxpdCB0aGUgc3RyaW5nIGJ5IHRoZSBcInxcIiBjaGFyYWN0ZXJcclxuICAgICAgY29uc3QgcGFydHMgPSBjbGVhbmVkTGluay5zcGxpdChcInxcIik7XHJcbiAgXHJcbiAgICAgIC8vIElmIG9ubHkgb25lIHBhcnQgZXhpc3RzLCB1c2UgaXQgYXMgYm90aCBwYXRoIGFuZCB0aXRsZVxyXG4gICAgICBjb25zdCBwYXRoID0gcGFydHNbMF0udHJpbSgpO1xyXG4gICAgICBjb25zdCB0aXRsZSA9IHBhcnRzLmxlbmd0aCA+IDEgPyBwYXJ0c1sxXS50cmltKCkgOiBwYXRoO1xyXG4gICAgICAvL2xvZ2dlci5sb2coREVCVUcsYGV4dHJhY3RMaW5rUGFydHMoJHtsaW5rfSkgLT4gcGF0aDogJHtwYXRofSwgdGl0bGU6ICR7dGl0bGV9YCk7XHJcbiAgICAgIHJldHVybiB7IHBhdGgsIHRpdGxlIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4dHJhY3RzIHRoZSBwYXRoLCB0aXRsZSwgYW5kIGZpbGUgbmFtZSBmcm9tIGEgZ2l2ZW4gZmlsZSBsaW5rIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBTcGxpdHMgdGhlIGlucHV0IHN0cmluZyBieSB0aGUgXCIvXCIgY2hhcmFjdGVyIHRvIHNlcGFyYXRlIHRoZSBmaWxlIG5hbWUgZnJvbSBpdHMgcGF0aC5cclxuICAgICAqIFRoZSB0aXRsZSBpcyBkZXJpdmVkIGZyb20gdGhlIGZpbGUgbmFtZSBieSByZW1vdmluZyBhbGwgZXh0ZW5zaW9ucyBhbmQgdHJpbW1pbmcgd2hpdGVzcGFjZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGluayAtIFRoZSBmaWxlIGxpbmsgc3RyaW5nIHRvIGV4dHJhY3QgcGFydHMgZnJvbS5cclxuICAgICAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nOlxyXG4gICAgICogICAtIGBwYXRoYDogVGhlIGRpcmVjdG9yeSBwYXRoIHBvcnRpb24gb2YgdGhlIGxpbmsgKGV4Y2x1ZGluZyB0aGUgZmlsZSBuYW1lKS5cclxuICAgICAqICAgLSBgdGl0bGVgOiBUaGUgZmlsZSBuYW1lIHdpdGhvdXQgZXh0ZW5zaW9ucyBhbmQgdHJpbW1lZC5cclxuICAgICAqICAgLSBgZmlsZU5hbWVgOiBUaGUgZnVsbCBmaWxlIG5hbWUgKHdpdGggZXh0ZW5zaW9ucywgaWYgYW55KS5cclxuICAgICAqL1xyXG4gICAgZXh0cmFjdFBhdGhQYXJ0cyhsaW5rOiBzdHJpbmcpOiB7IHBhdGg6IHN0cmluZzsgdGl0bGU6IHN0cmluZzsgZmlsZU5hbWU6IHN0cmluZyB9IHtcclxuIFxyXG4gICAgICAvLyBTcGxpdCB0aGUgc3RyaW5nIGJ5IHRoZSBcIi9cIiBjaGFyYWN0ZXJcclxuICAgICAgY29uc3QgcGFydHMgPSBsaW5rLnNwbGl0KFwiL1wiKTtcclxuICBcclxuICAgICAgLy8gSWYgb25seSBvbmUgcGFydCBleGlzdHMsIHVzZSBpdCBhcyBib3RoIHBhdGggYW5kIHRpdGxlXHJcbiAgICAgIGNvbnN0IGZpbGVOYW1lID0gcGFydHMucG9wKCkgfHwgXCJcIjtcclxuICAgICAgY29uc3QgdGl0bGUgPSB0aGlzLnJlbW92ZUFsbEV4dGVuc2lvbnMoZmlsZU5hbWUpLnRyaW0oKTtcclxuICAgICAgY29uc3QgcGF0aCA9IHBhcnRzLmpvaW4oXCIvXCIpLnRyaW0oKTtcclxuICAgICAgLy9sb2dnZXIubG9nKERFQlVHLGBleHRyYWN0TGlua1BhcnRzKCR7bGlua30pIC0+IHBhdGg6ICR7cGF0aH0sIHRpdGxlOiAke3RpdGxlfWApO1xyXG4gICAgICByZXR1cm4geyBwYXRoLCB0aXRsZSwgZmlsZU5hbWUgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgb25lIG9yIG1vcmUgbGVhZGluZyBzbGFzaGVzIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhdGggLSBUaGUgaW5wdXQgc3RyaW5nIGZyb20gd2hpY2ggdG8gcmVtb3ZlIGxlYWRpbmcgc2xhc2hlcy5cclxuICAgICAqIEByZXR1cm5zIFRoZSBpbnB1dCBzdHJpbmcgd2l0aG91dCBhbnkgbGVhZGluZyBzbGFzaGVzLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVMZWFkaW5nU2xhc2gocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXlxcLysvLCBcIlwiKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW5zdXJlcyB0aGF0IHRoZSBnaXZlbiBwYXRoIHN0cmluZyBzdGFydHMgd2l0aCBhIGxlYWRpbmcgc2xhc2ggKCcvJykuXHJcbiAgICAgKiBJZiB0aGUgcGF0aCBhbHJlYWR5IGJlZ2lucyB3aXRoIGEgc2xhc2gsIGl0IGlzIHJldHVybmVkIHVuY2hhbmdlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBpbnB1dCBwYXRoIHN0cmluZyB0byBtb2RpZnkuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgcGF0aCBzdHJpbmcgZ3VhcmFudGVlZCB0byBzdGFydCB3aXRoIGEgbGVhZGluZyBzbGFzaC5cclxuICAgICAqL1xyXG4gICAgYWRkTGVhZGluZ1NsYXNoKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL14oPyFcXC8pLywgXCIvXCIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiBhIHN0cmluZyBjb21wbGllcyB3aXRoIElTTyBTdGFuZGFyZFxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0gc3RyIEFueSBzdHJpbmdcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gbG9vayBmb3JcclxuICAgICAqIEByZXR1cm5zIFxyXG4gICAgICovXHJcbiAgICBpc0lTT1N0cmluZyhcclxuICAgICAgc3RyOiBzdHJpbmcsXHJcbiAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICB3aXRoTWlsbGlzZWNvbmRzPzogYm9vbGVhbjtcclxuICAgICAgICB3aXRoVGltZXpvbmU/OiBib29sZWFuO1xyXG4gICAgICAgIHdpdGhUaW1lPzogYm9vbGVhbjtcclxuICAgICAgICB3aXRoRGF0ZT86IGJvb2xlYW47IFxyXG4gICAgICB9ID0ge31cclxuICAgICk6IGJvb2xlYW4ge1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgd2l0aE1pbGxpc2Vjb25kcyA9IGZhbHNlLFxyXG4gICAgICAgIHdpdGhUaW1lem9uZSA9IGZhbHNlLFxyXG4gICAgICAgIHdpdGhUaW1lID0gdHJ1ZSxcclxuICAgICAgICB3aXRoRGF0ZSA9IHRydWUsIFxyXG4gICAgICB9ID0gb3B0aW9ucztcclxuICAgIFxyXG4gICAgICBsZXQgZGF0ZVJlZ2V4U3RyID0gXCJeKD86XFxcXGR7NH0tKD86MFsxLTldfDFbMC0yXSktKD86MFsxLTldfFsxMl1cXFxcZHwzWzAxXSkpXCI7XHJcbiAgICAgIGxldCB0aW1lUmVnZXhTdHIgPSBcIig/OlQoPzpbMDFdXFxcXGR8MlswLTNdKTpbMC01XVxcXFxkOlswLTVdXFxcXGRcIjtcclxuICAgIFxyXG4gICAgICBpZiAod2l0aE1pbGxpc2Vjb25kcykge1xyXG4gICAgICAgIHRpbWVSZWdleFN0ciArPSBcIlxcXFwuXFxcXGR7M31cIjtcclxuICAgICAgfVxyXG4gICAgXHJcbiAgICAgIGlmICh3aXRoVGltZXpvbmUpIHtcclxuICAgICAgICB0aW1lUmVnZXhTdHIgKz0gXCIoPzpafFsrLV0oPzpbMDFdXFxcXGR8MlswLTNdKTpbMC01XVxcXFxkKT8pP1wiO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRpbWVSZWdleFN0ciArPSBcIik/XCI7XHJcbiAgICAgIH1cclxuICAgIFxyXG4gICAgICBsZXQgcmVnZXhTdHIgPSBcIlwiO1xyXG4gICAgICBpZiAod2l0aERhdGUgJiYgd2l0aFRpbWUpIHtcclxuICAgICAgICByZWdleFN0ciA9IGAke2RhdGVSZWdleFN0cn0ke3RpbWVSZWdleFN0cn0kYDtcclxuICAgICAgfSBlbHNlIGlmICh3aXRoRGF0ZSkge1xyXG4gICAgICAgIHJlZ2V4U3RyID0gYCR7ZGF0ZVJlZ2V4U3RyfSRgO1xyXG4gICAgICB9IGVsc2UgaWYgKHdpdGhUaW1lKSB7XHJcbiAgICAgICAgcmVnZXhTdHIgPSBgXiR7dGltZVJlZ2V4U3RyLnNsaWNlKDQpfSRgOyBcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7IFxyXG4gICAgICB9XHJcbiAgICBcclxuICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4U3RyKTtcclxuICAgICAgcmV0dXJuIHJlZ2V4LnRlc3Qoc3RyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJ5IHRvIGNvbnZlcnQgQW55IFR5cGVzIHRvIGEgc3BlY2lmaWMgVHlwZVxyXG4gICAgICogQHBhcmFtIGlucHV0IFxyXG4gICAgICogQHBhcmFtIHR5cGVTdHJpbmcgJ3N0cmluZycgfCAnbnVtYmVyJyB8ICdib29sZWFuJyB8ICdzdHJpbmdbXSdcclxuICAgICAqIEByZXR1cm5zIFxyXG4gICAgICovXHJcbiAgICB0cnlDb252ZXJ0KGlucHV0OiBhbnksIHR5cGVTdHJpbmc6ICdzdHJpbmcnIHwgJ251bWJlcicgfCAnYm9vbGVhbicgfCAnc3RyaW5nW10nKTogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IHN0cmluZ1tdIHwgdW5kZWZpbmVkIHtcclxuICAgICAgc3dpdGNoICh0eXBlU3RyaW5nKSB7XHJcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcclxuICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgICAgIGNvbnN0IG51bSA9IE51bWJlcihpbnB1dCk7XHJcbiAgICAgICAgICBpZiAoIWlzTmFOKG51bSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICAgIHJldHVybiBpbnB1dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGxvd2VyVmFsdWUgPSBpbnB1dC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgIGlmIChsb3dlclZhbHVlID09PSAndHJ1ZScpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAobG93ZXJWYWx1ZSA9PT0gJ2ZhbHNlJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIGNhc2UgJ3N0cmluZ1tdJzpcclxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSAmJiBpbnB1dC5ldmVyeShpdGVtID0+IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIFxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3JtYXRzIGEgZ2l2ZW4gdGV4dCBzdHJpbmcgdG8gYmUgc2FmZSBmb3IgdXNlIGluIFlBTUwgYnkgcmVwbGFjaW5nIHNwZWNpYWwgY2hhcmFjdGVycy5cclxuICAgICAqXHJcbiAgICAgKiBSZXBsYWNlcyBhbGwgY2hhcmFjdGVycyB0aGF0IGFyZSBub3QgYWxwaGFudW1lcmljLCBkYXNoLCB1bmRlcnNjb3JlLCBzbGFzaCwgb3IgY2VydGFpbiBhY2NlbnRlZCBjaGFyYWN0ZXJzXHJcbiAgICAgKiB3aXRoIGEgc3BlY2lmaWVkIHJlcGxhY2VtZW50IHN0cmluZy4gSWYgbm8gcmVwbGFjZW1lbnQgc3RyaW5nIGlzIHByb3ZpZGVkLCBpdCB1c2VzIHRoZSB2YWx1ZSBmcm9tIHNldHRpbmdzLFxyXG4gICAgICogb3IgZGVmYXVsdHMgdG8gYCctJ2AuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRleHQgLSBUaGUgaW5wdXQgc3RyaW5nIHRvIGZvcm1hdC5cclxuICAgICAqIEBwYXJhbSByZXBsYWNlQnkgLSBPcHRpb25hbC4gVGhlIHN0cmluZyB0byByZXBsYWNlIHNwZWNpYWwgY2hhcmFjdGVycyB3aXRoLiBJZiBub3QgcHJvdmlkZWQsIHVzZXMgdGhlIHZhbHVlIGZyb20gc2V0dGluZ3Mgb3IgYCctJ2AuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZm9ybWF0dGVkIHN0cmluZyBzYWZlIGZvciBZQU1MIHVzYWdlLlxyXG4gICAgICovXHJcbiAgICBmb3JtYXRUb1lBTUxTYXZlU3RyaW5nKHRleHQ6c3RyaW5nLCByZXBsYWNlQnk6c3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkKTpzdHJpbmcge1xyXG4gICAgICBsZXQgcmVwbGFjZVN0cmluZyA9ICctJztcclxuICAgICAgaWYgKCFyZXBsYWNlQnkgJiYgdGhpcy5zZXR0aW5ncykge1xyXG4gICAgICAgIHJlcGxhY2VTdHJpbmcgPSB0aGlzLnNldHRpbmdzLnNwZWNpYWxDaGFyUmVwbGFjZW1lbnQgfHwgJy0nO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChyZXBsYWNlQnkpIHJlcGxhY2VTdHJpbmcgPSByZXBsYWNlQnk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRleHQucmVwbGFjZSgvW15hLXpBLVowLTlcXC1fXFwvXHUwMEU0XHUwMEY2XHUwMEZDXHUwMERGXHUwMEM0XHUwMEQ2XHUwMERDXHUwMEUxXHUwMEU5XHUwMEVEXHUwMEYzXHUwMEZBXHUwMEZEXHUwMEMxXHUwMEM5XHUwMENEXHUwMEQzXHUwMERBXHUwMEREXHUwMEUwXHUwMEU4XHUwMEVDXHUwMEYyXHUwMEY5XHUwMEMwXHUwMEM4XHUwMENDXHUwMEQyXHUwMEQ5XHUwMEUyXHUwMEVBXHUwMEVFXHUwMEY0XHUwMEZCXHUwMEMyXHUwMENBXHUwMENFXHUwMEQ0XHUwMERCXHUwMEUzXHUwMEYxXHUwMEY1XHUwMEMzXHUwMEQxXHUwMEQ1XS9nLCByZXBsYWNlU3RyaW5nKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIHRvIGEgWUFNTC1zYWZlIGZvcm1hdCBieSBhZGRpbmcgcXVvdGVzIHdoZW4gbmVjZXNzYXJ5LlxyXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBzdHJpbmcsIGJvb2xlYW4sIG51bWJlciBvciBhcnJheSB0byBtYWtlIFlBTUwtc2FmZVxyXG4gICAgICogQHJldHVybnMgVGhlIHNhZmVseSBxdW90ZWQgc3RyaW5nIHdoZW4gbmVlZGVkLCBvciB0aGUgb3JpZ2luYWwgc3RyaW5nIGlmIHNhZmVcclxuICAgICAqL1xyXG4gICAgdG9ZYW1sU2FmZVN0cmluZyhpbnB1dDogc3RyaW5nfG51bWJlcnxib29sZWFufHN0cmluZ1tdKTogc3RyaW5nfG51bWJlcnxzdHJpbmdbXSB7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgIGlucHV0LmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICBpbnB1dFtpbmRleF0gPSB0aGlzLnRvWWFtbFNhZmVTdHJpbmcoaXRlbSkudG9TdHJpbmcoKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIHJldHVybiBpbnB1dDtcclxuICAgICAgfVxyXG4gICAgICBzd2l0Y2ggKHR5cGVvZiBpbnB1dCkge1xyXG4gICAgICAgIGNhc2UgJ251bWJlcic6IHJldHVybiBpbnB1dDtcclxuICAgICAgICBjYXNlICdib29sZWFuJzogcmV0dXJuIGlucHV0ID8gJ3RydWUnIDogJ2ZhbHNlJztcclxuICAgICAgICBjYXNlICdzdHJpbmcnOlxyXG4gICAgICAgICAgLy8gVHJpbSB3aGl0ZXNwYWNlIGZpcnN0XHJcbiAgICAgICAgICBjb25zdCB0cmltbWVkID0gaW5wdXQudHJpbSgpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBFbXB0eSBzdHJpbmdzIG5lZWQgcXVvdGVzXHJcbiAgICAgICAgICBpZiAodHJpbW1lZCA9PT0gJycpIHJldHVybiAnXCJcIic7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIENoZWNrIGZvciBzcGVjaWFsIGNoYXJhY3RlcnMvcGF0dGVybnMgdGhhdCByZXF1aXJlIHF1b3RpbmdcclxuICAgICAgICAgIGNvbnN0IG5lZWRzUXVvdGVzID0gL1s6e31cXFtcXF0sJiojP3w8Pj0hJUBgXCInXFxcXF18XlstP1xcbl18W1xcc1xcbl18Xlt5WW5OXXxeWzAtOV18XlsrLV18Xih0cnVlfGZhbHNlfHllc3xub3xvbnxvZmYpJC9pLnRlc3QodHJpbW1lZCk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBzdHJpbmcgaXMgYWxyZWFkeSBwcm9wZXJseSBxdW90ZWRcclxuICAgICAgICAgIGNvbnN0IGlzQWxyZWFkeVF1b3RlZCA9ICh0cmltbWVkLnN0YXJ0c1dpdGgoJ1wiJykgJiYgdHJpbW1lZC5lbmRzV2l0aCgnXCInKSkgfHwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRyaW1tZWQuc3RhcnRzV2l0aChcIidcIikgJiYgdHJpbW1lZC5lbmRzV2l0aChcIidcIikpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAoIW5lZWRzUXVvdGVzICYmICFpc0FscmVhZHlRdW90ZWQpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gdHJpbW1lZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIHdlIG5lZWQgcXVvdGVzXHJcbiAgICAgICAgICAvLyBVc2UgZG91YmxlIHF1b3RlcyBhbmQgZXNjYXBlIGFueSBleGlzdGluZyBkb3VibGUgcXVvdGVzXHJcbiAgICAgICAgICBpZiAoIWlzQWxyZWFkeVF1b3RlZCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBgXCIke3RyaW1tZWQucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpfVwiYDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gSWYgYWxyZWFkeSBxdW90ZWQsIHJldHVybiBhcy1pc1xyXG4gICAgICAgICAgcmV0dXJuIHRyaW1tZWQ7XHJcbiAgICAgICAgZGVmYXVsdDogXHJcbiAgICAgICAgICBsb2dnZXIubG9nKEVSUk9SLGB0b1lhbWxTYWZlU3RyaW5nKCR7aW5wdXR9KSBpZiBvZiB0eXBlICcke3R5cGVvZiBpbnB1dH0nYCk7XHJcbiAgICAgICAgICByZXR1cm4gaW5wdXQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYW4gaW5wdXQgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MgaW50byBhIE1hcmtkb3duIExpbmsgZm9ybWF0LlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0gaW5wdXQgLSBUaGUgaW5wdXQgdG8gYmUgY29udmVydGVkLiBDYW4gYmUgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cclxuICAgICAqIEBwYXJhbSByZXBsYWNlU3BhY2VzIC0gT3B0aW9uYWwgcGFyYW1ldGVyIHRvIHNwZWNpZnkgYSByZXBsYWNlbWVudCBmb3Igc3BhY2VzIGluIHRoZSBwYXRoIG9yIHRpdGxlLlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICBJZiBwcm92aWRlZCwgc3BhY2VzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGlzIHZhbHVlLlxyXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgaW4gTWFya2Rvd24gTGluayBmb3JtYXQgaWYgdGhlIGlucHV0IGlzIGEgc2luZ2xlIHN0cmluZywgb3IgYSBjb25jYXRlbmF0ZWQgc3RyaW5nXHJcbiAgICAgKiAgICAgICAgICBvZiBNYXJrZG93biBMaW5rcyBpZiB0aGUgaW5wdXQgaXMgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cclxuICAgICAqIFxyXG4gICAgICogVGhlIE1hcmtkb3duIExpbmsgZm9ybWF0IGlzIGBbdGl0bGVdKHBhdGgpYCwgd2hlcmU6XHJcbiAgICAgKiAtIGBwYXRoYCBpcyB0aGUgZm9ybWF0dGVkIHBhdGggb2YgdGhlIGxpbmsuXHJcbiAgICAgKiAtIGB0aXRsZWAgaXMgdGhlIGZvcm1hdHRlZCB0aXRsZSBvZiB0aGUgbGluay5cclxuICAgICAqIFxyXG4gICAgICogSWYgdGhlIGlucHV0IGlzIGFuIGFycmF5LCBlYWNoIGVsZW1lbnQgaXMgY29udmVydGVkIHRvIGEgV2lraUxpbmsgYW5kIGpvaW5lZCB3aXRoIGEgY29tbWEuXHJcbiAgICAgKi9cclxuICAgIHRvTWFya2Rvd25MaW5rKGlucHV0OiBhbnksIHJlcGxhY2VTcGFjZXM/OiBzdHJpbmcpOiBzdHJpbmcgfCBzdHJpbmdbXSB7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgIHJldHVybiBpbnB1dC5tYXAoaXRlbSA9PiB0aGlzLnRvV2lraUxpbmsoaXRlbSkpLmpvaW4oJywgJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBjb25zdCB7IHBhdGgsIHRpdGxlLCBmaWxlTmFtZSB9ID0gdGhpcy5leHRyYWN0UGF0aFBhcnRzKGlucHV0KTtcclxuICAgICAgICBjb25zdCBmb3JtYXR0ZWRQYXRoID0gdGhpcy5yZXBsYWNlU3BhY2VzKGlucHV0LCByZXBsYWNlU3BhY2VzKTtcclxuICAgICAgICBjb25zdCBmb3JtYXR0ZWRUaXRsZSA9IHRoaXMucmVwbGFjZVNwYWNlcyh0aXRsZSwgcmVwbGFjZVNwYWNlcyk7XHJcbiAgICAgICAgcmV0dXJuIGBbWyR7Zm9ybWF0dGVkUGF0aH18JHtmb3JtYXR0ZWRUaXRsZX1dXWA7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGlucHV0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBhbiBpbnB1dCBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncyBpbnRvIGEgV2lraUxpbmsgZm9ybWF0IHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0gaW5wdXQgLSBUaGUgaW5wdXQgdG8gYmUgY29udmVydGVkLiBDYW4gYmUgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cclxuICAgICAqIEBwYXJhbSByZXBsYWNlU3BhY2VzIC0gT3B0aW9uYWwgcGFyYW1ldGVyIHRvIHNwZWNpZnkgYSByZXBsYWNlbWVudCBmb3Igc3BhY2VzIGluIHRoZSBwYXRoIG9yIHRpdGxlLlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICBJZiBwcm92aWRlZCwgc3BhY2VzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGlzIHZhbHVlLlxyXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgaW4gV2lraUxpbmsgZm9ybWF0IGlmIHRoZSBpbnB1dCBpcyBhIHNpbmdsZSBzdHJpbmcsIG9yIGEgY29uY2F0ZW5hdGVkIHN0cmluZ1xyXG4gICAgICogICAgICAgICAgb2YgV2lraUxpbmtzIGlmIHRoZSBpbnB1dCBpcyBhbiBhcnJheSBvZiBzdHJpbmdzLlxyXG4gICAgICogXHJcbiAgICAgKiBUaGUgV2lraUxpbmsgZm9ybWF0IGlzIGBbW2ZpbGVOYW1lXV1gLCB3aGVyZTpcclxuICAgICAqIC0gYGZpbGVOYW1lYCBpcyB0aGUgZm9ybWF0dGVkIHVuaXF1ZSBmaWxlTmFtZSBvZiB0aGUgbGluay5cclxuICAgICAqIFxyXG4gICAgICogSWYgdGhlIGlucHV0IGlzIGFuIGFycmF5LCBlYWNoIGVsZW1lbnQgaXMgY29udmVydGVkIHRvIGEgV2lraUxpbmsgYW5kIGpvaW5lZCB3aXRoIGEgY29tbWEuXHJcbiAgICAgKi9cclxuICAgIHRvV2lraUxpbmsoaW5wdXQ6IGFueSwgcmVwbGFjZVNwYWNlcyA9ICcgJyk6IHN0cmluZyB8IHN0cmluZ1tdIHtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0LmZsYXRNYXAoaXRlbSA9PiB0aGlzLnRvV2lraUxpbmsoaXRlbSkpO1xyXG4gICAgICAgIC8vcmV0dXJuIGlucHV0Lm1hcChpdGVtID0+IHRoaXMudG9XaWtpTGluayhpdGVtKSkuam9pbignLCAnKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGNvbnN0IHsgcGF0aCwgdGl0bGUgfSA9IHRoaXMuZXh0cmFjdExpbmtQYXJ0cyhpbnB1dCk7XHJcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkVGl0bGUgPSB0aGlzLnJlcGxhY2VTcGFjZXModGhpcy5yZW1vdmVBbGxFeHRlbnNpb25zKHRpdGxlKSwgcmVwbGFjZVNwYWNlcyk7XHJcbiAgICAgICAgcmV0dXJuIGBbWyR7Zm9ybWF0dGVkVGl0bGV9XV1gO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBpbnB1dDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVwbGFjZXMgYWxsIHdoaXRlc3BhY2UgY2hhcmFjdGVycyBpbiB0aGUgZ2l2ZW4gdGV4dCB3aXRoIGEgc3BlY2lmaWVkIHJlcGxhY2VtZW50IHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGV4dCAtIFRoZSBpbnB1dCBzdHJpbmcgaW4gd2hpY2ggc3BhY2VzIHdpbGwgYmUgcmVwbGFjZWQuXHJcbiAgICAgKiBAcGFyYW0gcmVwbGFjZUJ5IC0gT3B0aW9uYWwuIFRoZSBzdHJpbmcgdG8gcmVwbGFjZSBzcGFjZXMgd2l0aC4gSWYgbm90IHByb3ZpZGVkLCB1c2VzIHRoZSB2YWx1ZSBmcm9tIGB0aGlzLnNldHRpbmdzLnNwYWNlUmVwbGFjZW1lbnRgIG9yIGRlZmF1bHRzIHRvICdfJy5cclxuICAgICAqIEByZXR1cm5zIFRoZSBtb2RpZmllZCBzdHJpbmcgd2l0aCBzcGFjZXMgcmVwbGFjZWQgYnkgdGhlIHNwZWNpZmllZCByZXBsYWNlbWVudCBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIHJlcGxhY2VTcGFjZXModGV4dDpzdHJpbmcsIHJlcGxhY2VCeTpzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQpOnN0cmluZyB7XHJcbiAgICAgIGxldCByZXBsYWNlU3RyaW5nID0gJ18nO1xyXG4gICAgICBpZiAoIXJlcGxhY2VCeSAmJiB0aGlzLnNldHRpbmdzKSB7XHJcbiAgICAgICAgcmVwbGFjZVN0cmluZyA9IHRoaXMuc2V0dGluZ3Muc3BhY2VSZXBsYWNlbWVudCB8fCAnXyc7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKHJlcGxhY2VCeSkgcmVwbGFjZVN0cmluZyA9IHJlcGxhY2VCeTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9cXHMrL2csIHJlcGxhY2VTdHJpbmcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBBTEwgZmlsZSBleHRlbnNpb24ocykgZnJvbSBhIGdpdmVuIGZpbGUgbmFtZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZmlsZU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZmlsZSwgaW5jbHVkaW5nIGl0cyBleHRlbnNpb24uXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZmlsZSBuYW1lIHdpdGhvdXQgaXRzIGV4dGVuc2lvbi5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlQWxsRXh0ZW5zaW9ucyhmaWxlTmFtZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gZmlsZU5hbWUuc3BsaXQoJy4nKVswXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgbGFzdCBmaWxlIGV4dGVuc2lvbihzKSBmcm9tIGEgZ2l2ZW4gZmlsZSBuYW1lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmaWxlTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmaWxlLCBpbmNsdWRpbmcgaXRzIGV4dGVuc2lvbi5cclxuICAgICAqIEByZXR1cm5zIFRoZSBmaWxlIG5hbWUgd2l0aG91dCBpdHMgZXh0ZW5zaW9uLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVFeHRlbnNpb25zKGZpbGVOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGZpbGVOYW1lLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgcmVzdWx0LnBvcCgpOyAvLyByZW1vdmUgdGhlIGxhc3QgcGFydFxyXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSByZXR1cm4gZmlsZU5hbWU7IC8vIG5vIGV4dGVuc2lvblxyXG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbignLicpIHx8IGZpbGVOYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYSBnaXZlbiBzdHJpbmcgdG8gY2FtZWxDYXNlIGZvcm1hdC5cclxuICAgICAqXHJcbiAgICAgKiBTcGxpdHMgdGhlIGlucHV0IHRleHQgYnkgc3BhY2VzLCBsb3dlcmNhc2VzIHRoZSBmaXJzdCB3b3JkLFxyXG4gICAgICogYW5kIGNhcGl0YWxpemVzIHRoZSBmaXJzdCBsZXR0ZXIgb2YgZWFjaCBzdWJzZXF1ZW50IHdvcmQsXHJcbiAgICAgKiB0aGVuIGpvaW5zIHRoZW0gdG9nZXRoZXIgd2l0aG91dCBzcGFjZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRleHQgLSBUaGUgaW5wdXQgc3RyaW5nIHRvIGJlIGNvbnZlcnRlZC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBjYW1lbENhc2UgZm9ybWF0dGVkIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgZm9ybWF0VXBwZXJDYW1lbENhc2UodGV4dDpzdHJpbmcpOnN0cmluZyB7XHJcbiAgICAgIGxldCB0ZXh0UGFydHMgPSB0ZXh0LnNwbGl0KCcgJyk7XHJcbiAgICAgIGxldCBjb252ZXJ0ZWRUZXh0UGFydHM6c3RyaW5nW10gPSBbXTtcclxuICAgICAgdGV4dFBhcnRzLmZvckVhY2goKHRleHQsaW5kZXgpID0+IHtcclxuICAgICAgICBsZXQgbmV3VGV4dFBhcnQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgbmV3VGV4dFBhcnQgPSBuZXdUZXh0UGFydC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5ld1RleHRQYXJ0LnNsaWNlKDEpO1xyXG4gICAgICAgIGNvbnZlcnRlZFRleHRQYXJ0cy5wdXNoKG5ld1RleHRQYXJ0KTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBjb252ZXJ0ZWRUZXh0UGFydHMuam9pbignJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQgdGhlIHBhdGggdG8gYSBmaWxlIGZyb20gYSBzdHJpbmcgY29udGFpbmluZyB0aGUgZnVsbCBwYXJoL25hbWUgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBzdHJpbmdcclxuICAgICAqIEBwYXJhbSBzZXBhcmF0b3Igc3RyaW5nIGRlZmF1bHRzIHRvICcvJ1xyXG4gICAgICogQHJldHVybnMgc3RyaW5nXHJcbiAgICAgKi9cclxuICAgIGdldEZvbGRlckZyb21QYXRoIChwYXRoOnN0cmluZ3xudWxsfHVuZGVmaW5lZCwgc2VwYXJhdG9yID0gJy8nKSB7XHJcbiAgICAgICAgaWYgKHBhdGggPT09IG51bGwpIHJldHVybiBudWxsO1xyXG4gICAgICAgIGlmIChwYXRoID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFBhdGhQYXJ0cyA9IHBhdGguc3BsaXQoJy8nKTtcclxuICAgICAgICBjdXJyZW50UGF0aFBhcnRzLnBvcCgpOyAvLyByZW1vdmUgRmlsZSBuYW1lO1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50UGF0aFBhcnRzLmpvaW4oc2VwYXJhdG9yKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiByZW1vdmVzIGR1cGxpY2F0ZSBzdHJpbmdzIGluIGFuIGFycmF5IGFuZCBkZWxldGVzIGVtcHR5IHN0cmluZ3NcclxuICAgICAqIEBwYXJhbSBzdHJpbmdBcnJheSBcclxuICAgICAqIEByZXR1cm5zIFxyXG4gICAgICovXHJcbiAgICByZW1vdmVEdXBsaWNhdGVTdHJpbmdzKHN0cmluZ0FycmF5OiBzdHJpbmdbXSk6IHN0cmluZ1tdIHtcclxuICAgICAgaWYgKCFzdHJpbmdBcnJheSkgcmV0dXJuIFtdO1xyXG4gICAgICBjb25zdCB1bmlxdWVTdHJpbmdzU2V0ID0gbmV3IFNldDxzdHJpbmc+KHN0cmluZ0FycmF5KTtcclxuICAgICAgdW5pcXVlU3RyaW5nc1NldC5kZWxldGUoJycpOyAvLyByZW1vdmUgZW1wdHkgc3RyaW5nc1xyXG4gICAgICByZXR1cm4gWy4uLnVuaXF1ZVN0cmluZ3NTZXRdO1xyXG4gICAgfVxyXG4gIH1cclxuLyoqXHJcbiAqIGdldCB0aGUgcGF0aCB0byBhIGZpbGUgZnJvbSBhIHN0cmluZyBjb250YWluaW5nIHRoZSBmdWxsIHBhcmgvbmFtZSBzdHJpbmdcclxuICogQHBhcmFtIHBhdGggc3RyaW5nXHJcbiAqIEBwYXJhbSBzZXBhcmF0b3Igc3RyaW5nIGRlZmF1bHRzIHRvICcvJ1xyXG4gKiBAcmV0dXJucyBzdHJpbmdcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRGb2xkZXJGcm9tUGF0aCAocGF0aDpzdHJpbmd8bnVsbHx1bmRlZmluZWQsIHNlcGFyYXRvciA9ICcvJykge1xyXG4gICAgaWYgKHBhdGggPT09IG51bGwpIHJldHVybiBudWxsO1xyXG4gICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IGN1cnJlbnRQYXRoUGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XHJcbiAgICBjdXJyZW50UGF0aFBhcnRzLnBvcCgpOyAvLyByZW1vdmUgRmlsZSBuYW1lO1xyXG4gICAgcmV0dXJuIGN1cnJlbnRQYXRoUGFydHMuam9pbihzZXBhcmF0b3IpO1xyXG59XHJcbiAgICAiLCAiaW1wb3J0IHsgTW9kYWwsIEFwcCwgU2V0dGluZyB9IGZyb20gJ29ic2lkaWFuJztcclxuXHJcbi8qKlxyXG4gKiBkaXNwbGF5IGFuIEFsZXJ0IE1vZGFsXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQWxlcnRNb2RhbCBleHRlbmRzIE1vZGFsIHtcclxuICAgIHByaXZhdGUgdGl0bGU6IHN0cmluZztcclxuICAgIHByaXZhdGUgZGVzY3JpcHRpb246IHN0cmluZztcclxuICAgIHByaXZhdGUgcmVzb2x2ZVByb21pc2UhOiAodmFsdWU6IHtwcm9jZWVkOmJvb2xlYW4sIGRhdGE6YW55fSkgPT4gdm9pZDtcclxuICAgIHByaXZhdGUgcHJvbWlzZTogUHJvbWlzZTx7cHJvY2VlZDpib29sZWFuLCBkYXRhOmFueX0+O1xyXG4gICAgcHJpdmF0ZSBidG4xVGV4dDogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBidG4yVGV4dDogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBjaGVja2JveEVsITogSFRNTElucHV0RWxlbWVudDtcclxuICAgIHByaXZhdGUgYXNrQWdhaW5MYWJlbDogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG4gIFxyXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHRpdGxlOiBzdHJpbmcsIGRlc2NyaXB0aW9uOiBzdHJpbmcsIGJ0bjE6IHN0cmluZywgYnRuMjpzdHJpbmcsIGFza0FnYWluTGFiZWw/OiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcclxuICAgICAgc3VwZXIoYXBwKTtcclxuICAgICAgdGhpcy50aXRsZSA9IHRpdGxlO1xyXG4gICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XHJcbiAgICAgIHRoaXMuYnRuMVRleHQgPSBidG4xO1xyXG4gICAgICB0aGlzLmJ0bjJUZXh0ID0gYnRuMjtcclxuICAgICAgdGhpcy5hc2tBZ2FpbkxhYmVsID0gYXNrQWdhaW5MYWJlbDtcclxuICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICB0aGlzLnJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgXHJcbiAgICBvbk9wZW4oKSB7XHJcbiAgICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xyXG4gIFxyXG4gICAgICBjb250ZW50RWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiB0aGlzLnRpdGxlIH0pO1xyXG4gICAgICBjb250ZW50RWwuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6IHRoaXMuZGVzY3JpcHRpb24gfSk7XHJcbiAgXHJcbiAgICAgIGNvbnN0IHNldHRpbmdzID0gbmV3IFNldHRpbmcoY29udGVudEVsKTtcclxuICAgICAgaWYgKHRoaXMuYXNrQWdhaW5MYWJlbCkge1xyXG4gICAgICAgIGNvbnN0IGl0ZW1JbmZvRGl2ID0gc2V0dGluZ3Muc2V0dGluZ0VsLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3NldHRpbmctaXRlbS1pbmZvJylbMF07XHJcbiAgICAgICAgaWYgKGl0ZW1JbmZvRGl2KSB7XHJcbiAgICAgICAgICB0aGlzLmNoZWNrYm94RWwgPSBpdGVtSW5mb0Rpdi5jcmVhdGVFbCgnaW5wdXQnLCB7IHR5cGU6ICdjaGVja2JveCcgfSk7XHJcbiAgICAgICAgICBjb25zdCBsYWJlbCA9IGl0ZW1JbmZvRGl2LmNyZWF0ZUVsKCdsYWJlbCcsIHsgdGV4dDogdGhpcy5hc2tBZ2FpbkxhYmVsIH0pO1xyXG4gICAgICAgICAgbGFiZWwuc3R5bGUubWFyZ2luTGVmdCA9ICc4cHgnO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBzZXR0aW5ncy5hZGRCdXR0b24oKGJ0bikgPT4ge1xyXG4gICAgICAgICAgYnRuLnNldEJ1dHRvblRleHQodGhpcy5idG4xVGV4dClcclxuICAgICAgICAgICAgLnNldEN0YSgpXHJcbiAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlUHJvbWlzZSh7cHJvY2VlZDp0cnVlLCBkYXRhOnthc2tDb25maXJtYXRpb246IHRoaXMuY2hlY2tib3hFbD8uY2hlY2tlZH19KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgc2V0dGluZ3MuYWRkQnV0dG9uKChidG4pID0+IHtcclxuICAgICAgICAgIGJ0bi5zZXRCdXR0b25UZXh0KHRoaXMuYnRuMlRleHQpXHJcbiAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlUHJvbWlzZSh7cHJvY2VlZDpmYWxzZSwgZGF0YTp7YXNrQ29uZmlybWF0aW9uOiB0aGlzLmNoZWNrYm94RWw/LmNoZWNrZWR9fSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgb25DbG9zZSgpIHtcclxuICAgICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XHJcbiAgICAgIGNvbnRlbnRFbC5lbXB0eSgpO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgYXN5bmMgb3BlbkFuZEdldFZhbHVlKCk6IFByb21pc2U8e3Byb2NlZWQ6Ym9vbGVhbiwgZGF0YTphbnl9PiB7XHJcbiAgICAgIHRoaXMub3BlbigpO1xyXG4gICAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xyXG4gICAgfVxyXG4gIH0iLCAiaW1wb3J0IHsgQXBwLCBQbHVnaW4sIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7IHBhcnNlSlNDb2RlLCBTY3JpcHRpbmdUb29scyB9IGZyb20gXCIuLi90b29sc1wiO1xyXG5pbXBvcnQgeyBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCBPYnNpZGlhblByb3BlcnR5VHlwZXMgfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuaW1wb3J0IHsgRVJST1IsIGxvZ2dlciwgV0FSTklORyB9IGZyb20gXCIuLi9Mb2dcIjtcclxuXHJcbmV4cG9ydCB0eXBlIEZyb250bWF0dGVyQXV0b21hdGVSdWxlVHlwZXMgPSAnYnVpbGRJbicgfCAnYnVpbGRJbi5pbnB1dFByb3BlcnR5JyB8ICdhdXRvY29tcGxldGUubW9kYWwnIHwgJ2F1dG9tYXRpb24nIHwgJ3NjcmlwdCcgfCAnZm9ybWF0dGVyJyB8ICdsaW5rRm9ybWF0dGVyJyA7XHJcbi8qKlxyXG4gKiBUaGUgYFJ1bGVDb25maWdFbGVtZW50c2AgaW50ZXJmYWNlIGRlZmluZXMgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgYSBydWxlLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBpbnRlcmZhY2UgUnVsZUNvbmZpZ0VsZW1lbnRzXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFJ1bGVDb25maWdFbGVtZW50cyB7XHJcbiAgICBba2V5OiBzdHJpbmddOiBib29sZWFuOyAvLyBBbGxvdyBzdHJpbmcga2V5cyB3aXRoIGJvb2xlYW4gdmFsdWVzXHJcbiAgICByZW1vdmVDb250ZW50OiBib29sZWFuO1xyXG4gICAgcnVsZUFjdGl2ZTogYm9vbGVhbjtcclxuICAgIG1vZGlmeU9ubHk6IGJvb2xlYW47XHJcbiAgICBpbnB1dFByb3BlcnR5OiBib29sZWFuO1xyXG4gICAgYWRkUHJlZml4OiBib29sZWFuO1xyXG4gICAgc3BhY2VSZXBsYWNlbWVudDogYm9vbGVhbjtcclxuICAgIHNwZWNpYWxDaGFyYWN0ZXJSZXBsYWNlbWVudDogYm9vbGVhbjtcclxuICAgIGNvbnZlcnRUb0xvd2VyQ2FzZTogYm9vbGVhbjtcclxuICAgIHJlc3VsdEFzTGluazogYm9vbGVhbjtcclxuICAgIGFkZENvbnRlbnQ6IGJvb2xlYW47XHJcbiAgICBleGNsdWRlRm9sZGVyczogYm9vbGVhbjtcclxuICAgIGluY2x1ZGVGb2xkZXJzOiBib29sZWFuO1xyXG4gICAgc2NyaXB0OiBib29sZWFuO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgUnVsZVByb3RvdHlwZSB7XHJcbiAgICBydWxlc0NvbmZpZ0RpdjogSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcbiAgICBzY3JpcHRpbmdUb29sczogU2NyaXB0aW5nVG9vbHM7XHJcbiAgICBpZCE6IHN0cmluZztcclxuICAgIG5hbWUhOiBzdHJpbmc7XHJcbiAgICBkZXNjcmlwdGlvbiE6IHN0cmluZztcclxuICAgIHJ1bGVUeXBlOiBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVR5cGVzID0gJ2J1aWxkSW4nO1xyXG4gICAgaXNMaXZlUnVsZTogYm9vbGVhbiA9IGZhbHNlOyAvLyBJZiB0cnVlLCB0aGUgcnVsZSBpcyBhIGxpdmUgcnVsZSBhbmQgd2lsbCBiZSBleGVjdXRlZCBvbiBmaWxlIGNoYW5nZVxyXG4gICAgdHlwZTogc3RyaW5nW10gPSBbJ3RleHQnXTsgLy8gVHlwZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGJ5IHRoaXMgcnVsZVxyXG4gICAgY29uZmlnRWxlbWVudHM6IFJ1bGVDb25maWdFbGVtZW50cyB8IG9iamVjdCA9IHt9OyAvLyBFbGVtZW50cyB0aGF0IGFyZSB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUgcnVsZVxyXG4gICAgc291cmNlOiBzdHJpbmcgPSAnZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBsZXQgcmVzdWx0ID0gXFwnXFwnXFxuICByZXR1cm4gcmVzdWx0O1xcbn0nO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFwcD86IEFwcCB8IHVuZGVmaW5lZCwgcGx1Z2luPzogYW55fCB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aGlzLnNjcmlwdGluZ1Rvb2xzID0gbmV3IFNjcmlwdGluZ1Rvb2xzKGFwcCwgcGx1Z2luKTtcclxuICAgIH07XHJcblxyXG4gICAgZ2V0U291cmNlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ4IChhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogYW55LCB0b29sczogU2NyaXB0aW5nVG9vbHMsIGlucHV0PzphbnkpIHsgLy8gRGVmYXVsdCBmdW5jdGlvbiBzaWduYXR1cmVcclxuICAgICAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCB8fCBpbnB1dCA9PT0gbnVsbCkgaW5wdXQgPSB0b29scy5nZXRDdXJyZW50Q29udGVudCgpOyAvLyBHZXQgdGhlIGN1cnJlbnQgY29udGVudCBvZiBwcm9wZXJ0eVxyXG4gICAgICAgIHJldHVybiBpbnB1dDsgLy8gUmV0dXJuIHRoZSBpbnB1dCB1bmFsdGVyZWRcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25maWd1cmVzIHRoZSBzZXR0aW5ncyB0YWIgZm9yIGEgc3BlY2lmaWMgcnVsZSBpbiB0aGUgcGx1Z2luLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25FTCAtIFRoZSBIVE1MIGVsZW1lbnQgd2hlcmUgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB3aWxsIGJlIHJlbmRlcmVkLlxyXG4gICAgICogQHBhcmFtIHJ1bGUgLSBUaGUgc2V0dGluZ3Mgb2JqZWN0IGZvciB0aGUgZnJvbnRtYXR0ZXIgYXV0b21hdGlvbiBydWxlLlxyXG4gICAgICogQHBhcmFtIHRoYXQgLSBUaGUgY29udGV4dCBvciByZWZlcmVuY2UgdG8gdGhlIGNhbGxpbmcgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHByZXZpZXdDb21wb25lbnQgLSBUaGUgY29tcG9uZW50IHVzZWQgdG8gcmVuZGVyIGEgcHJldmlldyBvZiB0aGUgcnVsZSdzIGVmZmVjdC5cclxuICAgICAqL1xyXG4gICAgY29uZmlnVGFiIChvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6RnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDphbnksIHByZXZpZXdDb21wb25lbnQ6IGFueSkge1xyXG4gICAgICAgIG9wdGlvbkVMLmVtcHR5KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGRlZmF1bHRDb25maWdFbGVtZW50cyhtb2RpZmllcnM6IFJ1bGVDb25maWdFbGVtZW50cyB8IGFueSk6IFJ1bGVDb25maWdFbGVtZW50cyB7XHJcbiAgICAgICAgY29uc3QgY29uZmlnRWxlbWVudHM6IFJ1bGVDb25maWdFbGVtZW50cyA9IHtcclxuICAgICAgICAgICAgcmVtb3ZlQ29udGVudDogdHJ1ZSxcclxuICAgICAgICAgICAgcnVsZUFjdGl2ZTogdHJ1ZSxcclxuICAgICAgICAgICAgbW9kaWZ5T25seTogdHJ1ZSxcclxuICAgICAgICAgICAgaW5wdXRQcm9wZXJ0eTogZmFsc2UsXHJcbiAgICAgICAgICAgIGFkZFByZWZpeDogdHJ1ZSxcclxuICAgICAgICAgICAgc3BhY2VSZXBsYWNlbWVudDogdHJ1ZSxcclxuICAgICAgICAgICAgc3BlY2lhbENoYXJhY3RlclJlcGxhY2VtZW50OiB0cnVlLFxyXG4gICAgICAgICAgICBjb252ZXJ0VG9Mb3dlckNhc2U6IHRydWUsXHJcbiAgICAgICAgICAgIHJlc3VsdEFzTGluazogdHJ1ZSxcclxuICAgICAgICAgICAgYWRkQ29udGVudDogdHJ1ZSxcclxuICAgICAgICAgICAgZXhjbHVkZUZvbGRlcnM6IHRydWUsXHJcbiAgICAgICAgICAgIGluY2x1ZGVGb2xkZXJzOiB0cnVlLFxyXG4gICAgICAgICAgICBzY3JpcHQ6IHRydWUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnRWxlbWVudHMsIG1vZGlmaWVycyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBhIHNwZWNpZmljIHJ1bGUgb3B0aW9uIGlzIGVuYWJsZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbiAtIFRoZSBuYW1lIG9mIHRoZSBydWxlIG9wdGlvbiB0byBjaGVjay5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBpZiB0aGUgb3B0aW9uIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgdXNlUnVsZU9wdGlvbihvcHRpb246c3RyaW5nKTpib29sZWFuIHtcclxuICAgICAgICBpZiAoKHRoaXMuY29uZmlnRWxlbWVudHMgYXMgUnVsZUNvbmZpZ0VsZW1lbnRzKVtvcHRpb25dID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKHRoaXMuY29uZmlnRWxlbWVudHMgYXMgUnVsZUNvbmZpZ0VsZW1lbnRzKVtvcHRpb25dIHx8IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgdGhlIHJ1bGUgaGFzIGFueSBjb25maWd1cmF0aW9uIG9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IC0gUmV0dXJucyB0cnVlIGlmIHRoZSBydWxlIGhhcyBvcHRpb25zLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIGhhc093bkNvbmZpZ1RhYigpOiBib29sZWFuIHtcclxuICAgICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuY29uZmlnVGFiICE9PSBSdWxlUHJvdG90eXBlLnByb3RvdHlwZS5jb25maWdUYWI7XHJcbiAgICB9ICAgXHJcbiAgICAvKipcclxuICAgICAqIEV4ZWN1dGVzIHRoZSBgZnhgIGZ1bmN0aW9uIGJhc2VkIG9uIHRoZSBgcnVsZVR5cGVgLlxyXG4gICAgICogSGFuZGxlcyBkaWZmZXJlbnQgZnVuY3Rpb24gc2lnbmF0dXJlcyBkeW5hbWljYWxseS5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtBcHB9IGFwcCAtIFRoZSBPYnNpZGlhbiBhcHAgaW5zdGFuY2UuXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gZmlsZSAtIFRoZSBmaWxlIHRvIHBhc3MgdG8gdGhlIHJ1bGUncyBgZnhgIGZ1bmN0aW9uLlxyXG4gICAgICogQHBhcmFtIHtTY3JpcHRpbmdUb29sc30gdG9vbHMgLSBUaGUgc2NyaXB0aW5nIHRvb2xzIHRvIHBhc3MgdG8gdGhlIHJ1bGUncyBgZnhgIGZ1bmN0aW9uLlxyXG4gICAgICogQHBhcmFtIHthbnl9IFtpbnB1dF0gLSBPcHRpb25hbCBpbnB1dCBmb3IgcnVsZXMgdGhhdCByZXF1aXJlIGl0IChlLmcuLCBgYnVpbGRJbi5pbnB1dFByb3BlcnR5YCkuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSByZXN1bHQgb2YgdGhlIGBmeGAgZnVuY3Rpb24uXHJcbiAgICAqL1xyXG4gICAgZXhlY3V0ZShhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogYW55LCB0b29sczogU2NyaXB0aW5nVG9vbHMsIGlucHV0PzogYW55KTogc3RyaW5nIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMucnVsZVR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnZm9ybWF0dGVyJzpcclxuICAgICAgICAgICAgY2FzZSAnbGlua0Zvcm1hdHRlcic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5meChhcHAsIGZpbGUsIHRvb2xzLCBpbnB1dCk7IC8vIGBmb3JtYXR0ZXJgIHJ1bGVzIGV4cGVjdCAoaW5wdXQsIHRvb2xzKVxyXG5cclxuICAgICAgICAgICAgY2FzZSAnYnVpbGRJbi5pbnB1dFByb3BlcnR5JzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZ4KGFwcCwgZmlsZSwgdG9vbHMsIGlucHV0KTsgLy8gYGJ1aWxkSW4uaW5wdXRQcm9wZXJ0eWAgcnVsZXMgZXhwZWN0IChhcHAsIGZpbGUsIHRvb2xzLCBpbnB1dClcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ2F1dG9jb21wbGV0ZS5tb2RhbCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ2F1dG9tYXRpb24nOlxyXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGFzeW5jIGZ1bmN0aW9ucyBieSByZXNvbHZpbmcgdGhlIFByb21pc2Ugc3luY2hyb25vdXNseVxyXG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5meChhcHAsIGZpbGUsIHRvb2xzKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChyZXM6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycjogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coRVJST1IsYEVycm9yIGV4ZWN1dGluZyBhc3luYyBhdXRvbWF0aW9uIHJ1bGU6ICR7ZXJyfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsgLy8gUmV0dXJuIHRoZSByZXNvbHZlZCByZXN1bHQgYXMgYSBzdHJpbmdcclxuXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5meChhcHAsIGZpbGUsIHRvb2xzKTsgLy8gRGVmYXVsdCBydWxlcyBleHBlY3QgKGFwcCwgZmlsZSwgdG9vbHMpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgYFJ1bGVzYCBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgbWFuYWdpbmcgYW5kIG9yZ2FuaXppbmcgYSBjb2xsZWN0aW9uIG9mIHJ1bGVzLlxyXG4gKiBJdCBwcm92aWRlcyBtZXRob2RzIHRvIHJlZ2lzdGVyIG5ldyBydWxlcyBhbmQgcmV0cmlldmUgcnVsZXMgYmFzZWQgb24gdGhlaXIgdHlwZS5cclxuICpcclxuICogQHJlbWFya3NcclxuICogVGhpcyBjbGFzcyBpcyBkZXNpZ25lZCB0byB3b3JrIHdpdGhpbiB0aGUgY29udGV4dCBvZiBhbiBPYnNpZGlhbiBwbHVnaW4gYW5kIHJlbGllcyBvblxyXG4gKiB0aGUgYEFwcGAgYW5kIGBwbHVnaW5gIGluc3RhbmNlcyBmb3IgaXRzIGZ1bmN0aW9uYWxpdHkuIFJ1bGVzIGFyZSBzdG9yZWQgYXMgYW4gYXJyYXlcclxuICogb2YgYFJ1bGVQcm90b3R5cGVgIG9iamVjdHMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY29uc3QgcnVsZXNNYW5hZ2VyID0gbmV3IFJ1bGVzKGFwcCwgcGx1Z2luKTtcclxuICogcnVsZXNNYW5hZ2VyLnJlZ2lzdGVyUnVsZSh7XHJcbiAqICAgaWQ6IFwiZXhhbXBsZS1ydWxlXCIsXHJcbiAqICAgbmFtZTogXCJFeGFtcGxlIFJ1bGVcIixcclxuICogICBydWxlVHlwZTogRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVUeXBlcy5Tb21lVHlwZSxcclxuICogfSk7XHJcbiAqIGNvbnN0IGZpbHRlcmVkUnVsZXMgPSBydWxlc01hbmFnZXIuZ2V0UnVsZXNCeVR5cGUoRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVUeXBlcy5Tb21lVHlwZSk7XHJcbiAqIGNvbnNvbGUubG9nKGZpbHRlcmVkUnVsZXMpO1xyXG4gKiBgYGBcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVzIHtcclxuICAgIGFwcDogQXBwIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG4gICAgcGx1Z2luOiBhbnkgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcbiAgICBydWxlczogUnVsZVByb3RvdHlwZVtdO1xyXG4gICAgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFwcD86IEFwcCB8IHVuZGVmaW5lZCwgcGx1Z2luPzogYW55KSB7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICAgICAgdGhpcy50b29scyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnJ1bGVzID0gW107XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGluaXQgKGFwcDogQXBwLCBwbHVnaW46IGFueSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzKSB7XHJcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICAgICAgdGhpcy50b29scyA9IHRvb2xzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJzIGEgbmV3IHJ1bGUgYnkgYWRkaW5nIGl0IHRvIHRoZSBsaXN0IG9mIGV4aXN0aW5nIHJ1bGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBydWxlIC0gVGhlIHJ1bGUgcHJvdG90eXBlIHRvIGJlIHJlZ2lzdGVyZWQuIFRoaXMgc2hvdWxkIGNvbmZvcm0gdG8gdGhlIGBSdWxlUHJvdG90eXBlYCBpbnRlcmZhY2UuXHJcbiAgICAgKi9cclxuICAgIHJlZ2lzdGVyUnVsZShydWxlOiBSdWxlUHJvdG90eXBlKSB7XHJcbiAgICAgICAgdGhpcy5ydWxlcy5wdXNoKHJ1bGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBydWxlcyBmaWx0ZXJlZCBieSB0aGUgc3BlY2lmaWVkIHJ1bGUgdHlwZSBhbmQgcHJvcGVydHkgdHlwZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcnVsZVR5cGUgLSBUaGUgdHlwZSBvZiBydWxlIHRvIGZpbHRlciBieS5cclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eVR5cGUgLSBUaGUgcHJvcGVydHkgdHlwZSB0byBmaWx0ZXIgYnkgd2l0aGluIHRoZSBydWxlJ3MgdHlwZSBhcnJheS5cclxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyB0aGUgYGlkYCBhbmQgYG5hbWVgIG9mIGVhY2ggbWF0Y2hpbmcgcnVsZSwgc29ydGVkIGFscGhhYmV0aWNhbGx5IGJ5IG5hbWUuXHJcbiAgICAgKi9cclxuICAgIGdldFJ1bGVzQnlUeXBlKHJ1bGVUeXBlOiBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVR5cGVzLCBwcm9wZXJ0eVR5cGU/OiBPYnNpZGlhblByb3BlcnR5VHlwZXMpOiBBcnJheTx7aWQ6IHN0cmluZywgbmFtZTogc3RyaW5nfT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJ1bGVzXHJcbiAgICAgICAgICAgIC5maWx0ZXIocnVsZSA9PiBydWxlLnJ1bGVUeXBlID09PSBydWxlVHlwZSAmJiAoIXByb3BlcnR5VHlwZSB8fCBydWxlLnR5cGUuaW5jbHVkZXMocHJvcGVydHlUeXBlKSkpIC8vIEZpbHRlciBydWxlcyBieSBydWxlVHlwZSBhbmQgcHJvcGVydHlUeXBlXHJcbiAgICAgICAgICAgIC5tYXAocnVsZSA9PiAoeyBpZDogcnVsZS5pZCwgbmFtZTogcnVsZS5uYW1lIH0pKSAvLyBNYXAgdG8ge2lkLCBuYW1lfVxyXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKSk7IC8vIFNvcnQgYWxwaGFiZXRpY2FsbHkgYnkgbmFtZVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIGEgcnVsZSBvYmplY3QgYnkgaXRzIHVuaXF1ZSBpZGVudGlmaWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgcnVsZSB0byByZXRyaWV2ZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBydWxlIG9iamVjdCBtYXRjaGluZyB0aGUgcHJvdmlkZWQgSUQsIG9yIGB1bmRlZmluZWRgIGlmIG5vIG1hdGNoaW5nIHJ1bGUgaXMgZm91bmQuXHJcbiAgICAgKiBAdGhyb3dzIExvZ3MgYSB3YXJuaW5nIHRvIHRoZSBjb25zb2xlIGlmIHRoZSBydWxlIHdpdGggdGhlIHNwZWNpZmllZCBJRCBpcyBub3QgZm91bmQuXHJcbiAgICAgKi9cclxuICAgIGdldFJ1bGVCeUlkKGlkOiBzdHJpbmcpOiBSdWxlUHJvdG90eXBlIHwgdW5kZWZpbmVkIHtcclxuICAgICAgICBjb25zdCBydWxlT2JqZWN0ID0gdGhpcy5ydWxlcy5maW5kKHJ1bGUgPT4gcnVsZS5pZCA9PT0gaWQpO1xyXG4gICAgICAgIGlmICghcnVsZU9iamVjdCkge1xyXG4gICAgICAgICAgICBsb2dnZXIubG9nKFdBUk5JTkcsYFJ1bGUgd2l0aCBpZCBcIiR7aWR9XCIgbm90IGZvdW5kLmApO1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcnVsZU9iamVjdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSBzb3VyY2UgY29kZSBvZiBhIHJ1bGUgYnkgaXRzIHVuaXF1ZSBpZGVudGlmaWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgcnVsZSBmb3Igd2hpY2ggdG8gcmV0cmlldmUgdGhlIHNvdXJjZSBjb2RlLlxyXG4gICAgICogQHJldHVybnMgVGhlIHNvdXJjZSBjb2RlIG9mIHRoZSBydWxlLCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgcnVsZSBpcyBub3QgZm91bmQuXHJcbiAgICAgKi9cclxuICAgIGdldFNvdXJjZShpZDogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuICAgICAgICBjb25zdCBydWxlT2JqZWN0ID0gdGhpcy5nZXRSdWxlQnlJZChpZCk7XHJcbiAgICAgICAgaWYgKCFydWxlT2JqZWN0KSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5sb2coV0FSTklORyxgU291cmNlIGZvciBydWxlIHdpdGggaWQgXCIke2lkfVwiIG5vdCBmb3VuZC5gKTtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJ1bGVPYmplY3QuZ2V0U291cmNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeGVjdXRlcyB0aGUgYGZ4YCBmdW5jdGlvbiBvZiBhIHJ1bGUgbWF0Y2hpbmcgdGhlIGdpdmVuIGBpZGAgYW5kIHJldHVybnMgaXRzIHJlc3VsdC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBydWxlIHRvIGV4ZWN1dGUuXHJcbiAgICAgKiBAcGFyYW0ge0FwcH0gYXBwIC0gVGhlIE9ic2lkaWFuIGFwcCBpbnN0YW5jZS5cclxuICAgICAqIEBwYXJhbSB7YW55fSBmaWxlIC0gVGhlIGZpbGUgdG8gcGFzcyB0byB0aGUgcnVsZSdzIGBmeGAgZnVuY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0ge1NjcmlwdGluZ1Rvb2xzfSB0b29scyAtIFRoZSBzY3JpcHRpbmcgdG9vbHMgdG8gcGFzcyB0byB0aGUgcnVsZSdzIGBmeGAgZnVuY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gW2lucHV0XSAtIE9wdGlvbmFsIGlucHV0IGZvciBydWxlcyB0aGF0IHJlcXVpcmUgaXQuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgbnVsbH0gLSBUaGUgcmVzdWx0IG9mIHRoZSBgZnhgIGZ1bmN0aW9uLCBvciBgbnVsbGAgaWYgdGhlIHJ1bGUgaXMgbm90IGZvdW5kLlxyXG4gICAgKi9cclxuICAgIGV4ZWN1dGVSdWxlQnlJZChpZDogc3RyaW5nLCBydWxlU2V0dGluZ3M6IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBhbnksIHRvb2xzOiBTY3JpcHRpbmdUb29scywgaW5wdXQ/OiBhbnkpOiBzdHJpbmcgfCBudWxsIHtcclxuICAgICAgICBjb25zdCBydWxlID0gdGhpcy5ydWxlcy5maW5kKHJ1bGUgPT4gcnVsZS5pZCA9PT0gaWQpO1xyXG4gICAgICAgIGlmICghcnVsZSkge1xyXG4gICAgICAgICAgICBsb2dnZXIubG9nKFdBUk5JTkcsYFJ1bGUgd2l0aCBpZCBcIiR7aWR9XCIgbm90IGZvdW5kLmApO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZVJ1bGUocnVsZVNldHRpbmdzLCBydWxlLCBhcHAsIGZpbGUsIHRvb2xzLCBpbnB1dCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4ZWN1dGVzIHRoZSBgZnhgIGZ1bmN0aW9uIG9mIGEgZ2l2ZW4gcnVsZSBhbmQgcmV0dXJucyBpdHMgcmVzdWx0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBydWxlIC0gVGhlIHJ1bGUgdG8gZXhlY3V0ZS5cclxuICAgICAqIEBwYXJhbSBhcHAgLSBUaGUgT2JzaWRpYW4gYXBwIGluc3RhbmNlLlxyXG4gICAgICogQHBhcmFtIGZpbGUgLSBUaGUgZmlsZSB0byBwYXNzIHRvIHRoZSBydWxlJ3MgYGZ4YCBmdW5jdGlvbi5cclxuICAgICAqIEBwYXJhbSB0b29scyAtIFRoZSBzY3JpcHRpbmcgdG9vbHMgdG8gcGFzcyB0byB0aGUgcnVsZSdzIGBmeGAgZnVuY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gaW5wdXQgLSBPcHRpb25hbCBpbnB1dCBmb3IgcnVsZXMgdGhhdCByZXF1aXJlIGl0LlxyXG4gICAgICogQHJldHVybnMge3N0cmluZyB8IG51bGx9IC0gVGhlIHJlc3VsdCBvZiB0aGUgYGZ4YCBmdW5jdGlvbiwgb3IgYG51bGxgIGlmIHRoZSBydWxlIGlzIG5vdCBmb3VuZC5cclxuICAgICAqL1xyXG4gICAgZXhlY3V0ZVJ1bGUocnVsZVNldHRpbmdzOiBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCBydWxlOiBSdWxlUHJvdG90eXBlLCBhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogYW55LCB0b29sczogU2NyaXB0aW5nVG9vbHMsIGlucHV0PzogYW55KTogc3RyaW5nIHwgbnVsbCB7XHJcbiAgICAgICAgc3dpdGNoIChydWxlLnJ1bGVUeXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2Zvcm1hdHRlcic6XHJcbiAgICAgICAgICAgIGNhc2UgJ2xpbmtGb3JtYXR0ZXInOlxyXG4gICAgICAgICAgICBjYXNlICdidWlsZEluLmlucHV0UHJvcGVydHknOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGUuZXhlY3V0ZShhcHAsIGZpbGUsIHRvb2xzLCBpbnB1dCk7XHJcbiAgICAgICAgICAgIGNhc2UgJ2F1dG9tYXRpb24nOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGUuZXhlY3V0ZShhcHAsIGZpbGUsIHRvb2xzKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGlmIChydWxlU2V0dGluZ3MudXNlQ3VzdG9tQ29kZSAmJiBydWxlU2V0dGluZ3MuYnVpbGRJbkNvZGUgJiYgcnVsZVNldHRpbmdzLmJ1aWxkSW5Db2RlICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBydWxlIGhhcyBjdXN0b20gY29kZSwgZXhlY3V0ZSBpdFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBwYXJzZUpTQ29kZShydWxlU2V0dGluZ3MuYnVpbGRJbkNvZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29kZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZShhcHAsIGZpbGUsIHRvb2xzKTsgLy8gUGFzcyBpbnB1dCBpZiBhdmFpbGFibGVcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKEVSUk9SLGBJbnZhbGlkIGN1c3RvbSBjb2RlIGZvciBydWxlIFwiJHtydWxlU2V0dGluZ3MuY29udGVudH1cIjogJHtydWxlU2V0dGluZ3MuYnVpbGRJbkNvZGV9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgSW52YWxpZCBjdXN0b20gY29kZSBmb3IgcnVsZSBcIiR7cnVsZVNldHRpbmdzLmlkfVwiYDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBydWxlLmV4ZWN1dGUoYXBwLCBmaWxlLCB0b29scywgaW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhcHBseUZvcm1hdE9wdGlvbnModmFsdWU6YW55LCBydWxlOkZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIGFjdGl2ZUZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMgKTphbnkge1xyXG5cclxuICAgICAgICBpZiAocnVsZS50eXBlID09PSAnbnVtYmVyJyB8fCBydWxlLnR5cGUgPT09ICdjaGVja2JveCcgfHwgcnVsZS50eXBlID09PSAnZGF0ZScgfHwgcnVsZS50eXBlID09PSAnZGF0ZXRpbWUnKSByZXR1cm4gdmFsdWU7IC8vIGxlYXZlIGRhdGUgYW5kIGRhdGVUaW1lIHVudG91Y2hlZFxyXG5cclxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xyXG4gICAgICAgICAgY2FzZSAnYm9vbGVhbic6XHJcbiAgICAgICAgICBjYXNlICdudW1iZXInOlxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICBjYXNlICdzdHJpbmcnOlxyXG4gICAgICAgICAgICAvL2lmIChydWxlLnNwYWNlUmVwbGFjZW1lbnQgJiYgcnVsZS5zcGFjZVJlcGxhY2VtZW50ICE9PSAnJykgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXHMrL2csIHJ1bGUuc3BhY2VSZXBsYWNlbWVudCk7XHJcbiAgICAgICAgICAgIC8vaWYgKHJ1bGUuc3BlY2lhbENoYXJSZXBsYWNlbWVudCAmJiBydWxlLnNwZWNpYWxDaGFyUmVwbGFjZW1lbnQgIT09JycpIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW15hLXpBLVowLTlcXC1fXFwvXHUwMEU0XHUwMEY2XHUwMEZDXHUwMERGXHUwMEM0XHUwMEQ2XHUwMERDXHUwMEUxXHUwMEU5XHUwMEVEXHUwMEYzXHUwMEZBXHUwMEZEXHUwMEMxXHUwMEM5XHUwMENEXHUwMEQzXHUwMERBXHUwMEREXHUwMEUwXHUwMEU4XHUwMEVDXHUwMEYyXHUwMEY5XHUwMEMwXHUwMEM4XHUwMENDXHUwMEQyXHUwMEQ5XHUwMEUyXHUwMEVBXHUwMEVFXHUwMEY0XHUwMEZCXHUwMEMyXHUwMENBXHUwMENFXHUwMEQ0XHUwMERCXHUwMEUzXHUwMEYxXHUwMEY1XHUwMEMzXHUwMEQxXHUwMEQ1XS9nLCBydWxlLnNwZWNpYWxDaGFyUmVwbGFjZW1lbnQpO1xyXG4gICAgICAgICAgICBpZiAocnVsZS5mb3JtYXR0ZXJzICYmIHJ1bGUuZm9ybWF0dGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgcnVsZS5mb3JtYXR0ZXJzLmZvckVhY2goZm9ybWF0dGVySWQgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmV4ZWN1dGVSdWxlQnlJZChmb3JtYXR0ZXJJZCwgcnVsZSwgdGhpcy5hcHAsIGFjdGl2ZUZpbGUsIHRvb2xzLCB2YWx1ZSk7IC8vIGV4ZWN1dGUgdGhlIGZvcm1hdHRlciBydWxlXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJ1bGUubGlua0Zvcm1hdHRlciAmJiBydWxlLmxpbmtGb3JtYXR0ZXIgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmV4ZWN1dGVSdWxlQnlJZChydWxlLmxpbmtGb3JtYXR0ZXIsIHJ1bGUsIHRoaXMuYXBwLCBhY3RpdmVGaWxlLCB0b29scywgdmFsdWUpOyAvLyBleGVjdXRlIHRoZSBsaW5rIGZvcm1hdHRlciBydWxlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9pZiAocnVsZS5wcmVmaXggJiYgcnVsZS5wcmVmaXggIT09ICcnKSB2YWx1ZSA9IHJ1bGUucHJlZml4ICsgdmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVxyXG4gICAgICAgICAgY2FzZSAnb2JqZWN0JzpcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCh2YWx1ZSA9PiB0aGlzLmFwcGx5Rm9ybWF0T3B0aW9ucyh2YWx1ZSwgcnVsZSwgYWN0aXZlRmlsZSwgdG9vbHMpKTsgLy8gcGFzcyBhY3RpdmVGaWxlIGFuZCB0b29sc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgbWVyZ2VSZXN1bHQocmVzdWx0OiBhbnksIG9sZFJlc3VsdDogYW55LCByZXR1cm5SZXN1bHQ6IGFueSwgcnVsZTogRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyk6IGFueSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnRvb2xzKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignVG9vbHMgYXJlIG5vdCBhdmFpbGFibGUgZm9yIG1lcmdpbmcgcmVzdWx0cy4nKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsgLy8gaWYgdG9vbHMgYXJlIG5vdCBhdmFpbGFibGUsIHJldHVybiB0aGUgcmVzdWx0IGFzIGlzXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAocnVsZS5hZGRDb250ZW50KSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ292ZXJ3cml0ZSc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm5SZXN1bHQgPSByZXN1bHQ7IC8vIHVwZGF0ZSBvciBhZGQgdGhlIG5ldyB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XHJcbiAgICAgICAgICAgICAgICBpZiAocnVsZS50eXBlID09PSAnbXVsdGl0ZXh0JyB8fCBydWxlLnR5cGUgPT09ICd0YWdzJyB8fCBydWxlLnR5cGUgPT09ICdhbGlhc2VzJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KSByZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHJlc3VsdCA9IFtyZXN1bHRdOyAvLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSBcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmV0dXJuUmVzdWx0KSkgcmV0dXJuUmVzdWx0ID0gW3JldHVyblJlc3VsdF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9sZFJlc3VsdCkpIG9sZFJlc3VsdCA9IFtvbGRSZXN1bHRdO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWx0ZXJlZCA9IHJldHVyblJlc3VsdC5maWx0ZXIoKHZhbHVlOmFueSkgPT4gIW9sZFJlc3VsdC5pbmNsdWRlcyh2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuUmVzdWx0ID0gdGhpcy50b29scy5yZW1vdmVEdXBsaWNhdGVTdHJpbmdzKGZpbHRlcmVkLmNvbmNhdChyZXN1bHQpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXR1cm5SZXN1bHQpIHJldHVyblJlc3VsdCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblJlc3VsdCA9IHJldHVyblJlc3VsdC5yZXBsYWNlQWxsKHJldHVyblJlc3VsdCxvbGRSZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblJlc3VsdCA9IHJldHVyblJlc3VsdCArIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdzdGFydCc6XHJcbiAgICAgICAgICAgICAgICBpZiAocnVsZS50eXBlID09PSAnbXVsdGl0ZXh0JyB8fCBydWxlLnR5cGUgPT09ICd0YWdzJyB8fCBydWxlLnR5cGUgPT09ICdhbGlhc2VzJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KSByZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHJlc3VsdCA9IFtyZXN1bHRdOyAvLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSBcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmV0dXJuUmVzdWx0KSkgcmV0dXJuUmVzdWx0ID0gW3JldHVyblJlc3VsdF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9sZFJlc3VsdCkpIG9sZFJlc3VsdCA9IFtvbGRSZXN1bHRdO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWx0ZXJlZCA9IHJldHVyblJlc3VsdC5maWx0ZXIoKHZhbHVlOmFueSkgPT4gIW9sZFJlc3VsdC5pbmNsdWRlcyh2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuUmVzdWx0ID0gdGhpcy50b29scy5yZW1vdmVEdXBsaWNhdGVTdHJpbmdzKHJlc3VsdC5jb25jYXQoZmlsdGVyZWQpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXR1cm5SZXN1bHQpIHJldHVyblJlc3VsdCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblJlc3VsdCA9IHJldHVyblJlc3VsdC5yZXBsYWNlQWxsKHJldHVyblJlc3VsdCxvbGRSZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblJlc3VsdCA9IHJlc3VsdCArIHJldHVyblJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0dXJuUmVzdWx0O1xyXG4gICAgfTtcclxuICAgICAgICAgICAgXHJcbiAgICAvKipcclxuICAgICAqIEJ1aWxkcyB0aGUgY29uZmlndXJhdGlvbiB0YWIgZm9yIGEgc3BlY2lmaWMgcnVsZSBieSBpdHMgSUQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBydWxlIGZvciB3aGljaCB0aGUgY29uZmlndXJhdGlvbiB0YWIgaXMgYmVpbmcgYnVpbHQuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uRUwgLSBUaGUgSFRNTCBlbGVtZW50IHdoZXJlIHRoZSBjb25maWd1cmF0aW9uIHRhYiB3aWxsIGJlIHJlbmRlcmVkLlxyXG4gICAgICogQHBhcmFtIHJ1bGUgLSBUaGUgZGVmaW5pdGlvbiBvZiB0aGUgcnVsZSwgY29udGFpbmluZyBpdHMgcHJvcGVydGllcyBhbmQgc2V0dGluZ3MuXHJcbiAgICAgKiBAcGFyYW0gdGhhdCAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGNvbnRleHQgb3Igb2JqZWN0LCB0eXBpY2FsbHkgdXNlZCBmb3IgbWFpbnRhaW5pbmcgc2NvcGUuXHJcbiAgICAgKiBAcGFyYW0gcHJldmlld0NvbXBvbmVudCAtIEEgY29tcG9uZW50IHVzZWQgdG8gcmVuZGVyIGEgcHJldmlldyBvZiB0aGUgcnVsZSdzIGVmZmVjdCBvciBjb25maWd1cmF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKiBJZiBhIHJ1bGUgd2l0aCB0aGUgc3BlY2lmaWVkIElEIGlzIGZvdW5kLCBpdHMgYGNvbmZpZ1RhYmAgbWV0aG9kIGlzIGludm9rZWQgdG8gYnVpbGQgdGhlIGNvbmZpZ3VyYXRpb24gdGFiLlxyXG4gICAgICogSWYgbm8gcnVsZSBpcyBmb3VuZCwgYSB3YXJuaW5nIGlzIGxvZ2dlZCB0byB0aGUgY29uc29sZS5cclxuICAgICAqL1xyXG4gICAgYnVpbGRDb25maWdUYWIoaWQ6IHN0cmluZywgb3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOiBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCB0aGF0OiBhbnksIHByZXZpZXdDb21wb25lbnQ6IGFueSkge1xyXG4gICAgICAgIGNvbnN0IHJ1bGVJbnN0YW5jZSA9IHRoaXMucnVsZXMuZmluZChydWxlID0+IHJ1bGUuaWQgPT09IGlkKTtcclxuICAgICAgICBpZiAocnVsZUluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHJ1bGVJbnN0YW5jZS5jb25maWdUYWIob3B0aW9uRUwsIHJ1bGUsIHRoYXQsIHByZXZpZXdDb21wb25lbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgUnVsZSB3aXRoIGlkIFwiJHtpZH1cIiBub3QgZm91bmQgZm9yIGNvbmZpZyB0YWIuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgcnVsZXNNYW5hZ2VyID0gbmV3IFJ1bGVzKCk7IiwgImltcG9ydCBleHAgZnJvbSAnY29uc3RhbnRzJztcclxuaW1wb3J0IHsgQXBwLCBNb2RhbCwgU2V0dGluZywgVEFic3RyYWN0RmlsZSwgVEZpbGUsIFRGb2xkZXIsIFZhdWx0LCBzZXRJY29uIH0gZnJvbSAnb2JzaWRpYW4nOyAvLyBBZGRlZCBzZXRJY29uXHJcblxyXG4vLyBEZWZpbmUgdGhlIHN0cnVjdHVyZSBmb3IgdHJlZSBub2Rlc1xyXG5pbnRlcmZhY2UgVHJlZU5vZGUge1xyXG4gICAgcGF0aDogc3RyaW5nO1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgdHlwZTogc3RyaW5nOyAvLyAnZm9sZGVyJyB8ICdmaWxlJztcclxuICAgIGNoaWxkcmVuPzogVHJlZU5vZGVbXTtcclxuICAgIGVsZW1lbnQ6IEhUTUxFbGVtZW50OyAvLyBSZWZlcmVuY2UgdG8gdGhlIGxpc3QgaXRlbSBlbGVtZW50IChsaSlcclxuICAgIGNoZWNrYm94OiBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgbGFiZWw6IEhUTUxMYWJlbEVsZW1lbnQ7XHJcbiAgICBjb250YWluZXI6IEhUTUxFbGVtZW50OyAvLyBSZWZlcmVuY2UgdG8gdGhlIGNvbnRhaW5lciBkaXYgaG9sZGluZyBjaGVja2JveCBhbmQgbGFiZWxcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgRGlyZWN0b3J5U2VsZWN0aW9uTW9kZSA9ICdpbmNsdWRlJyB8ICdleGNsdWRlJzsgLy8gRGVmaW5lIHNlbGVjdGlvbiBtb2Rlc1xyXG5leHBvcnQgdHlwZSBEaXJlY3RvcnlEaXNwbGF5TW9kZSA9ICdmb2xkZXJzJyB8ICdmaWxlcycgfCAnZm9sZGVyJyB8ICdmaWxlJzsgLy8gRGVmaW5lIGRpc3BsYXkgbW9kZXNcclxuZXhwb3J0IGludGVyZmFjZSBEaXJlY3RvcnlTZWxlY3Rpb25PcHRpb25zIHtcclxuICAgIHRpdGxlPzogc3RyaW5nOyAvLyBUaXRsZSBvZiB0aGUgbW9kYWxcclxuICAgIHNlbGVjdGlvbk1vZGU6IERpcmVjdG9yeVNlbGVjdGlvbk1vZGU7IC8vICdpbmNsdWRlJyBvciAnZXhjbHVkZSdcclxuICAgIGRpc3BsYXlNb2RlOiBEaXJlY3RvcnlEaXNwbGF5TW9kZTsgLy8gJ2ZvbGRlcnMnIG9yICdmaWxlcydcclxuICAgIG9wdGlvblNlbGVjdGlvbk1vZGU6IGJvb2xlYW47IC8vIFNob3cgaW5jbHVkZS9leGNsdWRlIG9wdGlvblxyXG4gICAgb3B0aW9uU2hvd0ZpbGVzOiBib29sZWFuOyAvLyBTaG93IGZpbGVzIG9wdGlvblxyXG59XHJcbi8vIERlZmluZSB0aGUgcmVzdWx0IHN0cnVjdHVyZSByZXR1cm5lZCBieSB0aGUgbW9kYWxcclxuZXhwb3J0IGludGVyZmFjZSBEaXJlY3RvcnlTZWxlY3Rpb25SZXN1bHQge1xyXG4gICAgZm9sZGVyczogc3RyaW5nW107XHJcbiAgICBmaWxlczogc3RyaW5nW107XHJcbiAgICBtb2RlOiBEaXJlY3RvcnlTZWxlY3Rpb25Nb2RlO1xyXG4gICAgZGlzcGxheTogRGlyZWN0b3J5RGlzcGxheU1vZGU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBPYnNpZGlhbiBNb2RhbCBmb3Igc2VsZWN0aW5nIGRpcmVjdG9yaWVzIGFuZCBmaWxlcyBmcm9tIHRoZSB2YXVsdCBzdHJ1Y3R1cmUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRGlyZWN0b3J5U2VsZWN0aW9uTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XHJcbiAgICAvLyBJbml0aWFsIHN0YXRlIHBhc3NlZCB0byB0aGUgbW9kYWwgKHN0b3JlZCBmb3IgcmVzZXQgZnVuY3Rpb25hbGl0eSlcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgaW5pdGlhbEZvbGRlcnNTbmFwc2hvdDogUmVhZG9ubHlTZXQ8c3RyaW5nPjtcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgaW5pdGlhbEZpbGVzU25hcHNob3Q6IFJlYWRvbmx5U2V0PHN0cmluZz47XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IGluaXRpYWxNb2RlU25hcHNob3Q6IERpcmVjdG9yeVNlbGVjdGlvbk1vZGU7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IGluaXRpYWxEaXNwbGF5U25hcHNob3Q6IERpcmVjdG9yeURpc3BsYXlNb2RlO1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBvcHRpb25zOiBEaXJlY3RvcnlTZWxlY3Rpb25PcHRpb25zOyAvLyBPcHRpb25zIGZvciB0aGUgbW9kYWxcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgb2tDYWxsYmFjazogKHJlc3VsdDogRGlyZWN0b3J5U2VsZWN0aW9uUmVzdWx0IHwgbnVsbCkgPT4gdm9pZDtcclxuXHJcbiAgICAvLyBDdXJyZW50IHN0YXRlIGJlaW5nIG1vZGlmaWVkIHdpdGhpbiB0aGUgbW9kYWxcclxuICAgIHByaXZhdGUgY3VycmVudEZvbGRlcnMhOiBTZXQ8c3RyaW5nPjtcclxuICAgIHByaXZhdGUgY3VycmVudEZpbGVzITogU2V0PHN0cmluZz47XHJcbiAgICBwcml2YXRlIGN1cnJlbnRNb2RlITogRGlyZWN0b3J5U2VsZWN0aW9uTW9kZTtcclxuICAgIHByaXZhdGUgY3VycmVudERpc3BsYXkhOiBEaXJlY3RvcnlEaXNwbGF5TW9kZTtcclxuICAgIHByaXZhdGUgaW5jbHVkZUV4Y2x1ZGVTZWxlY3RhYmxlITogYm9vbGVhbjtcclxuICAgIHByaXZhdGUgc2hvd0ZpbGVzOiBib29sZWFuID0gZmFsc2U7IC8vIFN0YXRlIGZvciBzaG93aW5nIGZpbGVzIGluIHRoZSB0cmVlXHJcblxyXG4gICAgLy8gVUkgRWxlbWVudHNcclxuICAgIHByaXZhdGUgdHJlZVJvb3RFbGVtZW50ITogSFRNTEVsZW1lbnQ7IC8vIENvbnRhaW5lciBmb3IgdGhlIHRyZWUgdmlld1xyXG4gICAgcHJpdmF0ZSB0cmVlTm9kZXM6IE1hcDxzdHJpbmcsIFRyZWVOb2RlPiA9IG5ldyBNYXAoKTsgLy8gTWFwIHBhdGggdG8gbm9kZSBpbmZvIGZvciBxdWljayBhY2Nlc3NcclxuICAgIHByaXZhdGUgbW9kZURyb3Bkb3duOiBTZXR0aW5nIHwgbnVsbCA9IG51bGw7IC8vIFJlZmVyZW5jZSB0byB1cGRhdGUgZHJvcGRvd24gb24gcmVzZXRcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhlIERpcmVjdG9yeVNlbGVjdGlvbk1vZGFsLlxyXG4gICAgICogQHBhcmFtIGFwcCAtIFRoZSBPYnNpZGlhbiBBcHAgaW5zdGFuY2UuXHJcbiAgICAgKiBAcGFyYW0gaW5pdGlhbEZvbGRlcnMgLSBBcnJheSBvZiBpbml0aWFsbHkgc2VsZWN0ZWQgZm9sZGVyIHBhdGhzLlxyXG4gICAgICogQHBhcmFtIGluaXRpYWxGaWxlcyAtIEFycmF5IG9mIGluaXRpYWxseSBzZWxlY3RlZCBmaWxlIHBhdGhzLlxyXG4gICAgICogQHBhcmFtIGluaXRpYWxNb2RlIC0gVGhlIGluaXRpYWwgc2VsZWN0aW9uIG1vZGUgKCdpbmNsdWRlJyBvciAnZXhjbHVkZScpLlxyXG4gICAgICogQHBhcmFtIG9rQ2FsbGJhY2sgLSBGdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHVzZXIgY2xpY2tzIFwiT0tcIi4gUmVjZWl2ZXMgdGhlIHNlbGVjdGlvbiByZXN1bHQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIGFwcDogQXBwLFxyXG4gICAgICAgIGluaXRpYWxGb2xkZXJzOiBzdHJpbmdbXSxcclxuICAgICAgICBpbml0aWFsRmlsZXM6IHN0cmluZ1tdLFxyXG4gICAgICAgIGluaXRpYWxPcHRpb25zOiBEaXJlY3RvcnlTZWxlY3Rpb25PcHRpb25zLFxyXG4gICAgICAgIG9rQ2FsbGJhY2s6IChyZXN1bHQ6IERpcmVjdG9yeVNlbGVjdGlvblJlc3VsdCB8IG51bGwpID0+IHZvaWRcclxuICAgICkge1xyXG4gICAgICAgIHN1cGVyKGFwcCk7XHJcbiAgICAgICAgLy8gU3RvcmUgaW5pdGlhbCBzdGF0ZSBmb3IgcmVzZXRcclxuICAgICAgICB0aGlzLmluaXRpYWxGb2xkZXJzU25hcHNob3QgPSBuZXcgU2V0KGluaXRpYWxGb2xkZXJzKTtcclxuICAgICAgICB0aGlzLmluaXRpYWxGaWxlc1NuYXBzaG90ID0gbmV3IFNldChpbml0aWFsRmlsZXMpO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbE1vZGVTbmFwc2hvdCA9IGluaXRpYWxPcHRpb25zLnNlbGVjdGlvbk1vZGU7XHJcbiAgICAgICAgdGhpcy5pbml0aWFsRGlzcGxheVNuYXBzaG90ID0gaW5pdGlhbE9wdGlvbnMuZGlzcGxheU1vZGU7XHJcbiAgICAgICAgdGhpcy5zaG93RmlsZXMgPSBpbml0aWFsT3B0aW9ucy5kaXNwbGF5TW9kZT09PSdmaWxlcycgfHwgaW5pdGlhbE9wdGlvbnMuZGlzcGxheU1vZGU9PT0nZmlsZSd8fCBpbml0aWFsRmlsZXMubGVuZ3RoPjA7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gaW5pdGlhbE9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5va0NhbGxiYWNrID0gb2tDYWxsYmFjaztcclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBjdXJyZW50IHN0YXRlIGZyb20gaW5pdGlhbCBzdGF0ZSBmb3IgZWRpdGluZ1xyXG4gICAgICAgIHRoaXMucmVzZXRTZWxlY3Rpb25Ub0luaXRpYWwoKTsgLy8gVXNlIGEgbWV0aG9kIGZvciBpbml0aWFsaXphdGlvbiBhbmQgcmVzZXRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGUgY3VycmVudCBzZWxlY3Rpb24gc3RhdGUgdG8gdGhlIGluaXRpYWwgc3RhdGUgcHJvdmlkZWQgYXQgY29uc3RydWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlc2V0U2VsZWN0aW9uVG9Jbml0aWFsKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuY3VycmVudEZvbGRlcnMgPSBuZXcgU2V0KHRoaXMuaW5pdGlhbEZvbGRlcnNTbmFwc2hvdCk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RmlsZXMgPSBuZXcgU2V0KHRoaXMuaW5pdGlhbEZpbGVzU25hcHNob3QpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudE1vZGUgPSB0aGlzLmluaXRpYWxNb2RlU25hcHNob3Q7XHJcbiAgICAgICAgLy8gTm90ZTogc2hvd0ZpbGVzIGlzIG5vdCByZXNldCBieSB0aGlzIGFjdGlvbiwgdXNlciBjYW4gdG9nZ2xlIGl0IGluZGVwZW5kZW50bHlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGUgY3VycmVudCBzZWxlY3Rpb24gc3RhdGUgdG8gZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVzZXRTZWxlY3Rpb25Ub0VtcHR5KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuY3VycmVudEZvbGRlcnMgPSBuZXcgU2V0KFtdKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRGaWxlcyA9IG5ldyBTZXQoW10pO1xyXG4gICAgICAgIHRoaXMuY3VycmVudE1vZGUgPSB0aGlzLmluaXRpYWxNb2RlU25hcHNob3Q7XHJcbiAgICAgICAgLy8gTm90ZTogc2hvd0ZpbGVzIGlzIG5vdCByZXNldCBieSB0aGlzIGFjdGlvbiwgdXNlciBjYW4gdG9nZ2xlIGl0IGluZGVwZW5kZW50bHlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBtb2RhbCBpcyBvcGVuZWQuIEJ1aWxkcyB0aGUgVUkuXHJcbiAgICAgKi9cclxuICAgIG9uT3BlbigpIHtcclxuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcclxuICAgICAgICBjb250ZW50RWwuZW1wdHkoKTsgLy8gQ2xlYXIgcHJldmlvdXMgY29udGVudFxyXG4gICAgICAgIGNvbnRlbnRFbC5hZGRDbGFzcygnZGlyZWN0b3J5LXNlbGVjdGlvbi1tb2RhbCcpOyBcclxuXHJcbiAgICAgICAgLy8gLS0tIE1vZGFsIFRpdGxlIC0tLVxyXG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVFeGNsdWRlU2VsZWN0YWJsZSkge1xyXG4gICAgICAgICAgICBjb250ZW50RWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiB0aGlzLm9wdGlvbnMudGl0bGUgfHwgJ0luY2x1ZGUgb3IgRXhjbHVkZSBGb2xkZXJzIGFuZCBGaWxlcycgfSk7IFxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6IHRoaXMub3B0aW9ucy50aXRsZSB8fCBgJHt0aGlzLmN1cnJlbnRNb2RlID09PSAnZXhjbHVkZScgPyAnRXhjbHVkZScgOiAnSW5jbHVkZSd9IEZvbGRlcnMgYW5kIEZpbGVzYCB9KTsgXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAtLS0gU2V0dGluZ3MgQ29udHJvbHMgLS0tXHJcbiAgICAgICAgY29uc3QgY29udHJvbHNFbCA9IGNvbnRlbnRFbC5jcmVhdGVEaXYoeyBjbHM6ICdtb2RhbC1jb250cm9scycgfSk7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVNb2RlU2V0dGluZyhjb250cm9sc0VsKTsgLy8gQ3JlYXRlIG1vZGUgZHJvcGRvd25cclxuICAgICAgICB0aGlzLmNyZWF0ZVNob3dGaWxlc1NldHRpbmcoY29udHJvbHNFbCk7IC8vIENyZWF0ZSBmaWxlIHRvZ2dsZVxyXG5cclxuICAgICAgICAvLyAtLS0gVHJlZSBDb250YWluZXIgLS0tXHJcbiAgICAgICAgdGhpcy50cmVlUm9vdEVsZW1lbnQgPSBjb250ZW50RWwuY3JlYXRlRGl2KHsgY2xzOiAndHJlZS12aWV3LWNvbnRhaW5lcicgfSk7XHJcbiAgICAgICAgdGhpcy50cmVlUm9vdEVsZW1lbnQuc3R5bGUubWF4SGVpZ2h0ID0gJzYwMHB4JztcclxuICAgICAgICB0aGlzLnRyZWVSb290RWxlbWVudC5zdHlsZS5vdmVyZmxvd1kgPSAnYXV0byc7XHJcbiAgICAgICAgdGhpcy50cmVlUm9vdEVsZW1lbnQuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCB2YXIoLS1iYWNrZ3JvdW5kLW1vZGlmaWVyLWJvcmRlciknO1xyXG4gICAgICAgIHRoaXMudHJlZVJvb3RFbGVtZW50LnN0eWxlLnBhZGRpbmcgPSAnMTBweCc7XHJcbiAgICAgICAgdGhpcy50cmVlUm9vdEVsZW1lbnQuc3R5bGUubWFyZ2luVG9wID0gJzEwcHgnO1xyXG4gICAgICAgIHRoaXMudHJlZVJvb3RFbGVtZW50LnN0eWxlLm1hcmdpbkJvdHRvbSA9ICcxMHB4JztcclxuXHJcbiAgICAgICAgLy8gLS0tIEJ1aWxkIGFuZCBSZW5kZXIgVHJlZSAtLS1cclxuICAgICAgICBpZiAoIXRoaXMudHJlZU5vZGVzLnNpemUpIHsgLy8gRW5zdXJlIHRoZSB0cmVlIGlzIG9ubHkgcmVuZGVyZWQgb25jZVxyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkQW5kUmVuZGVyVHJlZSgpOyAvLyBJbml0aWFsIHJlbmRlcmluZyBiYXNlZCBvbiBjdXJyZW50IHN0YXRlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAtLS0gQWN0aW9uIEJ1dHRvbnMgLS0tXHJcbiAgICAgICAgdGhpcy5jcmVhdGVBY3Rpb25CdXR0b25zKGNvbnRlbnRFbCk7IC8vIENyZWF0ZSBPSyBhbmQgUmVzZXQgYnV0dG9uc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgZHJvcGRvd24gc2V0dGluZyBmb3IgY2hvb3NpbmcgdGhlIHNlbGVjdGlvbiBtb2RlLlxyXG4gICAgICogQHBhcmFtIGNvbnRhaW5lckVsIC0gVGhlIEhUTUwgZWxlbWVudCB0byBhcHBlbmQgdGhlIHNldHRpbmcgdG8uXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY3JlYXRlTW9kZVNldHRpbmcoY29udGFpbmVyRWw6IEhUTUxFbGVtZW50KTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZUV4Y2x1ZGVTZWxlY3RhYmxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZURyb3Bkb3duID0gbmV3IFNldHRpbmcoY29udGFpbmVyRWwpIC8vIFN0b3JlIHJlZmVyZW5jZVxyXG4gICAgICAgICAgICAgICAgLnNldE5hbWUoJ1NlbGVjdGlvbiBNb2RlJykgLy8gU2V0dGluZyBOYW1lIGluIEdlcm1hblxyXG4gICAgICAgICAgICAgICAgLnNldERlc2MoJ0Nob29zZSBpZiB0aGUgc2VsZWN0ZWQgZmlsZXMgYW5kIGZvbGRlcnMgc2hvdWxkIGJlIGV4Y2x1ZGVkIG9yIGluY2x1ZGVkLicpIFxyXG4gICAgICAgICAgICAgICAgLmFkZERyb3Bkb3duKGRyb3Bkb3duID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBkcm9wZG93blxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9uKCdleGNsdWRlJywgJ2V4Y2x1ZGUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9uKCdpbmNsdWRlJywgJ2luY2x1ZGUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5jdXJyZW50TW9kZSkgLy8gU2V0IGluaXRpYWwgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKHZhbHVlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudE1vZGUgPSB2YWx1ZSBhcyAnaW5jbHVkZScgfCAnZXhjbHVkZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRyZWVBcHBlYXJhbmNlKCk7IC8vIFVwZGF0ZSB0cmVlIHZpc3VhbHMgYmFzZWQgb24gbmV3IG1vZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBtb2RlIGRyb3Bkb3duIFVJIGVsZW1lbnQgdG8gcmVmbGVjdCB0aGUgY3VycmVudE1vZGUgc3RhdGUuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdXBkYXRlTW9kZURyb3Bkb3duKCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGRyb3Bkb3duQ29tcG9uZW50ID0gdGhpcy5tb2RlRHJvcGRvd24/LmNvbXBvbmVudHNbMF0gYXMgYW55OyAvLyBBY2Nlc3MgZHJvcGRvd24gY29tcG9uZW50XHJcbiAgICAgICAgaWYgKGRyb3Bkb3duQ29tcG9uZW50ICYmIHR5cGVvZiBkcm9wZG93bkNvbXBvbmVudC5zZXRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgZHJvcGRvd25Db21wb25lbnQuc2V0VmFsdWUodGhpcy5jdXJyZW50TW9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIHRvZ2dsZSBzZXR0aW5nIGZvciBzaG93aW5nL2hpZGluZyBmaWxlcyBpbiB0aGUgdHJlZS5cclxuICAgICAqIEBwYXJhbSBjb250YWluZXJFbCAtIFRoZSBIVE1MIGVsZW1lbnQgdG8gYXBwZW5kIHRoZSBzZXR0aW5nIHRvLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNyZWF0ZVNob3dGaWxlc1NldHRpbmcoY29udGFpbmVyRWw6IEhUTUxFbGVtZW50KTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vcHRpb25TaG93RmlsZXMpIHtcclxuICAgICAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgICAgICAuc2V0TmFtZSgnU2hvdyBGaWxlcycpXHJcbiAgICAgICAgICAgICAgICAuc2V0RGVzYygnU2hvdyBGaWxlcyB3aXRoaW4gdGhlIGRpcmVjdG9yeSB0cmVlLicpXHJcbiAgICAgICAgICAgICAgICAuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnNob3dGaWxlcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKHZhbHVlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0ZpbGVzID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkQW5kUmVuZGVyVHJlZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIFwiT0tcIiBhbmQgXCJSZXNldFwiIGJ1dHRvbnMuXHJcbiAgICAgKiBAcGFyYW0gY29udGFpbmVyRWwgLSBUaGUgSFRNTCBlbGVtZW50IHRvIGFwcGVuZCB0aGUgYnV0dG9ucyB0by5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjcmVhdGVBY3Rpb25CdXR0b25zKGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGJ1dHRvbnNFbCA9IGNvbnRhaW5lckVsLmNyZWF0ZURpdih7IGNsczogJ21vZGFsLWJ1dHRvbnMnIH0pO1xyXG4gICAgICAgIGJ1dHRvbnNFbC5zdHlsZS5tYXJnaW5Ub3AgPSAnMTVweCc7XHJcbiAgICAgICAgYnV0dG9uc0VsLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7IC8vIFVzZSBmbGV4IGZvciBhbGlnbm1lbnRcclxuICAgICAgICBidXR0b25zRWwuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSAnZmxleC1lbmQnOyAvLyBBbGlnbiBidXR0b25zIHRvIHRoZSByaWdodFxyXG4gICAgICAgIGJ1dHRvbnNFbC5zdHlsZS5nYXAgPSAnMTBweCc7IC8vIFNwYWNlIGJldHdlZW4gYnV0dG9uc1xyXG5cclxuICAgICAgICAvLyBSZXNldCBCdXR0b24gKFVuZG8gXHUyMUFBXHVGRTBGKVxyXG4gICAgICAgIGNvbnN0IHJlc2V0QnV0dG9uID0gYnV0dG9uc0VsLmNyZWF0ZUVsKCdidXR0b24nKTtcclxuICAgICAgICAvLyBVc2UgT2JzaWRpYW4ncyBzZXRJY29uIGZvciBjb25zaXN0ZW5jeSwgb3IgdXNlIHRleHRcclxuICAgICAgICBzZXRJY29uKHJlc2V0QnV0dG9uLCAncmVzZXQnKTsgLy8gVXNlIGEgc3VpdGFibGUgaWNvbiBsaWtlICdyZXNldCcgb3IgJ3VuZG8nXHJcbiAgICAgICAgcmVzZXRCdXR0b24uYXJpYUxhYmVsID0gJ1Jlc2V0IHNlbGVjdGlvbic7IC8vIEFjY2Vzc2liaWxpdHlcclxuICAgICAgICByZXNldEJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlc2V0U2VsZWN0aW9uVG9Jbml0aWFsKCk7IC8vIFJlc2V0IGludGVybmFsIHN0YXRlXHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTW9kZURyb3Bkb3duKCk7IC8vIFVwZGF0ZSBkcm9wZG93biBVSVxyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkQW5kUmVuZGVyVHJlZSgpOyAvLyBSZS1yZW5kZXIgdHJlZSB3aXRoIHJlc2V0IHN0YXRlXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gQ2xlYXIgQnV0dG9uIChDbGVhciBcdUQ4M0RcdURFQUUpXHJcbiAgICAgICAgY29uc3QgZW1wdHlCdXR0b24gPSBidXR0b25zRWwuY3JlYXRlRWwoJ2J1dHRvbicpO1xyXG4gICAgICAgIC8vIFVzZSBPYnNpZGlhbidzIHNldEljb24gZm9yIGNvbnNpc3RlbmN5LCBvciB1c2UgdGV4dFxyXG4gICAgICAgIHNldEljb24oZW1wdHlCdXR0b24sICdlcmFzZXInKTsgLy8gVXNlIGEgc3VpdGFibGUgaWNvbiBsaWtlICdyZXNldCcgb3IgJ3VuZG8nXHJcbiAgICAgICAgZW1wdHlCdXR0b24uYXJpYUxhYmVsID0gJ0NsZWFyIHNlbGVjdGlvbic7IC8vIEFjY2Vzc2liaWxpdHlcclxuICAgICAgICBlbXB0eUJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlc2V0U2VsZWN0aW9uVG9FbXB0eSgpOyAvLyBDbGVhciBzdGF0ZVxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1vZGVEcm9wZG93bigpOyAvLyBVcGRhdGUgZHJvcGRvd24gVUlcclxuICAgICAgICAgICAgdGhpcy5idWlsZEFuZFJlbmRlclRyZWUoKTsgLy8gUmUtcmVuZGVyIHRyZWUgd2l0aCByZXNldCBzdGF0ZVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIGNhbmNlbCBCdXR0b25cclxuICAgICAgICBjb25zdCBjYW5jZWxCdXR0b24gPSBidXR0b25zRWwuY3JlYXRlRWwoJ2J1dHRvbicsIHsgdGV4dDogJ0NhbmNlbCcgfSk7XHJcbiAgICAgICAgY2FuY2VsQnV0dG9uLmFyaWFMYWJlbCA9ICdjbG9zZSBhbmQgZGlzY2FyZCBjaGFuZ2VzJzsgLy8gQWNjZXNzaWJpbGl0eVxyXG4gICAgICAgIGNhbmNlbEJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBsb2dnZXIubG9nKERFQlVHLFwiQ2FuY2VsIENsaWNrZWQgLSBSZXR1cm5pbmdcIik7IC8vIERlYnVnIGxvZ1xyXG4gICAgICAgICAgICB0aGlzLm9rQ2FsbGJhY2soIG51bGwgKTsgLy8gUGFzcyB0aGUgZmluYWwgc2VsZWN0aW9uIGJhY2tcclxuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIE9LIEJ1dHRvblxyXG4gICAgICAgIGNvbnN0IG9rQnV0dG9uID0gYnV0dG9uc0VsLmNyZWF0ZUVsKCdidXR0b24nLCB7IHRleHQ6ICdPSycsIGNsczogJ21vZC1jdGEnIH0pO1xyXG4gICAgICAgIG9rQnV0dG9uLmFyaWFMYWJlbCA9ICdjbG9zZSBhbmQgc2F2ZSBjaGFuZ2VzJzsgLy8gQWNjZXNzaWJpbGl0eVxyXG4gICAgICAgIG9rQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZHMgdGhlIGxvZ2ljYWwgdHJlZSBzdHJ1Y3R1cmUgZGF0YSBmcm9tIHRoZSB2YXVsdCdzIGZpbGVzIGFuZCBmb2xkZXJzLlxyXG4gICAgICogQHJldHVybnMgVGhlIHJvb3Qgbm9kZSBvZiB0aGUgdHJlZSBzdHJ1Y3R1cmUuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYnVpbGRUcmVlRGF0YSgpOiBUcmVlTm9kZSB7XHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgdmlydHVhbCByb290IG5vZGUgcmVwcmVzZW50aW5nIHRoZSB2YXVsdFxyXG4gICAgICAgIGNvbnN0IHZhdWx0Um9vdE5vZGU6IFRyZWVOb2RlID0ge1xyXG4gICAgICAgICAgICBwYXRoOiAnLycsIC8vIFJvb3QgZm9sZGVyIHBhdGhcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5hcHAudmF1bHQuZ2V0TmFtZSgpIHx8ICdWYXVsdCcsIC8vIFVzZSB2YXVsdCBuYW1lIG9yIGRlZmF1bHRcclxuICAgICAgICAgICAgdHlwZTogJ2ZvbGRlcicsXHJcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcclxuICAgICAgICAgICAgLy8gUGxhY2Vob2xkZXIgZWxlbWVudHMsIHdpbGwgYmUgYXNzaWduZWQgZHVyaW5nIHJlbmRlcmluZ1xyXG4gICAgICAgICAgICBlbGVtZW50OiBudWxsISxcclxuICAgICAgICAgICAgY2hlY2tib3g6IG51bGwhLFxyXG4gICAgICAgICAgICBsYWJlbDogbnVsbCEsXHJcbiAgICAgICAgICAgIGNvbnRhaW5lcjogbnVsbCEsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgZm9sZGVyTm9kZXMgPSBuZXcgTWFwPHN0cmluZywgVHJlZU5vZGU+KCk7XHJcbiAgICAgICAgZm9sZGVyTm9kZXMuc2V0KCcvJywgdmF1bHRSb290Tm9kZSk7IC8vIEFkZCByb290IHRvIHRoZSBtYXBcclxuXHJcbiAgICAgICAgLy8gVXNlIGdldEZpbGVzKCkgdG8gcmV0cmlldmUgYWxsIFRGaWxlIG9iamVjdHMgKE1hcmtkb3duLCBpbWFnZXMsIHBkZiwgZXRjLilcclxuICAgICAgICBjb25zdCBhbGxGaWxlcyA9IHRoaXMuYXBwLnZhdWx0LmdldEZpbGVzKCk7XHJcblxyXG4gICAgICAgIC8vIC0tLSBTdGVwIDE6IENyZWF0ZSBhbGwgZm9sZGVyIG5vZGVzIGJhc2VkIG9uIGZpbGUgcGFyZW50IHBhdGhzIC0tLVxyXG4gICAgICAgIGFsbEZpbGVzLmZvckVhY2goZmlsZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEZvbGRlciA9IGZpbGUucGFyZW50O1xyXG4gICAgICAgICAgICBpZiAoIXBhcmVudEZvbGRlcikgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRQYXRoID0gJyc7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGhQYXJ0cyA9IHBhcmVudEZvbGRlci5wYXRoLnNwbGl0KCcvJykuZmlsdGVyKHAgPT4gcC5sZW5ndGggPiAwKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBwYXJlbnROb2RlID0gdmF1bHRSb290Tm9kZTsgLy8gU3RhcnQgZnJvbSB2YXVsdCByb290XHJcbiAgICAgICAgICAgIHBhdGhQYXJ0cy5mb3JFYWNoKHBhcnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFBhdGggPSBjdXJyZW50UGF0aCA9PT0gJy8nID8gcGFydCA6IGAke2N1cnJlbnRQYXRofS8ke3BhcnR9YDtcclxuICAgICAgICAgICAgICAgIGlmICghZm9sZGVyTm9kZXMuaGFzKGN1cnJlbnRQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0ZvbGRlck5vZGU6IFRyZWVOb2RlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdXJyZW50UGF0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2ZvbGRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogbnVsbCEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrYm94OiBudWxsISxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IG51bGwhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IG51bGwhLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9sZGVyTm9kZXMuc2V0KGN1cnJlbnRQYXRoLCBuZXdGb2xkZXJOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudE5vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5jaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmNoaWxkcmVuIS5wdXNoKG5ld0ZvbGRlck5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBuZXdGb2xkZXJOb2RlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlID0gZm9sZGVyTm9kZXMuZ2V0KGN1cnJlbnRQYXRoKSE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyAtLS0gU3RlcCAyOiBBZGQgZmlsZSBub2RlcyBpZiAnc2hvd0ZpbGVzJyBpcyBlbmFibGVkIC0tLVxyXG4gICAgICAgIGlmICh0aGlzLnNob3dGaWxlcykge1xyXG4gICAgICAgICAgICBhbGxGaWxlcy5mb3JFYWNoKGZpbGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50Rm9sZGVyID0gZmlsZS5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50UGF0aCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Rm9sZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50UGF0aCA9IFwiL1wiICsgKHBhcmVudEZvbGRlci5wYXRoPT09ICcvJyA/ICcnIDogcGFyZW50Rm9sZGVyLnBhdGgpOyAvLyBFbnN1cmUgdGhlIHBhdGggc3RhcnRzIHdpdGggYSBzbGFzaFxyXG4gICAgICAgICAgICAgICAgfSAvLyBFbnN1cmUgdGhlIHBhdGggc3RhcnRzIHdpdGggYSBzbGFzaFxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBmb2xkZXJOb2Rlcy5nZXQocGFyZW50UGF0aCk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZU5vZGU6IFRyZWVOb2RlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGZpbGUucGF0aCxcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBmaWxlLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2ZpbGUnLFxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG51bGwhLFxyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrYm94OiBudWxsISxcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogbnVsbCEsXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiBudWxsISxcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudE5vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5jaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmNoaWxkcmVuIS5wdXNoKGZpbGVOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAtLS0gU3RlcCAzOiBTb3J0IGNoaWxkcmVuIGFscGhhYmV0aWNhbGx5IChmb2xkZXJzIGZpcnN0LCB0aGVuIGZpbGVzKSAtLS1cclxuICAgICAgICBjb25zdCBzb3J0Tm9kZXMgPSAoYTogVHJlZU5vZGUsIGI6IFRyZWVOb2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChhLnR5cGUgPT09ICdmb2xkZXInICYmIGIudHlwZSA9PT0gJ2ZpbGUnKSByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIGlmIChhLnR5cGUgPT09ICdmaWxlJyAmJiBiLnR5cGUgPT09ICdmb2xkZXInKSByZXR1cm4gMTtcclxuICAgICAgICAgICAgcmV0dXJuIGEubmFtZS5sb2NhbGVDb21wYXJlKGIubmFtZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZm9sZGVyTm9kZXMuZm9yRWFjaChub2RlID0+IG5vZGUuY2hpbGRyZW4/LnNvcnQoc29ydE5vZGVzKSk7XHJcblxyXG4gICAgICAgIHJldHVybiB2YXVsdFJvb3ROb2RlOyAvLyBSZXR1cm4gdGhlIHBvcHVsYXRlZCByb290IG5vZGVcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIHRoZSBlbnRpcmUgdHJlZSBzdHJ1Y3R1cmUgaW4gdGhlIERPTSBiYXNlZCBvbiB0aGUgdHJlZSBkYXRhLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlbmRlclRyZWUoKSB7XHJcbiAgICAgICAgIHRoaXMudHJlZVJvb3RFbGVtZW50LmVtcHR5KCk7IC8vIENsZWFyIGV4aXN0aW5nIERPTSBlbGVtZW50c1xyXG4gICAgICAgICB0aGlzLnRyZWVOb2Rlcy5jbGVhcigpOyAvLyBDbGVhciB0aGUgbm9kZSBtYXBcclxuXHJcbiAgICAgICAgIGNvbnN0IHRyZWVEYXRhID0gdGhpcy5idWlsZFRyZWVEYXRhKCk7IC8vIEdldCB0aGUgc3RydWN0dXJlZCBkYXRhXHJcblxyXG4gICAgICAgICAvLyBDcmVhdGUgdGhlIHRvcC1sZXZlbCBsaXN0IGZvciB0aGUgdmF1bHQgY29udGVudHNcclxuICAgICAgICAgY29uc3Qgcm9vdFVsID0gdGhpcy50cmVlUm9vdEVsZW1lbnQuY3JlYXRlRWwoJ3VsJyk7XHJcbiAgICAgICAgIHJvb3RVbC5hZGRDbGFzcygndHJlZS1yb290LXVsJyk7XHJcbiAgICAgICAgIHJvb3RVbC5zdHlsZS5saXN0U3R5bGUgPSAnbm9uZSc7XHJcbiAgICAgICAgIHJvb3RVbC5zdHlsZS5wYWRkaW5nTGVmdCA9ICcwJzsgLy8gUmVtb3ZlIGRlZmF1bHQgbGlzdCBpbmRlbnRhdGlvblxyXG5cclxuICAgICAgICAgLy8gUmVuZGVyIHRoZSByb290IGZvbGRlciBpdHNlbGZcclxuICAgICAgICAgLy90aGlzLnJlbmRlclRyZWVOb2RlKHRyZWVEYXRhLCByb290VWwsIDAsIHRoaXMuY3VycmVudE1vZGUgPT09ICdpbmNsdWRlJyA/IHRoaXMuY3VycmVudEZvbGRlcnMgOiB0aGlzLmN1cnJlbnRGaWxlcyk7XHJcbiAgICAgICAgIHRoaXMucmVuZGVyVHJlZU5vZGUodHJlZURhdGEsIHJvb3RVbCwgMCwgdGhpcy5jdXJyZW50Rm9sZGVycywgdGhpcy5jdXJyZW50RmlsZXMpOyAvL1RPRE86IGV4cGFuZCB0aGlzIHRvIGluY2x1ZGUgZmlsZXMgYXMgd2VsbFxyXG5cclxuICAgICAgICAgLy8gUmVuZGVyIGNoaWxkcmVuIG9mIHRoZSByb290IGZvbGRlclxyXG4gICAgICAgICB0cmVlRGF0YS5jaGlsZHJlbj8uZm9yRWFjaChjaGlsZE5vZGUgPT4ge1xyXG4gICAgICAgICAgICAgLy90aGlzLnJlbmRlclRyZWVOb2RlKGNoaWxkTm9kZSwgcm9vdFVsLCAxLCB0aGlzLmN1cnJlbnRNb2RlID09PSAnaW5jbHVkZScgPyB0aGlzLmN1cnJlbnRGb2xkZXJzIDogdGhpcy5jdXJyZW50RmlsZXMpOyAvLyBTdGFydCByZW5kZXJpbmcgYXQgbGV2ZWwgMVxyXG4gICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlY3Vyc2l2ZWx5IHJlbmRlcnMgYSBzaW5nbGUgdHJlZSBub2RlIGFuZCBpdHMgY2hpbGRyZW4gaW4gdGhlIERPTS5cclxuICAgICAqIEBwYXJhbSBub2RlIC0gVGhlIFRyZWVOb2RlIGRhdGEgdG8gcmVuZGVyLlxyXG4gICAgICogQHBhcmFtIHBhcmVudEVsZW1lbnQgLSBUaGUgSFRNTCBgdWxgIGVsZW1lbnQgdG8gYXBwZW5kIHRoaXMgbm9kZSdzIGBsaWAgdG8uXHJcbiAgICAgKiBAcGFyYW0gbGV2ZWwgLSBUaGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZW5kZXJUcmVlTm9kZShub2RlOiBUcmVlTm9kZSwgcGFyZW50RWxlbWVudDogSFRNTEVsZW1lbnQsIGxldmVsOiBudW1iZXIsIHNlbGVjdGVkUGF0aHM6IFNldDxzdHJpbmc+LCBzZWxlY3RlZGZpbGVzOiBTZXQ8c3RyaW5nPikge1xyXG4gICAgICAgIGNvbnN0IGxpID0gcGFyZW50RWxlbWVudC5jcmVhdGVFbCgnbGknKTtcclxuICAgICAgICBsaS5zdHlsZS5tYXJnaW5MZWZ0ID0gYCR7bGV2ZWwgKiAyMH1weGA7IC8vIEFwcGx5IGluZGVudGF0aW9uIGJhc2VkIG9uIGxldmVsXHJcbiAgICAgICAgbGkuYWRkQ2xhc3MoYHRyZWUtbm9kZS0ke25vZGUudHlwZX1gKTsgLy8gQWRkIGNsYXNzIGZvciB0eXBlIChmb2xkZXIvZmlsZSlcclxuXHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gbGkuY3JlYXRlRGl2KHsgY2xzOiAndHJlZS1ub2RlLWNvbnRhaW5lcicgfSk7XHJcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XHJcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmFsaWduSXRlbXMgPSAnY2VudGVyJztcclxuICAgICAgICBjb250YWluZXIuc3R5bGUucGFkZGluZyA9ICcycHggMCc7IC8vIEFkZCBzb21lIHZlcnRpY2FsIHBhZGRpbmdcclxuXHJcbiAgICAgICAgLy8gLS0tIFRvZ2dsZSBCdXR0b24gZm9yIEZvbGRlcnMgLS0tXHJcbiAgICAgICAgbGV0IHRvZ2dsZUJ1dHRvbjogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbDtcclxuICAgICAgICBsZXQgaXNDb2xsYXBzZWQgPSB0cnVlOyAvLyBEZWZhdWx0IHN0YXRlIGlzIGNvbGxhcHNlZFxyXG5cclxuICAgICAgICBpZiAobm9kZS50eXBlID09PSAnZm9sZGVyJykge1xyXG4gICAgICAgICAgICB0b2dnbGVCdXR0b24gPSBjb250YWluZXIuY3JlYXRlU3Bhbih7IGNsczogJ3RyZWUtdG9nZ2xlLWJ1dHRvbicgfSk7XHJcbiAgICAgICAgICAgIHRvZ2dsZUJ1dHRvbi50ZXh0Q29udGVudCA9ICdcdTI1QjYnOyAvLyBSaWdodC1wb2ludGluZyB0cmlhbmdsZVxyXG4gICAgICAgICAgICB0b2dnbGVCdXR0b24uc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xyXG4gICAgICAgICAgICB0b2dnbGVCdXR0b24uc3R5bGUubWFyZ2luUmlnaHQgPSAnNXB4JztcclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgZm9sZGVyIG9yIGFueSBvZiBpdHMgY2hpbGRyZW4gYXJlIHNlbGVjdGVkXHJcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEV4cGFuZCA9IHRoaXMuc2hvdWxkRXhwYW5kRm9sZGVyKG5vZGUsIHNlbGVjdGVkUGF0aHMsIHNlbGVjdGVkZmlsZXMpO1xyXG4gICAgICAgICAgICBpZiAoc2hvdWxkRXhwYW5kKSB7XHJcbiAgICAgICAgICAgICAgICBpc0NvbGxhcHNlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0b2dnbGVCdXR0b24ub25jbGljayA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlzQ29sbGFwc2VkID0gIWlzQ29sbGFwc2VkO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvZ2dsZUJ1dHRvbikgdG9nZ2xlQnV0dG9uLnRleHRDb250ZW50ID0gaXNDb2xsYXBzZWQgPyAnXHUyNUI2JyA6ICdcdTI1QkMnOyAvLyBVcGRhdGUgdHJpYW5nbGUgZGlyZWN0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW5VbCkgY2hpbGRyZW5VbC5zdHlsZS5kaXNwbGF5ID0gaXNDb2xsYXBzZWQgPyAnbm9uZScgOiAnYmxvY2snOyAvLyBTaG93L2hpZGUgY2hpbGRyZW5cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIC0tLSBDaGVja2JveCAtLS1cclxuICAgICAgICBjb25zdCBjaGVja2JveCA9IGNvbnRhaW5lci5jcmVhdGVFbCgnaW5wdXQnLCB7IHR5cGU6ICdjaGVja2JveCcgfSk7XHJcbiAgICAgICAgY2hlY2tib3guaWQgPSBgdHJlZS1jYi0ke25vZGUucGF0aC5yZXBsYWNlKC9bXmEtekEtWjAtOV0vZywgJy0nKX1gOyAvLyBDcmVhdGUgYSBzYWZlIElEXHJcbiAgICAgICAgY2hlY2tib3guZGF0YXNldC5wYXRoID0gbm9kZS5wYXRoOyAvLyBTdG9yZSBwYXRoIGluIGRhdGEgYXR0cmlidXRlXHJcbiAgICAgICAgY2hlY2tib3guZGF0YXNldC50eXBlID0gbm9kZS50eXBlOyAvLyBTdG9yZSB0eXBlXHJcblxyXG4gICAgICAgIC8vIC0tLSBMYWJlbCAtLS1cclxuICAgICAgICBjb25zdCBsYWJlbCA9IGNvbnRhaW5lci5jcmVhdGVFbCgnbGFiZWwnKTtcclxuICAgICAgICBsYWJlbC50ZXh0Q29udGVudCA9IGAke25vZGUudHlwZSA9PT0gJ2ZvbGRlcicgPyAnXHVEODNEXHVEQ0MxJyA6ICdcdUQ4M0RcdURDQzQnfSAke25vZGUubmFtZX1gO1xyXG4gICAgICAgIC8vIGxhYmVsLnRleHRDb250ZW50ID0gbm9kZS5uYW1lO1xyXG4gICAgICAgIGxhYmVsLmh0bWxGb3IgPSBjaGVja2JveC5pZDsgLy8gTGluayBsYWJlbCB0byBjaGVja2JveFxyXG4gICAgICAgIGxhYmVsLnN0eWxlLm1hcmdpbkxlZnQgPSAnNXB4JztcclxuICAgICAgICBsYWJlbC5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XHJcbiAgICAgICAgbGFiZWwudGl0bGUgPSBub2RlLnBhdGg7IC8vIFNob3cgZnVsbCBwYXRoIG9uIGhvdmVyXHJcblxyXG4gICAgICAgIC8vIC0tLSBTdG9yZSByZWZlcmVuY2VzIGluIHRoZSBub2RlIG9iamVjdCBhbmQgbWFwIC0tLVxyXG4gICAgICAgIG5vZGUuZWxlbWVudCA9IGxpO1xyXG4gICAgICAgIG5vZGUuY2hlY2tib3ggPSBjaGVja2JveDtcclxuICAgICAgICBub2RlLmxhYmVsID0gbGFiZWw7XHJcbiAgICAgICAgbm9kZS5jb250YWluZXIgPSBjb250YWluZXI7IC8vIFN0b3JlIGNvbnRhaW5lciByZWZlcmVuY2VcclxuICAgICAgICB0aGlzLnRyZWVOb2Rlcy5zZXQobm9kZS5wYXRoLCBub2RlKTtcclxuXHJcbiAgICAgICAgLy8gLS0tIFNldCBpbml0aWFsIGNoZWNrZWQgc3RhdGUgYmFzZWQgb24gY3VycmVudCBzZWxlY3Rpb24gLS0tXHJcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2ZvbGRlcicpIHtcclxuICAgICAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9IHRoaXMuY3VycmVudEZvbGRlcnMuaGFzKG5vZGUucGF0aCk7XHJcbiAgICAgICAgfSBlbHNlIHsgLy8gZmlsZVxyXG4gICAgICAgICAgICBjaGVja2JveC5jaGVja2VkID0gdGhpcy5jdXJyZW50RmlsZXMuaGFzKG5vZGUucGF0aCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAtLS0gQWRkIGV2ZW50IGxpc3RlbmVyIGZvciBjaGVja2JveCBjaGFuZ2VzIC0tLVxyXG4gICAgICAgIGNoZWNrYm94Lm9uY2hhbmdlID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgICAgICBjb25zdCBwYXRoID0gdGFyZ2V0LmRhdGFzZXQucGF0aCE7XHJcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB0YXJnZXQuZGF0YXNldC50eXBlIGFzICdmb2xkZXInIHwgJ2ZpbGUnO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBzZXRzXHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQuY2hlY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdmb2xkZXInKXtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRpc3BsYXlNb2RlID09PSAnZm9sZGVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRGb2xkZXJzLmNsZWFyKCk7IC8vIENsZWFyIHByZXZpb3VzIHNlbGVjdGlvbiBpZiBvbmx5IG9uZSBmb2xkZXIgY2FuIGJlIHNlbGVjdGVkXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRGb2xkZXJzLmFkZChwYXRoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXNwbGF5TW9kZSA9PT0gJ2ZpbGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEZpbGVzLmNsZWFyKCk7IC8vIENsZWFyIHByZXZpb3VzIHNlbGVjdGlvbiBpZiBvbmx5IG9uZSBmaWxlIGNhbiBiZSBzZWxlY3RlZFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRGaWxlcy5hZGQocGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2ZvbGRlcicpIHRoaXMuY3VycmVudEZvbGRlcnMuZGVsZXRlKHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB0aGlzLmN1cnJlbnRGaWxlcy5kZWxldGUocGF0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB2aXN1YWwgc3RhdGUgb2YgdGhlIGVudGlyZSB0cmVlIGFmdGVyIGEgY2hhbmdlXHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVHJlZUFwcGVhcmFuY2UoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyAtLS0gUmVuZGVyIGNoaWxkcmVuIHJlY3Vyc2l2ZWx5IGlmIGl0J3MgYSBmb2xkZXIgLS0tXHJcbiAgICAgICAgbGV0IGNoaWxkcmVuVWw6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2ZvbGRlcicgJiYgbm9kZS5jaGlsZHJlbiAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY2hpbGRyZW5VbCA9IGxpLmNyZWF0ZUVsKCd1bCcpO1xyXG4gICAgICAgICAgICBjaGlsZHJlblVsLnN0eWxlLmxpc3RTdHlsZSA9ICdub25lJztcclxuICAgICAgICAgICAgY2hpbGRyZW5VbC5zdHlsZS5wYWRkaW5nTGVmdCA9ICcwJzsgLy8gUmVzZXQgcGFkZGluZyBmb3IgbmVzdGVkIGxpc3RcclxuICAgICAgICAgICAgY2hpbGRyZW5VbC5zdHlsZS5tYXJnaW5MZWZ0ID0gJzAnOyAvLyBQcmV2ZW50IGRvdWJsZSBpbmRlbnRhdGlvbiBmcm9tIGRlZmF1bHQgVUwgc3R5bGVzXHJcbiAgICAgICAgICAgIGNoaWxkcmVuVWwuc3R5bGUuZGlzcGxheSA9IGlzQ29sbGFwc2VkID8gJ25vbmUnIDogJ2Jsb2NrJzsgLy8gU2hvdy9oaWRlIGNoaWxkcmVuIGJhc2VkIG9uIGluaXRpYWwgc3RhdGVcclxuXHJcbiAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB0aGlzLnJlbmRlclRyZWVOb2RlKGNoaWxkLCBjaGlsZHJlblVsISwgbGV2ZWwgKyAxLCBzZWxlY3RlZFBhdGhzLCBzZWxlY3RlZGZpbGVzKSk7IC8vIEluY3JlYXNlIGxldmVsIGZvciBjaGlsZHJlblxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBIZWxwZXIgbWV0aG9kIHRvIGRldGVybWluZSBpZiBhIGZvbGRlciBzaG91bGQgYmUgZXhwYW5kZWRcclxuICAgIHByaXZhdGUgc2hvdWxkRXhwYW5kRm9sZGVyKG5vZGU6IFRyZWVOb2RlLCBzZWxlY3RlZFBhdGhzOiBTZXQ8c3RyaW5nPiwgc2VsZWN0ZWRGaWxlczogU2V0PHN0cmluZz4pOiBib29sZWFuIHtcclxuICAgICAgICBpZiAoc2VsZWN0ZWRQYXRocy5oYXMobm9kZS5wYXRoKSB8fCBzZWxlY3RlZEZpbGVzLmhhcyhub2RlLnBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBUaGUgZm9sZGVyIGl0c2VsZiBpcyBzZWxlY3RlZFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRFeHBhbmRGb2xkZXIoY2hpbGQsIHNlbGVjdGVkUGF0aHMsIHNlbGVjdGVkRmlsZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIEEgY2hpbGQgaXMgc2VsZWN0ZWRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBOZWl0aGVyIHRoZSBmb2xkZXIgbm9yIGl0cyBjaGlsZHJlbiBhcmUgc2VsZWN0ZWRcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSB2aXN1YWwgYXBwZWFyYW5jZSAoZW5hYmxlZC9kaXNhYmxlZC9zdHlsaW5nKSBvZiBhbGwgbm9kZXNcclxuICAgICAqIGluIHRoZSB0cmVlIGJhc2VkIG9uIHRoZSBjdXJyZW50IG1vZGUgYW5kIHNlbGVjdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdXBkYXRlVHJlZUFwcGVhcmFuY2UoKSB7XHJcbiAgICAgICAgdGhpcy50cmVlTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaXNEaXNhYmxlZCA9IGZhbHNlOyAvLyBTaG91bGQgdGhlIG5vZGUgYXBwZWFyIGRpc2FibGVkIChncmV5ZWQgb3V0KT9cclxuICAgICAgICAgICAgbGV0IGlzRWZmZWN0aXZlbHlJbmNsdWRlZCA9IGZhbHNlOyAvLyBJcyB0aGUgbm9kZSBwYXJ0IG9mIHRoZSAnYWN0aXZlJyBzZXQgaW4gaW5jbHVkZSBtb2RlP1xyXG4gICAgICAgICAgICBsZXQgaXNFZmZlY3RpdmVseUV4Y2x1ZGVkID0gZmFsc2U7IC8vIElzIHRoZSBub2RlIHBhcnQgb2YgdGhlICdpbmFjdGl2ZScgc2V0IGluIGV4Y2x1ZGUgbW9kZT9cclxuXHJcbiAgICAgICAgICAgIC8vIERldGVybWluZSBpZiBhbiBhbmNlc3RvciBGT0xERVIgb2YgdGhpcyBub2RlIGlzIHNlbGVjdGVkXHJcbiAgICAgICAgICAgIGxldCBhbmNlc3RvckZvbGRlclNlbGVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50UGF0aCA9IG5vZGUucGF0aDtcclxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRQYXRoICE9PSAnLycpIHtcclxuICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRQYXRoID0gY3VycmVudFBhdGguc3Vic3RyaW5nKDAsIGN1cnJlbnRQYXRoLmxhc3RJbmRleE9mKCcvJykpIHx8ICcvJztcclxuICAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50Rm9sZGVycy5oYXMocGFyZW50UGF0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgYW5jZXN0b3JGb2xkZXJTZWxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICBpZiAocGFyZW50UGF0aCA9PT0gY3VycmVudFBhdGgpIGJyZWFrOyAvLyBTYWZldHkgYnJlYWsgYXQgcm9vdFxyXG4gICAgICAgICAgICAgICAgIGN1cnJlbnRQYXRoID0gcGFyZW50UGF0aDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG5vZGUgaXRzZWxmIGlzIHNlbGVjdGVkXHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGVTZWxlY3RlZCA9IG5vZGUudHlwZSA9PT0gJ2ZvbGRlcidcclxuICAgICAgICAgICAgICAgID8gdGhpcy5jdXJyZW50Rm9sZGVycy5oYXMobm9kZS5wYXRoKVxyXG4gICAgICAgICAgICAgICAgOiB0aGlzLmN1cnJlbnRGaWxlcy5oYXMobm9kZS5wYXRoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIC0tLSBBcHBseSBMb2dpYyBCYXNlZCBvbiBNb2RlIC0tLVxyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50TW9kZSA9PT0gJ2V4Y2x1ZGUnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFWENMVURFIE1vZGU6IEEgbm9kZSBpcyBjb25zaWRlcmVkIGV4Y2x1ZGVkIGlmIGl0IE9SIGFuIGFuY2VzdG9yIEZPTERFUiBpcyBzZWxlY3RlZC5cclxuICAgICAgICAgICAgICAgIC8vIFZpc3VhbGx5IGRpc2FibGUgKGdyZXkgb3V0KSBub2RlcyB0aGF0IGFyZSBleGNsdWRlZC5cclxuICAgICAgICAgICAgICAgIGlzRWZmZWN0aXZlbHlFeGNsdWRlZCA9IG5vZGVTZWxlY3RlZCB8fCBhbmNlc3RvckZvbGRlclNlbGVjdGVkO1xyXG4gICAgICAgICAgICAgICAgaXNEaXNhYmxlZCA9IGlzRWZmZWN0aXZlbHlFeGNsdWRlZDtcclxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gSU5DTFVERSBNb2RlXHJcbiAgICAgICAgICAgICAgICAvLyBJTkNMVURFIE1vZGU6IEEgbm9kZSBpcyBjb25zaWRlcmVkIGluY2x1ZGVkIGlmIGl0IE9SIGFuIGFuY2VzdG9yIEZPTERFUiBpcyBzZWxlY3RlZC5cclxuICAgICAgICAgICAgICAgIC8vIFZpc3VhbGx5IGRpc2FibGUgKGdyZXkgb3V0KSBub2RlcyB0aGF0IGFyZSBOT1QgaW5jbHVkZWQuXHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnZm9sZGVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzRWZmZWN0aXZlbHlJbmNsdWRlZCA9IG5vZGVTZWxlY3RlZCB8fCBhbmNlc3RvckZvbGRlclNlbGVjdGVkO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gZmlsZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbGUgaW5jbHVkZWQgaWYgc2VsZWN0ZWQgT1IgcGFyZW50IHBhdGggaXMgaW5jbHVkZWRcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRQYXRoID0gbm9kZS5wYXRoLnN1YnN0cmluZygwLCBub2RlLnBhdGgubGFzdEluZGV4T2YoJy8nKSkgfHwgJy8nO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudEVmZmVjdGl2ZWx5SW5jbHVkZWQgPSB0aGlzLmlzUGF0aEVmZmVjdGl2ZWx5SW5jbHVkZWQocGFyZW50UGF0aCk7IC8vIENoZWNrIHBhcmVudCBmb2xkZXIgc3RhdHVzXHJcbiAgICAgICAgICAgICAgICAgICAgaXNFZmZlY3RpdmVseUluY2x1ZGVkID0gbm9kZVNlbGVjdGVkIHx8IHBhcmVudEVmZmVjdGl2ZWx5SW5jbHVkZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpc0Rpc2FibGVkID0gIWlzRWZmZWN0aXZlbHlJbmNsdWRlZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gLS0tIEFwcGx5IFZpc3VhbCBTdHlsZXMgLS0tXHJcbiAgICAgICAgICAgIC8vIENoZWNrYm94IGl0c2VsZiBzaG91bGQgYWx3YXlzIGJlIGNsaWNrYWJsZSB0byBjaGFuZ2Ugc2VsZWN0aW9uIHN0YXRlXHJcbiAgICAgICAgICAgIG5vZGUuY2hlY2tib3guZGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgbm9kZS5jaGVja2JveC5jaGVja2VkID0gbm9kZVNlbGVjdGVkO1xyXG5cclxuICAgICAgICAgICAgLy8gQXBwbHkgc3R5bGluZyB0byB0aGUgY29udGFpbmVyIChsYWJlbCwgaWNvbikgYmFzZWQgb24gZGlzYWJsZWQgc3RhdGVcclxuICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuZWxlbWVudC5hZGRDbGFzcygnaXMtZGlzYWJsZWQnKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuZWxlbWVudC5yZW1vdmVDbGFzcygnaXMtZGlzYWJsZWQnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gLS0tIEZJWCBmb3IgSW52YWxpZENoYXJhY3RlckVycm9yIC0tLVxyXG4gICAgICAgICAgICAvLyBSZW1vdmUgY2xhc3NlcyBpbmRpdmlkdWFsbHlcclxuICAgICAgICAgICAgbm9kZS5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWluY2x1ZGVkJywgJ2lzLWV4Y2x1ZGVkJyk7XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgc3BlY2lmaWMgY2xhc3NlcyBmb3Igc3R5bGluZyBpbmNsdWRlZC9leGNsdWRlZCBzdGF0ZXNcclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudE1vZGUgPT09ICdpbmNsdWRlJyAmJiBpc0VmZmVjdGl2ZWx5SW5jbHVkZWQpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuZWxlbWVudC5hZGRDbGFzcygnaXMtaW5jbHVkZWQnKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRNb2RlID09PSAnZXhjbHVkZScgJiYgaXNFZmZlY3RpdmVseUV4Y2x1ZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgLy8gQXBwbHkgZXhjbHVkZWQgY2xhc3MgZXZlbiBpZiBpdCdzIGp1c3QgdmlzdWFsbHkgZGlzYWJsZWRcclxuICAgICAgICAgICAgICAgICAvLyBUaGlzIGFsbG93cyBzcGVjaWZpYyBzdHlsaW5nIGZvciBleGNsdWRlZCBpdGVtcyBiZXlvbmQganVzdCBncmV5ZWQgb3V0XHJcbiAgICAgICAgICAgICAgICBub2RlLmVsZW1lbnQuYWRkQ2xhc3MoJ2lzLWV4Y2x1ZGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgaWYgYSBnaXZlbiBwYXRoIGlzIGVmZmVjdGl2ZWx5IGluY2x1ZGVkXHJcbiAgICAgKiBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24gdW5kZXIgJ2luY2x1ZGUnIG1vZGUuXHJcbiAgICAgKiBBIHBhdGggaXMgaW5jbHVkZWQgaWYgaXQgKGZpbGUgb3IgZm9sZGVyKSBpcyBzZWxlY3RlZCwgb3IgaWYgYW55IG9mIGl0cyBhbmNlc3RvciBGT0xERVJTIGFyZSBzZWxlY3RlZC5cclxuICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIGZvbGRlciBvciBmaWxlIHBhdGggdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBwYXRoIHNob3VsZCBiZSBjb25zaWRlcmVkIGluY2x1ZGVkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaXNQYXRoRWZmZWN0aXZlbHlJbmNsdWRlZChwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICAvLyBUaGlzIGNoZWNrIGlzIHByaW1hcmlseSBmb3IgJ2luY2x1ZGUnIG1vZGUgbG9naWMuXHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE1vZGUgIT09ICdpbmNsdWRlJykge1xyXG4gICAgICAgICAgICAgLy8gSW4gJ2V4Y2x1ZGUnIG1vZGUsIGNvbmNlcHR1YWxseSBldmVyeXRoaW5nIGlzIGluY2x1ZGVkIHVubGVzcyBleGNsdWRlZC5cclxuICAgICAgICAgICAgIC8vIEZvciBpbnRlcm5hbCBjaGVja3MsIHdlIG1pZ2h0IG5lZWQgdGhlIGludmVyc2Ugb2YgZXhjbHVzaW9uLlxyXG4gICAgICAgICAgICAgcmV0dXJuICF0aGlzLmlzUGF0aEVmZmVjdGl2ZWx5RXhjbHVkZWQocGF0aCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgcGF0aCBpdHNlbGYgaXMgc2VsZWN0ZWQgKGFwcGxpZXMgdG8gYm90aCBmaWxlcyBhbmQgZm9sZGVycylcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50RmlsZXMuaGFzKHBhdGgpIHx8IHRoaXMuY3VycmVudEZvbGRlcnMuaGFzKHBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgYW55IGFuY2VzdG9yIEZPTERFUiBpcyBzZWxlY3RlZFxyXG4gICAgICAgIGxldCBjdXJyZW50ID0gcGF0aDtcclxuICAgICAgICB3aGlsZSAoY3VycmVudCAhPT0gJy8nKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBjdXJyZW50LnN1YnN0cmluZygwLCBjdXJyZW50Lmxhc3RJbmRleE9mKCcvJykpIHx8ICcvJztcclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudEZvbGRlcnMuaGFzKHBhcmVudFBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gQW4gYW5jZXN0b3IgZm9sZGVyIGlzIHNlbGVjdGVkXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBhcmVudFBhdGggPT09IGN1cnJlbnQpIGJyZWFrOyAvLyBSZWFjaGVkIHJvb3Qgb3IgZXJyb3JcclxuICAgICAgICAgICAgY3VycmVudCA9IHBhcmVudFBhdGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5laXRoZXIgdGhlIHBhdGggbm9yIGFueSBhbmNlc3RvciBmb2xkZXIgaXMgc2VsZWN0ZWRcclxuICAgIH1cclxuXHJcbiAgICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGlmIGEgZ2l2ZW4gcGF0aCBpcyBlZmZlY3RpdmVseSBleGNsdWRlZFxyXG4gICAgICogaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVuZGVyICdleGNsdWRlJyBtb2RlLlxyXG4gICAgICogQSBwYXRoIGlzIGV4Y2x1ZGVkIGlmIGl0IChmaWxlIG9yIGZvbGRlcikgaXMgc2VsZWN0ZWQsIG9yIGlmIGFueSBvZiBpdHMgYW5jZXN0b3IgRk9MREVSUyBhcmUgc2VsZWN0ZWQuXHJcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBmb2xkZXIgb3IgZmlsZSBwYXRoIHRvIGNoZWNrLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgcGF0aCBzaG91bGQgYmUgY29uc2lkZXJlZCBleGNsdWRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGlzUGF0aEVmZmVjdGl2ZWx5RXhjbHVkZWQocGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgIC8vIFRoaXMgY2hlY2sgaXMgcHJpbWFyaWx5IGZvciAnZXhjbHVkZScgbW9kZSBsb2dpYy5cclxuICAgICAgICAgaWYgKHRoaXMuY3VycmVudE1vZGUgIT09ICdleGNsdWRlJykge1xyXG4gICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICB9XHJcblxyXG4gICAgICAgICAvLyBDaGVjayBpZiB0aGUgcGF0aCBpdHNlbGYgaXMgc2VsZWN0ZWRcclxuICAgICAgICAgaWYgKHRoaXMuY3VycmVudEZpbGVzLmhhcyhwYXRoKSB8fCB0aGlzLmN1cnJlbnRGb2xkZXJzLmhhcyhwYXRoKSkge1xyXG4gICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgIH1cclxuXHJcbiAgICAgICAgIC8vIENoZWNrIGlmIGFueSBhbmNlc3RvciBGT0xERVIgaXMgc2VsZWN0ZWRcclxuICAgICAgICAgbGV0IGN1cnJlbnQgPSBwYXRoO1xyXG4gICAgICAgICB3aGlsZSAoY3VycmVudCAhPT0gJy8nKSB7XHJcbiAgICAgICAgICAgICBjb25zdCBwYXJlbnRQYXRoID0gY3VycmVudC5zdWJzdHJpbmcoMCwgY3VycmVudC5sYXN0SW5kZXhPZignLycpKSB8fCAnLyc7XHJcbiAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50Rm9sZGVycy5oYXMocGFyZW50UGF0aCkpIHtcclxuICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gQW4gYW5jZXN0b3IgZm9sZGVyIGlzIHNlbGVjdGVkXHJcbiAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICBpZiAocGFyZW50UGF0aCA9PT0gY3VycmVudCkgYnJlYWs7IC8vIFJlYWNoZWQgcm9vdCBvciBlcnJvclxyXG4gICAgICAgICAgICAgY3VycmVudCA9IHBhcmVudFBhdGg7XHJcbiAgICAgICAgIH1cclxuXHJcbiAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTmVpdGhlciB0aGUgcGF0aCBub3IgYW55IGFuY2VzdG9yIGZvbGRlciBpcyBzZWxlY3RlZCBmb3IgZXhjbHVzaW9uXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tYmluZXMgYnVpbGRpbmcgdGhlIHRyZWUgZGF0YSwgcmVuZGVyaW5nIHRoZSBET00sIGFuZCBhcHBseWluZyBpbml0aWFsIGFwcGVhcmFuY2UuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYnVpbGRBbmRSZW5kZXJUcmVlKCkge1xyXG4gICAgICAgIC8vIGxvZ2dlci5sb2coREVCVUcsJ0J1aWxkaW5nIGFuZCByZW5kZXJpbmcgdHJlZS4uLicpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyVHJlZSgpOyAvLyBCdWlsZCBkYXRhIGFuZCByZW5kZXIgRE9NIGVsZW1lbnRzXHJcbiAgICAgICAgdGhpcy51cGRhdGVUcmVlQXBwZWFyYW5jZSgpOyAvLyBBcHBseSBzdHlsZXMgYmFzZWQgb24gY3VycmVudCBtb2RlL3NlbGVjdGlvblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBtb2RhbCBpcyBjbG9zZWQuIENsZWFucyB1cCByZXNvdXJjZXMuXHJcbiAgICAgKi9cclxuICAgIG9uQ2xvc2UoKSB7XHJcbiAgICAgICAgLy8gR2F0aGVyIHRoZSBmaW5hbCBzdGF0ZSBPTkxZIHdoZW4gT0sgaXMgY2xpY2tlZFxyXG4gICAgICAgIGNvbnN0IHJlc3VsdDogRGlyZWN0b3J5U2VsZWN0aW9uUmVzdWx0ID0ge1xyXG4gICAgICAgICAgICBmb2xkZXJzOiBBcnJheS5mcm9tKHRoaXMuY3VycmVudEZvbGRlcnMpLFxyXG4gICAgICAgICAgICBmaWxlczogQXJyYXkuZnJvbSh0aGlzLmN1cnJlbnRGaWxlcyksXHJcbiAgICAgICAgICAgIG1vZGU6IHRoaXMuY3VycmVudE1vZGUsXHJcbiAgICAgICAgICAgIGRpc3BsYXk6IHRoaXMuY3VycmVudERpc3BsYXksXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBsb2dnZXIubG9nKERFQlVHLFwiT0sgQ2xpY2tlZCAtIFJldHVybmluZyBSZXN1bHQ6XCIsIHJlc3VsdCk7IC8vIERlYnVnIGxvZ1xyXG4gICAgICAgIHRoaXMub2tDYWxsYmFjayhyZXN1bHQpOyAvLyBQYXNzIHRoZSBmaW5hbCBzZWxlY3Rpb24gYmFja1xyXG4gICAgICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnRlbnRFbC5lbXB0eSgpOyAvLyBDbGVhciB0aGUgbW9kYWwncyBjb250ZW50XHJcbiAgICAgICAgdGhpcy50cmVlTm9kZXMuY2xlYXIoKTsgLy8gQ2xlYXIgdGhlIG5vZGUgbWFwIHRvIGZyZWUgbWVtb3J5XHJcbiAgICAgICAgdGhpcy5tb2RlRHJvcGRvd24gPSBudWxsOyAvLyBDbGVhciByZWZlcmVuY2VcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBlYXNpbHkgb3BlbiB0aGUgRGlyZWN0b3J5IFNlbGVjdGlvbiBNb2RhbC5cclxuICpcclxuICogQHBhcmFtIGFwcCAtIFRoZSBPYnNpZGlhbiBBcHAgaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBpbml0aWFsRm9sZGVycyAtIEFycmF5IG9mIGluaXRpYWxseSBzZWxlY3RlZCBmb2xkZXIgcGF0aHMuXHJcbiAqIEBwYXJhbSBpbml0aWFsRmlsZXMgLSBBcnJheSBvZiBpbml0aWFsbHkgc2VsZWN0ZWQgZmlsZSBwYXRocy5cclxuICogQHBhcmFtIGluaXRpYWxNb2RlIC0gVGhlIGluaXRpYWwgc2VsZWN0aW9uIG1vZGUgKCdpbmNsdWRlJyBvciAnZXhjbHVkZScpLlxyXG4gKiBAcGFyYW0gb2tDYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgdXNlciBjbGlja3MgXCJPS1wiLiBSZWNlaXZlcyB0aGUgc2VsZWN0aW9uIHJlc3VsdC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBvcGVuRGlyZWN0b3J5U2VsZWN0aW9uTW9kYWwoXHJcbiAgICBhcHA6IEFwcCxcclxuICAgIGluaXRpYWxGb2xkZXJzOiBzdHJpbmdbXSxcclxuICAgIGluaXRpYWxGaWxlczogc3RyaW5nW10sXHJcbiAgICBvcHRpb25zOiBEaXJlY3RvcnlTZWxlY3Rpb25PcHRpb25zLFxyXG4gICAgb2tDYWxsYmFjazogKHJlc3VsdDogRGlyZWN0b3J5U2VsZWN0aW9uUmVzdWx0IHwgbnVsbCkgPT4gdm9pZFxyXG4pOiB2b2lkIHtcclxuICAgIC8vIENyZWF0ZSBhbmQgb3BlbiB0aGUgbW9kYWwgaW5zdGFuY2VcclxuICAgIG5ldyBEaXJlY3RvcnlTZWxlY3Rpb25Nb2RhbChcclxuICAgICAgICBhcHAsXHJcbiAgICAgICAgaW5pdGlhbEZvbGRlcnMsXHJcbiAgICAgICAgaW5pdGlhbEZpbGVzLFxyXG4gICAgICAgIG9wdGlvbnMsXHJcbiAgICAgICAgb2tDYWxsYmFja1xyXG4gICAgKS5vcGVuKCk7XHJcbn1cclxuXHJcbi8qXHJcbi8vIC0tLSBFeGFtcGxlIFVzYWdlIGluIHlvdXIgUGx1Z2luJ3MgU2V0dGluZ3MgVGFiIC0tLVxyXG4vLyAoUGxhY2UgdGhpcyBpbiB5b3VyIHNldHRpbmdzIHRhYiBmaWxlLCBlLmcuLCBzZXR0aW5ncy50cylcclxuXHJcbmltcG9ydCB7IEFwcCwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZyB9IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IHsgb3BlbkRpcmVjdG9yeVNlbGVjdGlvbk1vZGFsLCBEaXJlY3RvcnlTZWxlY3Rpb25SZXN1bHQgfSBmcm9tICcuL0RpcmVjdG9yeVNlbGVjdGlvbk1vZGFsJzsgLy8gQWRqdXN0IHBhdGggYXMgbmVlZGVkXHJcbmltcG9ydCBZb3VyUGx1Z2luIGZyb20gJy4vbWFpbic7IC8vIEFkanVzdCBwYXRoIHRvIHlvdXIgbWFpbiBwbHVnaW4gZmlsZVxyXG5cclxuLy8gLS0tIEV4YW1wbGUgUGx1Z2luIFNldHRpbmdzIEludGVyZmFjZSAoaW4geW91ciBtYWluLnRzIG9yIHNldHRpbmdzIGZpbGUpIC0tLVxyXG5leHBvcnQgaW50ZXJmYWNlIFlvdXJQbHVnaW5TZXR0aW5ncyB7XHJcbiAgICBzZWxlY3RlZEZvbGRlcnM6IHN0cmluZ1tdO1xyXG4gICAgc2VsZWN0ZWRGaWxlczogc3RyaW5nW107XHJcbiAgICBzZWxlY3Rpb25Nb2RlOiAnaW5jbHVkZScgfCAnZXhjbHVkZSc7XHJcbiAgICAvLyAuLi4gb3RoZXIgc2V0dGluZ3MgZm9yIHlvdXIgcGx1Z2luXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX1NFVFRJTkdTOiBZb3VyUGx1Z2luU2V0dGluZ3MgPSB7XHJcbiAgICBzZWxlY3RlZEZvbGRlcnM6IFtdLFxyXG4gICAgc2VsZWN0ZWRGaWxlczogW10sXHJcbiAgICBzZWxlY3Rpb25Nb2RlOiAnZXhjbHVkZScsIC8vIERlZmF1bHQgbW9kZSBpcyBvZnRlbiAnZXhjbHVkZSdcclxuICAgIC8vIC4uLiBvdGhlciBkZWZhdWx0IHNldHRpbmdzXHJcbn1cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgWW91clBsdWdpblNldHRpbmdzVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XHJcbiAgICBwbHVnaW46IFlvdXJQbHVnaW47XHJcblxyXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogWW91clBsdWdpbikge1xyXG4gICAgICAgIHN1cGVyKGFwcCwgcGx1Z2luKTtcclxuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuICAgIH1cclxuXHJcbiAgICBkaXNwbGF5KCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XHJcbiAgICAgICAgY29udGFpbmVyRWwuZW1wdHkoKTtcclxuXHJcbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnRWluc3RlbGx1bmdlbiBmXHUwMEZDciBNZWluIFBsdWdpbicgfSk7IC8vIFNldHRpbmdzIFRpdGxlIGluIEdlcm1hblxyXG5cclxuICAgICAgICAvLyAtLS0gQnV0dG9uIHRvIE9wZW4gdGhlIE1vZGFsIC0tLVxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnVmVyemVpY2huaXNzZS9EYXRlaWVuIGtvbmZpZ3VyaWVyZW4nKSAvLyBTZXR0aW5nIE5hbWUgaW4gR2VybWFuXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdLbGlja2UgYXVmIGRlbiBCdXR0b24sIHVtIGRpZSBBdXN3YWhsIHp1IGJlYXJiZWl0ZW4uJykgLy8gU2V0dGluZyBEZXNjcmlwdGlvbiBpbiBHZXJtYW5cclxuICAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4ge1xyXG4gICAgICAgICAgICAgICAgYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoJ0F1c3dhaGwgXHUwMEY2ZmZuZW4nKSAvLyBCdXR0b24gVGV4dCBpbiBHZXJtYW5cclxuICAgICAgICAgICAgICAgICAgICAuc2V0Q3RhKCkgLy8gTWFrZXMgdGhlIGJ1dHRvbiBtb3JlIHByb21pbmVudFxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0cmlldmUgY3VycmVudCBzZXR0aW5ncyB0byBwcmUtcG9wdWxhdGUgdGhlIG1vZGFsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRGb2xkZXJzID0gdGhpcy5wbHVnaW4uc2V0dGluZ3Muc2VsZWN0ZWRGb2xkZXJzIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RmlsZXMgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zZWxlY3RlZEZpbGVzIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50TW9kZSA9IHRoaXMucGx1Z2luLnNldHRpbmdzLnNlbGVjdGlvbk1vZGUgfHwgJ2V4Y2x1ZGUnOyAvLyBVc2UgZGVmYXVsdCBpZiBub3Qgc2V0XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVuIHRoZSBtb2RhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuRGlyZWN0b3J5U2VsZWN0aW9uTW9kYWwoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGb2xkZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpbGVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE1vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBva0NhbGxiYWNrIGZ1bmN0aW9uOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHJlc3VsdDogRGlyZWN0b3J5U2VsZWN0aW9uUmVzdWx0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhERUJVRywnQXVzd2FobCBiZXN0XHUwMEU0dGlndDonLCByZXN1bHQpOyAvLyBMb2cgcmVzdWx0IGluIEdlcm1hbiBjb25zb2xlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0tLSBJTVBPUlRBTlQ6IFNhdmUgdGhlIHJlc3VsdHMgYmFjayB0byB5b3VyIHBsdWdpbiBzZXR0aW5ncyAtLS1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zZWxlY3RlZEZvbGRlcnMgPSByZXN1bHQuZm9sZGVycztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zZWxlY3RlZEZpbGVzID0gcmVzdWx0LmZpbGVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnNlbGVjdGlvbk1vZGUgPSByZXN1bHQubW9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTsgLy8gUGVyc2lzdCB0aGUgY2hhbmdlc1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcHRpb25hbGx5LCByZS1yZW5kZXIgdGhlIHNldHRpbmdzIHRhYiB0byBzaG93IHRoZSB1cGRhdGVkIHNlbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheSgpOyAvLyBSZS1yZW5kZXIgc2V0dGluZ3MgdGFiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgLy8gLS0tIERpc3BsYXkgQ3VycmVudCBTZWxlY3Rpb24gKFJlYWQtb25seSkgLS0tXHJcbiAgICAgICAgIGNvbnN0IHNlbGVjdGlvbkluZm9FbCA9IGNvbnRhaW5lckVsLmNyZWF0ZURpdih7IGNsczogJ3NldHRpbmdzLXNlbGVjdGlvbi1pbmZvJyB9KTtcclxuICAgICAgICAgc2VsZWN0aW9uSW5mb0VsLmNyZWF0ZUVsKCdoNCcsIHsgdGV4dDogJ0FrdHVlbGxlIEF1c3dhaGw6JyB9KTsgLy8gU2VjdGlvbiBUaXRsZSBpbiBHZXJtYW5cclxuICAgICAgICAgY29uc3QgbW9kZVRleHQgPSBgTW9kdXM6ICR7dGhpcy5wbHVnaW4uc2V0dGluZ3Muc2VsZWN0aW9uTW9kZSB8fCAnTmljaHQgZmVzdGdlbGVndCd9YDsgLy8gVGV4dCBpbiBHZXJtYW5cclxuICAgICAgICAgLy8gVHJ1bmNhdGUgbG9uZyBsaXN0cyBmb3IgZGlzcGxheSBpZiBuZWNlc3NhcnlcclxuICAgICAgICAgY29uc3QgZm9sZGVyVGV4dCA9IGBBdXNnZXdcdTAwRTRobHRlIE9yZG5lcjogJHsodGhpcy5wbHVnaW4uc2V0dGluZ3Muc2VsZWN0ZWRGb2xkZXJzPy5sZW5ndGggfHwgMCl9IFN0XHUwMEZDY2tgOyAvLyBUZXh0IGluIEdlcm1hblxyXG4gICAgICAgICBjb25zdCBmaWxlVGV4dCA9IGBBdXNnZXdcdTAwRTRobHRlIERhdGVpZW46ICR7KHRoaXMucGx1Z2luLnNldHRpbmdzLnNlbGVjdGVkRmlsZXM/Lmxlbmd0aCB8fCAwKX0gU3RcdTAwRkNja2A7IC8vIFRleHQgaW4gR2VybWFuXHJcblxyXG4gICAgICAgICBzZWxlY3Rpb25JbmZvRWwuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6IG1vZGVUZXh0IH0pO1xyXG4gICAgICAgICBzZWxlY3Rpb25JbmZvRWwuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6IGZvbGRlclRleHQgfSk7XHJcbiAgICAgICAgIHNlbGVjdGlvbkluZm9FbC5jcmVhdGVFbCgncCcsIHsgdGV4dDogZmlsZVRleHQgfSk7XHJcbiAgICAgICAgIC8vIFlvdSBjb3VsZCBhZGQgYSBzbWFsbCBidXR0b24vbGluayBoZXJlIHRvIHZpZXcgdGhlIGZ1bGwgbGlzdCBpZiBpdCdzIGxvbmdcclxuICAgIH1cclxufVxyXG4qL1xyXG4iLCAiaW1wb3J0IHsgQXBwLCBQbHVnaW4sIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcsIERyb3Bkb3duQ29tcG9uZW50LCBUZXh0Q29tcG9uZW50LCBCdXR0b25Db21wb25lbnQsIFRvZ2dsZUNvbXBvbmVudCwgc2V0SWNvbiwgYXBpVmVyc2lvbiwgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCB7IG9wZW5EaXJlY3RvcnlTZWxlY3Rpb25Nb2RhbCwgRGlyZWN0b3J5U2VsZWN0aW9uUmVzdWx0IH0gZnJvbSAnLi9kaXJlY3RvcnlTZWxlY3Rpb25Nb2RhbCc7XHJcbmltcG9ydCB7IHZlcnNpb25TdHJpbmcsIEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIERFRkFVTFRfUlVMRV9ERUZJTklUSU9OLCBQcm9wZXJ0eVR5cGVJbmZvLCBPYnNpZGlhblByb3BlcnR5VHlwZXMsIERFRkFVTFRfRklMVEVSX0ZJTEVTX0FORF9GT0xERVJTLCBQcm9wZXJ0eUluZm99IGZyb20gJy4vdHlwZXMnO1xyXG5pbXBvcnQgeyBjaGVja0lmRmlsZUFsbG93ZWQsIGV4ZWN1dGVSdWxlT2JqZWN0IH0gZnJvbSAnLi9ydWxlcyc7XHJcbmltcG9ydCB7IEFsZXJ0TW9kYWwgfSBmcm9tICcuL2FsZXJ0Qm94JztcclxuaW1wb3J0IHsgcmFuZG9tVVVJRCB9IGZyb20gJ2NyeXB0byc7XHJcbmltcG9ydCB7IGNvZGVFZGl0b3JNb2RhbCwgY29kZUVkaXRvck1vZGFsUmVzdWx0LCBvcGVuQ29kZUVkaXRvck1vZGFsIH0gZnJvbSAnLi9lZGl0b3JNb2RhbCc7XHJcbmltcG9ydCB7IGNvcHlGaWxlU3luYyB9IGZyb20gJ2ZzJztcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tICcuL3Rvb2xzJztcclxuaW1wb3J0IHsgdXBkYXRlUHJvcGVydHlJY29uIH0gZnJvbSAnLi91aUVsZW1lbnRzJztcclxuaW1wb3J0IHsgcnVsZXNNYW5hZ2VyIH0gZnJvbSAnLi9ydWxlcy9ydWxlcyc7XHJcbmltcG9ydCB7IERFQlVHLCBsb2dnZXIsIFdBUk5JTkcgfSBmcm9tICcuL0xvZyc7XHJcbmltcG9ydCB7IE11bHRpUHJvcGVydHlTZXR0aW5nIH0gZnJvbSAnLi91aU11bHRpUHJvcGVydHlTZXR0aW5nJztcclxuaW1wb3J0IHsgVHJlZUhpZXJhcmNoeURhdGEsIFRyZWVIaWVyYXJjaHlTb3J0YWJsZVNldHRpbmdzLCBST09UX0ZPTERFUiwgVHJlZUhpZXJhcmNoeVJvdyB9IGZyb20gJy4vdWlUcmVlSGllcmFyY2h5U29ydGFibGVTZXR0aW5ncyc7XHJcbmltcG9ydCB7IE1hcmtkb3duSGVscE1vZGFsIH0gZnJvbSAnLi91aU1hcmtkb3duSGVscE1vZGFsJztcclxuXHJcbmV4cG9ydCBjbGFzcyBSdWxlc1RhYmxlIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XHJcbiAgICBwbHVnaW46IGFueTtcclxuICAgIGtub3duUHJvcGVydGllczogUmVjb3JkPHN0cmluZywgUHJvcGVydHlJbmZvPiA9IHt9OyBcclxuICAgIGNvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQ7XHJcbiAgICBwcm9wZXJ0aWVzTGlzdEVsITogSFRNTERpdkVsZW1lbnQ7XHJcbiAgICBzZXR0aW5nczogVHJlZUhpZXJhcmNoeURhdGE7XHJcbiAgICB0b29sczogU2NyaXB0aW5nVG9vbHM7XHJcbiAgICBhY3RpdmVGaWxlOiBURmlsZSB8IG51bGwgPSBudWxsO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IGFueSwgY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCwgc2V0dGluZ3M6IFRyZWVIaWVyYXJjaHlEYXRhKSB7XHJcbiAgICAgICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xyXG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcclxuICAgICAgICB0aGlzLnRvb2xzID0gbmV3IFNjcmlwdGluZ1Rvb2xzKGFwcCwgcGx1Z2luKTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBIZWxwZXIgdG8gcmVuZGVyIG9uZSBydWxlXHJcblxyXG4gICAgcmVuZGVyUHJvcGVydHlSb3coY29udGFpbmVyRWw6IEhUTUxFbGVtZW50LCBydWxlOiBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzICkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vY29uc3QgYWN0aXZlRmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJvd0VsID0gY29udGFpbmVyRWwuY3JlYXRlRGl2KHsgY2xzOiAncHJvcGVydHktc2V0dGluZy1yb3cgc2V0dGluZy1pdGVtJyB9KTtcclxuICAgICAgICByb3dFbC5zdHlsZS53aWR0aCA9ICcxMDAlJzsgLy8gbWFrZSBzdXJlIHRoZSByb3cgdGFrZXMgZnVsbCB3aWR0aFxyXG4gICAgICAgIHJvd0VsLmlkID0gcnVsZS5pZDtcclxuICAgICAgICBjb25zdCBjb250cm9sRWwgPSByb3dFbC5jcmVhdGVEaXYoeyBjbHM6ICdzZXR0aW5nLWl0ZW0tY29udHJvbCcgfSk7IFxyXG4gICAgICAgIGNvbnRyb2xFbC5zdHlsZS53aWR0aCA9ICcxMDAlJztcclxuICAgICAgICBjb250cm9sRWwuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcclxuICAgICAgICBjb250cm9sRWwuc3R5bGUuZ2FwID0gJzBweCc7XHJcbiAgICAgICAgY29uc3QgbGVmdENvbnRhaW5lciA9IGNvbnRyb2xFbC5jcmVhdGVEaXYoeyBjbHM6ICdwcm9wZXJ0eS1sZWZ0LWNvbnRhaW5lcicgfSk7XHJcbiAgICAgICAgY29uc3QgaWNvbkVsID0gbGVmdENvbnRhaW5lci5jcmVhdGVTcGFuKHsgY2xzOiAncHJvcGVydHktaWNvbiBzZXR0aW5nLWl0ZW0taWNvbicgfSk7IFxyXG4gICAgICAgIHNldEljb24oaWNvbkVsLCAnaGFzaCcpOyAvLyBTdGFuZGFyZC1JY29uXHJcblxyXG5cclxuICAgICAgICBjb25zdCBzZWFyY2hDb250YWluZXIgPSBsZWZ0Q29udGFpbmVyLmNyZWF0ZURpdih7IGNsczogJ3Byb3BlcnR5LXNlYXJjaC1jb250YWluZXInIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBuYW1lSW5wdXQgPSBuZXcgVGV4dENvbXBvbmVudChzZWFyY2hDb250YWluZXIpXHJcbiAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignU2VsZWN0IHByb3BlcnR5Li4uJylcclxuICAgICAgICAgICAgLnNldFZhbHVlKHJ1bGUucHJvcGVydHkgfHwgJycpXHJcbiAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyU2VhcmNoUmVzdWx0cyhzZWFyY2hDb250YWluZXIsIHZhbHVlLCBydWxlKTtcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgbmFtZUlucHV0LmlucHV0RWwuc3R5bGUuYm9yZGVyID0gJ25vbmUnOyAvLyBtYWtlIGl0IGludmlzaWJsZVxyXG4gICAgICAgIG5hbWVJbnB1dC5pbnB1dEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclNlYXJjaFJlc3VsdHMoc2VhcmNoQ29udGFpbmVyLCBuYW1lSW5wdXQuZ2V0VmFsdWUoKSwgcnVsZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbmFtZUlucHV0LmlucHV0RWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU2VhcmNoUmVzdWx0cyhzZWFyY2hDb250YWluZXIsIG5hbWVJbnB1dC5nZXRWYWx1ZSgpLCBydWxlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBuYW1lSW5wdXQuaW5wdXRFbC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQgYXMgTm9kZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHNFbCA9IHNlYXJjaENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcucHJvcGVydHktc2VhcmNoLXJlc3VsdHMnKTtcclxuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0c0VsIHx8ICFyZXN1bHRzRWwuY29udGFpbnMocmVsYXRlZFRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyU2VhcmNoUmVzdWx0cyhzZWFyY2hDb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCAxMDApO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBjdXJyZW50UHJvcGVydHlJbmZvID0gdGhpcy5rbm93blByb3BlcnRpZXNbcnVsZS5wcm9wZXJ0eV07XHJcbiAgICAgICAgaWYgKGN1cnJlbnRQcm9wZXJ0eUluZm8pIHtcclxuICAgICAgICAgICAgdXBkYXRlUHJvcGVydHlJY29uKGljb25FbCwgY3VycmVudFByb3BlcnR5SW5mby50eXBlKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHJ1bGUucHJvcGVydHkpIHtcclxuICAgICAgICAgICAgc2V0SWNvbihpY29uRWwsICdhbGVydC1jaXJjbGUnKTsgXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBtaWRkbGVDb250YWluZXIgPSBjb250cm9sRWwuY3JlYXRlRGl2KHsgY2xzOiAncHJvcGVydHktbWlkZGxlLWNvbnRhaW5lcicgfSk7XHJcbiAgICAgICAgY29uc3QgdmFsdWVDb250YWluZXIgPSBtaWRkbGVDb250YWluZXIuY3JlYXRlRGl2KHsgY2xzOiAnRk1BLXByb3BlcnR5LXZhbHVlLWNvbnRhaW5lcicgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlRmlsZSkge1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5maWxlTWFuYWdlci5wcm9jZXNzRnJvbnRNYXR0ZXIodGhpcy5hY3RpdmVGaWxlLCBhc3luYyAoZnJvbnRtYXR0ZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIHJ1bGUudmFsdWUgPSBhd2FpdCBleGVjdXRlUnVsZU9iamVjdCgncHJldmlldycsdGhpcy5hcHAsIHRoaXMsIHRoaXMucGx1Z2luLnNldHRpbmdzLCB0aGlzLmFjdGl2ZUZpbGUsICcnLCBydWxlLCBmcm9udG1hdHRlcik7IC8vVE9ETzogaW1wbGVtZW50IHVzaW5nIG9ubHkgdXBkYXRlUGVydmlld1xyXG4gICAgICAgICAgICB9LHsnbXRpbWUnOnRoaXMuYWN0aXZlRmlsZS5zdGF0Lm10aW1lfSk7IC8vIGRvIG5vdCBjaGFuZ2UgdGhlIG1vZGlmeSB0aW1lLlxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwcmV2aWV3Q29tcG9uZW50ID0gdGhpcy5yZW5kZXJWYWx1ZUlucHV0KHZhbHVlQ29udGFpbmVyLCBjdXJyZW50UHJvcGVydHlJbmZvLCBydWxlLnZhbHVlLCBydWxlKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVByZXZpZXcocnVsZSwgcHJldmlld0NvbXBvbmVudCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHByb3BlcnR5RGV2RHJvcGRvd24gPSAgbmV3IERyb3Bkb3duQ29tcG9uZW50KG1pZGRsZUNvbnRhaW5lcik7XHJcbiAgICAgICAgcHJvcGVydHlEZXZEcm9wZG93bi5zZWxlY3RFbC5zdHlsZS5taW5XaWR0aCA9ICczNSUnXHJcbiAgICAgICAgcHJvcGVydHlEZXZEcm9wZG93bi5zZWxlY3RFbC5zdHlsZS5tYXhXaWR0aCA9ICc1MCUnO1xyXG4gICAgICAgIHByb3BlcnR5RGV2RHJvcGRvd24uYWRkT3B0aW9uKFwiXCIsIFwiU2VsZWN0IGEgY29udGVudFwiKTtcclxuXHJcbiAgICAgICAgLy8gYWRkIGJ1aWx0LWluIHJ1bGUgZnVuY3Rpb25zIHRvIGRyb3Bkb3duXHJcbiAgICAgICAgcnVsZXNNYW5hZ2VyLmdldFJ1bGVzQnlUeXBlKCdidWlsZEluJywgcnVsZS50eXBlKS5mb3JFYWNoKHJ1bGUgPT4ge1xyXG4gICAgICAgICAgICBwcm9wZXJ0eURldkRyb3Bkb3duLmFkZE9wdGlvbihydWxlLmlkLCBydWxlLm5hbWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGFkZCBhdXRvbWF0aW9uIHJ1bGUgZnVuY3Rpb25zIHRvIGRyb3Bkb3duXHJcbiAgICAgICAgcnVsZXNNYW5hZ2VyLmdldFJ1bGVzQnlUeXBlKCdhdXRvbWF0aW9uJywgcnVsZS50eXBlKS5mb3JFYWNoKHJ1bGUgPT4ge1xyXG4gICAgICAgICAgICBwcm9wZXJ0eURldkRyb3Bkb3duLmFkZE9wdGlvbihydWxlLmlkLCBydWxlLm5hbWUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBwcm9wZXJ0eURldkRyb3Bkb3duLmFkZE9wdGlvbihcInNjcmlwdFwiLCBcIkphdmFTY3JpcHQgZnVuY3Rpb24gKGFkdmFuY2VkKVwiKTtcclxuICAgICAgICBwcm9wZXJ0eURldkRyb3Bkb3duLnNldFZhbHVlKHJ1bGUuY29udGVudCk7XHJcbiAgICAgICAgcHJvcGVydHlEZXZEcm9wZG93bi5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcnVsZUZ1bmN0aW9uID0gcnVsZXNNYW5hZ2VyLmdldFJ1bGVCeUlkKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAocnVsZUZ1bmN0aW9uPy5ydWxlVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NjcmlwdCc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYnVpbGRJbi5pbnB1dFByb3BlcnR5JzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdhdXRvbWF0aW9uJzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdidWlsZEluJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9ydWxlLmJ1aWxkSW5Db2RlID0gcnVsZXNNYW5hZ2VyLmdldFNvdXJjZSh2YWx1ZSkgfHwgcnVsZXNNYW5hZ2VyLmdldFNvdXJjZSgnZGVmYXVsdCcpIHx8ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgb2xkT3JpZ2luYWxDb2RlID0gcnVsZXNNYW5hZ2VyLmdldFNvdXJjZSh2YWx1ZSkgfHwgcnVsZXNNYW5hZ2VyLmdldFNvdXJjZSgnZGVmYXVsdCcpIHx8ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJ1bGUuYnVpbGRJbkNvZGUgIT09ICcnKSAmJiAocnVsZS5idWlsZEluQ29kZSAhPT0gb2xkT3JpZ2luYWxDb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkUHJvY2VlZCA9IGF3YWl0IG5ldyBBbGVydE1vZGFsKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ092ZXJ3cml0ZSBleGlzdGluZyBjb2RlPycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdJIHNlZXMgbGlrZSB5b3UgaGF2ZSBjdXN0b20gY29kZSBmb3IgdGhpcyBydWxlISBTaG91bGQgdGhpcyBiZSBvdmVyd3JpdHRlbiBieSBkZWZhdWx0IGNvZGUgZm9yIHRoaXMgcGFyYW1ldGVyPycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdZZXMnLCAnTm8nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKS5vcGVuQW5kR2V0VmFsdWUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFByb2NlZWQucHJvY2VlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuYnVpbGRJbkNvZGUgPSBydWxlc01hbmFnZXIuZ2V0U291cmNlKHZhbHVlKSB8fCBydWxlc01hbmFnZXIuZ2V0U291cmNlKCdkZWZhdWx0JykgfHwgJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS51c2VDdXN0b21Db2RlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuYnVpbGRJbkNvZGU7IC8vIGtlZXAgdGhlIGV4aXN0aW5nIGNvZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5idWlsZEluQ29kZSA9IHJ1bGVzTWFuYWdlci5nZXRTb3VyY2UodmFsdWUpIHx8IHJ1bGVzTWFuYWdlci5nZXRTb3VyY2UoJ2RlZmF1bHQnKSB8fCAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUudXNlQ3VzdG9tQ29kZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2F1dG9jb21wbGV0ZS5tb2RhbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJ1bGUuaXNMaXZlUnVsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBydWxlLmNvbnRlbnQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIC8vcnVsZU9wdGlvbnNEaXYuc3R5bGUuZGlzcGxheSA9IGAkeyhydWxlLmNvbnRlbnQgPT09ICdzY3JpcHQnKSA/ICdmbGV4JyA6ICdub25lJ31gO1xyXG4gICAgICAgICAgICAgICAgLy9zaG93SnNGdW5jdGlvbkJ1dHRvbihydWxlLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVByZXZpZXcocnVsZSwgcHJldmlld0NvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclByb3BlcnR5T3B0aW9ucyhvcHRpb25FTCwgcnVsZSwgcHJldmlld0NvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBsZWZ0Q29udGFpbmVyRWwgPSBjb250cm9sRWwuY3JlYXRlRGl2KHsgY2xzOiAnRk1BLXByb3BlcnR5LXJpZ2h0LWNvbnRhaW5lcicgfSk7XHJcbiAgICAgICAgbmV3IEJ1dHRvbkNvbXBvbmVudChsZWZ0Q29udGFpbmVyRWwpXHJcbiAgICAgICAgLnNldEljb24oJ2dlYXInKVxyXG4gICAgICAgIC5zZXRUb29sdGlwKCdvcGVuIHNldHRpbmdzJylcclxuICAgICAgICAuc2V0Q2xhc3MoJ3Byb3BlcnR5LWljb24tYnV0dG9uJylcclxuICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBzZXR0aW5nc0NvbnRhaW5lcnMgPSBjb250YWluZXJFbC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdwcm9wZXJ0eS1vcHRpb25zLWNvbnRhaW5lcicpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBjb250YWluZXIgb2Ygc2V0dGluZ3NDb250YWluZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyLmdldEF0dHJpYnV0ZSgnaWQnKSAhPT0gcnVsZS5pZCkgY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCdkaXNwbGF5OiBub25lOycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUHJvcGVydHlPcHRpb25zKG9wdGlvbkVMLCBydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgb3B0aW9uRUwuc3R5bGUuZGlzcGxheSA9IG9wdGlvbkVMLnN0eWxlLmRpc3BsYXkgPT09ICdibG9jaycgPyAnbm9uZScgOiAnYmxvY2snO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgLy8gLS0tIHJpZ2h0IHBhcnQ6IGVyYXNlIHJ1bGUgLS0tXHJcbiAgICAgICAgY29uc3QgZGVsZXRlQnV0dG9uQ29udGFpbmVyID0gY29udHJvbEVsLmNyZWF0ZURpdih7IGNsczogJ3Byb3BlcnR5LWRlbGV0ZS1idXR0b24tY29udGFpbmVyJyB9KTtcclxuICAgICAgICBuZXcgQnV0dG9uQ29tcG9uZW50KGRlbGV0ZUJ1dHRvbkNvbnRhaW5lcilcclxuICAgICAgICAgICAgLnNldEljb24oJ3RyYXNoLTInKVxyXG4gICAgICAgICAgICAuc2V0VG9vbHRpcCgncmVtb3ZlIHRoaXMgcnVsZScpXHJcbiAgICAgICAgICAgIC5zZXRDbGFzcygnbW9kLXN1YnRsZScpXHJcbiAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzW3RoaXMuc2V0dGluZ3NQYXJhbWV0ZXJdLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheSgpOyAvLyBSZS1yZW5kZXIgdGhlIHNldHRpbmdzIHRhYlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBkZWxldGVCdXR0b25Db250YWluZXIuc3R5bGUubWFyZ2luTGVmdCA9ICdhdXRvJzsgXHJcbiAgICAgICAgKi9cclxuICAgICAgICBjb250cm9sRWwuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcclxuICAgICAgICBjb250cm9sRWwuc3R5bGUuYWxpZ25JdGVtcyA9ICdjZW50ZXInO1xyXG4gICAgICAgIGNvbnRyb2xFbC5zdHlsZS5qdXN0aWZ5Q29udGVudCA9ICdzcGFjZS1iZXR3ZWVuJztcclxuICAgICAgICBjb250cm9sRWwuc3R5bGUud2lkdGggPSAnMTAwJSc7XHJcblxyXG4gICAgICAgIGxlZnRDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcclxuICAgICAgICBsZWZ0Q29udGFpbmVyLnN0eWxlLmFsaWduSXRlbXMgPSAnY2VudGVyJztcclxuICAgICAgICBsZWZ0Q29udGFpbmVyLnN0eWxlLm1pbldpZHRoID0gJzEwMHB4JzsgXHJcbiAgICAgICAgaWNvbkVsLnN0eWxlLm1hcmdpblJpZ2h0ID0gJzhweCc7XHJcblxyXG4gICAgICAgIHNlYXJjaENvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7IFxyXG4gICAgICAgIC8vc2VhcmNoQ29udGFpbmVyLnN0eWxlLmZsZXhHcm93ID0gJzEnO1xyXG5cclxuICAgICAgICAvL3ZhbHVlQ29udGFpbmVyLnN0eWxlLmZsZXhHcm93ID0gJzQnOyBcclxuXHJcblxyXG4gICAgICAgIGxldCBvcHRpb25FTDogSFRNTERpdkVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5lckVsLnBhcmVudEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgb3B0aW9uRUwgPSBjb250YWluZXJFbC5wYXJlbnRFbGVtZW50LmNyZWF0ZURpdih7IGNsczogJ3Byb3BlcnR5LW9wdGlvbnMtY29udGFpbmVyJyB9KTtcclxuICAgICAgICAgICAgb3B0aW9uRUwuaWQgPSBydWxlLmlkO1xyXG4gICAgICAgICAgICBvcHRpb25FTC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrOiBjcmVhdGUgaW4gY29udGFpbmVyRWwgaWYgcGFyZW50RWxlbWVudCBpcyBudWxsXHJcbiAgICAgICAgICAgIG9wdGlvbkVMID0gY29udGFpbmVyRWwuY3JlYXRlRGl2KHsgY2xzOiAncHJvcGVydHktb3B0aW9ucy1jb250YWluZXInIH0pO1xyXG4gICAgICAgICAgICBvcHRpb25FTC5pZCA9IHJ1bGUuaWQ7XHJcbiAgICAgICAgICAgIG9wdGlvbkVMLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlclByb3BlcnR5T3B0aW9ucyhvcHRpb25FTDogSFRNTERpdkVsZW1lbnQsIHJ1bGU6IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIHByZXZpZXdDb21wb25lbnQ6IEhUTUxEaXZFbGVtZW50IHwgVGV4dENvbXBvbmVudCB8IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGlmICghKHByZXZpZXdDb21wb25lbnQgaW5zdGFuY2VvZiBUZXh0Q29tcG9uZW50KSkgcmV0dXJuO1xyXG4gICAgICAgIG9wdGlvbkVMLmVtcHR5KCk7IC8vIGNsZWFyIHByZXZpb3VzIG9wdGlvbnNcclxuICAgICAgICAvL2NvbnN0IHJ1bGVGbiA9IGdldFJ1bGVGdW5jdGlvbkJ5SWQocnVsZS5jb250ZW50KTtcclxuICAgICAgICBjb25zdCBydWxlRm4gPSBydWxlc01hbmFnZXIuZ2V0UnVsZUJ5SWQocnVsZS5jb250ZW50KTtcclxuICAgICAgICBpZiAoIXJ1bGVGbikgcmV0dXJuO1xyXG4gICAgICAgIGlmIChydWxlRm4udXNlUnVsZU9wdGlvbigncmVtb3ZlQ29udGVudCcpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZUNvbnRlbnRCdXR0b24gPSBuZXcgU2V0dGluZyhvcHRpb25FTClcclxuICAgICAgICAgICAgICAgIC5zZXROYW1lKCdSZW1vdmUgY29udGVudCcpXHJcbiAgICAgICAgICAgICAgICAuc2V0RGVzYyhgQmVmb3JlIG1ha2luZyBjaGFuZ2VzIHlvdSBtaWdodCBjb25zaWRlciB0byByZW1vdmUgY29udGVudCBnZW5lcmF0ZWQgYnkgdGhpcyBydWxlYClcclxuICAgICAgICAgICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBidXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldFdhcm5pbmcoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0QnV0dG9uVGV4dCgnUmVtb3ZlIENvbnRlbnQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0Q3RhKCkgLy8gTWFrZXMgdGhlIGJ1dHRvbiBtb3JlIHByb21pbmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY291bnQgPSB0aGlzLnBsdWdpbi5yZW1vdmVGcm9udG1hdHRlclBhcmFtc0Zyb21BbGxGaWxlcyhydWxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5yZW1vdmVDdGEoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXREaXNhYmxlZCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNvbnRlbnRCdXR0b24uc2V0RGVzYyhgUmVtb3ZlZCB0aGlzIHJ1bGUgZnJvbSAke2NvdW50LmZpbGVzfSBmaWxlcy5gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocnVsZUZuLnVzZVJ1bGVPcHRpb24oJ3J1bGVBY3RpdmUnKSkge1xyXG4gICAgICAgICAgICBuZXcgU2V0dGluZyhvcHRpb25FTClcclxuICAgICAgICAgICAgICAgIC5zZXROYW1lKCdSdWxlIGFjdGl2ZScpXHJcbiAgICAgICAgICAgICAgICAuc2V0RGVzYygnSWYgZW5hYmxlZCwgdGhlIHJ1bGUgd2lsbCBiZSBleGVjdXRlZCcpXHJcbiAgICAgICAgICAgICAgICAuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUocnVsZS5hY3RpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLmFjdGl2ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJ1bGVGbi51c2VSdWxlT3B0aW9uKCdtb2RpZnlPbmx5JykpIHtcclxuICAgICAgICAgICAgbmV3IFNldHRpbmcob3B0aW9uRUwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdNb2RpZnkgb25seScpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdPbmx5IG1vZGlmeSBleGlzdGluZyBwcm9wZXJ0aWVzJylcclxuICAgICAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUocnVsZS5vbmx5TW9kaWZ5KVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGUub25seU1vZGlmeSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUHJldmlldyhydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJ1bGUudHlwZSA9PT0gJ3RleHQnIHx8IHJ1bGUudHlwZSA9PT0gJ211bHRpdGV4dCcgfHwgcnVsZS50eXBlID09PSAndGFncycgfHwgcnVsZS50eXBlID09PSAnYWxpYXNlcycpIHtcclxuICAgICAgICAgICAgbGV0IGZvcm1hdFJ1bGUgPSBydWxlc01hbmFnZXIuZ2V0UnVsZUJ5SWQocnVsZS5mb3JtYXR0ZXIpO1xyXG4gICAgICAgICAgICBjb25zdCBmb3JtYXR0ZXJSdWxlcyA9IHJ1bGVzTWFuYWdlci5nZXRSdWxlc0J5VHlwZSgnZm9ybWF0dGVyJykgfHwgW107XHJcbiAgICAgICAgICAgIGxldCBmb3JtYXRPcHRpb25zQnV0dG9uOiBhbnk7XHJcbiAgICAgICAgICAgIGlmIChydWxlRm4udXNlUnVsZU9wdGlvbignY29udmVydFRvTG93ZXJDYXNlJykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG11bHRpUHJvcCA9IG5ldyBNdWx0aVByb3BlcnR5U2V0dGluZyhvcHRpb25FTClcclxuICAgICAgICAgICAgICAgICAgICAuc2V0TmFtZShcIkZvcm1hdCBvdXRwdXRcIilcclxuICAgICAgICAgICAgICAgICAgICAuc2V0RGVzYyhcIkZvcm1hdCBvdXRwdXQgdXNpbmcgc2VsZWN0ZWQgb3B0aW9ucy5cIilcclxuICAgICAgICAgICAgICAgICAgICAuc2V0T3B0aW9ucyhmb3JtYXR0ZXJSdWxlcylcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUocnVsZS5mb3JtYXR0ZXJzIHx8IFsndG9PcmlnaW5hbCddKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZSgoZm9ybWF0dGVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuZm9ybWF0dGVycyA9IGZvcm1hdHRlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0UnVsZSA9IHJ1bGVzTWFuYWdlci5nZXRSdWxlQnlJZChydWxlLmZvcm1hdHRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUHJldmlldyhydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIG11bHRpUHJvcC5hZGRFeHRyYUJ1dHRvbigoc2V0dGluZywgaWR4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmcuYWRkRXh0cmFCdXR0b24oYnRuID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ0bi5zZXRJY29uKCdnZWFyJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRUb29sdGlwKCdPcHRpb25zJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXREaXNhYmxlZCghcnVsZXNNYW5hZ2VyLmdldFJ1bGVCeUlkKHJ1bGU/LmZvcm1hdHRlcnM/LltpZHhdID8/IFwidG9PcmlnaW5hbFwiKT8uaGFzT3duQ29uZmlnVGFiKCkgfHwgZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydGVyT3B0aW9uRGl2LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRlck9wdGlvbkRpdi5lbXB0eSgpOyAvLyBjbGVhciBwcmV2aW91cyBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0UnVsZSA9IHJ1bGVzTWFuYWdlci5nZXRSdWxlQnlJZChydWxlPy5mb3JtYXR0ZXJzPy5baWR4XSA/PyBcInRvT3JpZ2luYWxcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0UnVsZT8uY29uZmlnVGFiKGNvbnZlcnRlck9wdGlvbkRpdiwgcnVsZSwgdGhpcywgcHJldmlld0NvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpUHJvcC5zdHlsZURpc2FibGVkKGJ0biwgIXJ1bGVzTWFuYWdlci5nZXRSdWxlQnlJZChydWxlPy5mb3JtYXR0ZXJzPy5baWR4XSA/PyBcInRvT3JpZ2luYWxcIik/Lmhhc093bkNvbmZpZ1RhYigpIHx8IGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGNvbnZlcnRlck9wdGlvbkRpdiA9IG9wdGlvbkVMLmNyZWF0ZURpdih7IGNsczogJ3Byb3BlcnR5LWNvbnZlcnRlci1vcHRpb24nIH0pO1xyXG4gICAgICAgICAgICBjb252ZXJ0ZXJPcHRpb25EaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICAgICAgY29udmVydGVyT3B0aW9uRGl2LnN0eWxlLm1hcmdpbkxlZnQgPSAnMjBweCc7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAocnVsZUZuLnVzZVJ1bGVPcHRpb24oJ3Jlc3VsdEFzTGluaycpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXcgU2V0dGluZyhvcHRpb25FTClcclxuICAgICAgICAgICAgICAgICAgICAuc2V0TmFtZSgnUmVzdWx0IGFzIExpbmsnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXREZXNjKCdGb3JtYXQgUmVzdWx0IGFzIExpbmsnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hZGREcm9wZG93bihkcm9wZG93biA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzTWFuYWdlci5nZXRSdWxlc0J5VHlwZSgnbGlua0Zvcm1hdHRlcicpLmZvckVhY2gocnVsZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcm9wZG93bi5hZGRPcHRpb24ocnVsZS5pZCwgcnVsZS5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyb3Bkb3duLnNldFZhbHVlKHJ1bGUubGlua0Zvcm1hdHRlciB8fCAndG9PcmlnaW5hbExpbmsnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkcm9wZG93bi5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUubGlua0Zvcm1hdHRlciA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVByZXZpZXcocnVsZSwgcHJldmlld0NvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJ1bGUudHlwZSA9PT0gJ3RleHQnIHx8IHJ1bGUudHlwZSA9PT0gJ211bHRpdGV4dCcgfHwgcnVsZS50eXBlID09PSAndGFncycgfHwgcnVsZS50eXBlID09PSAnYWxpYXNlcycpIHtcclxuICAgICAgICAgICAgaWYgKHJ1bGVGbi51c2VSdWxlT3B0aW9uKCdhZGRDb250ZW50JykpIHtcclxuICAgICAgICAgICAgICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXROYW1lKCdBZGQgY29udGVudCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldERlc2MoJ3NlbGVjdCBob3cgdGhlIGNvbnRlbnQgc2hvdWxkIGJlIHN0b3JlZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmFkZERyb3Bkb3duKGRyb3Bkb3duID0+IGRyb3Bkb3duXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRPcHRpb24oXCJvdmVyd3JpdGVcIiwgXCJyZXBsYWNlIGNvbnRlbnRcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZE9wdGlvbihcInN0YXJ0XCIsIFwicGxhY2Ugb24gc3RhcnRcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZE9wdGlvbihcImVuZFwiLCBcInBsYWNlIG9uIGVuZFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUocnVsZS5hZGRDb250ZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5hZGRDb250ZW50ID0gdmFsdWUgPT09ICdvdmVyd3JpdGUnID8gJ292ZXJ3cml0ZScgOiB2YWx1ZSA9PT0gJ3N0YXJ0JyA/ICdzdGFydCcgOiAnZW5kJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVByZXZpZXcocnVsZSwgcHJldmlld0NvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocnVsZUZuLnVzZVJ1bGVPcHRpb24oJ2V4Y2x1ZGVGb2xkZXJzJykpIHtcclxuICAgICAgICAgICAgY29uc3QgZXhjbHVkZUVMID0gbmV3IFNldHRpbmcob3B0aW9uRUwpXHJcbiAgICAgICAgICAgICAgICAuc2V0TmFtZSgnRXhjbHVkZSBGaWxlcyBhbmQgRm9sZGVycyBmcm9tIHRoaXMgcnVsZScpXHJcbiAgICAgICAgICAgICAgICAuc2V0RGVzYyhgQ3VycmVudGx5ICR7cnVsZS5leGNsdWRlPy5zZWxlY3RlZEZvbGRlcnMubGVuZ3RoIHx8IDB9IGZvbGRlcnMgYW5kICR7cnVsZS5leGNsdWRlPy5zZWxlY3RlZEZpbGVzLmxlbmd0aCB8fCAwfSBmaWxlcyB3aWxsIGJlICR7cnVsZS5leGNsdWRlPy5tb2RlIHx8ICdleGNsdWRlJ31kLmApXHJcbiAgICAgICAgICAgICAgICAuYWRkQnV0dG9uKGJ1dHRvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRJY29uKCdmb2xkZXIteCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdFeGNsdWRlJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldEN0YSgpIC8vIE1ha2VzIHRoZSBidXR0b24gbW9yZSBwcm9taW5lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlbkRpcmVjdG9yeVNlbGVjdGlvbk1vZGFsKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuZXhjbHVkZT8uc2VsZWN0ZWRGb2xkZXJzIHx8IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuZXhjbHVkZT8uc2VsZWN0ZWRGaWxlcyB8fCBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25Nb2RlOiAnZXhjbHVkZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlNb2RlOiBydWxlLmV4Y2x1ZGU/LmRpc3BsYXkgfHwgJ2ZvbGRlcnMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25TZWxlY3Rpb25Nb2RlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uU2hvd0ZpbGVzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHJlc3VsdDogRGlyZWN0b3J5U2VsZWN0aW9uUmVzdWx0IHwgbnVsbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJ1bGUuZXhjbHVkZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5leGNsdWRlPU9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfRklMVEVSX0ZJTEVTX0FORF9GT0xERVJTLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA6ICdleGNsdWRlJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuZXhjbHVkZS5zZWxlY3RlZEZvbGRlcnMgPSByZXN1bHQuZm9sZGVycztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5leGNsdWRlLnNlbGVjdGVkRmlsZXMgPSByZXN1bHQuZmlsZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuZXhjbHVkZS5tb2RlID0gJ2V4Y2x1ZGUnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLmV4Y2x1ZGUuZGlzcGxheSA9IHJlc3VsdC5kaXNwbGF5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhERUJVRyxydWxlLmV4Y2x1ZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUZpbHRlckluZGljYXRvcih0aGlzLmFjdGl2ZUZpbGUsIHRoaXMucHJvcGVydGllc0xpc3RFbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVFTC5zZXREZXNjKGBDdXJyZW50bHkgJHtydWxlLmV4Y2x1ZGU/LnNlbGVjdGVkRm9sZGVycy5sZW5ndGggfHwgMH0gZm9sZGVycyBhbmQgJHtydWxlLmV4Y2x1ZGU/LnNlbGVjdGVkRmlsZXMubGVuZ3RoIHx8IDB9IGZpbGVzIHdpbGwgYmUgJHtydWxlLmV4Y2x1ZGU/Lm1vZGUgfHwgJ2V4Y2x1ZGUnfWQuYClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pOyAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocnVsZUZuLnVzZVJ1bGVPcHRpb24oJ2luY2x1ZGVGb2xkZXJzJykpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5jbHVkZUVMID0gbmV3IFNldHRpbmcob3B0aW9uRUwpXHJcbiAgICAgICAgICAgICAgICAuc2V0TmFtZSgnSW5jbHVkZSBGaWxlcyBhbmQgRm9sZGVycyBmb3IgdGhpcyBydWxlICcpXHJcbiAgICAgICAgICAgICAgICAuc2V0RGVzYyhgQ3VycmVudGx5ICR7cnVsZS5pbmNsdWRlPy5zZWxlY3RlZEZvbGRlcnMubGVuZ3RoIHx8IDB9IGZvbGRlcnMgYW5kICR7cnVsZS5pbmNsdWRlPy5zZWxlY3RlZEZpbGVzLmxlbmd0aCB8fCAwfSBmaWxlcyB3aWxsIGJlICR7cnVsZS5pbmNsdWRlPy5tb2RlIHx8ICdpbmNsdWRlJ31kIGV2ZW4gaWYgdGhleSBhcmUgZXhjbHVkZWQgZ2xvYmFsbHkuYClcclxuICAgICAgICAgICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IHtidXR0b25cclxuICAgICAgICAgICAgICAgICAgICAuc2V0SWNvbignZm9sZGVyLWNoZWNrJylcclxuICAgICAgICAgICAgICAgICAgICAuc2V0QnV0dG9uVGV4dCgnSW5jbHVkZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldEN0YSgpIC8vIE1ha2VzIHRoZSBidXR0b24gbW9yZSBwcm9taW5lbnRcclxuICAgICAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5EaXJlY3RvcnlTZWxlY3Rpb25Nb2RhbChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5pbmNsdWRlPy5zZWxlY3RlZEZvbGRlcnMgfHwgW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLmluY2x1ZGU/LnNlbGVjdGVkRmlsZXMgfHwgW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbk1vZGU6ICdpbmNsdWRlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TW9kZTogcnVsZS5pbmNsdWRlPy5kaXNwbGF5IHx8ICdmb2xkZXJzJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25TZWxlY3Rpb25Nb2RlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25TaG93RmlsZXM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHJlc3VsdDogRGlyZWN0b3J5U2VsZWN0aW9uUmVzdWx0IHwgbnVsbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFydWxlLmluY2x1ZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5pbmNsdWRlID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9GSUxURVJfRklMRVNfQU5EX0ZPTERFUlMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgOiAnaW5jbHVkZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5pbmNsdWRlLnNlbGVjdGVkRm9sZGVycyA9IHJlc3VsdC5mb2xkZXJzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuaW5jbHVkZS5zZWxlY3RlZEZpbGVzID0gcmVzdWx0LmZpbGVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuaW5jbHVkZS5tb2RlID0gJ2luY2x1ZGUnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuaW5jbHVkZS5kaXNwbGF5ID0gcmVzdWx0LmRpc3BsYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhERUJVRyxydWxlLmluY2x1ZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRmlsdGVySW5kaWNhdG9yKHRoaXMuYWN0aXZlRmlsZSwgdGhpcy5wcm9wZXJ0aWVzTGlzdEVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlRUwuc2V0RGVzYyhgQ3VycmVudGx5ICR7cnVsZS5pbmNsdWRlPy5zZWxlY3RlZEZvbGRlcnMubGVuZ3RoIHx8IDB9IGZvbGRlcnMgYW5kICR7cnVsZS5pbmNsdWRlPy5zZWxlY3RlZEZpbGVzLmxlbmd0aCB8fCAwfSBmaWxlcyB3aWxsIGJlICR7cnVsZS5pbmNsdWRlPy5tb2RlIHx8ICdpbmNsdWRlJ31kLmApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pOyBcclxuICAgICAgICB9ICAgICAgXHJcbiAgICAgICAgaWYgKHJ1bGVGbi51c2VSdWxlT3B0aW9uKCdzY3JpcHQnKSkge1xyXG4gICAgICAgICAgICBuZXcgU2V0dGluZyhvcHRpb25FTClcclxuICAgICAgICAgICAgICAgIC5zZXROYW1lKCdTY3JpcHQnKVxyXG4gICAgICAgICAgICAgICAgLnNldERlc2MoJ2VkaXQgdGhlIHNjcmlwdCBmb3Igb3duIG1vZGlmaWNhdGlvbnMnKVxyXG4gICAgICAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4geyBidXR0b25cclxuICAgICAgICAgICAgICAgICAgICAuc2V0QnV0dG9uVGV4dCgnSlMgRWRpdG9yJylcclxuICAgICAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBERUJVRyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBPcGVuaW5nIGNvZGUgZWRpdG9yIGZvciBydWxlICR7cnVsZS5pZH0gd2l0aCBjb250ZW50ICR7cnVsZS5jb250ZW50fSwgZmlsZTogJHt0aGlzLmFjdGl2ZUZpbGU/LnBhdGh9YCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlRmlsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlRmlsZSA/IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKHRoaXMuYWN0aXZlRmlsZSkgfHwge30gOiB7fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuQ29kZUVkaXRvck1vZGFsKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuYnVpbGRJbkNvZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLnR5cGVQcm9wZXJ0eT8udHlwZSB8fCAndGV4dCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUZpbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUZpbGUgPyB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZSh0aGlzLmFjdGl2ZUZpbGUpPy5mcm9udG1hdHRlciB8fCB7fSA6IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHJlc3VsdDogY29kZUVkaXRvck1vZGFsUmVzdWx0IHwgbnVsbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5idWlsZEluQ29kZSA9IHJlc3VsdC5jb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUudXNlQ3VzdG9tQ29kZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLnNldEN0YSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUHJldmlldyhydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocnVsZS51c2VDdXN0b21Db2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXRDdGEoKTsgLy8gTWFrZXMgdGhlIGJ1dHRvbiBtb3JlIHByb21pbmVudFxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5yZW1vdmVDdGEoKTsgLy8gTWFrZXMgdGhlIGJ1dHRvbiBsZXNzIHByb21pbmVudFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYWRkIGN1c3RvbSBjb25maWdcclxuICAgICAgICBsZXQgcnVsZU9wdGlvbkRpdiA9IG9wdGlvbkVMLmNyZWF0ZURpdih7IGNsczogJ3Byb3BlcnR5LXJ1bGUtb3B0aW9uJyB9KTtcclxuICAgICAgICBydWxlT3B0aW9uRGl2LnN0eWxlLm1hcmdpbkxlZnQgPSAnMjBweCc7XHJcbiAgICAgICAgcnVsZXNNYW5hZ2VyLmJ1aWxkQ29uZmlnVGFiKHJ1bGUuY29udGVudCwgcnVsZU9wdGlvbkRpdiwgcnVsZSwgdGhpcywgcHJldmlld0NvbXBvbmVudCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy51cGRhdGVQcmV2aWV3KHJ1bGUsIHByZXZpZXdDb21wb25lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbiBmb3IgYSBzcGVjaWZpYyBydWxlIGFuZCBwcm9wZXJ0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcnVsZUlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBydWxlLlxyXG4gICAgICogQHBhcmFtIHByb3BlcnR5SWQgLSBUaGUgc3BlY2lmaWMgcHJvcGVydHkgZm9yIHdoaWNoIHRoZSBjb25maWd1cmF0aW9uIGlzIGJlaW5nIHJldHJpZXZlZC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBjb25maWd1cmF0aW9uIHZhbHVlIGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LCBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxyXG4gICAgICovXHJcbiAgICBnZXRPcHRpb25Db25maWcocnVsZUlkOnN0cmluZyxwcm9wZXJ0eUlkOnN0cmluZyl7XHJcbiAgICAgICAgY29uc3QgcnVsZSA9IHRoaXMuZ2V0UnVsZUJ5SWQocnVsZUlkKTtcclxuICAgICAgICBpZiAocnVsZSkge1xyXG4gICAgICAgICAgICBjb25zdCBvcHRpb25Db25maWcgPSBydWxlLm9wdGlvbnNDb25maWdbcnVsZUlkXVxyXG4gICAgICAgICAgICBpZiAob3B0aW9uQ29uZmlnW3Byb3BlcnR5SWRdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uQ29uZmlnW3Byb3BlcnR5SWRdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyBhIHJ1bGUgZnJvbSB0aGUgcGx1Z2luJ3Mgc2V0dGluZ3MgYnkgaXRzIHVuaXF1ZSBpZGVudGlmaWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBydWxlSWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHJ1bGUgdG8gcmV0cmlldmUuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbWF0Y2hpbmcge0BsaW5rIEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3N9IG9iamVjdCBpZiBmb3VuZDsgb3RoZXJ3aXNlLCBgdW5kZWZpbmVkYC5cclxuICAgICAqL1xyXG4gICAgZ2V0UnVsZUJ5SWQocnVsZUlkOnN0cmluZyk6IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MgfCB1bmRlZmluZWQge1xyXG4gICAgICAgIGNvbnN0IHJvdyA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlckNvbmZpZy5yb3dzLmZpbmQoKHJvdzpUcmVlSGllcmFyY2h5Um93KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChyb3cucGF5bG9hZCAmJiByb3cucGF5bG9hZC5pZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvdy5wYXlsb2FkLmlkID09PSBydWxlSWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByb3c/LnBheWxvYWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9uIGZvciBhIHNwZWNpZmljIHJ1bGUgYW5kIHByb3BlcnR5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBydWxlSWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHJ1bGUuXHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydHlJZCAtIFRoZSBzcGVjaWZpYyBwcm9wZXJ0eSBmb3Igd2hpY2ggdGhlIGNvbmZpZ3VyYXRpb24gaXMgYmVpbmcgc2V0LlxyXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIFRoZSBjb25maWd1cmF0aW9uIHZhbHVlIHRvIGJlIHNldC5cclxuICAgICAqL1xyXG4gICAgc2V0T3B0aW9uQ29uZmlnKHJ1bGVJZDpzdHJpbmcscHJvcGVydHlJZDpzdHJpbmcsY29uZmlnOmFueSl7XHJcblxyXG4gICAgICAgIGNvbnN0IHJ1bGUgPSB0aGlzLmdldFJ1bGVCeUlkKHJ1bGVJZCk7XHJcbiAgICAgICAgaWYgKHJ1bGUpIHtcclxuICAgICAgICAgICAgaWYgKCFydWxlLm9wdGlvbnNDb25maWcpIHJ1bGUub3B0aW9uc0NvbmZpZyA9IHt9XHJcbiAgICAgICAgICAgIGlmICghcnVsZS5vcHRpb25zQ29uZmlnW3J1bGVJZF0pIHJ1bGUub3B0aW9uc0NvbmZpZ1tydWxlSWRdID0ge307XHJcblxyXG4gICAgICAgICAgICBydWxlLm9wdGlvbnNDb25maWdbcnVsZUlkXVtwcm9wZXJ0eUlkXSA9IGNvbmZpZztcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGhhc09wdGlvbkNvbmZpZyhydWxlSWQ6c3RyaW5nKTpib29sZWFue1xyXG4gICAgICAgIGNvbnN0IHJ1bGUgPSB0aGlzLmdldFJ1bGVCeUlkKHJ1bGVJZCk7XHJcbiAgICAgICAgaWYgKHJ1bGUpIHtcclxuICAgICAgICAgICAgaWYgKCFydWxlLm9wdGlvbnNDb25maWcpIHJ1bGUub3B0aW9uc0NvbmZpZyA9IHt9XHJcbiAgICAgICAgICAgIGlmICghcnVsZS5vcHRpb25zQ29uZmlnW3J1bGVJZF0pIHJ1bGUub3B0aW9uc0NvbmZpZ1tydWxlSWRdID0ge307XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhydWxlLm9wdGlvbnNDb25maWdbcnVsZUlkXSkubGVuZ3RoID4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHNldE9wdGlvbkNvbmZpZ0RlZmF1bHRzKHJ1bGVJZDpzdHJpbmcsIGRlZmF1bHRzOmFueSl7XHJcbiAgICAgICAgY29uc3QgcnVsZSA9IHRoaXMuZ2V0UnVsZUJ5SWQocnVsZUlkKTtcclxuICAgICAgICBpZiAocnVsZSkge1xyXG4gICAgICAgICAgICBpZiAoIXJ1bGUub3B0aW9uc0NvbmZpZykgcnVsZS5vcHRpb25zQ29uZmlnID0ge31cclxuICAgICAgICAgICAgcnVsZS5vcHRpb25zQ29uZmlnW3J1bGVJZF0gPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgcnVsZS5vcHRpb25zQ29uZmlnW3J1bGVJZF0gfHwge30pO1xyXG4gICAgICAgICAgICByZXR1cm4gcnVsZS5vcHRpb25zQ29uZmlnW3J1bGVJZF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXJTZWFyY2hSZXN1bHRzKHNlYXJjaENvbnRhaW5lckVsOiBIVE1MRWxlbWVudCwgc2VhcmNoVGVybTogc3RyaW5nLCBwYXlsb2FkOiBhbnkpIHtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmNsZWFyU2VhcmNoUmVzdWx0cyhzZWFyY2hDb250YWluZXJFbCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkUHJvcGVydGllcyA9IE9iamVjdC5lbnRyaWVzKHRoaXMua25vd25Qcm9wZXJ0aWVzKVxyXG4gICAgICAgICAgICAuZmlsdGVyKChbbmFtZV0pID0+IG5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hUZXJtLnRvTG93ZXJDYXNlKCkpKTtcclxuXHJcbiAgICAgICAgaWYgKGZpbHRlcmVkUHJvcGVydGllcy5sZW5ndGggPT09IDAgJiYgc2VhcmNoVGVybSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmaWx0ZXJlZFByb3BlcnRpZXMubGVuZ3RoID09PSAwICYmICFzZWFyY2hUZXJtKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3VsdHNFbCA9IHNlYXJjaENvbnRhaW5lckVsLmNyZWF0ZURpdih7IGNsczogJ3Byb3BlcnR5LXNlYXJjaC1yZXN1bHRzIG1lbnUnIH0pO1xyXG4gICAgICAgIHJlc3VsdHNFbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICAgICAgcmVzdWx0c0VsLnN0eWxlLnRvcCA9ICcxMDAlJztcclxuICAgICAgICByZXN1bHRzRWwuc3R5bGUubGVmdCA9ICcwJztcclxuICAgICAgICByZXN1bHRzRWwuc3R5bGUud2lkdGggPSAnY2FsYygxMDAlICsgMTAwcHgpJztcclxuICAgICAgICByZXN1bHRzRWwuc3R5bGUuekluZGV4ID0gJzEwJztcclxuICAgICAgICByZXN1bHRzRWwuc3R5bGUubWF4SGVpZ2h0ID0gJzIwMHB4JztcclxuICAgICAgICByZXN1bHRzRWwuc3R5bGUub3ZlcmZsb3dZID0gJ2F1dG8nO1xyXG5cclxuICAgICAgICBsZXQgYWN0aXZlSW5kZXggPSAtMTtcclxuXHJcbiAgICAgICAgY29uc3QgdXBkYXRlQWN0aXZlSXRlbSA9IChuZXdJbmRleDogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gcmVzdWx0c0VsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5tZW51LWl0ZW0nKTtcclxuICAgICAgICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gbmV3SW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLmFkZENsYXNzKCdwcm9wZXJ0eS1zZWFyY2gtaXMtYWN0aXZlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zY3JvbGxJbnRvVmlldyh7IGJsb2NrOiAnbmVhcmVzdCcgfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ucmVtb3ZlQ2xhc3MoJ3Byb3BlcnR5LXNlYXJjaC1pcy1hY3RpdmUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGFjdGl2ZUluZGV4ID0gbmV3SW5kZXg7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2VsZWN0QWN0aXZlSXRlbSA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGFjdGl2ZUluZGV4ID49IDAgJiYgYWN0aXZlSW5kZXggPCBmaWx0ZXJlZFByb3BlcnRpZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBbbmFtZSwgaW5mb10gPSBmaWx0ZXJlZFByb3BlcnRpZXNbYWN0aXZlSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgcGF5bG9hZC5wcm9wZXJ0eSA9IG5hbWU7XHJcbiAgICAgICAgICAgICAgICBwYXlsb2FkLnR5cGUgPSBpbmZvLnR5cGU7XHJcbiAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gdW5kZWZpbmVkOyAvLyBSZXNldCB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgLy90aGlzLnBsdWdpbi5zZXR0aW5nc1t0aGlzLnNldHRpbmdzUGFyYW1ldGVyXVtyb3dJbmRleF0ucHJvcGVydHkgPSBuYW1lO1xyXG4gICAgICAgICAgICAgICAgLy90aGlzLnBsdWdpbi5zZXR0aW5nc1t0aGlzLnNldHRpbmdzUGFyYW1ldGVyXVtyb3dJbmRleF0udHlwZSA9IGluZm8udHlwZTtcclxuICAgICAgICAgICAgICAgIC8vdGhpcy5wbHVnaW4uc2V0dGluZ3NbdGhpcy5zZXR0aW5nc1BhcmFtZXRlcl1bcm93SW5kZXhdLnZhbHVlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyU2VhcmNoUmVzdWx0cyhzZWFyY2hDb250YWluZXJFbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTsgLy8gUmUtcmVuZGVyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBmaWx0ZXJlZFByb3BlcnRpZXMuZm9yRWFjaCgoW25hbWUsIGluZm9dLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpdGVtRWwgPSByZXN1bHRzRWwuY3JlYXRlRGl2KHsgY2xzOiAnbWVudS1pdGVtJyB9KTtcclxuICAgICAgICAgICAgY29uc3QgaXRlbUljb24gPSBpdGVtRWwuY3JlYXRlU3Bhbih7IGNsczogJ21lbnUtaXRlbS1pY29uJyB9KTtcclxuICAgICAgICAgICAgdXBkYXRlUHJvcGVydHlJY29uKGl0ZW1JY29uLCBpbmZvLnR5cGUpO1xyXG4gICAgICAgICAgICBpdGVtRWwuY3JlYXRlU3Bhbih7IHRleHQ6IG5hbWUgfSk7XHJcblxyXG4gICAgICAgICAgICBpdGVtRWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgYXN5bmMgKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZUluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBzZWxlY3RBY3RpdmVJdGVtKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzZWFyY2hDb250YWluZXJFbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgYXN5bmMgKGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSByZXN1bHRzRWwucXVlcnlTZWxlY3RvckFsbCgnLm1lbnUtaXRlbScpO1xyXG4gICAgICAgICAgICBpZiAoZS5rZXkgPT09ICdBcnJvd0Rvd24nKSB7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVBY3RpdmVJdGVtKChhY3RpdmVJbmRleCArIDEpICUgaXRlbXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChlLmtleSA9PT0gJ0Fycm93VXAnKSB7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVBY3RpdmVJdGVtKChhY3RpdmVJbmRleCAtIDEgKyBpdGVtcy5sZW5ndGgpICUgaXRlbXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChlLmtleSA9PT0gJ0VudGVyJykge1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgc2VsZWN0QWN0aXZlSXRlbSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xlYXJTZWFyY2hSZXN1bHRzKHNlYXJjaENvbnRhaW5lckVsOiBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdHNFbCA9IHNlYXJjaENvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3IoJy5wcm9wZXJ0eS1zZWFyY2gtcmVzdWx0cycpO1xyXG4gICAgICAgIGlmIChyZXN1bHRzRWwpIHtcclxuICAgICAgICAgICAgcmVzdWx0c0VsLnJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZW5kZXJWYWx1ZUlucHV0KGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCwgcHJvcGVydHlJbmZvOiBQcm9wZXJ0eUluZm8gfCB1bmRlZmluZWQsIGN1cnJlbnRWYWx1ZTogYW55LCBwYXlsb2FkOiBhbnkpIHtcclxuICAgICAgICBsZXQgcmV0dXJuQ29tcG9uZW50OiBhbnk7XHJcblxyXG4gICAgICAgIGlmICghcHJvcGVydHlJbmZvKSB7XHJcbiAgICAgICAgICAgICBjb250YWluZXJFbC5zZXRUZXh0KCcnKTtcclxuICAgICAgICAgICAgIGNvbnRhaW5lckVsLmFkZENsYXNzKCd0ZXh0LW11dGVkJyk7XHJcbiAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0eXBlID0gcHJvcGVydHlJbmZvLnR5cGU7XHJcblxyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50ID0gbmV3IFRleHRDb21wb25lbnQoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdOdW1lcmljIFZhbHVlJylcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUoY3VycmVudFZhbHVlICE9PSB1bmRlZmluZWQgJiYgY3VycmVudFZhbHVlICE9PSBudWxsID8gU3RyaW5nKGN1cnJlbnRWYWx1ZSkgOiAnJylcclxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG51bVZhbHVlID0gdmFsdWUgPT09ICcnID8gdW5kZWZpbmVkIDogcGFyc2VGbG9hdCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQudmFsdWUgPSBpc05hTihudW1WYWx1ZSBhcyBudW1iZXIpID8gdW5kZWZpbmVkIDogbnVtVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcy5wbHVnaW4uc2V0dGluZ3NbdGhpcy5zZXR0aW5nc1BhcmFtZXRlcl1baW5kZXhdLnZhbHVlID0gaXNOYU4obnVtVmFsdWUgYXMgbnVtYmVyKSA/IHVuZGVmaW5lZCA6IG51bVZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkNvbXBvbmVudC5pbnB1dEVsLnR5cGUgPSAnbnVtYmVyJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdjaGVja2JveCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm5Db21wb25lbnQgPSBjb250YWluZXJFbC5jcmVhdGVEaXYoeyBjbHM6ICdGTUEtdHJpLXN0YXRlLWNoZWNrYm94JyB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybkNvbXBvbmVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCAnQ2hlY2tib3ggY2hhbmdlIHN0YXRlJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5Db21wb25lbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2NoZWNrYm94Jyk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlQ2hlY2tib3hWaXN1YWwgPSAoc3RhdGU6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaWNvbk5hbWU6IHN0cmluZztcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYXJpYVN0YXRlOiAndHJ1ZScgfCAnZmFsc2UnIHwgJ21peGVkJztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbk5hbWUgPSAnY2hlY2stc3F1YXJlJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJpYVN0YXRlID0gJ3RydWUnO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb25OYW1lID0gJ3NxdWFyZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyaWFTdGF0ZSA9ICdmYWxzZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gdW5kZWZpbmVkIG9yIG51bGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbk5hbWUgPSAnbWludXMtc3F1YXJlJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJpYVN0YXRlID0gJ21peGVkJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0SWNvbihyZXR1cm5Db21wb25lbnQsIGljb25OYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5Db21wb25lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnLCBhcmlhU3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkNvbXBvbmVudC5kYXRhc2V0LnN0YXRlID0gU3RyaW5nKHN0YXRlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgdXBkYXRlQ2hlY2tib3hWaXN1YWwoY3VycmVudFZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm5Db21wb25lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRTdGF0ZSA9IHJldHVybkNvbXBvbmVudC5kYXRhc2V0LnN0YXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0U3RhdGU6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGUgPT09ICdmYWxzZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gJ3RydWUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZSA9IHVuZGVmaW5lZDsgXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZSA9IGZhbHNlOyBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IG5leHRTdGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICAvL3RoaXMucGx1Z2luLnNldHRpbmdzW3RoaXMuc2V0dGluZ3NQYXJhbWV0ZXJdW2luZGV4XS52YWx1ZSA9IG5leHRTdGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ2hlY2tib3hWaXN1YWwobmV4dFN0YXRlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50ID0gbmV3IFRleHRDb21wb25lbnQoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdZWVlZLU1NLUREJylcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUoY3VycmVudFZhbHVlIHx8ICcnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IHZhbHVlIHx8IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzLnBsdWdpbi5zZXR0aW5nc1t0aGlzLnNldHRpbmdzUGFyYW1ldGVyXVtpbmRleF0udmFsdWUgPSB2YWx1ZSB8fCB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50LmlucHV0RWwudHlwZSA9ICdkYXRlJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdkYXRldGltZSc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm5Db21wb25lbnQgPSBuZXcgVGV4dENvbXBvbmVudChjb250YWluZXJFbClcclxuICAgICAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ1lZWVktTU0tRERUSEg6bW0nKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShjdXJyZW50VmFsdWUgfHwgJycpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gdmFsdWUgfHwgdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMucGx1Z2luLnNldHRpbmdzW3RoaXMuc2V0dGluZ3NQYXJhbWV0ZXJdW2luZGV4XS52YWx1ZSA9IHZhbHVlIHx8IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5Db21wb25lbnQuaW5wdXRFbC50eXBlID0gJ2RhdGV0aW1lLWxvY2FsJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdhbGlhc2VzJzpcclxuICAgICAgICAgICAgY2FzZSAndGFncyc6XHJcbiAgICAgICAgICAgIGNhc2UgJ211bHRpdGV4dCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm5Db21wb25lbnQgPSBuZXcgVGV4dENvbXBvbmVudChjb250YWluZXJFbClcclxuICAgICAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ3ZhbHVlcyAoZGl2aWRlZCBieSBjb21tYSknKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShBcnJheS5pc0FycmF5KGN1cnJlbnRWYWx1ZSkgPyBjdXJyZW50VmFsdWUuam9pbignLCAnKSA6IChjdXJyZW50VmFsdWUgfHwgJycpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJyYXlWYWx1ZSA9IHZhbHVlLnNwbGl0KCcsJykubWFwKHMgPT4gcy50cmltKCkpLmZpbHRlcihzID0+IHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gYXJyYXlWYWx1ZS5sZW5ndGggPiAwID8gYXJyYXlWYWx1ZSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzLnBsdWdpbi5zZXR0aW5nc1t0aGlzLnNldHRpbmdzUGFyYW1ldGVyXVtpbmRleF0udmFsdWUgPSBhcnJheVZhbHVlLmxlbmd0aCA+IDAgPyBhcnJheVZhbHVlIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICd0ZXh0JzpcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybkNvbXBvbmVudCA9IG5ldyBUZXh0Q29tcG9uZW50KGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcigndmFsdWUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShjdXJyZW50VmFsdWUgfHwgJycpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gdmFsdWUgfHwgdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMucGx1Z2luLnNldHRpbmdzW3RoaXMuc2V0dGluZ3NQYXJhbWV0ZXJdW2luZGV4XS52YWx1ZSA9IHZhbHVlIHx8IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZSAhPT0gJ2NoZWNrYm94Jykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50LmlucHV0RWwuYWRkQ2xhc3MoJ0ZNQS1wcm9wZXJ0eS12YWx1ZS1pbnB1dCcpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50LmFkZENsYXNzKCdGTUEtcHJvcGVydHktdmFsdWUtaW5wdXQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuQ29tcG9uZW50O1xyXG4gICBcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyB1cGRhdGVQcmV2aWV3KHJ1bGU6IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIHByZXZpZXdDb21wb25lbnQ6IGFueSkge1xyXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUZpbGUpIHtcclxuICAgICAgICAgICAgbGV0IHJ1bGVSZXN1bHQ6YW55O1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC5maWxlTWFuYWdlci5wcm9jZXNzRnJvbnRNYXR0ZXIodGhpcy5hY3RpdmVGaWxlLCBhc3luYyAoZnJvbnRtYXR0ZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIHJ1bGVSZXN1bHQgPSBhd2FpdCBleGVjdXRlUnVsZSgncHJldmlldycsdGhpcy5hcHAsIHRoaXMucGx1Z2luLnNldHRpbmdzLCB0aGlzLmFjdGl2ZUZpbGUsICcnLCBydWxlLCBmcm9udG1hdHRlcik7XHJcbiAgICAgICAgICAgICAgICBydWxlUmVzdWx0ID0gYXdhaXQgZXhlY3V0ZVJ1bGVPYmplY3QoJ3ByZXZpZXcnLHRoaXMuYXBwLCB0aGlzLCB0aGlzLnBsdWdpbi5zZXR0aW5ncywgdGhpcy5hY3RpdmVGaWxlLCAnJywgcnVsZSwgZnJvbnRtYXR0ZXIpO1xyXG4gICAgICAgICAgICB9LHsnbXRpbWUnOnRoaXMuYWN0aXZlRmlsZS5zdGF0Lm10aW1lfSk7ICBcclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHJ1bGVSZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocnVsZVJlc3VsdCkpIHByZXZpZXdDb21wb25lbnQuaW5wdXRFbC52YWx1ZSA9IHJ1bGVSZXN1bHQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpZXdDb21wb25lbnQ/LmlucHV0RWwpIHByZXZpZXdDb21wb25lbnQuaW5wdXRFbC52YWx1ZSA9IHJ1bGVSZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudEVsLnNldFRvb2x0aXAoY29tcG9uZW50RWwudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVLZXl3b3Jkcyhyb3c6IFRyZWVIaWVyYXJjaHlSb3d8IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGlmIChyb3c/LnBheWxvYWQ/LmlkKSB7IC8vIFVwZGF0ZSBLZXl3b3Jkc1xyXG4gICAgICAgICAgICByb3cucGF5bG9hZC5rZXl3b3JkcyA9IFtdO1xyXG4gICAgICAgICAgICByb3cucGF5bG9hZC5rZXl3b3Jkcy5wdXNoKHJvdy5wYXlsb2FkLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyb3cucGF5bG9hZC5WYWx1ZSkgJiYgcm93LnBheWxvYWQuVmFsdWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcm93LnBheWxvYWQua2V5d29yZHMucHVzaCguLi5yb3cucGF5bG9hZC5WYWx1ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJvdy5wYXlsb2FkLlZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgcm93LnBheWxvYWQua2V5d29yZHMucHVzaChyb3cucGF5bG9hZC5WYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcnVsZSA9IHJ1bGVzTWFuYWdlci5nZXRSdWxlQnlJZChyb3cucGF5bG9hZC5jb250ZW50KTtcclxuICAgICAgICAgICAgaWYgKHJ1bGUpIHtcclxuICAgICAgICAgICAgICAgIHJvdy5wYXlsb2FkLmtleXdvcmRzLnB1c2gocnVsZS5uYW1lKTtcclxuICAgICAgICAgICAgICAgIHJvdy5wYXlsb2FkLmtleXdvcmRzLnB1c2gocnVsZS5kZXNjcmlwdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbG9nZ2VyLmxvZyhERUJVRywgJ1VwZGF0ZWQga2V5d29yZHMgZm9yIHJ1bGUnLCByb3cucGF5bG9hZC5pZCwgcm93LnBheWxvYWQua2V5d29yZHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBkaXNwbGF5KCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lckVsID0gdGhpcy5jb250YWluZXI7XHJcbiAgICAgICAgY29udGFpbmVyRWwuZW1wdHkoKTtcclxuXHJcbiAgICAgICAgdGhpcy5rbm93blByb3BlcnRpZXMgPSBhd2FpdCB0aGlzLnRvb2xzLmZldGNoS25vd25Qcm9wZXJ0aWVzKHRoaXMuYXBwKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXNMaXN0RWwgPSBjb250YWluZXJFbDsgLy8uY3JlYXRlRGl2KCdwcm9wZXJ0aWVzLWxpc3QnKTtcclxuXHJcbiAgICAgICAgLy90aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJDb25maWcucm93cyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGZvbGRlckxpc3QgPSBuZXcgVHJlZUhpZXJhcmNoeVNvcnRhYmxlU2V0dGluZ3MoXHJcbiAgICAgICAgICAgIGNvbnRhaW5lckVsLFxyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJDb25maWcsXHJcbiAgICAgICAgICAgIChyb3csIHJvd0VsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZW5kZXIgcm93IGNvbnRlbnQgaGVyZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJQcm9wZXJ0eVJvdyhyb3dFbCwgcm93LnBheWxvYWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICAgLnNldFRpdGxlKCdSdWxlcycpXHJcbiAgICAgICAgICAgIC5zZXREZXNjcmlwdGlvbignYWRkIHJ1bGVzIHRvIHNlbGVjdGVkIGZyb250bWF0dGVyIHByb3BlcnRpZXMnKVxyXG4gICAgICAgICAgICAub25DaGFuZ2UoKGRhdGEsIHJvdykgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9sZGVyQ29uZmlnID0gZGF0YTtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRmlsdGVySW5kaWNhdG9yKHRoaXMuYWN0aXZlRmlsZSwgdGhpcy5wcm9wZXJ0aWVzTGlzdEVsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub25GaWx0ZXIoKHJvdzogVHJlZUhpZXJhcmNoeVJvdywgZmlsdGVyOiBzdHJpbmcpOmJvb2xlYW4gPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJvdz8ucGF5bG9hZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IGZpbHRlci50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGVTZXR0aW5ncyA9IHJvdy5wYXlsb2FkO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChydWxlU2V0dGluZ3MuY29udGVudC50b0xvd2VyQ2FzZSgpLmNvbnRhaW5zKGZpbHRlcikpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChydWxlU2V0dGluZ3MudmFsdWUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLmNvbnRhaW5zKGZpbHRlcikpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBydWxlc01hbmFnZXIuZ2V0UnVsZUJ5SWQocm93LnBheWxvYWQuY29udGVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFydWxlKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUubmFtZS50b0xvd2VyQ2FzZSgpLmNvbnRhaW5zKGZpbHRlcikpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChydWxlLmRlc2NyaXB0aW9uLnRvTG93ZXJDYXNlKCkuY29udGFpbnMoZmlsdGVyKSkgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub25SZW5kZXJlZCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUZpbHRlckluZGljYXRvcih0aGlzLmFjdGl2ZUZpbGUsIHRoaXMucHJvcGVydGllc0xpc3RFbCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vblJvd0NyZWF0ZWQoYXN5bmMgKHJvdykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdE5hbWUgPSAnJzsgLy9PYmplY3Qua2V5cyh0aGlzLmtub3duUHJvcGVydGllcylbMF0gfHwgJyc7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJvdy5wYXlsb2FkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm93LnBheWxvYWQgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1JVTEVfREVGSU5JVElPTiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogcmFuZG9tVVVJRCgpLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhERUJVRywgJ05ldyBydWxlIGNyZWF0ZWQnLCByb3csIHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlckNvbmZpZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUtleXdvcmRzKHJvdyk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vbkRlbGV0ZUJ0KGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZFByb2NlZWQgPSBhd2FpdCBuZXcgQWxlcnRNb2RhbChcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcCxcclxuICAgICAgICAgICAgICAgICAgICAnRXJhc2UgYWxsIFJ1bGVzPycsXHJcbiAgICAgICAgICAgICAgICAgICAgJ0RvIHlvdSByZWFsbHkgbGlrZSB0byBlcmFzZSBBTEwgcnVsZXM/JyxcclxuICAgICAgICAgICAgICAgICAgICAnWWVzJywgJ05vJ1xyXG4gICAgICAgICAgICAgICAgKS5vcGVuQW5kR2V0VmFsdWUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFByb2NlZWQucHJvY2VlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLmZvbGRlckNvbmZpZy5yb3dzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hZGRFeHRyYUJ1dHRvblRvSGVhZGVyKChlbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZWwuYWRkRXh0cmFCdXR0b24oYnRuID0+IGJ0blxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRJY29uKFwiY2lyY2xlLWhlbHBcIilcclxuICAgICAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtYXJrZG93biA9IFwiQ291bGQgbm90IGxvYWQgaGVscCBmcm9tIEdpdEh1Yi5cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9tYXJrZG93biA9IGF3YWl0IGZldGNoTWFya2Rvd25Gcm9tR2l0SHViKFwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0NocmlzdGlhbi1NZS9vYnNpZGlhbi1mcm9udC1tYXR0ZXItYXV0b21hdGUvbWFpbi9kb2MvUkVBRE1FLm1kXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9tYXJrZG93biA9IGF3YWl0IHJlYWRQbHVnaW5Eb2NGaWxlKFwiUkVBRE1FLm1kXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgTWFya2Rvd25IZWxwTW9kYWwodGhpcy5hcHAsIHRoaXMucGx1Z2luLCBtYXJrZG93biwgXCJSRUFETUUubWRcIikub3BlbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBpZiAodGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9sZGVyQ29uZmlnLnJvd3MubGVuZ3RoID09PSAwICYmIHRoaXMucGx1Z2luLnNldHRpbmdzLnJ1bGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIHJ1bGVzIGJ1dCBubyBmb2xkZXIgY29uZmlnLCBjcmVhdGUgZGVmYXVsdCByb3dzXHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnJ1bGVzLmZvckVhY2goKHJ1bGU6IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleXdvcmRzIDogc3RyaW5nW10gPSBbXTtcclxuICAgICAgICAgICAgICAgIGtleXdvcmRzLnB1c2gocnVsZS5jb250ZW50KTtcclxuICAgICAgICAgICAgICAgIGZvbGRlckxpc3QuYWRkUm93KFJPT1RfRk9MREVSLCBbXSwgcnVsZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKlxyXG4gICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnJ1bGVzLmZvckVhY2goKHJ1bGU6IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIGluZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJQcm9wZXJ0eVJvdyh0aGlzLnByb3BlcnRpZXNMaXN0RWwsIHJ1bGUsIGluZGV4KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAqL1xyXG4gICAgICAgIGxldCBhY3RpdmVGaWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUZpbHRlckluZGljYXRvcihhY3RpdmVGaWxlLCB0aGlzLnByb3BlcnRpZXNMaXN0RWwpO1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgY29uc3QgYWRkQnRuQ29udGFpbmVyID0gY29udGFpbmVyRWwuY3JlYXRlRGl2KHsgY2xzOiAnc2V0dGluZy1pdGVtLWNvbnRyb2wnIH0pO1xyXG4gICAgICAgIGFkZEJ0bkNvbnRhaW5lci5zdHlsZS5qdXN0aWZ5Q29udGVudCA9ICdyaWdodCc7XHJcbiAgICAgICAgbmV3IEJ1dHRvbkNvbXBvbmVudChhZGRCdG5Db250YWluZXIpXHJcbiAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdBZGQgUHJvcGVydHknKVxyXG4gICAgICAgICAgICAuc2V0SWNvbigncGx1cy1jaXJjbGUnKVxyXG4gICAgICAgICAgICAuc2V0Q3RhKClcclxuICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdE5hbWUgPSAnJzsgLy9PYmplY3Qua2V5cyh0aGlzLmtub3duUHJvcGVydGllcylbMF0gfHwgJyc7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzLnBsdWdpbi5zZXR0aW5nc1t0aGlzLnNldHRpbmdzUGFyYW1ldGVyXS5wdXNoKHsgbmFtZTogZGVmYXVsdE5hbWUsIHZhbHVlOiB1bmRlZmluZWQgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5nc1t0aGlzLnNldHRpbmdzUGFyYW1ldGVyXS5wdXNoKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfUlVMRV9ERUZJTklUSU9OLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHJhbmRvbVVVSUQoKS50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmJ1dHRvbkVsLmNsYXNzTmFtZT0ncHJvcGVydHktcGx1cy1idXR0b24nO1xyXG4gICAgICAgICovXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB1cGRhdGVGaWx0ZXJJbmRpY2F0b3IoYWN0aXZlRmlsZTpURmlsZSB8IG51bGwsIHByb3BlcnRpZXNMaXN0RWw6IEhUTUxEaXZFbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKGFjdGl2ZUZpbGUpIHsgLy9UT0RPOiBmaXggZm9yIG5ldyBzb3J0YWJsZSBUYWJsZVxyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJDb25maWcucm93cy5mb3JFYWNoKChyb3c6IFRyZWVIaWVyYXJjaHlSb3csIGluZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSByb3cucGF5bG9hZCBhcyBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFydWxlIHx8ICFydWxlLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhXQVJOSU5HLCBgdXBkYXRlRmlsdGVySW5kaWNhdG9yOiBSdWxlIHdpdGggaWQgJHtydWxlPy5pZH0gbm90IGZvdW5kIGluIGZvbGRlckNvbmZpZyByb3dzLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gU2tpcCBpZiBubyBydWxlIG9yIGlkIGlzIG5vdCBzZXRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5Um93RWxlbWVudHMgPSBwcm9wZXJ0aWVzTGlzdEVsLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3Byb3BlcnR5LXNldHRpbmctcm93Jyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eVJvd0VsID0gQXJyYXkuZnJvbShwcm9wZXJ0eVJvd0VsZW1lbnRzKS5maWx0ZXIoZWwgPT4gZWwuaWQgPT09IHJ1bGUuaWQpWzBdIGFzIEhUTUxEaXZFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwcm9wZXJ0eVJvd0VsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBTa2lwIGlmIG5vIHJvdyBmb3VuZCBmb3IgdGhpcyBydWxlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eUxlZnREaXYgPSBwcm9wZXJ0eVJvd0VsLnF1ZXJ5U2VsZWN0b3IoJy5wcm9wZXJ0eS1sZWZ0LWNvbnRhaW5lcicpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrSWZGaWxlQWxsb3dlZChhY3RpdmVGaWxlLCB0aGlzLnBsdWdpbi5zZXR0aW5ncywgcnVsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eUxlZnREaXY/LmFkZENsYXNzKCdwcm9wZXJ0eS1sZWZ0LWNvbnRhaW5lci1hbGxvd2VkJyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5TGVmdERpdj8ucmVtb3ZlQ2xhc3MoJ3Byb3BlcnR5LWxlZnQtY29udGFpbmVyLWFsbG93ZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsICJpbXBvcnQgeyBEaXJlY3RvcnlEaXNwbGF5TW9kZSwgRGlyZWN0b3J5U2VsZWN0aW9uTW9kZSB9IGZyb20gJy4vZGlyZWN0b3J5U2VsZWN0aW9uTW9kYWwnO1xyXG5pbXBvcnQgeyBUcmVlSGllcmFyY2h5RGF0YSB9IGZyb20gJy4vdWlUcmVlSGllcmFyY2h5U29ydGFibGVTZXR0aW5ncyc7XHJcbmltcG9ydCB7IFdBUk5JTkcgfSBmcm9tICcuL0xvZyc7XHJcbmltcG9ydCB7IEFueU5zUmVjb3JkIH0gZnJvbSAnZG5zJztcclxuXHJcbmV4cG9ydCBjb25zdCB2ZXJzaW9uU3RyaW5nID0gXCIwLjAuMjZcIjtcclxuXHJcbmV4cG9ydCB0eXBlIE9ic2lkaWFuUHJvcGVydHlUeXBlcyA9IFwiYWxpYXNlc1wifFwiY2hlY2tib3hcInxcImRhdGVcInxcImRhdGV0aW1lXCJ8XCJtdWx0aXRleHRcInxcIm51bWJlclwifFwidGFnc1wifFwidGV4dFwiO1xyXG5leHBvcnQgdHlwZSBGcm9udG1hdHRlckF1dG9tYXRlRXZlbnRzID0gJ2NyZWF0ZScgfCAncmVuYW1lJyB8ICdhY3RpdmUtbGVhZi1jaGFuZ2UnIHwgJ21ldGFkYXRhLWNoYW5nZWQnIHwgJ2RlbGV0ZScgfCAnbW9kaWZ5JyB8ICdwcmV2aWV3JyB8ICdhbGwnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBGaWx0ZXJGaWxlc0FuZEZvbGRlcnMge1xyXG4gICAgc2VsZWN0ZWRGb2xkZXJzOiBzdHJpbmdbXSxcclxuICAgIHNlbGVjdGVkRmlsZXM6IHN0cmluZ1tdLFxyXG4gICAgbW9kZTogRGlyZWN0b3J5U2VsZWN0aW9uTW9kZSxcclxuICAgIGRpc3BsYXk6IERpcmVjdG9yeURpc3BsYXlNb2RlXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX0ZJTFRFUl9GSUxFU19BTkRfRk9MREVSUzogRmlsdGVyRmlsZXNBbmRGb2xkZXJzID0ge1xyXG4gICAgc2VsZWN0ZWRGb2xkZXJzOiBbXSxcclxuICAgIHNlbGVjdGVkRmlsZXM6IFtdLFxyXG4gICAgbW9kZTogJ2V4Y2x1ZGUnLFxyXG4gICAgZGlzcGxheTogJ2ZvbGRlcnMnLFxyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgRnJvbnRtYXR0ZXJBdXRvbWF0ZVNldHRpbmdzIHtcclxuICAgIHRhZ1ByZWZpeDogc3RyaW5nO1xyXG4gICAgZXhjbHVkZVJvb3RGb2xkZXI6IGJvb2xlYW47XHJcbiAgICB0YWdzUHJvcGVydHlOYW1lOiBzdHJpbmc7XHJcbiAgICBzcGFjZVJlcGxhY2VtZW50OiBzdHJpbmc7XHJcbiAgICBzcGVjaWFsQ2hhclJlcGxhY2VtZW50OiBzdHJpbmc7XHJcbiAgICBsb3dlcmNhc2VUYWdzOiBib29sZWFuO1xyXG4gICAga25vd25Qcm9wZXJ0aWVzOiBQcm9wZXJ0eVR5cGVJbmZvW107XHJcbiAgICBydWxlczogRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5nc1tdO1xyXG4gICAgdXNlVGV4dEFyZWE6IGJvb2xlYW47XHJcbiAgICBleGNsdWRlOiBGaWx0ZXJGaWxlc0FuZEZvbGRlcnM7XHJcbiAgICBpbmNsdWRlOiBGaWx0ZXJGaWxlc0FuZEZvbGRlcnM7XHJcbiAgICBjb25maWd1cmVkUHJvcGVydGllczogQXJyYXk8eyBuYW1lOiBzdHJpbmc7IHZhbHVlOiBhbnkgfT47XHJcbiAgICBkZWJ1Z0xldmVsOiBudW1iZXI7XHJcbiAgICBkZWxheUNyZWF0ZUV2ZW50OiBudW1iZXI7IC8vIG9wdGlvbmFsIGRlbGF5IGZvciBjcmVhdGUgZXZlbnRzXHJcbiAgICBmb2xkZXJDb25maWc6IFRyZWVIaWVyYXJjaHlEYXRhO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgREVGQVVMVF9GUk9OVE1BVFRFUl9BVVRPTUFURV9TRVRUSU5HUzogRnJvbnRtYXR0ZXJBdXRvbWF0ZVNldHRpbmdzID0ge1xyXG4gICAgdGFnUHJlZml4OiAnJyxcclxuICAgIGV4Y2x1ZGVSb290Rm9sZGVyOiBmYWxzZSxcclxuICAgIHRhZ3NQcm9wZXJ0eU5hbWU6ICd0YWdzJyxcclxuICAgIHNwYWNlUmVwbGFjZW1lbnQ6ICcnLFxyXG4gICAgc3BlY2lhbENoYXJSZXBsYWNlbWVudDogJycsXHJcbiAgICBsb3dlcmNhc2VUYWdzOiBmYWxzZSxcclxuICAgIGtub3duUHJvcGVydGllczogW10sXHJcbiAgICBydWxlczogW10sXHJcbiAgICB1c2VUZXh0QXJlYTogZmFsc2UsXHJcbiAgICBleGNsdWRlOiB7XHJcbiAgICAgICAgc2VsZWN0ZWRGb2xkZXJzOiBbXSxcclxuICAgICAgICBzZWxlY3RlZEZpbGVzOiBbXSxcclxuICAgICAgICBtb2RlOiAnZXhjbHVkZScsXHJcbiAgICAgICAgZGlzcGxheTogJ2ZvbGRlcnMnLFxyXG4gICAgfSxcclxuICAgIGluY2x1ZGU6IHtcclxuICAgICAgICBzZWxlY3RlZEZvbGRlcnM6IFtdLFxyXG4gICAgICAgIHNlbGVjdGVkRmlsZXM6IFtdLFxyXG4gICAgICAgIG1vZGU6ICdpbmNsdWRlJyxcclxuICAgICAgICBkaXNwbGF5OiAnZm9sZGVycycsXHJcbiAgICB9LFxyXG4gICAgY29uZmlndXJlZFByb3BlcnRpZXM6IFtdLFxyXG4gICAgZGVidWdMZXZlbDogV0FSTklORyxcclxuICAgIGRlbGF5Q3JlYXRlRXZlbnQ6IDAsIC8vIGRlZmF1bHQgdG8gbm8gZGVsYXlcclxuICAgIGZvbGRlckNvbmZpZzoge2ZvbGRlcnM6IFtdLCByb3dzOiBbXX0sXHJcbn07XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3Mge1xyXG4gICAgaWQ6IHN0cmluZztcclxuICAgIGFjdGl2ZTogYm9vbGVhbjtcclxuICAgIGFkZENvbnRlbnQ6ICdvdmVyd3JpdGUnIHwgJ3N0YXJ0JyB8ICdlbmQnO1xyXG4gICAgYXNMaW5rOiBib29sZWFuOyAvL2RlcHJlY2F0ZWRcclxuICAgIHByb3BlcnR5OiBzdHJpbmc7XHJcbiAgICB2YWx1ZTogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbjtcclxuICAgIGN1c3RvbVByb3BlcnR5OiBzdHJpbmc7XHJcbiAgICB0eXBlOiBPYnNpZGlhblByb3BlcnR5VHlwZXM7XHJcbiAgICB0eXBlUHJvcGVydHk6IFByb3BlcnR5VHlwZUluZm8gfCB1bmRlZmluZWQ7XHJcbiAgICBjb250ZW50OiBzdHJpbmc7XHJcbiAgICBidWlsZEluQ29kZTogc3RyaW5nO1xyXG4gICAganNDb2RlOiBzdHJpbmc7XHJcbiAgICBzaG93Q29udGVudDogYm9vbGVhbjtcclxuICAgIGV4Y2x1ZGU6IEZpbHRlckZpbGVzQW5kRm9sZGVycztcclxuICAgIGluY2x1ZGU6IEZpbHRlckZpbGVzQW5kRm9sZGVycztcclxuICAgIHByZWZpeDogc3RyaW5nO1xyXG4gICAgc3BhY2VSZXBsYWNlbWVudDogc3RyaW5nO1xyXG4gICAgc3BlY2lhbENoYXJSZXBsYWNlbWVudDogc3RyaW5nO1xyXG4gICAgbG93ZXJjYXNlVGFnczogYm9vbGVhbjsgLy9kZXByZWNhdGVkXHJcbiAgICBmb3JtYXR0ZXI6IHN0cmluZzsgLy9kZXByZWNhdGVkXHJcbiAgICBmb3JtYXR0ZXJzOiBzdHJpbmdbXTsgLy9hZGRlZFxyXG4gICAgbGlua0Zvcm1hdHRlcjogc3RyaW5nOyAvL2FkZGVkXHJcbiAgICBpbnB1dFByb3BlcnR5OiBzdHJpbmc7XHJcbiAgICBvbmx5TW9kaWZ5OiBib29sZWFuO1xyXG4gICAgdXNlQ3VzdG9tQ29kZTogYm9vbGVhbjtcclxuICAgIG9wdGlvbnNDb25maWc6IGFueSB8IHVuZGVmaW5lZDsgLy8gdXNlZCBmb3IgY3VzdG9tIGNvZGUgb3B0aW9ucywgY2FuIGJlIGFueSB0eXBlXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX1JVTEVfREVGSU5JVElPTiA6IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MgPSB7XHJcbiAgICBpZDogJycsXHJcbiAgICBhY3RpdmUgOiB0cnVlLFxyXG4gICAgYXNMaW5rOiBmYWxzZSwgLy9kZXByZWNhdGVkXHJcbiAgICBhZGRDb250ZW50OiAnb3ZlcndyaXRlJyxcclxuICAgIHByb3BlcnR5IDogJycsXHJcbiAgICB2YWx1ZTogJycsXHJcbiAgICBjdXN0b21Qcm9wZXJ0eSA6ICcnLFxyXG4gICAgdHlwZTogJ3RleHQnLFxyXG4gICAgdHlwZVByb3BlcnR5OiB7bmFtZTonJyx0eXBlOid0ZXh0Jywgc291cmNlOidyZWdpc3RlcmVkJ30sXHJcbiAgICBjb250ZW50OiAnJyxcclxuICAgIGJ1aWxkSW5Db2RlOiAnJyxcclxuICAgIGpzQ29kZTogJycsXHJcbiAgICBzaG93Q29udGVudDogZmFsc2UsXHJcbiAgICBleGNsdWRlOiB7XHJcbiAgICAgICAgc2VsZWN0ZWRGb2xkZXJzOiBbXSxcclxuICAgICAgICBzZWxlY3RlZEZpbGVzOiBbXSxcclxuICAgICAgICBtb2RlOiAnZXhjbHVkZScsXHJcbiAgICAgICAgZGlzcGxheTogJ2ZvbGRlcnMnLFxyXG4gICAgfSxcclxuICAgIGluY2x1ZGU6IHtcclxuICAgICAgICBzZWxlY3RlZEZvbGRlcnM6IFtdLFxyXG4gICAgICAgIHNlbGVjdGVkRmlsZXM6IFtdLFxyXG4gICAgICAgIG1vZGU6ICdpbmNsdWRlJyxcclxuICAgICAgICBkaXNwbGF5OiAnZm9sZGVycycsXHJcbiAgICB9LFxyXG4gICAgcHJlZml4OiAnJyxcclxuICAgIHNwYWNlUmVwbGFjZW1lbnQ6ICcnLFxyXG4gICAgc3BlY2lhbENoYXJSZXBsYWNlbWVudDogJycsXHJcbiAgICBsb3dlcmNhc2VUYWdzOiBmYWxzZSwgLy9kZXByZWNhdGVkXHJcbiAgICBmb3JtYXR0ZXI6ICd0b09yaWdpbmFsJywgLy9kZXByZWNhdGVkXHJcbiAgICBmb3JtYXR0ZXJzOiBbJ3RvT3JpZ2luYWwnXSxcclxuICAgIGxpbmtGb3JtYXR0ZXI6ICd0b09yaWdpbmFsTGluaycsXHJcbiAgICBpbnB1dFByb3BlcnR5OiAnJyxcclxuICAgIG9ubHlNb2RpZnk6IHRydWUsXHJcbiAgICB1c2VDdXN0b21Db2RlOiBmYWxzZSxcclxuICAgIG9wdGlvbnNDb25maWc6IHVuZGVmaW5lZCxcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgUHJvcGVydHlJbmZvID0ge1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgdHlwZTogT2JzaWRpYW5Qcm9wZXJ0eVR5cGVzO1xyXG4gICAgY291bnQ/OiBudW1iZXI7XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBQcm9wZXJ0eVR5cGVJbmZvID0ge1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgICAgIHR5cGU6IE9ic2lkaWFuUHJvcGVydHlUeXBlcztcclxuICAgIGNvdW50PzogbnVtYmVyO1xyXG4gICAgaXNBcnJheT86IGJvb2xlYW47XHJcbiAgICB2YWx1ZXM/OiBzdHJpbmdbXTtcclxuICAgIHNvdXJjZTogJ3JlZ2lzdGVyZWQnIHwgJ2luZmVycmVkJztcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIFByb3BlcnR5VHlwZSA9IHtcclxuICAgIHR5cGU6IHN0cmluZztcclxuICAgIGljb246IHN0cmluZztcclxuICAgIGpzVHlwZTogc3RyaW5nO1xyXG59OyIsICJpbXBvcnQgeyBBcHAsIHJlbmRlclJlc3VsdHMsIFNlYXJjaENvbXBvbmVudCwgU2V0dGluZywgVEZpbGUsIFRGb2xkZXIgfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCB7IGdldEZvbGRlckZyb21QYXRoLCBwYXJzZUpTQ29kZSwgU2NyaXB0aW5nVG9vbHMgfSBmcm9tICcuL3Rvb2xzJztcclxuaW1wb3J0IHsgT2JzaWRpYW5Qcm9wZXJ0eVR5cGVzLCBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCBGcm9udG1hdHRlckF1dG9tYXRlU2V0dGluZ3MsIEZyb250bWF0dGVyQXV0b21hdGVFdmVudHMgfSBmcm9tICcuL3R5cGVzJztcclxuaW1wb3J0IHsgQXV0b2NvbXBsZXRlTW9kYWwsIGF1dG9jb21wbGV0ZU1vZGFsUmVzdWx0LCBvcGVuQXV0b2NvbXBsZXRlTW9kYWwgfSBmcm9tICcuL2F1dG9jb21wbGV0ZU1vZGFsJztcclxuaW1wb3J0IHsgY29kZUVkaXRvck1vZGFsUmVzdWx0IH0gZnJvbSAnLi9lZGl0b3JNb2RhbCc7XHJcbmltcG9ydCB7IEZvbGRlclN1Z2dlc3QgfSBmcm9tIFwiLi9zdWdnZXN0ZXJzL0ZvbGRlclN1Z2dlc3RlclwiO1xyXG5pbXBvcnQgeyBGaWxlU3VnZ2VzdCB9IGZyb20gXCIuL3N1Z2dlc3RlcnMvRmlsZVN1Z2dlc3RlclwiO1xyXG5pbXBvcnQgeyBEaXJlY3RvcnlTZWxlY3Rpb25SZXN1bHQsIG9wZW5EaXJlY3RvcnlTZWxlY3Rpb25Nb2RhbCB9IGZyb20gJy4vZGlyZWN0b3J5U2VsZWN0aW9uTW9kYWwnO1xyXG5pbXBvcnQgeyBBbGVydE1vZGFsIH0gZnJvbSAnLi9hbGVydEJveCc7XHJcbmltcG9ydCB7IHJ1bGVzTWFuYWdlciB9IGZyb20gJy4vcnVsZXMvcnVsZXMnO1xyXG5pbXBvcnQgeyBERUJVRywgRVJST1IsIGxvZ2dlciwgVFJBQ0UgfSBmcm9tICcuL0xvZyc7XHJcblxyXG5leHBvcnQgdHlwZSBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVR5cGVzID0gJ2J1aWxkSW4nIHwgJ2J1aWxkSW4uaW5wdXRQcm9wZXJ0eScgfCAnYXV0b2NvbXBsZXRlLm1vZGFsJyB8ICdhdXRvbWF0aW9uJyB8ICdzY3JpcHQnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDb25maWdFbGVtZW50cyB7XHJcbiAgICBba2V5OiBzdHJpbmddOiBib29sZWFuIHwgdW5kZWZpbmVkO1xyXG4gICAgcmVtb3ZlQ29udGVudDogYm9vbGVhbjtcclxuICAgIHJ1bGVBY3RpdmU6IGJvb2xlYW47XHJcbiAgICBtb2RpZnlPbmx5OiBib29sZWFuO1xyXG4gICAgaW5wdXRQcm9wZXJ0eTogYm9vbGVhbjtcclxuICAgIGFkZFByZWZpeDogYm9vbGVhbjtcclxuICAgIHNwYWNlUmVwbGFjZW1lbnQ6IGJvb2xlYW47XHJcbiAgICBzcGVjaWFsQ2hhcmFjdGVyUmVwbGFjZW1lbnQ6IGJvb2xlYW47XHJcbiAgICBjb252ZXJ0VG9Mb3dlckNhc2U6IGJvb2xlYW47XHJcbiAgICByZXN1bHRBc0xpbms6IGJvb2xlYW47XHJcbiAgICBhZGRDb250ZW50OiBib29sZWFuO1xyXG4gICAgZXhjbHVkZUZvbGRlcnM6IGJvb2xlYW47XHJcbiAgICBpbmNsdWRlRm9sZGVyczogYm9vbGVhbjtcclxuICAgIHNjcmlwdDogYm9vbGVhbjtcclxufVxyXG5leHBvcnQgaW50ZXJmYWNlIFJ1bGVGdW5jdGlvbiB7XHJcbiAgICBpZDpzdHJpbmc7XHJcbiAgICBydWxlVHlwZTogRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVUeXBlcztcclxuICAgIGRlc2NyaXB0aW9uOnN0cmluZztcclxuICAgIHRvb2x0aXA/OiBzdHJpbmc7XHJcbiAgICBpbnB1dFByb3BlcnR5PzogYm9vbGVhbjtcclxuICAgIGlzTGl2ZVJ1bGU/OiBib29sZWFuO1xyXG4gICAgc291cmNlOnN0cmluZztcclxuICAgIHR5cGU6T2JzaWRpYW5Qcm9wZXJ0eVR5cGVzW107XHJcbiAgICBmeDpGdW5jdGlvbjtcclxuICAgIGNvbmZpZ0VsZW1lbnRzOiBDb25maWdFbGVtZW50cztcclxuICAgIGNvbmZpZ1RhYj86IChvcHRpb25FbDogSFRNTEVsZW1lbnQsIHJ1bGU6RnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDphbnksIHByZXZpZXdDb21wb25lbnQ6YW55KSA9PiB2b2lkOyAvLyBmdW5jdGlvbiB0byByZW5kZXIgdGhlIGNvbmZpZyB0YWIgZm9yIHRoZSBydWxlXHJcbn1cclxuLypcclxuZXhwb3J0IGNvbnN0IHJ1bGVGdW5jdGlvbnM6UnVsZUZ1bmN0aW9uW109W107XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UnVsZUZ1bmN0aW9uQnlJZCAoaWQgOiBzdHJpbmcpOlJ1bGVGdW5jdGlvbiB8IHVuZGVmaW5lZCB7XHJcbiAgICBjb25zdCBydWxlRnVuY3Rpb24gPSBydWxlRnVuY3Rpb25zLmZpbmQocnVsZSA9PiBydWxlLmlkID09PSBpZCk7XHJcbiAgICBpZiAoIXJ1bGVGdW5jdGlvbikge1xyXG4gICAgICAgIGxvZ2dlci5sb2coRVJST1IsYFJ1bGUgZnVuY3Rpb24gJHtpZH0gbm90IGZvdW5kIWApO1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcnVsZUZ1bmN0aW9uO1xyXG59XHJcbiovXHJcbmZ1bmN0aW9uIGFwcGx5Rm9ybWF0T3B0aW9ucyh0aGlzOiBhbnksIHZhbHVlOmFueSwgcnVsZTpGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzKTphbnkge1xyXG4gIGlmIChydWxlLnR5cGUgPT09ICdkYXRlJyB8fCBydWxlLnR5cGUgPT09ICdkYXRldGltZScpIHJldHVybiB2YWx1ZTsgLy8gbGVhdmUgZGF0ZSBhbmQgZGF0ZVRpbWUgdW50b3VjaGVkXHJcbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcclxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxyXG4gICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgY2FzZSAnc3RyaW5nJzpcclxuICAgICAgaWYgKHJ1bGUuc3BhY2VSZXBsYWNlbWVudCAmJiBydWxlLnNwYWNlUmVwbGFjZW1lbnQgIT09ICcnKSB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xccysvZywgcnVsZS5zcGFjZVJlcGxhY2VtZW50KTtcclxuICAgICAgaWYgKHJ1bGUuc3BlY2lhbENoYXJSZXBsYWNlbWVudCAmJiBydWxlLnNwZWNpYWxDaGFyUmVwbGFjZW1lbnQgIT09JycpIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW15hLXpBLVowLTlcXC1fXFwvXHUwMEU0XHUwMEY2XHUwMEZDXHUwMERGXHUwMEM0XHUwMEQ2XHUwMERDXHUwMEUxXHUwMEU5XHUwMEVEXHUwMEYzXHUwMEZBXHUwMEZEXHUwMEMxXHUwMEM5XHUwMENEXHUwMEQzXHUwMERBXHUwMEREXHUwMEUwXHUwMEU4XHUwMEVDXHUwMEYyXHUwMEY5XHUwMEMwXHUwMEM4XHUwMENDXHUwMEQyXHUwMEQ5XHUwMEUyXHUwMEVBXHUwMEVFXHUwMEY0XHUwMEZCXHUwMEMyXHUwMENBXHUwMENFXHUwMEQ0XHUwMERCXHUwMEUzXHUwMEYxXHUwMEY1XHUwMEMzXHUwMEQxXHUwMEQ1XS9nLCBydWxlLnNwZWNpYWxDaGFyUmVwbGFjZW1lbnQpO1xyXG4gICAgICBpZiAocnVsZS5mb3JtYXR0ZXIgJiYgcnVsZS5mb3JtYXR0ZXIgIT09ICcnKSB7XHJcbiAgICAgICAgdmFsdWUgPSBydWxlc01hbmFnZXIuZXhlY3V0ZVJ1bGVCeUlkKHJ1bGUuZm9ybWF0dGVyLCB0aGlzLmFwcCwgdGhpcy5hY3RpdmVGaWxlLCB0aGlzLnRvb2xzLCB2YWx1ZSk7IC8vIGV4ZWN1dGUgdGhlIGZvcm1hdHRlciBydWxlXHJcbiAgICAgIH1cclxuICAgICAgaWYgKHJ1bGUubGlua0Zvcm1hdHRlciAmJiBydWxlLmxpbmtGb3JtYXR0ZXIgIT09ICcnKSB7XHJcbiAgICAgICAgdmFsdWUgPSBydWxlc01hbmFnZXIuZXhlY3V0ZVJ1bGVCeUlkKHJ1bGUubGlua0Zvcm1hdHRlciwgdGhpcy5hcHAsIHRoaXMuYWN0aXZlRmlsZSwgdGhpcy50b29scywgdmFsdWUpOyAvLyBleGVjdXRlIHRoZSBsaW5rIGZvcm1hdHRlciBydWxlXHJcbiAgICAgIH1cclxuICAgICAgaWYgKHJ1bGUucHJlZml4ICYmIHJ1bGUucHJlZml4ICE9PSAnJykgdmFsdWUgPSBydWxlLnByZWZpeCArIHZhbHVlO1xyXG4gICAgICByZXR1cm4gdmFsdWVcclxuICAgIGNhc2UgJ29iamVjdCc6XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAodmFsdWUgPT4gYXBwbHlGb3JtYXRPcHRpb25zKHZhbHVlLCBydWxlKSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gIH1cclxuICByZXR1cm5cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0UnVsZVJlc3VsdChydWxlRng6IEZ1bmN0aW9uLCBhcHA6IEFwcCwgcnVsZTogRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgcnVsZUZ1bmN0aW9uOiBSdWxlRnVuY3Rpb24sIGN1cnJlbnRGaWxlOiBURmlsZSwgdG9vbHM6U2NyaXB0aW5nVG9vbHMsIGZyb250TWF0dGVyOmFueSk6UHJvbWlzZTxhbnk+IHtcclxuICBsZXQgcmVzdWx0OmFueSA9IHVuZGVmaW5lZDtcclxuICAvL2xvZ2dlci5sb2coREVCVUcsJ2dldFJ1bGVSZXN1bHQnLCBydWxlRngsIHJ1bGVGdW5jdGlvbiwgY3VycmVudEZpbGUsIHRvb2xzLCBmcm9udE1hdHRlcik7XHJcbiAgc3dpdGNoIChydWxlRnVuY3Rpb24ucnVsZVR5cGUpIHtcclxuICAgIGNhc2UgJ3NjcmlwdCc6XHJcbiAgICBjYXNlICdidWlsZEluJzpcclxuICAgICAgcmVzdWx0ID0gYXBwbHlGb3JtYXRPcHRpb25zKHJ1bGVGeChhcHAsIGN1cnJlbnRGaWxlLCB0b29scyksIHJ1bGUpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ2J1aWxkSW4uaW5wdXRQcm9wZXJ0eSc6XHJcbiAgICAgIHJlc3VsdCA9IGFwcGx5Rm9ybWF0T3B0aW9ucyhydWxlRngoYXBwLCBjdXJyZW50RmlsZSwgdG9vbHMsIGZyb250TWF0dGVyW3J1bGUuaW5wdXRQcm9wZXJ0eV0pLCBydWxlKTtcclxuICAgICAgYnJlYWtcclxuICAgIGNhc2UgJ2F1dG9jb21wbGV0ZS5tb2RhbCc6XHJcbiAgICAgIHJ1bGVGeChhcHAsIGN1cnJlbnRGaWxlLCB0b29scyk7XHJcbiAgICAgIC8vbG9nZ2VyLmxvZyhERUJVRywnYXV0b2NvbXBsZXRlIG1vZGFsJywgcnVsZUZ4LCBydWxlRnVuY3Rpb24sIGN1cnJlbnRGaWxlLCB0b29scyk7XHJcbiAgICAgIHJlc3VsdCA9IG51bGw7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnYXV0b21hdGlvbic6XHJcbiAgICAgIC8vbG9nZ2VyLmxvZyhERUJVRywnYXV0b21hdGlvbicsIHJ1bGVGdW5jdGlvbiwgY3VycmVudEZpbGUsIHRvb2xzKTtcclxuICAgICAgcmVzdWx0ID0gYXBwbHlGb3JtYXRPcHRpb25zKHJ1bGVGeChhcHAsIGN1cnJlbnRGaWxlLCB0b29scyksIHJ1bGUpO1xyXG4gICAgICBicmVhaztcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGVSdWxlT2JqZWN0IChcclxuICBldmVudDogRnJvbnRtYXR0ZXJBdXRvbWF0ZUV2ZW50cyxcclxuICBhcHA6IEFwcCxcclxuICBwbHVnaW46IGFueSxcclxuICBzZXR0aW5nczogRnJvbnRtYXR0ZXJBdXRvbWF0ZVNldHRpbmdzLCBcclxuICBjdXJyZW50RmlsZTogVEZpbGUgfCB1bmRlZmluZWQgfCBudWxsLCBcclxuICBjdXJyZW50Q29udGVudDogYW55LCBcclxuICBydWxlOkZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIFxyXG4gIGZyb250TWF0dGVyOiBhbnksIFxyXG4gIG9sZExvY2F0aW9uUmVzdWx0cz86e3J1bGVJZDogc3RyaW5nLCByZXN1bHQ6IGFueX1bXSk6YW55IHtcclxuXHJcbiAgaWYgKCFydWxlKSByZXR1cm4gY3VycmVudENvbnRlbnQ7XHJcbiAgaWYgKCFydWxlLmFjdGl2ZSkgcmV0dXJuIGN1cnJlbnRDb250ZW50O1xyXG4gIGlmICghY3VycmVudEZpbGUpIHJldHVybiBjdXJyZW50Q29udGVudDtcclxuICBpZiAoIWNoZWNrSWZGaWxlQWxsb3dlZChjdXJyZW50RmlsZSwgc2V0dGluZ3MsIHJ1bGUpKSByZXR1cm4gY3VycmVudENvbnRlbnQ7XHJcbiAgY29uc3QgdG9vbHMgPSBuZXcgU2NyaXB0aW5nVG9vbHMoYXBwLCBwbHVnaW4sIHNldHRpbmdzLCBydWxlLCBmcm9udE1hdHRlcik7XHJcbiAgbGV0IHJlc3VsdCA9IGN1cnJlbnRDb250ZW50O1xyXG4gIGxldCBvbGRSZXN1bHQ6YW55ID0gdW5kZWZpbmVkO1xyXG4gIHRvb2xzLnNldEN1cnJlbnRDb250ZW50KGZyb250TWF0dGVyW3J1bGUucHJvcGVydHldKVxyXG4gIHRvb2xzLnNldFJ1bGUocnVsZSk7XHJcbiAgdG9vbHMuc2V0RnJvbnRtYXR0ZXIoZnJvbnRNYXR0ZXIpO1xyXG4gIHRvb2xzLnNldEFjdGl2ZUZpbGUoY3VycmVudEZpbGUpO1xyXG4gIGNvbnN0IHJ1bGVPYmplY3QgPSBydWxlc01hbmFnZXIuZ2V0UnVsZUJ5SWQocnVsZS5jb250ZW50KTtcclxuICBpZiAoIXJ1bGVPYmplY3QpIHJldHVybiBjdXJyZW50Q29udGVudDtcclxuXHJcbiAgcmVzdWx0ID0gcnVsZXNNYW5hZ2VyLmV4ZWN1dGVSdWxlKHJ1bGUsIHJ1bGVPYmplY3QsIGFwcCwgY3VycmVudEZpbGUsIHRvb2xzLCBmcm9udE1hdHRlcik7IC8vIGV4ZWN1dGUgdGhlIGZvcm1hdHRlciBydWxlXHJcbiAgcmVzdWx0ID0gcnVsZXNNYW5hZ2VyLmFwcGx5Rm9ybWF0T3B0aW9ucyhyZXN1bHQsIHJ1bGUsIGN1cnJlbnRGaWxlLCB0b29scyk7IC8vIGFwcGx5IGZvcm1hdCBvcHRpb25zXHJcbiAgaWYgKG9sZExvY2F0aW9uUmVzdWx0cyAmJiBvbGRMb2NhdGlvblJlc3VsdHMubGVuZ3RoID4gMCAmJiBydWxlLmFkZENvbnRlbnQgIT09ICdvdmVyd3JpdGUnKSB7XHJcbiAgICBvbGRSZXN1bHQgPSBvbGRMb2NhdGlvblJlc3VsdHMuZmluZChyZXMgPT4gcmVzLnJ1bGVJZCA9PT0gcnVsZS5pZCk/LnJlc3VsdDtcclxuICAgIGlmICghb2xkUmVzdWx0KSB7XHJcbiAgICAgIGxvZ2dlci5sb2coRVJST1IsYGV4ZWN1dGVSdWxlT2JqZWN0OiBPbGQgcmVzdWx0IGZvciBydWxlICR7cnVsZS5wcm9wZXJ0eX18JHtydWxlLmNvbnRlbnR9IG5vdCBmb3VuZCFgLCBvbGRMb2NhdGlvblJlc3VsdHMpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0OyAvLyByZXR1cm4gdGhlIGN1cnJlbnQgcmVzdWx0IGlmIG5vIG9sZCByZXN1bHQgaXMgZm91bmRcclxuICAgIH1cclxuICAgIG9sZFJlc3VsdCA9IHJ1bGVzTWFuYWdlci5hcHBseUZvcm1hdE9wdGlvbnMob2xkUmVzdWx0LCBydWxlLCBjdXJyZW50RmlsZSwgdG9vbHMpOyAvLyBhcHBseSBmb3JtYXQgb3B0aW9ucyBvbiB0aGUgb2xkIGZpbGUgbG9jYXRpb25cclxuICAgIGxvZ2dlci5sb2coREVCVUcsYGV4ZWN1dGVSdWxlT2JqZWN0OiBNZXJnaW5nIHJlc3VsdCBmb3IgcnVsZSAke3J1bGUucHJvcGVydHl9fCR7cnVsZS5jb250ZW50fSB3aXRoIG9sZCByZXN1bHRgLCBvbGRSZXN1bHQsIHJlc3VsdCk7XHJcbiAgICByZXN1bHQgPSBydWxlc01hbmFnZXIubWVyZ2VSZXN1bHQocmVzdWx0LCBvbGRSZXN1bHQsIGN1cnJlbnRDb250ZW50LCBydWxlKTsgLy8gbWVyZ2UgdGhlIHJlc3VsdCB3aXRoIHRoZSBjdXJyZW50IGNvbnRlbnQuIFJlbW92ZSBvbGQgcmVzdWx0IGlmIG5lY2Vzc2FyeVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXN1bHQgPSBydWxlc01hbmFnZXIubWVyZ2VSZXN1bHQocmVzdWx0LCByZXN1bHQsIGN1cnJlbnRDb250ZW50LCBydWxlKTsgLy8gbWVyZ2UgdGhlIHJlc3VsdCB3aXRoIHRoZSBjdXJyZW50IGNvbnRlbnQuIFJlbW92ZSBvbGQgcmVzdWx0IGlmIG5lY2Vzc2FyeVxyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8qXHJcbmV4cG9ydCBmdW5jdGlvbiBleGVjdXRlUnVsZU9sZCAoZXZlbnQ6IEZyb250bWF0dGVyQXV0b21hdGVFdmVudHMsIGFwcCwgc2V0dGluZ3MsIGN1cnJlbnRGaWxlOiBURmlsZSB8IG51bGwsIHJldHVyblJlc3VsdDogYW55LCBydWxlOkZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIGZyb250TWF0dGVyLCBvbGRQYXRoPzpzdHJpbmcpIHtcclxuICAvL2xvZ2dlci5sb2coREVCVUcsYEV2ZW50OiAke2V2ZW50fSBmb3IgcnVsZSAke3J1bGUucHJvcGVydHl9fCR7cnVsZS5jb250ZW50fWAsIHJ1bGUpO1xyXG4gIGlmICghcnVsZS5hY3RpdmUgfHwgIWN1cnJlbnRGaWxlKSByZXR1cm4gcmV0dXJuUmVzdWx0O1xyXG4gIGNvbnN0IHRvb2xzID0gbmV3IFNjcmlwdGluZ1Rvb2xzKGFwcCwgdGhpcywgc2V0dGluZ3MsIHJ1bGUsIGZyb250TWF0dGVyLCBjdXJyZW50RmlsZSk7XHJcbiAgbGV0IGZ4UmVzdWx0ID0gcmV0dXJuUmVzdWx0O1xyXG4gIGxldCBvbGRSZXN1bHQ6YW55O1xyXG4gIGxldCBvbGRGaWxlOlRGaWxlIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG4gIGlmIChvbGRQYXRoKSB7XHJcbiAgICBsZXQgb2xkRmlsZVBhcnRzID0gb2xkUGF0aC5zcGxpdCgnLycpO1xyXG4gICAgb2xkRmlsZSA9IHtcclxuICAgICAgcGF0aDogb2xkUGF0aCxcclxuICAgICAgZXh0ZW5zaW9uOiBvbGRGaWxlUGFydHNbb2xkRmlsZVBhcnRzLmxlbmd0aC0xXS5zcGxpdCgnLicpWzFdLFxyXG4gICAgICBuYW1lOiBvbGRGaWxlUGFydHNbb2xkRmlsZVBhcnRzLmxlbmd0aC0xXS5zcGxpdCgnLicpWzBdLFxyXG4gICAgICBzdGF0OiBjdXJyZW50RmlsZS5zdGF0LFxyXG4gICAgICBiYXNlbmFtZTogY3VycmVudEZpbGUuYmFzZW5hbWUsXHJcbiAgICAgIHZhdWx0OiBjdXJyZW50RmlsZS52YXVsdCxcclxuICAgICAgcGFyZW50OiBjdXJyZW50RmlsZS5wYXJlbnRcclxuICAgIH1cclxuICB9XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGZ1bmN0aW9uSW5kZXggPSBydWxlRnVuY3Rpb25zLmZpbmRJbmRleChmeCA9PiBmeC5pZCA9PT0gcnVsZS5jb250ZW50KTtcclxuICAgIGlmIChmdW5jdGlvbkluZGV4PT09LTEpe1xyXG4gICAgICBsb2dnZXIubG9nKEVSUk9SLGBSdWxlIGZ1bmN0aW9uICR7cnVsZS5jb250ZW50fSBub3QgZm91bmQhYCk7XHJcbiAgICAgIHJldHVybiByZXR1cm5SZXN1bHQ7IC8vIHJldHVybiB0aGUgb3JpZ2luYWwgdmFsdWUgaWYgdGhlIGZ1bmN0aW9uIGlzIG5vdCBmb3VuZFxyXG4gICAgfVxyXG4gICAgY29uc3QgcnVsZUZ1bmN0aW9uQ29uZmlnID0gcnVsZUZ1bmN0aW9uc1tmdW5jdGlvbkluZGV4XTtcclxuICAgIHRvb2xzLnNldEN1cnJlbnRDb250ZW50KGZyb250TWF0dGVyW3J1bGUucHJvcGVydHldKVxyXG4gICAgdG9vbHMuc2V0UnVsZShydWxlKTtcclxuICAgIHRvb2xzLnNldEZyb250bWF0dGVyKGZyb250TWF0dGVyKTtcclxuICAgIHN3aXRjaCAocnVsZUZ1bmN0aW9uQ29uZmlnLnJ1bGVUeXBlKSB7XHJcbiAgICAgIGNhc2UgJ3NjcmlwdCc6IFxyXG4gICAgICAgIGNvbnN0IGN1c3RvbVJ1bGVGdW5jdGlvbiA9IHBhcnNlSlNDb2RlKHJ1bGUuanNDb2RlKTtcclxuICAgICAgICBpZiAodHlwZW9mIGN1c3RvbVJ1bGVGdW5jdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZyhFUlJPUixgQ291bGQgbm90IHBhcnNlIGN1c3RvbSBmdW5jdGlvbiBmb3IgJHtydWxlLmNvbnRlbnR9IWApO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmeFJlc3VsdCA9IGFwcGx5Rm9ybWF0T3B0aW9ucyhjdXN0b21SdWxlRnVuY3Rpb24oYXBwLCBjdXJyZW50RmlsZSwgdG9vbHMpLCBydWxlKTtcclxuICAgICAgICBpZiAob2xkRmlsZSkge1xyXG4gICAgICAgICAgb2xkUmVzdWx0ID0gYXBwbHlGb3JtYXRPcHRpb25zKGN1c3RvbVJ1bGVGdW5jdGlvbihhcHAsIG9sZEZpbGUsIHRvb2xzKSwgcnVsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdidWlsZEluLmlucHV0UHJvcGVydHknOlxyXG4gICAgICBjYXNlICdidWlsZEluJzogIFxyXG4gICAgICAgIGNvbnN0IHJ1bGVGdW5jdGlvbiA9IHJ1bGUudXNlQ3VzdG9tQ29kZSA/IHBhcnNlSlNDb2RlKHJ1bGUuYnVpbGRJbkNvZGUpIDogcnVsZUZ1bmN0aW9uQ29uZmlnLmZ4O1xyXG4gICAgICAgIGlmICh0eXBlb2YgcnVsZUZ1bmN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICBsb2dnZXIubG9nKEVSUk9SLGBDb3VsZCBub3QgcGFyc2UgY3VzdG9tIGZ1bmN0aW9uIGZvciAke3J1bGUuY29udGVudH0hYCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgZnhSZXN1bHQgPSBnZXRSdWxlUmVzdWx0KHJ1bGVGdW5jdGlvbiwgYXBwLCBydWxlLCBydWxlRnVuY3Rpb25Db25maWcsIGN1cnJlbnRGaWxlLCB0b29scywgZnJvbnRNYXR0ZXIpO1xyXG4gICAgICAgIGlmIChvbGRGaWxlKSB7XHJcbiAgICAgICAgICAgIG9sZFJlc3VsdCA9IGdldFJ1bGVSZXN1bHQocnVsZUZ1bmN0aW9uLCBhcHAsIHJ1bGUsIHJ1bGVGdW5jdGlvbkNvbmZpZywgb2xkRmlsZSwgdG9vbHMsIGZyb250TWF0dGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhERUJVRyxgICBleGVjdXRlUnVsZTogJHtydWxlLmNvbnRlbnR9ICR7cnVsZS5wcm9wZXJ0eX0gWyR7cnVsZS50eXBlfV09ICcke2Z4UmVzdWx0fSdgKVxyXG5cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnYXV0b2NvbXBsZXRlLm1vZGFsJzpcclxuICAgICAgICBmeFJlc3VsdCA9IGdldFJ1bGVSZXN1bHQocnVsZUZ1bmN0aW9uQ29uZmlnLmZ4LCBhcHAsIHJ1bGUsIHJ1bGVGdW5jdGlvbkNvbmZpZywgY3VycmVudEZpbGUsIHRvb2xzLCBmcm9udE1hdHRlcik7XHJcbiAgICAgICAgYnJlYWs7IC8vIGhhbmRsZWQgaW4gdGhlIGF1dG9jb21wbGV0ZSBtb2RhbFxyXG4gICAgICBjYXNlICdhdXRvbWF0aW9uJzpcclxuICAgICAgICAvLyBmeFJlc3VsdCA9IGdldFJ1bGVSZXN1bHQocnVsZUZ1bmN0aW9uQ29uZmlnLmZ4LCBhcHAsIHJ1bGUsIHJ1bGVGdW5jdGlvbkNvbmZpZywgY3VycmVudEZpbGUsIHRvb2xzLCBmcm9udE1hdHRlcik7XHJcbiAgICAgICAgZnhSZXN1bHQgPSBydWxlc01hbmFnZXIuZXhlY3V0ZVJ1bGVCeUlkKHJ1bGUuY29udGVudCwgYXBwLCBjdXJyZW50RmlsZSwgdG9vbHMsIGZyb250TWF0dGVyKTsgLy8gZXhlY3V0ZSB0aGUgZm9ybWF0dGVyIHJ1bGVcclxuXHJcbiAgICAgICAgYnJlYWs7IC8vIGhhbmRsZWQgaW4gdGhlIGF1dG9tYXRpb24gbW9kYWxcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBsb2dnZXIubG9nKEVSUk9SLGBFcnJvciBleGVjdXRpbmcgcnVsZSAke3J1bGUucHJvcGVydHl9fCR7cnVsZS5jb250ZW50fSBmb3IgZmlsZSAke2N1cnJlbnRGaWxlLnBhdGh9OiAke2Vycm9yfWApO1xyXG4gICAgcmV0dXJuIHJldHVyblJlc3VsdDsgLy8gcmV0dXJuIHRoZSBvcmlnaW5hbCB2YWx1ZSBpZiB0aGVyZSBpcyBhbiBlcnJvclxyXG4gIH1cclxuXHJcbiAgaWYgKHJ1bGUudHlwZSA9PT0gJ251bWJlcicgfHwgcnVsZS50eXBlID09PSAnY2hlY2tib3gnIHx8IHJ1bGUudHlwZSA9PT0gJ2RhdGUnIHx8IHJ1bGUudHlwZSA9PT0gJ2RhdGV0aW1lJykge1xyXG4gICAgICByZXR1cm4gZnhSZXN1bHQ7XHJcbiAgfVxyXG4gIHN3aXRjaCAocnVsZS5hZGRDb250ZW50KSB7XHJcbiAgICAgIGNhc2UgJ292ZXJ3cml0ZSc6XHJcbiAgICAgICAgICByZXR1cm5SZXN1bHQgPSBmeFJlc3VsdDsgLy8gdXBkYXRlIG9yIGFkZCB0aGUgbmV3IHZhbHVlXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnZW5kJzpcclxuICAgICAgICAgIGlmIChydWxlLnR5cGUgPT09ICdtdWx0aXRleHQnIHx8IHJ1bGUudHlwZSA9PT0gJ3RhZ3MnIHx8IHJ1bGUudHlwZSA9PT0gJ2FsaWFzZXMnKSB7XHJcbiAgICAgICAgICAgICAgaWYgKCFmeFJlc3VsdCkgZnhSZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGZ4UmVzdWx0ID09PSAnc3RyaW5nJykgZnhSZXN1bHQgPSBbZnhSZXN1bHRdOyAvLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSBcclxuICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmV0dXJuUmVzdWx0KSkgcmV0dXJuUmVzdWx0ID0gW3JldHVyblJlc3VsdF07XHJcbiAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9sZFJlc3VsdCkpIG9sZFJlc3VsdCA9IFtvbGRSZXN1bHRdO1xyXG4gICAgICAgICAgICAgIGxldCBmaWx0ZXJlZCA9IHJldHVyblJlc3VsdC5maWx0ZXIoKHZhbHVlKSA9PiAhb2xkUmVzdWx0LmluY2x1ZGVzKHZhbHVlKSlcclxuICAgICAgICAgICAgICByZXR1cm5SZXN1bHQgPSB0b29scy5yZW1vdmVEdXBsaWNhdGVTdHJpbmdzKGZpbHRlcmVkLmNvbmNhdChmeFJlc3VsdCkpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpZiAoIXJldHVyblJlc3VsdCkgcmV0dXJuUmVzdWx0ID0gJyc7XHJcbiAgICAgICAgICAgICAgcmV0dXJuUmVzdWx0ID0gcmV0dXJuUmVzdWx0LnJlcGxhY2VBbGwocmV0dXJuUmVzdWx0LG9sZFJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuUmVzdWx0ID0gcmV0dXJuUmVzdWx0ICsgZnhSZXN1bHQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnc3RhcnQnOlxyXG4gICAgICAgICAgaWYgKHJ1bGUudHlwZSA9PT0gJ211bHRpdGV4dCcgfHwgcnVsZS50eXBlID09PSAndGFncycgfHwgcnVsZS50eXBlID09PSAnYWxpYXNlcycpIHtcclxuICAgICAgICAgICAgICBpZiAoIWZ4UmVzdWx0KSBmeFJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZnhSZXN1bHQgPT09ICdzdHJpbmcnKSBmeFJlc3VsdCA9IFtmeFJlc3VsdF07IC8vIGNvbnZlcnQgc3RyaW5nIHRvIGFycmF5IFxyXG4gICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXR1cm5SZXN1bHQpKSByZXR1cm5SZXN1bHQgPSBbcmV0dXJuUmVzdWx0XTtcclxuICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2xkUmVzdWx0KSkgb2xkUmVzdWx0ID0gW29sZFJlc3VsdF07XHJcbiAgICAgICAgICAgICAgbGV0IGZpbHRlcmVkID0gcmV0dXJuUmVzdWx0LmZpbHRlcigodmFsdWUpID0+ICFvbGRSZXN1bHQuaW5jbHVkZXModmFsdWUpKVxyXG4gICAgICAgICAgICAgIHJldHVyblJlc3VsdCA9IHRvb2xzLnJlbW92ZUR1cGxpY2F0ZVN0cmluZ3MoZnhSZXN1bHQuY29uY2F0KGZpbHRlcmVkKSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGlmICghcmV0dXJuUmVzdWx0KSByZXR1cm5SZXN1bHQgPSAnJztcclxuICAgICAgICAgICAgICByZXR1cm5SZXN1bHQgPSByZXR1cm5SZXN1bHQucmVwbGFjZUFsbChyZXR1cm5SZXN1bHQsb2xkUmVzdWx0KTtcclxuICAgICAgICAgICAgICByZXR1cm5SZXN1bHQgPSBmeFJlc3VsdCArIHJldHVyblJlc3VsdDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gIH1cclxuICByZXR1cm4gcmV0dXJuUmVzdWx0O1xyXG5cclxufVxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlUnVsZU9iamVjdCAoYXBwOiBBcHAsIHNldHRpbmdzOiBhbnksIGN1cnJlbnRGaWxlOiBURmlsZSwgcmV0dXJuUmVzdWx0OiBhbnksIHJ1bGU6RnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgZnJvbnRNYXR0ZXI6IGFueSkge1xyXG59XHJcbi8qXHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVSdWxlIChhcHAsIHNldHRpbmdzLCBjdXJyZW50RmlsZTogVEZpbGUsIHJldHVyblJlc3VsdDogYW55LCBydWxlOkZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIGZyb250TWF0dGVyKSB7XHJcbiAgY29uc3QgdG9vbHMgPSBuZXcgU2NyaXB0aW5nVG9vbHMoYXBwLCBzZXR0aW5ncywgZnJvbnRNYXR0ZXIpO1xyXG4gIGxldCBmeFJlc3VsdDphbnk7XHJcbiAgaWYgKHJ1bGUuY29udGVudCA9PT0gJ3NjcmlwdCcpIHtcclxuICAgICAgY29uc3QgcnVsZUZ1bmN0aW9uID0gcGFyc2VKU0NvZGUocnVsZS5qc0NvZGUpO1xyXG4gICAgICBpZiAodHlwZW9mIHJ1bGVGdW5jdGlvbiAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xyXG4gICAgICBmeFJlc3VsdCA9IHJ1bGVGdW5jdGlvbihhcHAsIGN1cnJlbnRGaWxlLCB0b29scyk7XHJcbiAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgZnVuY3Rpb25JbmRleCA9IHJ1bGVGdW5jdGlvbnMuZmluZEluZGV4KGZ4ID0+IGZ4LmlkID09PSBydWxlLmNvbnRlbnQpO1xyXG4gICAgICBpZiAoZnVuY3Rpb25JbmRleCE9PS0xKXtcclxuICAgICAgICAgIGNvbnN0IHJ1bGVGdW5jdGlvbiA9IHJ1bGUudXNlQ3VzdG9tQ29kZSA/IHBhcnNlSlNDb2RlKHJ1bGUuYnVpbGRJbkNvZGUpIDogcnVsZUZ1bmN0aW9uc1tmdW5jdGlvbkluZGV4XS5meDtcclxuICAgICAgICAgIGlmICh0eXBlb2YgcnVsZUZ1bmN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5sb2coRVJST1IsYENvdWxkIG5vdCBwYXJzZSBjdXN0b20gZnVuY3Rpb24gZm9yICR7cnVsZS5jb250ZW50fSFgKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHJ1bGVGdW5jdGlvbnNbZnVuY3Rpb25JbmRleF0uaW5wdXRQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICBmeFJlc3VsdCA9IGFwcGx5Rm9ybWF0T3B0aW9ucyhydWxlRnVuY3Rpb24oYXBwLCBjdXJyZW50RmlsZSwgdG9vbHMsIGZyb250TWF0dGVyW3J1bGUuaW5wdXRQcm9wZXJ0eV0pLCBydWxlKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZ4UmVzdWx0ID0gYXBwbHlGb3JtYXRPcHRpb25zKHJ1bGVGdW5jdGlvbihhcHAsIGN1cnJlbnRGaWxlLCB0b29scyksIHJ1bGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgfVxyXG4gIHN3aXRjaCAocnVsZS5hZGRDb250ZW50KSB7XHJcbiAgICAgIGNhc2UgJ292ZXJ3cml0ZSc6XHJcbiAgICAgICAgICByZXR1cm5SZXN1bHQgPSBmeFJlc3VsdDsgLy8gdXBkYXRlIG9yIGFkZCB0aGUgbmV3IHZhbHVlXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnZW5kJzpcclxuICAgICAgICAgIGlmIChydWxlLnR5cGUgPT09ICdtdWx0aXRleHQnIHx8IHJ1bGUudHlwZSA9PT0gJ3RhZ3MnIHx8IHJ1bGUudHlwZSA9PT0gJ2FsaWFzZXMnKSB7XHJcbiAgICAgICAgICAgICAgaWYgKCFmeFJlc3VsdCkgZnhSZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGZ4UmVzdWx0ID09PSAnc3RyaW5nJykgZnhSZXN1bHQgPSBbZnhSZXN1bHRdOyAvLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSBcclxuICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmV0dXJuUmVzdWx0KSkgcmV0dXJuUmVzdWx0ID0gW3JldHVyblJlc3VsdF07XHJcbiAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZ4UmVzdWx0KSkgZnhSZXN1bHQgPSBbZnhSZXN1bHRdO1xyXG4gICAgICAgICAgICAgIGxldCBmaWx0ZXJlZCA9IHJldHVyblJlc3VsdC5maWx0ZXIoKHZhbHVlKSA9PiAhZnhSZXN1bHQuaW5jbHVkZXModmFsdWUpKVxyXG4gICAgICAgICAgICAgIHJldHVyblJlc3VsdCA9IHRvb2xzLnJlbW92ZUR1cGxpY2F0ZVN0cmluZ3MoZmlsdGVyZWQpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpZiAoIXJldHVyblJlc3VsdCkgcmV0dXJuUmVzdWx0ID0gJyc7XHJcbiAgICAgICAgICAgICAgcmV0dXJuUmVzdWx0ID0gcmV0dXJuUmVzdWx0LnJlcGxhY2VBbGwocmV0dXJuUmVzdWx0LGZ4UmVzdWx0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdzdGFydCc6XHJcbiAgICAgICAgICBpZiAocnVsZS50eXBlID09PSAnbXVsdGl0ZXh0JyB8fCBydWxlLnR5cGUgPT09ICd0YWdzJyB8fCBydWxlLnR5cGUgPT09ICdhbGlhc2VzJykge1xyXG4gICAgICAgICAgICAgIGlmICghZnhSZXN1bHQpIGZ4UmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmeFJlc3VsdCA9PT0gJ3N0cmluZycpIGZ4UmVzdWx0ID0gW2Z4UmVzdWx0XTsgLy8gY29udmVydCBzdHJpbmcgdG8gYXJyYXkgXHJcbiAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJldHVyblJlc3VsdCkpIHJldHVyblJlc3VsdCA9IFtyZXR1cm5SZXN1bHRdO1xyXG4gICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShmeFJlc3VsdCkpIGZ4UmVzdWx0ID0gW2Z4UmVzdWx0XTtcclxuICAgICAgICAgICAgICBsZXQgZmlsdGVyZWQgPSByZXR1cm5SZXN1bHQuZmlsdGVyKCh2YWx1ZSkgPT4gIWZ4UmVzdWx0LmluY2x1ZGVzKHZhbHVlKSlcclxuICAgICAgICAgICAgICByZXR1cm5SZXN1bHQgPSB0b29scy5yZW1vdmVEdXBsaWNhdGVTdHJpbmdzKGZpbHRlcmVkKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaWYgKCFyZXR1cm5SZXN1bHQpIHJldHVyblJlc3VsdCA9ICcnO1xyXG4gICAgICAgICAgICAgIHJldHVyblJlc3VsdCA9IHJldHVyblJlc3VsdC5yZXBsYWNlQWxsKHJldHVyblJlc3VsdCxmeFJlc3VsdCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICB9XHJcbiAgcmV0dXJuIHJldHVyblJlc3VsdDtcclxuXHJcbn1cclxuKi9cclxuLyoqXHJcbiAqIEZpbHRlcnMgYSBnaXZlbiBmaWxlIGFuZCByZXR1cm5zIHRydWUgaWYgaXQgaXMgaW5jbHVkZWQgaW4gYSBmb2xkZXIgb3IgZmlsZSBsaXN0XHJcbiAqIEBwYXJhbSBmaWxlIFxyXG4gKiBAcGFyYW0gZmlsdGVyTW9kZSAnZXhjbHVkZSd8J2luY2x1ZGUnXHJcbiAqIEBwYXJhbSB0eXBlICdmb2xkZXJzJ3wnZmlsZXMnXHJcbiAqIEByZXR1cm5zIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlckZpbGUoZmlsZTogVEZpbGUsIGZpbGVMaXN0OiBhbnksIGZpbHRlck1vZGU6IHN0cmluZywgdHlwZTpzdHJpbmcpOmJvb2xlYW4ge1xyXG4gICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xyXG4gICAgY29uc3QgZmlsdGVyQXJyYXkgPSAodHlwZT09PSdmb2xkZXJzJykgPyBmaWxlTGlzdFtmaWx0ZXJNb2RlXS5zZWxlY3RlZEZvbGRlcnMgOiBmaWxlTGlzdFtmaWx0ZXJNb2RlXS5zZWxlY3RlZEZpbGVzO1xyXG4gICAgaWYgKGZpbHRlckFycmF5Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIChmaWx0ZXJNb2RlID09PSAnaW5jbHVkZScpPyBmYWxzZSA6IHRydWU7XHJcbiAgICBjb25zdCBmaWxlUGF0aCA9IGZpbGUucGF0aDtcclxuICAgIGNvbnN0IGZpbGVGb2xkZXIgPSBnZXRGb2xkZXJGcm9tUGF0aChmaWxlLnBhdGgpOyAvLyB0aGlzLnRvb2xzLmFkZExlYWRpbmdTbGFzaChnZXRGb2xkZXJGcm9tUGF0aChmaWxlLnBhdGgpKTtcclxuICAgIGNvbnN0IGZpbGVOYW1lID0gZmlsZS5iYXNlbmFtZSArICcuJyArIGZpbGUuZXh0ZW5zaW9uO1xyXG4gICAgXHJcbiAgICBpZiAodHlwZSA9PT0gJ2ZpbGVzJykge1xyXG4gICAgICAgIHJlc3VsdCA9IGZpbHRlckFycmF5LmluY2x1ZGVzKGZpbGVQYXRoKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlID09PSAnZm9sZGVycycpIHtcclxuICAgICAgICBmb3IgKGxldCBwYXRoIG9mIGZpbHRlckFycmF5KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGZpbGVGb2xkZXI/LnN0YXJ0c1dpdGgocGF0aC5zbGljZSgxKSkgfHwgZmFsc2U7IC8vIHJlbW92ZSByb290ICcvJ1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB0cnVlKSByZXR1cm4gKGZpbHRlck1vZGUgPT09ICdleGNsdWRlJyk/ICFyZXN1bHQgOiByZXN1bHQ7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gKGZpbHRlck1vZGUgPT09ICdleGNsdWRlJyk/ICFyZXN1bHQgOiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjaGVja0lmRmlsZUFsbG93ZWQoZmlsZTogVEZpbGUsIHNldHRpbmdzPzpGcm9udG1hdHRlckF1dG9tYXRlU2V0dGluZ3MsIHJ1bGU/OkZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MpOmJvb2xlYW4ge1xyXG4gICAgICBsZXQgcmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgaWYgKCFmaWxlKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmIChzZXR0aW5ncykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAvL2xvZ2dlci5sb2coREVCVUcsYGNoZWNrIGZpbGUgJHtmaWxlLnBhdGh9IGFnYWluc3Qgc2V0dGluZ3NgLCBzZXR0aW5ncy5pbmNsdWRlLCBzZXR0aW5ncy5leGNsdWRlKTtcclxuICAgICAgICAgIGlmIChzZXR0aW5ncy5leGNsdWRlLnNlbGVjdGVkRmlsZXMubGVuZ3RoPjApIHsgLy8gdGhlcmUgYXJlIGZpbGVzIGluIHRoZSBleGNsdWRlIGZpbGVzIGxpc3QuXHJcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZmlsdGVyRmlsZShmaWxlLCBzZXR0aW5ncywgJ2V4Y2x1ZGUnLCAnZmlsZXMnKTsgICAgXHJcbiAgICAgICAgICB9ICAgICAgICBcclxuICAgICAgICAgIGlmIChyZXN1bHQgJiYgc2V0dGluZ3MuZXhjbHVkZS5zZWxlY3RlZEZvbGRlcnMubGVuZ3RoPjApIHsgLy8gdGhlcmUgYXJlIGZvbGRlcnMgaW4gdGhlIGV4Y2x1ZGUgZm9sZGVycyBsaXN0LlxyXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZpbHRlckZpbGUoZmlsZSwgc2V0dGluZ3MsICdleGNsdWRlJywgJ2ZvbGRlcnMnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICghcmVzdWx0ICYmIHNldHRpbmdzLmluY2x1ZGUuc2VsZWN0ZWRGaWxlcy5sZW5ndGg+MCkgeyAvLyB0aGVyZSBhcmUgZmlsZXMgaW4gdGhlIGluY2x1ZGUgZmlsZXMgbGlzdFxyXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZpbHRlckZpbGUoZmlsZSwgc2V0dGluZ3MsICdpbmNsdWRlJywgJ2ZpbGVzJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoIXJlc3VsdCAmJiBzZXR0aW5ncy5pbmNsdWRlLnNlbGVjdGVkRm9sZGVycy5sZW5ndGg+MCkgeyAvLyB0aGVyZSBhcmUgZm9sZGVycyBpbiB0aGUgaW5jbHVkZSBmb2xkZXJzIGxpc3RcclxuICAgICAgICAgICAgICByZXN1bHQgPSBmaWx0ZXJGaWxlKGZpbGUsIHNldHRpbmdzLCAnaW5jbHVkZScsICdmb2xkZXJzJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBpZiAocmVzdWx0ID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlOyAvLyBpZiB0aGUgZmlsZSBpcyBleGNsdWRlZCwgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGxvZ2dlci5sb2coRVJST1IsYEVycm9yIGZpbHRlcmluZyBmaWxlICR7ZmlsZS5wYXRofSBnbG9iYWxseTogJHtlcnJvcn1gKTtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gZGVmYXVsdCB0byBmYWxzZSBpZiB0aGVyZSBpcyBhbiBlcnJvclxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZihydWxlKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIC8vbG9nZ2VyLmxvZyhERUJVRyxgY2hlY2sgZmlsZSAke2ZpbGUucGF0aH0gYWdhaW5zdCBydWxlYCwgcnVsZS5pbmNsdWRlLCBydWxlLmV4Y2x1ZGUpO1xyXG4gICAgICAgICAgaWYgKHJlc3VsdCAmJiBydWxlLmV4Y2x1ZGUuc2VsZWN0ZWRGaWxlcy5sZW5ndGg+MCkgeyAvLyB0aGVyZSBhcmUgZmlsZXMgaW4gdGhlIGV4Y2x1ZGUgZmlsZXMgbGlzdC5cclxuICAgICAgICAgICAgICByZXN1bHQgPSBmaWx0ZXJGaWxlKGZpbGUsIHJ1bGUsICdleGNsdWRlJywgJ2ZpbGVzJyk7XHJcbiAgICAgICAgICB9ICAgICAgICBcclxuICAgICAgICAgIGlmIChyZXN1bHQgJiYgcnVsZS5leGNsdWRlLnNlbGVjdGVkRm9sZGVycy5sZW5ndGg+MCkgeyAvLyB0aGVyZSBhcmUgZm9sZGVycyBpbiB0aGUgaW5jbHVkZSBmb2xkZXJzIGxpc3QuXHJcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZmlsdGVyRmlsZShmaWxlLCBydWxlLCAnZXhjbHVkZScsICdmb2xkZXJzJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoIXJlc3VsdCAmJiBydWxlLmluY2x1ZGUuc2VsZWN0ZWRGaWxlcy5sZW5ndGg+MCkgeyAvLyBmaWxlIGlzIGV4Y2x1ZGVkIGJ1dCB0aGVyZSBhcmUgZmlsZXMgaW4gdGhlIGluY2x1ZGUgZmlsZXMgbGlzdFxyXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZpbHRlckZpbGUoZmlsZSwgcnVsZSwgJ2luY2x1ZGUnLCAnZmlsZXMnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICghcmVzdWx0ICYmIHJ1bGUuaW5jbHVkZS5zZWxlY3RlZEZvbGRlcnMubGVuZ3RoPjApIHsgLy8gZmlsZSBpcyBleGNsdWRlZCBidXQgdGhlcmUgYXJlIGZvbGRlcnMgaW4gdGhlIGluY2x1ZGUgZm9sZGVycyBsaXN0XHJcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZmlsdGVyRmlsZShmaWxlLCBydWxlLCAnaW5jbHVkZScsICdmb2xkZXJzJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGxvZ2dlci5sb2coRVJST1IsYEVycm9yIGZpbHRlcmluZyBmaWxlICR7ZmlsZS5wYXRofSBieSBydWxlICR7cnVsZS5wcm9wZXJ0eX18JHtydWxlLmNvbnRlbnR9OiAke2Vycm9yfWApO1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBkZWZhdWx0IHRvIGZhbHNlIGlmIHRoZXJlIGlzIGFuIGVycm9yXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRDb25maWdFbGVtZW50cyhtb2RpZmllcnM6Q29uZmlnRWxlbWVudHMgfCBhbnkpOkNvbmZpZ0VsZW1lbnRzIHtcclxuICBjb25zdCBjb25maWdFbGVtZW50czogQ29uZmlnRWxlbWVudHMgPSB7XHJcbiAgICByZW1vdmVDb250ZW50OiB0cnVlLFxyXG4gICAgcnVsZUFjdGl2ZTogdHJ1ZSxcclxuICAgIG1vZGlmeU9ubHk6IHRydWUsXHJcbiAgICBpbnB1dFByb3BlcnR5OiBmYWxzZSxcclxuICAgIGFkZFByZWZpeDogdHJ1ZSxcclxuICAgIHNwYWNlUmVwbGFjZW1lbnQ6IHRydWUsXHJcbiAgICBzcGVjaWFsQ2hhcmFjdGVyUmVwbGFjZW1lbnQ6IHRydWUsXHJcbiAgICBjb252ZXJ0VG9Mb3dlckNhc2U6IHRydWUsXHJcbiAgICByZXN1bHRBc0xpbms6IHRydWUsXHJcbiAgICBhZGRDb250ZW50OiB0cnVlLFxyXG4gICAgZXhjbHVkZUZvbGRlcnM6IHRydWUsXHJcbiAgICBpbmNsdWRlRm9sZGVyczogdHJ1ZSwgXHJcbiAgICBzY3JpcHQ6IHRydWUsXHJcbiAgfVxyXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb25maWdFbGVtZW50cywgbW9kaWZpZXJzKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERldGVybWluZXMgd2hldGhlciBhIHNwZWNpZmljIG9wdGlvbiBpcyBlbmFibGVkIGZvciBhIGdpdmVuIHJ1bGUgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBydWxlRm4gLSBUaGUgcnVsZSBmdW5jdGlvbiBvYmplY3QsIHdoaWNoIG1heSBiZSB1bmRlZmluZWQuIElmIGRlZmluZWQsIGl0IHNob3VsZCBjb250YWluIGEgYGNvbmZpZ0VsZW1lbnRzYCBwcm9wZXJ0eS5cclxuICogQHBhcmFtIG9wdGlvbiAtIFRoZSBuYW1lIG9mIHRoZSBvcHRpb24gdG8gY2hlY2sgd2l0aGluIHRoZSBgY29uZmlnRWxlbWVudHNgIG9mIHRoZSBydWxlIGZ1bmN0aW9uLlxyXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9wdGlvbiBpcyB1bmRlZmluZWQgaW4gdGhlIGBjb25maWdFbGVtZW50c2Agb3IgaWYgdGhlIG9wdGlvbiBpcyBleHBsaWNpdGx5IHNldCB0byBgdHJ1ZWAuXHJcbiAqICAgICAgICAgIFJldHVybnMgYGZhbHNlYCBpZiB0aGUgb3B0aW9uIGlzIGV4cGxpY2l0bHkgc2V0IHRvIGBmYWxzZWAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlUnVsZU9wdGlvbihydWxlRm4gOiBSdWxlRnVuY3Rpb24gfCB1bmRlZmluZWQsIG9wdGlvbiA6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gIGlmIChydWxlRm4/LmNvbmZpZ0VsZW1lbnRzW29wdGlvbl0gPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRydWU7XHJcbiAgcmV0dXJuIHJ1bGVGbi5jb25maWdFbGVtZW50c1tvcHRpb25dO1xyXG59XHJcbi8qKlxyXG5ydWxlRnVuY3Rpb25zLnB1c2goe1xyXG4gICAgaWQ6J2RlZmF1bHQnLFxyXG4gICAgcnVsZVR5cGU6ICdidWlsZEluJyxcclxuICAgIGRlc2NyaXB0aW9uOiAnUGFzcyBwYXJhbWV0ZXInLFxyXG4gICAgc291cmNlOiBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgbGV0IHJlc3VsdCA9ICcnO1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59XCIsXHJcbiAgICB0eXBlOiBbJ3RleHQnXSxcclxuICAgIGNvbmZpZ0VsZW1lbnRzOiBkZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pLFxyXG4gICAgZng6IGZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzOlNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIGxldCByZXN1bHQgPSAnJztcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9XHJcbn0pO1xyXG4qL1xyXG4vKlxyXG5ydWxlRnVuY3Rpb25zLnB1c2goe1xyXG4gIGlkOidjb25zdGFudCcsXHJcbiAgcnVsZVR5cGU6ICdidWlsZEluJyxcclxuICBkZXNjcmlwdGlvbjogJ0NvbnN0YW50IHZhbHVlJyxcclxuICBzb3VyY2U6IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICAvLyBhY3F1aXJlIGZpbGUgcGF0aFxcbiAgY29uc3QgcGF0aCA9IGZpbGUucGF0aDtcXG4gIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLycpO1xcbiAgbGV0IHJlc3VsdCA9ICcnO1xcbiAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcXG4gICAgcGFydHMucG9wKCk7IC8vIHJlbW92ZSBmaWxlIG5hbWVcXG4gICAgcmVzdWx0ID0gcmVzdWx0ICsgcGFydHMuam9pbignLycpO1xcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59XCIsXHJcbiAgdHlwZTogWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsJ211bHRpdGV4dCddLFxyXG4gIGNvbmZpZ0VsZW1lbnRzOiBkZWZhdWx0Q29uZmlnRWxlbWVudHMoe1xyXG4gICAgYWRkUHJlZml4OiBmYWxzZSxcclxuICAgIHNwYWNlUmVwbGFjZW1lbnQ6IGZhbHNlLFxyXG4gICAgc3BlY2lhbENoYXJhY3RlclJlcGxhY2VtZW50OiBmYWxzZSxcclxuICAgIGNvbnZlcnRUb0xvd2VyQ2FzZTogZmFsc2UsXHJcbiAgICByZXN1bHRBc0xpbms6IGZhbHNlLH0pLFxyXG4gIGZ4OmZ1bmN0aW9uIChhcHA6IEFwcCwgZmlsZTpURmlsZSwgdG9vbHM6U2NyaXB0aW5nVG9vbHMpe1xyXG4gICAgICBjb25zdCByZXN1bHQgPSB0b29scy5nZXRPcHRpb25Db25maWcodG9vbHMuZ2V0UnVsZSgpPy5pZCwnY29uc3RhbnRWYWx1ZScpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH0sXHJcbiAgY29uZmlnVGFiOiBmdW5jdGlvbiAob3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOkZvbGRlclRhZ1J1bGVEZWZpbml0aW9uLCB0aGF0OmFueSwgcHJldmlld0NvbXBvbmVudDogYW55KSB7XHJcblxyXG4gICAgdGhhdC5zZXRPcHRpb25Db25maWdEZWZhdWx0cyhydWxlLmlkLCB7XHJcbiAgICAgIGNvbnN0YW50VmFsdWU6ICcnLFxyXG4gICAgfSlcclxuXHJcbiAgICBuZXcgU2V0dGluZyhvcHRpb25FTClcclxuICAgIC5zZXROYW1lKCdDb25zdGFudCB2YWx1ZScpXHJcbiAgICAuc2V0RGVzYygnRW50ZXIgYSBjb25zdGFudCB2YWx1ZSB0byBiZSB1c2VkIGluIHRoZSBydWxlJylcclxuICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxyXG4gICAgICAgIC5zZXRWYWx1ZSh0aGF0LmdldE9wdGlvbkNvbmZpZyhydWxlLmlkICwnY29uc3RhbnRWYWx1ZScpIHx8ICcnKVxyXG4gICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQsJ2NvbnN0YW50VmFsdWUnLCB2YWx1ZSk7XHJcbiAgICAgICAgICB0aGF0LnVwZGF0ZVByZXZpZXcocnVsZSwgcHJldmlld0NvbXBvbmVudCk7XHJcbiAgICAgICAgfSkpO1xyXG4gIH1cclxufSk7XHJcblxyXG5ydWxlRnVuY3Rpb25zLnB1c2goe1xyXG4gIGlkOidmdWxsUGF0aCcsXHJcbiAgcnVsZVR5cGU6ICdidWlsZEluJyxcclxuICBkZXNjcmlwdGlvbjogJ0Z1bGwgcGF0aCwgZmlsZW5hbWUnLFxyXG4gIHNvdXJjZTogXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIC8vIGFjcXVpcmUgZmlsZSBwYXRoXFxuICBjb25zdCBwYXRoID0gZmlsZS5wYXRoO1xcbiAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XFxuICBsZXQgcmVzdWx0ID0gJyc7XFxuICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xcbiAgICBwYXJ0cy5wb3AoKTsgLy8gcmVtb3ZlIGZpbGUgbmFtZVxcbiAgICByZXN1bHQgPSByZXN1bHQgKyBwYXJ0cy5qb2luKCcvJyk7XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIixcclxuICB0eXBlOiBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywnbXVsdGl0ZXh0J10sXHJcbiAgY29uZmlnRWxlbWVudHM6IGRlZmF1bHRDb25maWdFbGVtZW50cyh7fSksXHJcbiAgZng6ZnVuY3Rpb24gKGFwcDogQXBwLCBmaWxlOlRGaWxlLCB0b29sczpTY3JpcHRpbmdUb29scyl7XHJcbiAgICAgIGxldCBwYXJ0cyA9IGZpbGUucGF0aC5zcGxpdCgnLycpO1xyXG4gICAgICBwYXJ0cy5wb3AoKTtcclxuICAgICAgcGFydHMucHVzaChmaWxlLmJhc2VuYW1lKTtcclxuICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJy8nKTtcclxuICB9XHJcbn0pO1xyXG5cclxucnVsZUZ1bmN0aW9ucy5wdXNoKHtcclxuICAgIGlkOidmdWxsUGF0aEV4dCcsXHJcbiAgICBydWxlVHlwZTogJ2J1aWxkSW4nLFxyXG4gICAgZGVzY3JpcHRpb246ICdGdWxsIHBhdGgsIGZpbGVuYW1lIGFuZCBFeHRlbnNpb24nLFxyXG4gICAgc291cmNlOiBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgLy8gYWNxdWlyZSBmaWxlIHBhdGhcXG4gIGNvbnN0IHJlc3VsdCA9IGZpbGUucGF0aDtcXG4gIHJldHVybiByZXN1bHQ7XFxufVwiLFxyXG4gICAgdHlwZTogWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcyddLFxyXG4gICAgY29uZmlnRWxlbWVudHM6IGRlZmF1bHRDb25maWdFbGVtZW50cyh7fSksXHJcbiAgICBmeDogZnVuY3Rpb24gKGFwcDogQXBwLCBmaWxlOlRGaWxlLCB0b29sczpTY3JpcHRpbmdUb29scyl7XHJcbiAgICAgICAgICAgIHJldHVybiBgJHtmaWxlLnBhdGh9YDtcclxuICAgICAgICB9XHJcbn0pO1xyXG5cclxucnVsZUZ1bmN0aW9ucy5wdXNoKHtcclxuICAgIGlkOidwYXRoJyxcclxuICAgIHJ1bGVUeXBlOiAnYnVpbGRJbicsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0Z1bGwgUGF0aCcsXHJcbiAgICBzb3VyY2U6IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICAvLyBhY3F1aXJlIGZpbGUgcGF0aFxcbiAgY29uc3QgcGF0aCA9IGZpbGUucGF0aDtcXG4gIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLycpO1xcbiAgbGV0IHJlc3VsdCA9ICcnO1xcbiAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcXG4gICAgcGFydHMucG9wKCk7IC8vIHJlbW92ZSBmaWxlIG5hbWVcXG4gICAgcmVzdWx0ID0gcmVzdWx0ICsgcGFydHMuam9pbignLycpO1xcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59XCIsXHJcbiAgICB0eXBlOiBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJ10sXHJcbiAgICBjb25maWdFbGVtZW50czogZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KSxcclxuICAgIGZ4OmZ1bmN0aW9uIChhcHA6IEFwcCwgZmlsZTpURmlsZSwgdG9vbHM6U2NyaXB0aW5nVG9vbHMpe1xyXG4gICAgICAgIGxldCBwYXJ0cyA9IGZpbGUucGF0aC5zcGxpdCgnLycpO1xyXG4gICAgICAgIHBhcnRzLnBvcCgpO1xyXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKCcvJyk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxucnVsZUZ1bmN0aW9ucy5wdXNoKHtcclxuICAgIGlkOidsaW5rVG9GaWxlJyxcclxuICAgIHJ1bGVUeXBlOiAnYnVpbGRJbicsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0xpbmsgdG8gZmlsZScsXHJcbiAgICBzb3VyY2U6IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICAvLyBhY3F1aXJlIGZpbGUgcGF0aFxcbiAgY29uc3QgcGF0aCA9IGZpbGUucGF0aDtcXG4gIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLycpO1xcbiAgbGV0IHJlc3VsdCA9ICcnO1xcbiAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcXG4gICAgcGFydHMucG9wKCk7IC8vIHJlbW92ZSBmaWxlIG5hbWVcXG4gICAgcmVzdWx0ID0gcmVzdWx0ICsgcGFydHMuam9pbignLycpO1xcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59XCIsXHJcbiAgICB0eXBlOiBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywnbXVsdGl0ZXh0J10sXHJcbiAgICBjb25maWdFbGVtZW50czogZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHtyZXN1bHRBc0xpbms6IGZhbHNlfSksXHJcbiAgICBmeDpmdW5jdGlvbiAoYXBwOiBBcHAsIGZpbGU6VEZpbGUsIHRvb2xzOlNjcmlwdGluZ1Rvb2xzKXtcclxuICAgICAgICBjb25zdCBwYXJ0cyA9IGZpbGUucGF0aC5zcGxpdCgnLycpO1xyXG4gICAgICAgIGNvbnN0IHJ1bGUgPSB0b29scy5nZXRSdWxlKCk7XHJcbiAgICAgICAgaWYgKCFydWxlKSByZXR1cm4gdG9vbHMuZ2V0Q3VycmVudENvbnRlbnQoKTtcclxuICAgICAgICBjb25zdCBhZGRFeHRlbnNpb24gPSB0b29scy5nZXRPcHRpb25Db25maWcocnVsZS5pZCwnYWRkRXh0ZW5zaW9uJykgXHJcbiAgICAgICAgcGFydHMucG9wKCk7XHJcbiAgICAgICAgaWYgKHBhcnRzW3BhcnRzLmxlbmd0aC0xXSA9PT0gZmlsZS5iYXNlbmFtZSkgcGFydHMucG9wKCk7XHJcbiAgICAgICAgbGV0IGZpbGVOYW1lID0gYWRkRXh0ZW5zaW9uPyBmaWxlLmJhc2VuYW1lICsgJy4nICsgZmlsZS5leHRlbnNpb24gOiBmaWxlLmJhc2VuYW1lOyBcclxuICAgICAgICByZXR1cm4gYFtbJHtwYXJ0cy5qb2luKCcvJyl9LyR7ZmlsZU5hbWV9fCR7ZmlsZS5iYXNlbmFtZX1dXWA7XHJcbiAgICB9LFxyXG4gICAgY29uZmlnVGFiOiBmdW5jdGlvbiAob3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOkZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIHRoYXQ6YW55LCBwcmV2aWV3Q29tcG9uZW50OiBhbnkpIHtcclxuXHJcbiAgICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnRGVmYXVsdHMocnVsZS5pZCwge1xyXG4gICAgICAgIGFkZEV4dGVuc2lvbjogdHJ1ZVxyXG4gICAgICB9KVxyXG4gIFxyXG4gICAgICBuZXcgU2V0dGluZyhvcHRpb25FTClcclxuICAgICAgICAuc2V0TmFtZSgnSW5jbHVkZSBmaWxlIGV4dGVuc2lvbicpXHJcbiAgICAgICAgLnNldERlc2MoJ0FkZCBmaWxlIGV4dGVuc2lvbiB0byBwYXRobmFtZScpXHJcbiAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXHJcbiAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGF0LmdldE9wdGlvbkNvbmZpZyhydWxlLmlkICwnYWRkRXh0ZW5zaW9uJykgfHwgZmFsc2UpXHJcbiAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQsJ2FkZEV4dGVuc2lvbicsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHRoYXQudXBkYXRlUHJldmlldyhydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICApO1xyXG4gICAgfSAgXHJcbn0pO1xyXG5cclxucnVsZUZ1bmN0aW9ucy5wdXNoKHtcclxuICAgIGlkOidwYXRoRm9sZGVyTm90ZXMnLFxyXG4gICAgcnVsZVR5cGU6ICdidWlsZEluJyxcclxuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCAoZm9sZGVyIG5vdGVzKScsXHJcbiAgICBzb3VyY2U6IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICAvLyBhY3F1aXJlIGZpbGUgcGF0aFxcbiAgY29uc3QgcGF0aCA9IGZpbGUucGF0aDtcXG4gIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLycpO1xcbiAgbGV0IHJlc3VsdCA9ICcnO1xcbiAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcXG4gICAgcGFydHMucG9wKCk7IC8vIHJlbW92ZSBmaWxlIG5hbWVcXG4gICAgcmVzdWx0ID0gcmVzdWx0ICsgcGFydHMuam9pbignLycpO1xcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59XCIsXHJcbiAgICB0eXBlOiBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywnbXVsdGl0ZXh0J10sXHJcbiAgICBjb25maWdFbGVtZW50czogZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KSxcclxuICAgIGZ4OmZ1bmN0aW9uIChhcHA6IEFwcCwgZmlsZTpURmlsZSwgdG9vbHM6U2NyaXB0aW5nVG9vbHMpe1xyXG4gICAgICAgIGxldCBwYXJ0cyA9IGZpbGUucGF0aC5zcGxpdCgnLycpO1xyXG4gICAgICAgIHBhcnRzLnBvcCgpO1xyXG4gICAgICAgIGlmIChwYXJ0c1twYXJ0cy5sZW5ndGgtMV0gPT09IGZpbGUuYmFzZW5hbWUpIHBhcnRzLnBvcCgpOyAvLyByZW1vdmUgcGFyZW50IGZvbGRlciBpZiBzYW1lIG5hbWUgYXMgdGhlIGZpbGVcclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbignLycpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbnJ1bGVGdW5jdGlvbnMucHVzaCh7XHJcbiAgaWQ6J2Z1bGxQYXRoRm9sZGVyTm90ZXMnLFxyXG4gIHJ1bGVUeXBlOiAnYnVpbGRJbicsXHJcbiAgZGVzY3JpcHRpb246ICdGdWxsIFBhdGggKGNvbXBseSB3aXRoIFwiZm9sZGVyIG5vdGVzXCIpJyxcclxuICBzb3VyY2U6IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICAvLyBhY3F1aXJlIGZpbGUgcGF0aFxcbiAgY29uc3QgcGF0aCA9IGZpbGUucGF0aDtcXG4gIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLycpO1xcbiAgbGV0IHJlc3VsdCA9ICcnO1xcbiAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcXG4gICAgcGFydHMucG9wKCk7IC8vIHJlbW92ZSBmaWxlIG5hbWVcXG4gICAgcmVzdWx0ID0gcmVzdWx0ICsgcGFydHMuam9pbignLycpO1xcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59XCIsXHJcbiAgdHlwZTogWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcyddLFxyXG4gIGNvbmZpZ0VsZW1lbnRzOiBkZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pLFxyXG4gIGZ4OmZ1bmN0aW9uIChhcHA6IEFwcCwgZmlsZTpURmlsZSwgdG9vbHM6U2NyaXB0aW5nVG9vbHMpe1xyXG4gICAgICBsZXQgcGFydHMgPSBmaWxlLnBhdGguc3BsaXQoJy8nKTtcclxuICAgICAgcGFydHMucG9wKCk7IC8vIHJlbW92ZSBmaWxlIG5hbWVcclxuICAgICAgaWYgKHBhcnRzW3BhcnRzLmxlbmd0aC0xXSA9PT0gZmlsZS5iYXNlbmFtZSkgcGFydHMucG9wKCk7IC8vIHJlbW92ZSBwYXJlbnQgZm9sZGVyIGlmIHNhbWUgbmFtZSBhcyB0aGUgZmlsZVxyXG4gICAgICBwYXJ0cy5wdXNoKGZpbGUuYmFzZW5hbWUpOyAvLyBhZGQgdGhlIGZpbGUgbmFtZSBiYWNrXHJcbiAgICAgIHJldHVybiBwYXJ0cy5qb2luKCcvJyk7XHJcbiAgfVxyXG59KTtcclxuXHJcbnJ1bGVGdW5jdGlvbnMucHVzaCh7XHJcbiAgICBpZDonZnVsbFBhdGhFeHRGb2xkZXJOb3RlcycsXHJcbiAgICBydWxlVHlwZTogJ2J1aWxkSW4nLFxyXG4gICAgZGVzY3JpcHRpb246ICdGdWxsIFBhdGggd2l0aCBFeHRlbnNpb24gKGNvbXBseSB3aXRoIFwiZm9sZGVyIG5vdGVzXCIpJyxcclxuICAgIHNvdXJjZTogXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIC8vIGFjcXVpcmUgZmlsZSBwYXRoXFxuICBjb25zdCBwYXRoID0gZmlsZS5wYXRoO1xcbiAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XFxuICBsZXQgcmVzdWx0ID0gJyc7XFxuICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xcbiAgICBwYXJ0cy5wb3AoKTsgLy8gcmVtb3ZlIGZpbGUgbmFtZVxcbiAgICByZXN1bHQgPSByZXN1bHQgKyBwYXJ0cy5qb2luKCcvJyk7XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIixcclxuICAgIHR5cGU6IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnXSxcclxuICAgIGNvbmZpZ0VsZW1lbnRzOiBkZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pLFxyXG4gICAgZng6ZnVuY3Rpb24gKGFwcDogQXBwLCBmaWxlOlRGaWxlLCB0b29sczpTY3JpcHRpbmdUb29scyl7XHJcbiAgICAgICAgbGV0IHBhcnRzID0gZmlsZS5wYXRoLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgcGFydHMucG9wKCk7IC8vIHJlbW92ZSBmaWxlIG5hbWVcclxuICAgICAgICBpZiAocGFydHNbcGFydHMubGVuZ3RoLTFdID09PSBmaWxlLmJhc2VuYW1lKSBwYXJ0cy5wb3AoKTsgLy8gcmVtb3ZlIHBhcmVudCBmb2xkZXIgaWYgc2FtZSBuYW1lIGFzIHRoZSBmaWxlXHJcbiAgICAgICAgcGFydHMucHVzaChmaWxlLm5hbWUpOyAvLyBhZGQgdGhlIGZpbGUgbmFtZSBiYWNrXHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJy8nKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5ydWxlRnVuY3Rpb25zLnB1c2goe1xyXG4gICAgaWQ6J2lzUm9vdCcsXHJcbiAgICBydWxlVHlwZTogJ2J1aWxkSW4nLFxyXG4gICAgZGVzY3JpcHRpb246ICdGaWxlIGluIFJvb3QgZm9sZGVyJyxcclxuICAgIHNvdXJjZTogXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIGxldCBwYXJ0cyA9IGZpbGUucGF0aC5zcGxpdCgnLycpO1xcbiAgcmV0dXJuIHBhcnRzLmxlbmd0aCA9PT0gMTtcXG59XCIsXHJcbiAgICB0eXBlOiBbJ2NoZWNrYm94J10sXHJcbiAgICBjb25maWdFbGVtZW50czogZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KSxcclxuICAgIGZ4OmZ1bmN0aW9uIChhcHA6IEFwcCwgZmlsZTpURmlsZSwgdG9vbHM6U2NyaXB0aW5nVG9vbHMpe1xyXG4gICAgICAgIGxldCBwYXJ0cyA9IGZpbGUucGF0aC5zcGxpdCgnLycpO1xyXG4gICAgICAgIHJldHVybiBwYXJ0cy5sZW5ndGggPT09IDE7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxucnVsZUZ1bmN0aW9ucy5wdXNoKHtcclxuICAgIGlkOidmb2xkZXInLFxyXG4gICAgcnVsZVR5cGU6ICdidWlsZEluJyxcclxuICAgIGRlc2NyaXB0aW9uOiAnUGFyZW50IEZvbGRlcicsXHJcbiAgICBzb3VyY2U6IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICAvLyBhY3F1aXJlIGZpbGUgcGF0aFxcbiAgY29uc3QgcGF0aCA9IGZpbGUucGF0aDtcXG4gIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLycpO1xcbiAgbGV0IHJlc3VsdCA9ICcnO1xcbiAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcXG4gICAgcmVzdWx0ID0gcGFydHNbcGFydHMubGVuZ3RoLTJdO1xcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59XCIsXHJcbiAgICB0eXBlOiBbJ3RleHQnLCAndGFncyddLFxyXG4gICAgY29uZmlnRWxlbWVudHM6IGRlZmF1bHRDb25maWdFbGVtZW50cyh7fSksXHJcbiAgICBmeDpmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29sczpTY3JpcHRpbmdUb29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgICAgICAvLyBhY3F1aXJlIGZpbGUgcGF0aFxyXG4gICAgICAgIGNvbnN0IHBhdGggPSBmaWxlLnBhdGg7XHJcbiAgICAgICAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xyXG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICByZXN1bHQgPSBwYXJ0c1twYXJ0cy5sZW5ndGgtMl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH1cclxufSk7XHJcblxyXG5ydWxlRnVuY3Rpb25zLnB1c2goe1xyXG4gICAgaWQ6J2ZvbGRlckZvbGRlck5vdGVzJyxcclxuICAgIHJ1bGVUeXBlOiAnYnVpbGRJbicsXHJcbiAgICBkZXNjcmlwdGlvbjogJ1BhcmVudCBGb2xkZXIgKGNvbXBsaWVzIHdpdGggXCJmb2xkZXIgbm90ZXNcIiknLFxyXG4gICAgc291cmNlOiBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgY29uc3QgcGFydHMgPSBmaWxlLnBhdGguc3BsaXQoJy8nKTtcXG4gIGxldCBpbmRleCA9IHBhcnRzLmxlbmd0aC0yOyAvLyBpbmRleCBvZiBwYXJlbnQgZm9sZGVyXFxuICBpZiAocGFydHNbcGFydHMubGVuZ3RoLTJdPT09ZmlsZS5iYXNlbmFtZSkge1xcbiAgICAgIGluZGV4LS07IC8vIGZvbGRlciBub3RlIHBhcmVudCBpcyB0aGUgY2hpbGRcXG4gIH1cXG4gIGlmIChpbmRleCA+PSAwKSB7XFxuICAgIHJldHVybiBwYXJ0c1tpbmRleF07IC8vIGZpbGUgaW4gZm9sZGVyXFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gdG9vbHMuYXBwPy52YXVsdD8uZ2V0TmFtZSgpIHx8ICdWYXVsdCc7IC8vIGZpbGUgaW4gcm9vdCA9IHZhdWx0XFxuICB9XFxufVwiLFxyXG4gICAgdHlwZTogWyd0ZXh0JywgJ3RhZ3MnXSxcclxuICAgIGNvbmZpZ0VsZW1lbnRzOiBkZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pLFxyXG4gICAgZng6ZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAgIGNvbnN0IHBhcnRzID0gZmlsZS5wYXRoLnNwbGl0KCcvJyk7XHJcbiAgICAgIGxldCBpbmRleCA9IHBhcnRzLmxlbmd0aC0yOyAvLyBpbmRleCBvZiBwYXJlbnQgZm9sZGVyXHJcbiAgICAgIGlmIChwYXJ0c1twYXJ0cy5sZW5ndGgtMl09PT1maWxlLmJhc2VuYW1lKSB7XHJcbiAgICAgICAgICBpbmRleC0tOyAvLyBmb2xkZXIgbm90ZSBwYXJlbnQgaXMgdGhlIGNoaWxkXHJcbiAgICAgIH1cclxuICAgICAgaWYgKGluZGV4ID49IDApIHtcclxuICAgICAgICByZXR1cm4gcGFydHNbaW5kZXhdOyAvLyBmaWxlIGluIGZvbGRlclxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0b29scy5hcHA/LnZhdWx0Py5nZXROYW1lKCkgfHwgJ1ZhdWx0JzsgLy8gZmlsZSBpbiByb290ID0gdmF1bHRcclxuICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJ1bGVGdW5jdGlvbnMucHVzaCh7XHJcbiAgICBpZDonZm9sZGVycycsXHJcbiAgICBydWxlVHlwZTogJ2J1aWxkSW4nLFxyXG4gICAgZGVzY3JpcHRpb246ICdBbGwgZm9sZGVycyBvZiB0aGUgZmlsZSBhcyBhIGxpc3QnLFxyXG4gICAgc291cmNlOiBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgY29uc3QgcGF0aCA9IGZpbGUucGF0aDsgLy8gYWNxdWlyZSBmaWxlIHBhdGhcXG4gIGNvbnN0IHJlc3VsdCA9IHBhdGguc3BsaXQoJy8nKTtcXG4gIHJlc3VsdC5wb3AoKTsgLy8gcmVtb3ZlIGZpbGUgbmFtZVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59XCIsXHJcbiAgICB0eXBlOiBbJ211bHRpdGV4dCcsJ3RhZ3MnLCdhbGlhc2VzJ10sXHJcbiAgICBjb25maWdFbGVtZW50czogZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KSxcclxuICAgIGZ4OmZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzOlNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIC8vIGFjcXVpcmUgZmlsZSBwYXRoXHJcbiAgICAgICAgY29uc3QgcGF0aCA9IGZpbGUucGF0aDtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBwYXRoLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgcmVzdWx0LnBvcCgpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH1cclxufSk7XHJcblxyXG5ydWxlRnVuY3Rpb25zLnB1c2goe1xyXG4gICAgaWQ6J3Jvb3RGb2xkZXInLFxyXG4gICAgcnVsZVR5cGU6ICdidWlsZEluJyxcclxuICAgIGRlc2NyaXB0aW9uOiAnUm9vdCBmb2xkZXInLFxyXG4gICAgc291cmNlOiBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgLy8gYWNxdWlyZSBmaWxlIHBhdGhcXG4gIGNvbnN0IHBhdGggPSBmaWxlLnBhdGg7XFxuICBjb25zdCBwYXJ0cyA9IHBhdGguc3BsaXQoJy8nKTtcXG4gIGxldCByZXN1bHQgPSAnJztcXG4gIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XFxuICAgIHJlc3VsdCA9IHBhcnRzWzBdO1xcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59XCIsXHJcbiAgICB0eXBlOiBbJ3RleHQnLCAnbXVsdGl0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcyddLFxyXG4gICAgY29uZmlnRWxlbWVudHM6IGRlZmF1bHRDb25maWdFbGVtZW50cyh7fSksXHJcbiAgICBmeDpmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29sczpTY3JpcHRpbmdUb29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgICAgICAvLyBhY3F1aXJlIGZpbGUgcGF0aFxyXG4gICAgICAgIGNvbnN0IHBhdGggPSBmaWxlLnBhdGg7XHJcbiAgICAgICAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xyXG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICByZXN1bHQgPSBwYXJ0c1swXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG59KTtcclxuXHJcbnJ1bGVGdW5jdGlvbnMucHVzaCh7XHJcbiAgICBpZDonbmFtZScsXHJcbiAgICBydWxlVHlwZTogJ2J1aWxkSW4nLFxyXG4gICAgZGVzY3JpcHRpb246ICdGaWxlIG5hbWUgd2l0aG91dCBleHRlbnNpb24nLFxyXG4gICAgc291cmNlOiBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgLy8gYWNxdWlyZSBmaWxlIG5hbWVcXG4gIGNvbnN0IHJlc3VsdCA9IGZpbGUubmFtZS5zcGxpdCgnLicpO1xcbiAgcmVzdWx0LnBvcCgpOyAvLyByZW1vdmUgZXh0ZW5zaW9uXFxuICByZXN1bHQuam9pbignLicpOyAvLyByZWNvbnN0cnVjdCB0aGUgZmlsZSBuYW1lXFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIixcclxuICAgIHR5cGU6IFsndGV4dCcsICdtdWx0aXRleHQnLCAndGFncycsICdhbGlhc2VzJ10sXHJcbiAgICBjb25maWdFbGVtZW50czogZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KSxcclxuICAgIGZ4OmZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzOlNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIC8vIGFjcXVpcmUgZmlsZSBuYW1lXHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZmlsZS5uYW1lLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgcmVzdWx0LnBvcCgpOyAvLyByZW1vdmUgZXh0ZW5zaW9uXHJcbiAgICAgICAgcmVzdWx0LmpvaW4oJy4nKTsgLy8gcmVjb25zdHJ1Y3QgdGhlIGZpbGUgbmFtZVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH1cclxufSk7XHJcblxyXG5ydWxlRnVuY3Rpb25zLnB1c2goe1xyXG4gICAgaWQ6J25hbWVFeHQnLFxyXG4gICAgcnVsZVR5cGU6ICdidWlsZEluJyxcclxuICAgIGRlc2NyaXB0aW9uOiAnRmlsZSBuYW1lIHdpdGggZXh0ZW5zaW9uJyxcclxuICAgIHNvdXJjZTogXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIC8vIGFjcXVpcmUgZmlsZSBuYW1lXFxuICBjb25zdCByZXN1bHQgPSBmaWxlLm5hbWU7XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIixcclxuICAgIHR5cGU6IFsndGV4dCcsICdtdWx0aXRleHQnLCAndGFncycsICdhbGlhc2VzJ10sXHJcbiAgICBjb25maWdFbGVtZW50czogZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KSxcclxuICAgIGZ4OmZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzOlNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIC8vIGFjcXVpcmUgZmlsZSBuYW1lXHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZmlsZS5uYW1lO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH1cclxufSk7XHJcblxyXG5ydWxlRnVuY3Rpb25zLnB1c2goe1xyXG4gICAgaWQ6J2dldFByb3BlcnR5JyxcclxuICAgIHJ1bGVUeXBlOiAnYnVpbGRJbi5pbnB1dFByb3BlcnR5JyxcclxuICAgIGRlc2NyaXB0aW9uOiAnR2V0IGEgcHJvcGVydHknLFxyXG4gICAgaXNMaXZlUnVsZTogdHJ1ZSxcclxuICAgIGlucHV0UHJvcGVydHk6IHRydWUsXHJcbiAgICBzb3VyY2U6IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBjb25zdCByZXN1bHQgPSBpbnB1dDtcXG4gIHJldHVybiByZXN1bHQ7XFxufVwiLFxyXG4gICAgdHlwZTogWyd0ZXh0JywgJ211bHRpdGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnXSxcclxuICAgIGNvbmZpZ0VsZW1lbnRzOiBkZWZhdWx0Q29uZmlnRWxlbWVudHMoe2lucHV0UHJvcGVydHk6dHJ1ZX0pLFxyXG4gICAgZng6ZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHM6U2NyaXB0aW5nVG9vbHMsIGlucHV0PykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBpbnB1dDtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9XHJcbn0pO1xyXG5cclxucnVsZUZ1bmN0aW9ucy5wdXNoKHtcclxuICAgIGlkOidkYXRlVGltZUNyZWF0ZWQnLFxyXG4gICAgcnVsZVR5cGU6ICdidWlsZEluJyxcclxuICAgIGRlc2NyaXB0aW9uOiAnRGF0ZSAoYW5kIFRpbWUpIGNyZWF0ZWQnLFxyXG4gICAgc291cmNlOiBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgY29uc3QgdGltZU9mZnNldCA9IG5ldyBEYXRlKERhdGUubm93KCkpLmdldFRpbWV6b25lT2Zmc2V0KCkqNjAwMDA7IC8vIGdldCBsb2NhbCB0aW1lIG9mZnNldFxcbiAgY29uc3QgcmVzdWx0ID0gbmV3IERhdGUoZmlsZS5zdGF0LmN0aW1lLXRpbWVPZmZzZXQpO1xcbiAgcmV0dXJuIHJlc3VsdC50b0lTT1N0cmluZygpLnNwbGl0KCdaJylbMF07IC8vIHJlbW92ZSBVVEMgc3ltYm9sXFxufVwiLFxyXG4gICAgdHlwZTogWydkYXRlJywgJ2RhdGV0aW1lJ10sXHJcbiAgICBjb25maWdFbGVtZW50czogZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KSxcclxuICAgIGZ4OmZ1bmN0aW9uIChhcHA6IEFwcCwgZmlsZTpURmlsZSwgdG9vbHM6U2NyaXB0aW5nVG9vbHMpIHsgXHJcbiAgICAgICAgY29uc3QgdGltZU9mZnNldCA9IG5ldyBEYXRlKERhdGUubm93KCkpLmdldFRpbWV6b25lT2Zmc2V0KCkqNjAwMDA7IC8vIGdldCBsb2NhbCB0aW1lIG9mZnNldFxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBEYXRlKGZpbGUuc3RhdC5jdGltZS10aW1lT2Zmc2V0KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1onKVswXTsgLy8gcmVtb3ZlIFVUQyBzeW1ib2xcclxuICAgICAgfVxyXG59KTtcclxuXHJcbnJ1bGVGdW5jdGlvbnMucHVzaCh7XHJcbiAgICBpZDonZGF0ZVRpbWVNb2RpZmllZCcsXHJcbiAgICBydWxlVHlwZTogJ2J1aWxkSW4nLFxyXG4gICAgZGVzY3JpcHRpb246ICdEYXRlIChhbmQgVGltZSkgbW9kaWZpZWQnLFxyXG4gICAgc291cmNlOiBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgY29uc3QgdGltZU9mZnNldCA9IG5ldyBEYXRlKERhdGUubm93KCkpLmdldFRpbWV6b25lT2Zmc2V0KCkqNjAwMDA7XFxuICBjb25zdCByZXN1bHQgPSBuZXcgRGF0ZShmaWxlLnN0YXQubXRpbWUtdGltZU9mZnNldCk7IC8vIEFwcGx5IG9mZnNldCB0byBHTVQgVGltZXN0YW1wXFxuICByZXR1cm4gcmVzdWx0LnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1onKVswXTsgLy8gcmVtb3ZlIFVUQyBzeW1ib2xcXG59XCIsXHJcbiAgICB0eXBlOiBbJ2RhdGUnLCAnZGF0ZXRpbWUnXSxcclxuICAgIGNvbmZpZ0VsZW1lbnRzOiBkZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pLFxyXG4gICAgZng6ZnVuY3Rpb24gKGFwcDogQXBwLCBmaWxlOlRGaWxlLCB0b29sczpTY3JpcHRpbmdUb29scykgeyBcclxuICAgICAgICBjb25zdCB0aW1lT2Zmc2V0ID0gbmV3IERhdGUoRGF0ZS5ub3coKSkuZ2V0VGltZXpvbmVPZmZzZXQoKSo2MDAwMDtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRGF0ZShmaWxlLnN0YXQubXRpbWUtdGltZU9mZnNldCk7IC8vIEFwcGx5IG9mZnNldCB0byBHTVQgVGltZXN0YW1wXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC50b0lTT1N0cmluZygpLnNwbGl0KCdaJylbMF07IC8vIHJlbW92ZSBVVEMgc3ltYm9sXHJcbiAgICAgIH1cclxufSk7XHJcblxyXG5ydWxlRnVuY3Rpb25zLnB1c2goe1xyXG4gICAgaWQ6J2ZpbGVTaXplQnl0ZXMnLFxyXG4gICAgcnVsZVR5cGU6ICdidWlsZEluJyxcclxuICAgIGRlc2NyaXB0aW9uOiAnRmlsZSBzaXplIGluIGJ5dGVzJyxcclxuICAgIHNvdXJjZTogXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIC8vIGFjcXVpcmUgZmlsZSBzaXplXFxuICBjb25zdCByZXN1bHQgPSBmaWxlLnN0YXQuc2l6ZTtcXG4gIHJldHVybiByZXN1bHQ7IC8vIHJldHVybiB5b3UgcmVzdWx0Llxcbn1cIixcclxuICAgIHR5cGU6IFsnbnVtYmVyJ10sXHJcbiAgICBjb25maWdFbGVtZW50czogZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KSxcclxuICAgIGZ4OmZ1bmN0aW9uIChhcHA6IEFwcCwgZmlsZTpURmlsZSwgdG9vbHM6U2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAgICAgLy8gYWNxdWlyZSBmaWxlIHNpemVcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBmaWxlLnN0YXQuc2l6ZTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0OyAvLyByZXR1cm4geW91IHJlc3VsdC5cclxuICAgICAgfVxyXG59KTtcclxuXHJcbnJ1bGVGdW5jdGlvbnMucHVzaCh7XHJcbiAgICBpZDonZmlsZVNpemVTdHJpbmcnLFxyXG4gICAgcnVsZVR5cGU6ICdidWlsZEluJyxcclxuICAgIGRlc2NyaXB0aW9uOiAnRmlsZSBzaXplIGZvcm1hdHRlZCBhcyB0ZXh0JyxcclxuICAgIHNvdXJjZTogXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIC8vIGFjcXVpcmUgZmlsZSBzaXplXFxuICBsZXQgc2l6ZSA9ZmlsZS5zdGF0LnNpemU7XFxuICBjb25zdCBwcmVjaXNpb24gPSAyOyAvLyBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcXG4gIGlmIChzaXplID4gMTAyNCkge1xcbiAgICBzaXplID0gc2l6ZSAvIDEwMjQ7XFxuICAgIGlmIChzaXplID4gMTAyNCkge1xcbiAgICAgIHNpemUgPSBzaXplIC8gMTAyNDtcXG4gICAgICBpZiAoc2l6ZSA+IDEwMjQpIHtcXG4gICAgICAgIHNpemUgPSBzaXplIC8gMTAyNDtcXG4gICAgICAgIHJldHVybiBOdW1iZXIucGFyc2VGbG9hdChzaXplKS50b0ZpeGVkKHByZWNpc2lvbikgKyAnIEdCJztcXG4gICAgICB9IFxcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VGbG9hdChzaXplKS50b0ZpeGVkKHByZWNpc2lvbikgKyAnIE1CJztcXG4gICAgfVxcbiAgICByZXR1cm4gTnVtYmVyLnBhcnNlRmxvYXQoc2l6ZSkudG9GaXhlZChwcmVjaXNpb24pICsgJyBLQic7XFxuICB9ICAgXFxuICByZXR1cm4gc2l6ZSArICcgQnl0ZXMnOyAvLyByZXR1cm4geW91IHJlc3VsdC5cXG59XCIsXHJcbiAgICB0eXBlOiBbJ3RleHQnXSxcclxuICAgIGNvbmZpZ0VsZW1lbnRzOiBkZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pLFxyXG4gICAgZng6ZnVuY3Rpb24gKGFwcDogQXBwLCBmaWxlOlRGaWxlLCB0b29sczpTY3JpcHRpbmdUb29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgICAgICAvLyBhY3F1aXJlIGZpbGUgc2l6ZVxyXG4gICAgICAgIGxldCBzaXplID1maWxlLnN0YXQuc2l6ZTtcclxuICAgICAgICBjb25zdCBwcmVjaXNpb24gPSAyOyAvLyBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcclxuICAgICAgICBpZiAoc2l6ZSA+IDEwMjQpIHtcclxuICAgICAgICAgIHNpemUgPSBzaXplIC8gMTAyNDtcclxuICAgICAgICAgIGlmIChzaXplID4gMTAyNCkge1xyXG4gICAgICAgICAgICBzaXplID0gc2l6ZSAvIDEwMjQ7XHJcbiAgICAgICAgICAgIGlmIChzaXplID4gMTAyNCkge1xyXG4gICAgICAgICAgICAgIHNpemUgPSBzaXplIC8gMTAyNDtcclxuICAgICAgICAgICAgICByZXR1cm4gc2l6ZS50b0ZpeGVkKHByZWNpc2lvbikgKyAnIEdCJztcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgcmV0dXJuIHNpemUudG9GaXhlZChwcmVjaXNpb24pICsgJyBNQic7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gc2l6ZS50b0ZpeGVkKHByZWNpc2lvbikgKyAnIEtCJztcclxuICAgICAgICB9ICAgXHJcbiAgICAgICAgcmV0dXJuIHNpemUgKyAnIEJ5dGVzJzsgLy8gcmV0dXJuIHlvdSByZXN1bHQuXHJcbiAgICAgIH1cclxufSk7XHJcblxyXG5ydWxlRnVuY3Rpb25zLnB1c2goe1xyXG4gIGlkOiAnYXV0b2NvbXBsZXRlLm1vZGFsJyxcclxuICBydWxlVHlwZTogJ2F1dG9jb21wbGV0ZS5tb2RhbCcsXHJcbiAgZGVzY3JpcHRpb246ICdBdXRvY29tcGxldGUgTW9kYWwgKGFkdmFuY2VkKScsXHJcbiAgaXNMaXZlUnVsZTogdHJ1ZSxcclxuICBzb3VyY2U6ICcnLFxyXG4gIHR5cGU6IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCdtdWx0aXRleHQnXSxcclxuICBjb25maWdFbGVtZW50czogZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHtyZW1vdmVDb250ZW50OiBmYWxzZSwgIGlucHV0UHJvcGVydHk6IGZhbHNlLCBhZGRQcmVmaXg6IGZhbHNlLCBzcGFjZVJlcGxhY2VtZW50OiBmYWxzZSwgc3BlY2lhbENoYXJhY3RlclJlcGxhY2VtZW50OiBmYWxzZSwgY29udmVydFRvTG93ZXJDYXNlOiBmYWxzZSwgcmVzdWx0QXNMaW5rOiBmYWxzZSwgYWRkQ29udGVudDogZmFsc2UsIHNjcmlwdDogZmFsc2V9KSxcclxuICBmeDogYXN5bmMgZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHM6U2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICBsb2dnZXIubG9nKERFQlVHLGBhdXRvY29tcGxldGUgbW9kYWwsIHdvcmsgaW4gcHJvZ3Jlc3MuLi5gKTtcclxuICAgIGNvbnN0IGN1cnJlbnRDb250ZW50ID0gdG9vbHMuZ2V0Q3VycmVudENvbnRlbnQoKTtcclxuICAgIGNvbnN0IHJ1bGUgPSB0b29scy5nZXRSdWxlKCk7XHJcbiAgICBpZiAoIXJ1bGUpIHJldHVybiBjdXJyZW50Q29udGVudDtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSB0b29scy5nZXRPcHRpb25Db25maWcocnVsZS5pZCk7XHJcbiAgICBpZiAoIXJ1bGUpIHJldHVybiB0b29scy5nZXRDdXJyZW50Q29udGVudCgpIHx8ICdhdXRvY29tcGxldGUubW9kYWwnOyAvLyByZXR1cm4gY3VycmVudCBjb250ZW50IGlmIG5vdCBpbXBsZW1lbnRlZCB5ZXRcclxuICAgIGNvbnN0IGZyb250bWF0dGVyID0gdG9vbHMuZ2V0RnJvbnRtYXR0ZXIoKTtcclxuICAgIGNvbnN0IGhhc0F1dG9jb21wbGV0ZVByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhmcm9udG1hdHRlcikuc29tZShrZXkgPT4gXHJcbiAgICAgIGtleS5zdGFydHNXaXRoKHJ1bGUucHJvcGVydHkgKyBvcHRpb25zLnByb3BlcnR5RGVsaW1pdGVyKSAmJlxyXG4gICAgICAoZnJvbnRtYXR0ZXJba2V5XSA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgIGZyb250bWF0dGVyW2tleV0gPT09IG51bGwgfHxcclxuICAgICAgZnJvbnRtYXR0ZXJba2V5XSA9PT0gJycpXHJcbiAgICApO1xyXG4gICAgaWYgKCFoYXNBdXRvY29tcGxldGVQcm9wZXJ0aWVzKSByZXR1cm4gdG9vbHMuZ2V0Q3VycmVudENvbnRlbnQoKSB8fCAnYXV0b2NvbXBsZXRlLm1vZGFsJzsgLy8gcmV0dXJuIGN1cnJlbnQgY29udGVudCBpZiBub3QgaW1wbGVtZW50ZWQgeWV0XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBvcGVuQXV0b2NvbXBsZXRlTW9kYWwoXHJcbiAgICAgICAgdGhpcy5hcHAsXHJcbiAgICAgICAgdGhpcy5wbHVnaW4sXHJcbiAgICAgICAgcnVsZSxcclxuICAgICAgICBvcHRpb25zLFxyXG4gICAgICAgIHRvb2xzLmdldEFjdGl2ZUZpbGUoKSxcclxuICAgICAgICB0b29scy5nZXRGcm9udG1hdHRlcigpXHJcbiAgICAgICk7XHJcbiAgICBsb2dnZXIubG9nKERFQlVHLCdhdXRvY29tcGxldGUgbW9kYWwgcmVzdWx0JywgcmVzdWx0LCB0b29scy5nZXRGcm9udG1hdHRlcigpKTtcclxuICAgIGlmIChyZXN1bHQ/LnZhbHVlcykge1xyXG4gICAgICB0aGlzLmFwcC5maWxlTWFuYWdlci5wcm9jZXNzRnJvbnRNYXR0ZXIoZmlsZSwgKGZyb250bWF0dGVyKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmVzdWx0LnZhbHVlcykpIHtcclxuICAgICAgICAgIGZyb250bWF0dGVyW2tleV0gPSB2YWx1ZTsgLy8gc2V0IHRoZSBmcm9udG1hdHRlciB2YWx1ZVxyXG4gICAgICAgIH1cclxuICAgICAgfSx7J210aW1lJzpmaWxlLnN0YXQubXRpbWV9KTsgLy8gZG8gbm90IGNoYW5nZSB0aGUgbW9kaWZ5IHRpbWUuXHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG9vbHMuZ2V0Q3VycmVudENvbnRlbnQoKSB8fCAnYXV0b2NvbXBsZXRlLm1vZGFsJzsgLy8gcmV0dXJuIGN1cnJlbnQgY29udGVudCBpZiBub3QgaW1wbGVtZW50ZWQgeWV0XHJcbiAgfSxcclxuICBjb25maWdUYWI6IGZ1bmN0aW9uIChvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6RnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDphbnksIHByZXZpZXdDb21wb25lbnQ6IGFueSkge1xyXG5cclxuICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnRGVmYXVsdHMocnVsZS5pZCwge1xyXG4gICAgICBwcm9wZXJ0eURlbGltaXRlcjogJy4nLFxyXG4gICAgfSlcclxuXHJcbiAgICBuZXcgU2V0dGluZyhvcHRpb25FTClcclxuICAgIC5zZXROYW1lKCdEZWxpbWl0ZXInKVxyXG4gICAgLnNldERlc2MoJ0NoYXJhY3RlciB0byBkZXRlcm1pbmUgd2hpY2ggcHJvcGVydHkgc2hvdWxkIGFwcGVhciBpbiB0aGUgbW9kYWwnKVxyXG4gICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgLnNldFZhbHVlKHRoYXQuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQgLCdwcm9wZXJ0eURlbGltaXRlcicpIHx8ICcuJylcclxuICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZyhydWxlLmlkLCdwcm9wZXJ0eURlbGltaXRlcicsIHZhbHVlKTtcclxuICAgICAgICB9KSk7XHJcbiAgfVxyXG59KVxyXG4qL1xyXG4iLCAiXHJcbmltcG9ydCB7IEFwcCwgTW9kYWwsIFNldHRpbmcsIFRBYnN0cmFjdEZpbGUsIFRGaWxlLCBURm9sZGVyLCBWYXVsdCwgc2V0SWNvbixCdXR0b25Db21wb25lbnQsIFRleHRDb21wb25lbnQsIENvbnN0cnVjdG9yIH0gZnJvbSAnb2JzaWRpYW4nOyAvLyBBZGRlZCBzZXRJY29uXHJcbi8vaW1wb3J0ICdjb2RlbWlycm9yL21vZGUvamF2YXNjcmlwdC9qYXZhc2NyaXB0JztcclxuaW1wb3J0IHsgT2JzaWRpYW5Qcm9wZXJ0eVR5cGVzIH0gZnJvbSAnLi90eXBlcyc7XHJcbmltcG9ydCB7IHBhcnNlSlNDb2RlLCBTY3JpcHRpbmdUb29scyB9IGZyb20gJy4vdG9vbHMnO1xyXG5pbXBvcnQgeyB1cGRhdGVQcm9wZXJ0eUljb24gfSBmcm9tICcuL3VpRWxlbWVudHMnO1xyXG5pbXBvcnQgeyBERUJVRywgRVJST1IsIGxvZ2dlciwgVFJBQ0UgfSBmcm9tICcuL0xvZyc7XHJcbi8vaW1wb3J0IHsgY2hkaXIgfSBmcm9tICdub2RlOnByb2Nlc3MnO1xyXG4vL2ltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcclxuLy9pbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcclxuXHJcblxyXG4vLyBEZWZpbmUgdGhlIHJlc3VsdCBzdHJ1Y3R1cmUgcmV0dXJuZWQgYnkgdGhlIG1vZGFsXHJcbmV4cG9ydCBpbnRlcmZhY2UgY29kZUVkaXRvck1vZGFsUmVzdWx0IHtcclxuICAgIGNvZGU6IHN0cmluZztcclxuICAgIHR5cGU6IE9ic2lkaWFuUHJvcGVydHlUeXBlcztcclxuICAgIGNoZWNrZWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBPYnNpZGlhbiBNb2RhbCBmb3Igc2VsZWN0aW5nIGRpcmVjdG9yaWVzIGFuZCBmaWxlcyBmcm9tIHRoZSB2YXVsdCBzdHJ1Y3R1cmUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgY29kZUVkaXRvck1vZGFsIGV4dGVuZHMgTW9kYWwge1xyXG4gICAgLy8gSW5pdGlhbCBzdGF0ZSBwYXNzZWQgdG8gdGhlIG1vZGFsIChzdG9yZWQgZm9yIHJlc2V0IGZ1bmN0aW9uYWxpdHkpXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IGluaXRpYWxDb2RlOiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IG9rQ2FsbGJhY2s6IChyZXN1bHQ6IGNvZGVFZGl0b3JNb2RhbFJlc3VsdCB8IG51bGwpID0+IHZvaWQ7XHJcbiAgICBwcml2YXRlIHNjcmlwdGluZ1Rvb2xzOiBTY3JpcHRpbmdUb29scztcclxuICAgIHByaXZhdGUgcGx1Z2luOiBhbnk7XHJcblxyXG4gICAgLy8gQ3VycmVudCBzdGF0ZSBiZWluZyBtb2RpZmllZCB3aXRoaW4gdGhlIG1vZGFsXHJcbiAgICBwcml2YXRlIGN1cnJlbnRDb2RlOiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIGV4cGVjdGVkVHlwZTogT2JzaWRpYW5Qcm9wZXJ0eVR5cGVzO1xyXG4gICAgcHJpdmF0ZSBjdXJyZW50VHlwZTogT2JzaWRpYW5Qcm9wZXJ0eVR5cGVzO1xyXG4gICAgcHJpdmF0ZSBjaGVja2VkU3VjY2Vzc2Z1bGx5IDogYm9vbGVhbjtcclxuICAgIHByaXZhdGUgdXNlVGV4dEFyZWEgOiBib29sZWFuO1xyXG4gICAgcHJpdmF0ZSBhY3RpdmVGaWxlOiBURmlsZSB8IFRGb2xkZXIgfCBudWxsXHJcbiAgICBwcml2YXRlIGZyb250bWF0dGVyOiBhbnk7IC8vIEZyb250bWF0dGVyIGRhdGEgZm9yIHRoZSBhY3RpdmUgZmlsZVxyXG5cclxuICAgIC8vIFVJIEVsZW1lbnRzXHJcbiAgICBwcml2YXRlIGVkaXRvclJvb3RFbGVtZW50ITogSFRNTEVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIGZ1bmN0aW9uVGVzdEJ1dHRvbiE6IEJ1dHRvbkNvbXBvbmVudDtcclxuICAgIHByaXZhdGUgZnVuY3Rpb25SZXN1bHRUZXh0Q29tcG9uZW50OiBUZXh0Q29tcG9uZW50IHwgdW5kZWZpbmVkO1xyXG4gICAgcHJpdmF0ZSBjbUVkaXRvciE6IENvZGVNaXJyb3IuRWRpdG9yIHwgbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhlIERpcmVjdG9yeVNlbGVjdGlvbk1vZGFsLlxyXG4gICAgICogQHBhcmFtIGFwcCAtIFRoZSBPYnNpZGlhbiBBcHAgaW5zdGFuY2UuXHJcbiAgICAgKiBAcGFyYW0gcGx1Z2luIC0gVGhlIHBsdWdpbiBpbnN0YW5jZS5cclxuICAgICAqIEBwYXJhbSBpbml0aWFsQ29kZSAtIFN0cmluZyB3aXRoIHRoZSBpbml0aWFsIGNvZGUuXHJcbiAgICAgKiBAcGFyYW0gZXhwZWN0ZWRUeXBlIC0gRXhwZWN0ZWQgcmV0dXJuIHR5cGUuXHJcbiAgICAgKiBAcGFyYW0gYWN0aXZlRmlsZSAtIFRoZSBjdXJyZW50bHkgYWN0aXZlIGZpbGUgb3IgZm9sZGVyLlxyXG4gICAgICogQHBhcmFtIGZyb250bWF0dGVyIC0gRnJvbnRtYXR0ZXIgZGF0YSBmb3IgdGhlIGFjdGl2ZSBmaWxlLlxyXG4gICAgICogQHBhcmFtIG9rQ2FsbGJhY2sgLSBGdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHVzZXIgY2xpY2tzIFwiT0tcIi4gUmVjZWl2ZXMgdGhlIHNlbGVjdGlvbiByZXN1bHQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIGFwcDogQXBwLFxyXG4gICAgICAgIHBsdWdpbjogYW55LFxyXG4gICAgICAgIGluaXRpYWxDb2RlOiBzdHJpbmcsXHJcbiAgICAgICAgZXhwZWN0ZWRUeXBlOiBPYnNpZGlhblByb3BlcnR5VHlwZXMsXHJcbiAgICAgICAgYWN0aXZlRmlsZTogVEZpbGUgfCBURm9sZGVyIHwgbnVsbCxcclxuICAgICAgICBmcm9udG1hdHRlcjogYW55LCAgIFxyXG4gICAgICAgIG9rQ2FsbGJhY2s6IChyZXN1bHQ6IGNvZGVFZGl0b3JNb2RhbFJlc3VsdCB8IG51bGwpID0+IHZvaWRcclxuICAgICkge1xyXG4gICAgICAgIHN1cGVyKGFwcCk7XHJcbiAgICAgICAgLy8gU3RvcmUgaW5pdGlhbCBzdGF0ZSBmb3IgcmVzZXRcclxuICAgICAgICB0aGlzLmluaXRpYWxDb2RlID0gaW5pdGlhbENvZGU7XHJcbiAgICAgICAgdGhpcy5leHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGU7XHJcbiAgICAgICAgdGhpcy51c2VUZXh0QXJlYSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY2hlY2tlZFN1Y2Nlc3NmdWxseSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRmlsZSA9IGFjdGl2ZUZpbGU7XHJcbiAgICAgICAgdGhpcy5mcm9udG1hdHRlciA9IGZyb250bWF0dGVyOyAvLyBTdG9yZSBmcm9udG1hdHRlciBkYXRhXHJcbiAgICAgICAgdGhpcy5jdXJyZW50VHlwZSA9IGV4cGVjdGVkVHlwZTsgLy8gSW5pdGlhbGl6ZSBjdXJyZW50IHR5cGUgdG8gZXhwZWN0ZWQgdHlwZVxyXG4gICAgICAgIHRoaXMuY3VycmVudENvZGUgPSBpbml0aWFsQ29kZTsgLy8gSW5pdGlhbGl6ZSBjdXJyZW50IGNvZGUgdG8gaW5pdGlhbCBjb2RlXHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICAgICAgdGhpcy5zY3JpcHRpbmdUb29scyA9IG5ldyBTY3JpcHRpbmdUb29scyhcclxuICAgICAgICAgICAgYXBwLFxyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbixcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MsXHJcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgdGhpcy5mcm9udG1hdHRlcixcclxuICAgICAgICAgICAgdGhpcy5hY3RpdmVGaWxlIGluc3RhbmNlb2YgVEZpbGUgPyB0aGlzLmFjdGl2ZUZpbGUgOiB1bmRlZmluZWRcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMub2tDYWxsYmFjayA9IG9rQ2FsbGJhY2s7XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgY3VycmVudCBzdGF0ZSBmcm9tIGluaXRpYWwgc3RhdGUgZm9yIGVkaXRpbmdcclxuICAgICAgICB0aGlzLnJlc2V0U2VsZWN0aW9uVG9Jbml0aWFsKCk7IC8vIFVzZSBhIG1ldGhvZCBmb3IgaW5pdGlhbGl6YXRpb24gYW5kIHJlc2V0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHN0YXRlIHRvIHRoZSBpbml0aWFsIHN0YXRlIHByb3ZpZGVkIGF0IGNvbnN0cnVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZXNldFNlbGVjdGlvblRvSW5pdGlhbCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRDb2RlID0gdGhpcy5pbml0aWFsQ29kZTtcclxuICAgICAgICB0aGlzLmNtRWRpdG9yPy5zZXRWYWx1ZSh0aGlzLmN1cnJlbnRDb2RlKTsgLy8gU2V0IHRoZSBpbml0aWFsIGNvZGUgaW4gdGhlIGVkaXRvclxyXG4gICAgICAgIGlmICh0aGlzLmZ1bmN0aW9uUmVzdWx0VGV4dENvbXBvbmVudCkgdGhpcy5mdW5jdGlvblJlc3VsdFRleHRDb21wb25lbnQuc2V0VmFsdWUoJycpOyAvLyBDbGVhciB0aGUgcmVzdWx0IHRleHQgY29tcG9uZW50XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHN0YXRlIHRvIGVtcHR5LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlc2V0U2VsZWN0aW9uVG9FbXB0eSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRDb2RlID0gXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIGxldCByZXN1bHQgPSAnJztcXG4gIHJldHVybiByZXN1bHQ7XFxufVwiO1xyXG4gICAgICAgIHRoaXMuY21FZGl0b3I/LnNldFZhbHVlKHRoaXMuY3VycmVudENvZGUpOyAvLyBTZXQgdGhlIGluaXRpYWwgY29kZSBpbiB0aGUgZWRpdG9yXHJcbiAgICAgICAgaWYgKHRoaXMuZnVuY3Rpb25SZXN1bHRUZXh0Q29tcG9uZW50KSB0aGlzLmZ1bmN0aW9uUmVzdWx0VGV4dENvbXBvbmVudC5zZXRWYWx1ZSgnJyk7IC8vIENsZWFyIHRoZSByZXN1bHQgdGV4dCBjb21wb25lbnQgXHJcbiAgICB9XHJcblxyXG4gICAgbG9hZENvZGVNaXJyb3JNb2RlKG1vZGU6IHN0cmluZykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAvLyBWZXJ3ZW5kZSByZXF1aXJlIChrXHUwMEY2bm50ZSBpbiB6dWtcdTAwRkNuZnRpZ2VuIFZlcnNpb25lbiB3ZW5pZ2VyIHp1dmVybFx1MDBFNHNzaWcgc2VpbilcclxuICAgICAgICAgIHJlcXVpcmUoYG9ic2lkaWFuL2xpYi9jb2RlbWlycm9yL21vZGUvJHttb2RlfS8ke21vZGV9LmpzYCk7XHJcbiAgICAgICAgICBsb2dnZXIubG9nKERFQlVHLGBDb2RlTWlycm9yIG1vZGUgJyR7bW9kZX0nIGxvYWRlZCBzdWNjZXNzZnVsbHkgKHVzaW5nIHJlcXVpcmUpLmApO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBsb2dnZXIubG9nKEVSUk9SLGBGYWlsZWQgdG8gbG9hZCBDb2RlTWlycm9yIG1vZGUgJyR7bW9kZX0nICh1c2luZyByZXF1aXJlKTpgLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgbW9kYWwgaXMgb3BlbmVkLiBCdWlsZHMgdGhlIFVJLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBvbk9wZW4oKSB7XHJcbiAgICAgICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGNvbnRlbnRFbC5wYXJlbnRFbGVtZW50KSBjb250ZW50RWwucGFyZW50RWxlbWVudC5zdHlsZS53aWR0aCA9ICc5MDBweCc7XHJcbiAgICAgICAgY29udGVudEVsLmVtcHR5KCk7IC8vIENsZWFyIHByZXZpb3VzIFxyXG4gICAgICAgIGNvbnRlbnRFbC5hZGRDbGFzcygnY29kZUVkaXRvci1tb2RhbCcpOyBcclxuXHJcbiAgICAgICAgLy8gLS0tIE1vZGFsIFRpdGxlIC0tLVxyXG4gICAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdKYXZhU2NyaXB0IEVkaXRvcicgfSk7ICAgIFxyXG4gICAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbCgnYm9keScsIHsgdGV4dDogYE1ha2Ugc3VyZSB5b3VyIGNvZGUgcmVzdWx0czogJHt0aGlzLmV4cGVjdGVkVHlwZX1gIH0pOyBcclxuXHJcbiAgICAgICAgLy8gLS0tIFRyZWUgQ29udGFpbmVyIC0tLVxyXG4gICAgICAgIHRoaXMuZWRpdG9yUm9vdEVsZW1lbnQgPSBjb250ZW50RWwuY3JlYXRlRGl2KHsgY2xzOiAnY29kZUVkaXRvci1jb250YWluZXInIH0pO1xyXG4gICAgICAgIC8vIEJhc2ljIHN0eWxpbmcgZm9yIHRoZSBzY3JvbGxhYmxlIHRyZWUgYXJlYVxyXG4gICAgICAgIC8vIHRoaXMuZWRpdG9yUm9vdEVsZW1lbnQuc3R5bGUud2lkdGggPSAnNjAwcHgnO1xyXG4gICAgICAgIHRoaXMuZWRpdG9yUm9vdEVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJzYwMHB4JztcclxuICAgICAgICB0aGlzLmVkaXRvclJvb3RFbGVtZW50LnN0eWxlLm92ZXJmbG93WSA9ICdhdXRvJztcclxuICAgICAgICAvL3RoaXMuZWRpdG9yUm9vdEVsZW1lbnQuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCB2YXIoLS1iYWNrZ3JvdW5kLW1vZGlmaWVyLWJvcmRlciknO1xyXG4gICAgICAgIHRoaXMuZWRpdG9yUm9vdEVsZW1lbnQuc3R5bGUucGFkZGluZyA9ICcxMHB4JztcclxuICAgICAgICB0aGlzLmVkaXRvclJvb3RFbGVtZW50LnN0eWxlLm1hcmdpblRvcCA9ICcxMHB4JztcclxuICAgICAgICB0aGlzLmVkaXRvclJvb3RFbGVtZW50LnN0eWxlLm1hcmdpbkJvdHRvbSA9ICcxMHB4JztcclxuXHJcbiAgICAgICAgdGhpcy5jbUVkaXRvciA9IG51bGw7XHJcblxyXG4gICAgICAgIGNvbnN0IHJ1bGVPcHRpb25zRGl2ID0gY29udGVudEVsLmNyZWF0ZURpdih7IGNsczogXCJjb2RlRWRpdG9yLW9wdGlvbnNcIiB9KTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMudXNlVGV4dEFyZWEpIHtcclxuICAgICAgICAgICAgY29uc3QgcnVsZU9wdGlvbnNTZXR0aW5ncyA9IG5ldyBTZXR0aW5nKHRoaXMuZWRpdG9yUm9vdEVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAuYWRkVGV4dEFyZWEodGV4dEFyZWEgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRBcmVhLnNldFBsYWNlaG9sZGVyKCdlbmRlciB2YWxpZCBKUyBDb2RlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFyZWEuaW5wdXRFbC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgYGhlaWdodDoxOTBweDsgd2lkdGg6ODAlO2ApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRBcmVhLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mdW5jdGlvblRlc3RCdXR0b24pIHRoaXMuZnVuY3Rpb25UZXN0QnV0dG9uLmJ1dHRvbkVsLmFkZENsYXNzKCdtb2Qtd2FybmluZycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDb2RlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgbGV0IHZpZXcgPSBuZXcgRWRpdG9yVmlldyh7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZTogRWRpdG9yU3RhdGUuY3JlYXRlKHtcclxuICAgICAgICAgICAgICAgICAgZG9jOiB0aGlzLmN1cnJlbnRDb2RlLCAgLy8gb3Igc29tZSBzdHJpbmcgY29udGVudHNcclxuICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uczogW1xyXG4gICAgICAgICAgICAgICAgICAgIEVkaXRvclZpZXcubGluZVdyYXBwaW5nLCAvLyBBZGQgeW91ciBleHRlbnRpb25zIGhlcmVcclxuICAgICAgICAgICAgICAgICAgICBqYXZhc2NyaXB0KCksXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2NlbmVHdXR0ZXIsIC8vIG9yIGxlYXZlIGVtcHR5IGZvciBiYXNpYyBlZGl0b3JcclxuICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgcGFyZW50OiB0aGlzLmVkaXRvclJvb3RFbGVtZW50XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgQ29kZU1pcnJvciA1XHJcbiAgICAgICAgICAgIC8vIENvZGVNaXJyb3ItQmlibGlvdGhlayBhYnJ1ZmVuXHJcbiAgICAgICAgICAgIGNvbnN0IENvZGVNaXJyb3IgPSAod2luZG93IGFzIGFueSkuQ29kZU1pcnJvcjtcclxuICAgICAgICAgICAgLy8gU2ljaGVyc3RlbGxlbiwgZGFzcyBDb2RlTWlycm9yIGdlbGFkZW4gaXN0XHJcbiAgICAgICAgICAgIGlmIChDb2RlTWlycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBKYXZhU2NyaXB0LU1vZHVzIGxhZGVuIChmYWxscyBub2NoIG5pY2h0IGdlbGFkZW4pXHJcbiAgICAgICAgICAgICAgICBpZiAoIUNvZGVNaXJyb3IubW9kZXMuamF2YXNjcmlwdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubG9hZENvZGVNaXJyb3JNb2RlKCdqYXZhc2NyaXB0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhUUkFDRSwnamF2YVNjcmlwdCBzdXBwb3J0IGxvYWRlZCcpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIGxldCBqc0NvZGUgPSB0aGlzLmN1cnJlbnRDb2RlO1xyXG4gICAgICAgICAgICB0aGlzLmNtRWRpdG9yID0gQ29kZU1pcnJvcih0aGlzLmVkaXRvclJvb3RFbGVtZW50LCB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZToganNDb2RlIHx8IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBsZXQgcmVzdWx0ID0gJyc7XFxuICByZXR1cm4gcmVzdWx0OyAvLyByZXR1cm4geW91IHJlc3VsdC5cXG59XCIsXHJcbiAgICAgICAgICAgICAgICBtb2RlOiBcImphdmFzY3JpcHRcIixcclxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXJzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgdGhlbWU6IFwib2JzaWRpYW5cIixcclxuICAgICAgICAgICAgICAgIGluZGVudFVuaXQ6IDQsICBcclxuICAgICAgICAgICAgICAgIGxpbmVXcmFwcGluZzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICByZWFkT25seTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBvdXRlckhlaWdodDogJzYwMHB4JyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAodGhpcy5jbUVkaXRvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbUVkaXRvci5vbignY2hhbmdlJywgKGNtRWRpdG9yOiBDb2RlTWlycm9yLkVkaXRvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZ1bmN0aW9uVGVzdEJ1dHRvbikgdGhpcy5mdW5jdGlvblRlc3RCdXR0b24uYnV0dG9uRWwuYWRkQ2xhc3MoJ21vZC13YXJuaW5nJyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY21FZGl0b3Iub24oJ2JsdXInLCAoY21FZGl0b3I6IENvZGVNaXJyb3IuRWRpdG9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29kZT0gY21FZGl0b3IuZ2V0VmFsdWUoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBBZGQgYSBidXR0b24gdG8gc2F2ZSB0aGUgY29kZVxyXG4gICAgICAgICAgICBuZXcgU2V0dGluZyhydWxlT3B0aW9uc0RpdilcclxuICAgICAgICAgICAgICAgIC5hZGRCdXR0b24oKGJ1dHRvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnVuY3Rpb25UZXN0QnV0dG9uID0gYnV0dG9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRXYXJuaW5nKClcclxuICAgICAgICAgICAgICAgICAgICAuc2V0QnV0dG9uVGV4dChcIlJ1biBDb2RlXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoXCJSdW4gdGhlIGNvZGUgYW5kIGNoZWNrIGZvciBlcnJvcnNcIilcclxuICAgICAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNtRWRpdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQganNDb2RlID0gdGhpcy5jbUVkaXRvci5nZXRWYWx1ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB1c2VyRnVuY3Rpb24gPSAgcGFyc2VKU0NvZGUoanNDb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdXNlckZ1bmN0aW9uID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlcnJvckhpbnQgPSBcIlNlZSBjb25zb2xlIGZvciBkZXRhaWxzIVwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VyRnVuY3Rpb24uY29udGFpbnMoJ1VuZXhwZWN0ZWQgdG9rZW4nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckhpbnQgPSBcIkRpZCB5b3UgbWlzc2VkIGEgc2VtaWNvbG9uICg7KT9cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZnVuY3Rpb25SZXN1bHRUZXh0Q29tcG9uZW50KSB0aGlzLmZ1bmN0aW9uUmVzdWx0VGV4dENvbXBvbmVudC5zZXRWYWx1ZShgU3ludGF4IGVycm9yOiAke3VzZXJGdW5jdGlvbn0hICR7ZXJyb3JIaW50fWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tlZFN1Y2Nlc3NmdWxseSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5idXR0b25FbC5hZGRDbGFzcygnbW9kLXdhcm5pbmcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdXNlckZ1bmN0aW9uKHRoaXMuYXBwLCB0aGlzLmFjdGl2ZUZpbGUsIHRoaXMuc2NyaXB0aW5nVG9vbHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mdW5jdGlvblJlc3VsdFRleHRDb21wb25lbnQpIHRoaXMuZnVuY3Rpb25SZXN1bHRUZXh0Q29tcG9uZW50LnNldFZhbHVlKGAnJHtyZXN1bHQudG9TdHJpbmcoKX0nICgke3R5cGVvZiByZXN1bHR9KWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUeXBlSWNvbnMocmVzdWx0LCB0eXBlc0NvbnRhaW5lciwgdGhpcy5leHBlY3RlZFR5cGUsIHRoaXMuY3VycmVudFR5cGUsIHRoaXMucGx1Z2luLnNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5idXR0b25FbC5yZW1vdmVDbGFzcygnbW9kLXdhcm5pbmcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tlZFN1Y2Nlc3NmdWxseSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZ1bmN0aW9uUmVzdWx0VGV4dENvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IChlIGluc3RhbmNlb2YgRXJyb3IpID8gZS5tZXNzYWdlIDogU3RyaW5nKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnVuY3Rpb25SZXN1bHRUZXh0Q29tcG9uZW50LnNldFZhbHVlKGBTeW50YXggZXJyb3I6ICR7ZXJyb3JNZXNzYWdlfSEgU2VlIGNvbnNvbGUgZm9yIGRldGFpbHMhYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKEVSUk9SLFwiU3ludGF4IGVycm9yLiBcIiwgZSwganNDb2RlLCB1c2VyRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja2VkU3VjY2Vzc2Z1bGx5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b24uYnV0dG9uRWwuYWRkQ2xhc3MoJ21vZC13YXJuaW5nJyk7ICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhFUlJPUixcInN5bnRheCBlcnJvclwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja2VkU3VjY2Vzc2Z1bGx5ID0gZmFsc2U7ICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYWRkVGV4dCgodGV4dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnVuY3Rpb25SZXN1bHRUZXh0Q29tcG9uZW50ID0gdGV4dDtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdmdW5jdGlvbiByZXN1bHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXREaXNhYmxlZCh0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnVuY3Rpb25SZXN1bHRUZXh0Q29tcG9uZW50LmlucHV0RWwuc3R5bGUud2lkdGggPSAnNTgwcHgnO1xyXG5cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlc0NvbnRhaW5lciA9IHJ1bGVPcHRpb25zRGl2LmNyZWF0ZURpdih7IGNsczogJ3Byb3BlcnR5LWljb25zLWNvbnRhaW5lcicgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIC0tLSBBY3Rpb24gQnV0dG9ucyAtLS1cclxuICAgICAgICB0aGlzLmNyZWF0ZUFjdGlvbkJ1dHRvbnMoY29udGVudEVsKTsgLy8gQ3JlYXRlIE9LIGFuZCBSZXNldCBidXR0b25zXHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlVHlwZUljb25zKHZhbHVlOmFueSwgY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCwgZXhwZWN0ZWRUeXBlOiBPYnNpZGlhblByb3BlcnR5VHlwZXMsIGN1cnJlbnRUeXBlOiBPYnNpZGlhblByb3BlcnR5VHlwZXMsIHNldHRpbmdzOiBhbnkpIHtcclxuICAgICAgICBjb25zdCBuZXdUeXBlID0gdHlwZW9mIHZhbHVlO1xyXG4gICAgICAgIGNvbnN0IHR5cGVJY29uczoge1trZXk6c3RyaW5nXTogT2JzaWRpYW5Qcm9wZXJ0eVR5cGVzW119ID0ge1xyXG4gICAgICAgICAgICAnc3RyaW5nJzogWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnLCdkYXRlJywgJ2RhdGV0aW1lJ10sXHJcbiAgICAgICAgICAgICdudW1iZXInOiBbJ251bWJlciddLFxyXG4gICAgICAgICAgICAnYm9vbGVhbic6IFsnY2hlY2tib3gnXSxcclxuICAgICAgICAgICAgJ29iamVjdCc6IFsndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAobmV3VHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnNjcmlwdGluZ1Rvb2xzLmlzSVNPU3RyaW5nKHZhbHVlLCB7d2l0aERhdGU6IHRydWV9KSkge1xyXG4gICAgICAgICAgICAgICAgdHlwZUljb25zW25ld1R5cGVdLnNwbGljZSh0eXBlSWNvbnNbbmV3VHlwZV0uaW5kZXhPZignZGF0ZScpLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuc2NyaXB0aW5nVG9vbHMuaXNJU09TdHJpbmcodmFsdWUsIHt3aXRoRGF0ZTogdHJ1ZSwgd2l0aFRpbWU6IHRydWV9KSkge1xyXG4gICAgICAgICAgICAgICAgdHlwZUljb25zW25ld1R5cGVdLnNwbGljZSh0eXBlSWNvbnNbbmV3VHlwZV0uaW5kZXhPZignZGF0ZXRpbWUnKSwgMSk7IFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRhaW5lci5lbXB0eSgpOyAvLyBDbGVhciB0aGUgY29udGFpbmVyIGJlZm9yZSBhZGRpbmcgbmV3IGljb25zXHJcbiAgICAgICAgZm9yIChsZXQgb2JzaWRpYW5UeXBlIG9mIHR5cGVJY29uc1tuZXdUeXBlXSkge1xyXG4gICAgICAgICAgICBpZiAob2JzaWRpYW5UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpY29uRWwgPSBjb250YWluZXIuY3JlYXRlU3Bhbih7IGNsczogJ3Byb3BlcnR5LWljb24gc2V0dGluZy1pdGVtLWljb24nIH0pO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlUHJvcGVydHlJY29uKGljb25FbCwgb2JzaWRpYW5UeXBlKTsgLy8gVXBkYXRlIHRoZSBpY29uIGJhc2VkIG9uIHRoZSB0eXBlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSBcIk9LXCIgYW5kIFwiUmVzZXRcIiBidXR0b25zLlxyXG4gICAgICogQHBhcmFtIGNvbnRhaW5lckVsIC0gVGhlIEhUTUwgZWxlbWVudCB0byBhcHBlbmQgdGhlIGJ1dHRvbnMgdG8uXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY3JlYXRlQWN0aW9uQnV0dG9ucyhjb250YWluZXJFbDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBidXR0b25zRWwgPSBjb250YWluZXJFbC5jcmVhdGVEaXYoeyBjbHM6ICdtb2RhbC1idXR0b25zJyB9KTtcclxuICAgICAgICBidXR0b25zRWwuc3R5bGUubWFyZ2luVG9wID0gJzE1cHgnO1xyXG4gICAgICAgIGJ1dHRvbnNFbC5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnOyAvLyBVc2UgZmxleCBmb3IgYWxpZ25tZW50XHJcbiAgICAgICAgYnV0dG9uc0VsLnN0eWxlLmp1c3RpZnlDb250ZW50ID0gJ2ZsZXgtZW5kJzsgLy8gQWxpZ24gYnV0dG9ucyB0byB0aGUgcmlnaHRcclxuICAgICAgICBidXR0b25zRWwuc3R5bGUuZ2FwID0gJzEwcHgnOyAvLyBTcGFjZSBiZXR3ZWVuIGJ1dHRvbnNcclxuXHJcbiAgICAgICAgLy8gUmVzZXQgQnV0dG9uIChVbmRvIFx1MjFBQVx1RkUwRilcclxuICAgICAgICBjb25zdCByZXNldEJ1dHRvbiA9IGJ1dHRvbnNFbC5jcmVhdGVFbCgnYnV0dG9uJyk7XHJcbiAgICAgICAgLy8gVXNlIE9ic2lkaWFuJ3Mgc2V0SWNvbiBmb3IgY29uc2lzdGVuY3ksIG9yIHVzZSB0ZXh0XHJcbiAgICAgICAgc2V0SWNvbihyZXNldEJ1dHRvbiwgJ3Jlc2V0Jyk7IC8vIFVzZSBhIHN1aXRhYmxlIGljb24gbGlrZSAncmVzZXQnIG9yICd1bmRvJ1xyXG4gICAgICAgIHJlc2V0QnV0dG9uLmFyaWFMYWJlbCA9ICdSZXNldCBzZWxlY3Rpb24nOyAvLyBBY2Nlc3NpYmlsaXR5XHJcbiAgICAgICAgcmVzZXRCdXR0b24ub25jbGljayA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZXNldFNlbGVjdGlvblRvSW5pdGlhbCgpOyAvLyBSZXNldCBpbnRlcm5hbCBzdGF0ZVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIENsZWFyIEJ1dHRvbiAoQ2xlYXIgXHVEODNEXHVERUFFKVxyXG4gICAgICAgIGNvbnN0IGVtcHR5QnV0dG9uID0gYnV0dG9uc0VsLmNyZWF0ZUVsKCdidXR0b24nKTtcclxuICAgICAgICAvLyBVc2UgT2JzaWRpYW4ncyBzZXRJY29uIGZvciBjb25zaXN0ZW5jeSwgb3IgdXNlIHRleHRcclxuICAgICAgICBzZXRJY29uKGVtcHR5QnV0dG9uLCAnZXJhc2VyJyk7IC8vIFVzZSBhIHN1aXRhYmxlIGljb24gbGlrZSAncmVzZXQnIG9yICd1bmRvJ1xyXG4gICAgICAgIGVtcHR5QnV0dG9uLmFyaWFMYWJlbCA9ICdDbGVhciBzZWxlY3Rpb24nOyAvLyBBY2Nlc3NpYmlsaXR5XHJcbiAgICAgICAgZW1wdHlCdXR0b24ub25jbGljayA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZXNldFNlbGVjdGlvblRvRW1wdHkoKTsgLy8gQ2xlYXIgc3RhdGVcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBjYW5jZWwgQnV0dG9uXHJcbiAgICAgICAgY29uc3QgY2FuY2VsQnV0dG9uID0gYnV0dG9uc0VsLmNyZWF0ZUVsKCdidXR0b24nLCB7IHRleHQ6ICdDYW5jZWwnIH0pO1xyXG4gICAgICAgIGNhbmNlbEJ1dHRvbi5hcmlhTGFiZWwgPSAnY2xvc2UgYW5kIGRpc2NhcmQgY2hhbmdlcyc7IC8vIEFjY2Vzc2liaWxpdHlcclxuICAgICAgICBjYW5jZWxCdXR0b24ub25jbGljayA9ICgpID0+IHtcclxuICAgICAgICAgICAgbG9nZ2VyLmxvZyhUUkFDRSxcIkNhbmNlbCBDbGlja2VkIC0gUmV0dXJuaW5nXCIpOyAvLyBEZWJ1ZyBsb2dcclxuICAgICAgICAgICAgdGhpcy5va0NhbGxiYWNrKCBudWxsICk7IC8vIFBhc3MgdGhlIGZpbmFsIHNlbGVjdGlvbiBiYWNrXHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBPSyBCdXR0b25cclxuICAgICAgICBjb25zdCBva0J1dHRvbiA9IGJ1dHRvbnNFbC5jcmVhdGVFbCgnYnV0dG9uJywgeyB0ZXh0OiAnT0snLCBjbHM6ICdtb2QtY3RhJyB9KTtcclxuICAgICAgICBjYW5jZWxCdXR0b24uYXJpYUxhYmVsID0gJ2Nsb3NlIGFuZCBzYXZlIGNoYW5nZXMnOyAvLyBBY2Nlc3NpYmlsaXR5XHJcbiAgICAgICAgb2tCdXR0b24ub25jbGljayA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBtb2RhbCBpcyBjbG9zZWQuIENsZWFucyB1cCByZXNvdXJjZXMuXHJcbiAgICAgKi9cclxuICAgIG9uQ2xvc2UoKSB7XHJcbiAgICAgICAgLy8gR2F0aGVyIHRoZSBmaW5hbCBzdGF0ZSBPTkxZIHdoZW4gT0sgaXMgY2xpY2tlZFxyXG4gICAgICAgIGNvbnN0IHJlc3VsdDogY29kZUVkaXRvck1vZGFsUmVzdWx0ID0ge1xyXG4gICAgICAgICAgICBjb2RlOiB0aGlzLmN1cnJlbnRDb2RlLFxyXG4gICAgICAgICAgICBjaGVja2VkOiB0aGlzLmNoZWNrZWRTdWNjZXNzZnVsbHksXHJcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxvZ2dlci5sb2coVFJBQ0UsXCJPSyBDbGlja2VkIC0gUmV0dXJuaW5nIFJlc3VsdDpcIiwgcmVzdWx0KTsgLy8gRGVidWcgbG9nXHJcbiAgICAgICAgdGhpcy5va0NhbGxiYWNrKHJlc3VsdCk7IC8vIFBhc3MgdGhlIGZpbmFsIHNlbGVjdGlvbiBiYWNrXHJcbiAgICAgICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XHJcbiAgICAgICAgY29udGVudEVsLmVtcHR5KCk7IC8vIENsZWFyIHRoZSBtb2RhbCdzIGNvbnRlbnRcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBlYXNpbHkgb3BlbiB0aGUgRGlyZWN0b3J5IFNlbGVjdGlvbiBNb2RhbC5cclxuICpcclxuICogQHBhcmFtIGFwcCAtIFRoZSBPYnNpZGlhbiBBcHAgaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBpbml0aWFsQ29kZSAtIFN0cmluZyB3aXRoIHRoZSBpbml0aWFsIGNvZGUuXHJcbiAqIEBwYXJhbSBleHBlY3RlZFR5cGUgLSBFeHBlY3RlZCByZXR1cm4gdHlwZS5cclxuICogQHBhcmFtIG9rQ2FsbGJhY2sgLSBGdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHVzZXIgY2xpY2tzIFwiT0tcIi4gUmVjZWl2ZXMgdGhlIHNlbGVjdGlvbiByZXN1bHQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gb3BlbkNvZGVFZGl0b3JNb2RhbChcclxuICAgIGFwcDogQXBwLFxyXG4gICAgcGx1Z2luOiBhbnksXHJcbiAgICBpbml0aWFsQ29kZTogc3RyaW5nLFxyXG4gICAgZXhwZWN0ZWRUeXBlOiBPYnNpZGlhblByb3BlcnR5VHlwZXMsXHJcbiAgICBhY3RpdmVGaWxlOiBURmlsZSB8IFRGb2xkZXIgfCBudWxsLFxyXG4gICAgZnJvbnRtYXR0ZXI6IGFueSxcclxuICAgIG9rQ2FsbGJhY2s6IChyZXN1bHQ6IGNvZGVFZGl0b3JNb2RhbFJlc3VsdCB8IG51bGwpID0+IHZvaWRcclxuKTogdm9pZCB7XHJcbiAgICAvLyBDcmVhdGUgYW5kIG9wZW4gdGhlIG1vZGFsIGluc3RhbmNlXHJcbiAgICBuZXcgY29kZUVkaXRvck1vZGFsKFxyXG4gICAgICAgIGFwcCxcclxuICAgICAgICBwbHVnaW4sXHJcbiAgICAgICAgaW5pdGlhbENvZGUsXHJcbiAgICAgICAgZXhwZWN0ZWRUeXBlLFxyXG4gICAgICAgIGFjdGl2ZUZpbGUsXHJcbiAgICAgICAgZnJvbnRtYXR0ZXIsXHJcbiAgICAgICAgb2tDYWxsYmFja1xyXG4gICAgKS5vcGVuKCk7XHJcbn0iLCAiaW1wb3J0IHsgc2V0SWNvbiwgVGV4dENvbXBvbmVudCB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgeyBPYnNpZGlhblByb3BlcnR5VHlwZXMsIFByb3BlcnR5SW5mbyB9IGZyb20gXCIuL3R5cGVzXCI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyVmFsdWVJbnB1dChjb250YWluZXJFbDogSFRNTEVsZW1lbnQsIHByb3BlcnR5SW5mbzogUHJvcGVydHlJbmZvIHwgdW5kZWZpbmVkLCBjdXJyZW50VmFsdWU6IGFueSwgY2hhbmdlQ2FsbGJhY2s6IChwcm9wZXJ0eUluZm86IFByb3BlcnR5SW5mbyB8IHVuZGVmaW5lZCwgdmFsdWU6IGFueSkgPT4gdm9pZCkge1xyXG4gICAgbGV0IHJldHVybkNvbXBvbmVudDphbnk7XHJcbiAgICBjb250YWluZXJFbC5lbXB0eSgpOyBcclxuXHJcbiAgICBpZiAoIXByb3BlcnR5SW5mbykge1xyXG4gICAgICAgICAgICBjb250YWluZXJFbC5zZXRUZXh0KCcnKTtcclxuICAgICAgICAgICAgY29udGFpbmVyRWwuYWRkQ2xhc3MoJ3RleHQtbXV0ZWQnKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHR5cGUgPSBwcm9wZXJ0eUluZm8udHlwZTtcclxuXHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICBjYXNlICdudW1iZXInOlxyXG4gICAgICAgICAgICByZXR1cm5Db21wb25lbnQgPSBuZXcgVGV4dENvbXBvbmVudChjb250YWluZXJFbClcclxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignTnVtZXJpYyBWYWx1ZScpXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUoY3VycmVudFZhbHVlICE9PSB1bmRlZmluZWQgJiYgY3VycmVudFZhbHVlICE9PSBudWxsID8gU3RyaW5nKGN1cnJlbnRWYWx1ZSkgOiAnJylcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBudW1WYWx1ZSA9IHZhbHVlID09PSAnJyA/IHVuZGVmaW5lZCA6IHBhcnNlRmxvYXQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUNhbGxiYWNrKHByb3BlcnR5SW5mbywgaXNOYU4obnVtVmFsdWUgYXMgbnVtYmVyKSA/IHVuZGVmaW5lZCA6IG51bVZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICByZXR1cm5Db21wb25lbnQuaW5wdXRFbC50eXBlID0gJ251bWJlcic7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcclxuICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50ID0gY29udGFpbmVyRWwuY3JlYXRlRGl2KHsgY2xzOiAndHJpLXN0YXRlLWNoZWNrYm94IGNsaWNrYWJsZS1pY29uJyB9KTtcclxuICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsICdDaGVja2JveCBjaGFuZ2Ugc3RhdGUnKTtcclxuICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdjaGVja2JveCcpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgdXBkYXRlQ2hlY2tib3hWaXN1YWwgPSAoc3RhdGU6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBpY29uTmFtZTogc3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgbGV0IGFyaWFTdGF0ZTogJ3RydWUnIHwgJ2ZhbHNlJyB8ICdtaXhlZCc7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpY29uTmFtZSA9ICdjaGVjay1zcXVhcmUnO1xyXG4gICAgICAgICAgICAgICAgICAgIGFyaWFTdGF0ZSA9ICd0cnVlJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWNvbk5hbWUgPSAnc3F1YXJlJztcclxuICAgICAgICAgICAgICAgICAgICBhcmlhU3RhdGUgPSAnZmFsc2UnO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gdW5kZWZpbmVkIG9yIG51bGxcclxuICAgICAgICAgICAgICAgICAgICBpY29uTmFtZSA9ICdtaW51cy1zcXVhcmUnO1xyXG4gICAgICAgICAgICAgICAgICAgIGFyaWFTdGF0ZSA9ICdtaXhlZCc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZXRJY29uKHJldHVybkNvbXBvbmVudCwgaWNvbk5hbWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuQ29tcG9uZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1jaGVja2VkJywgYXJpYVN0YXRlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybkNvbXBvbmVudC5kYXRhc2V0LnN0YXRlID0gU3RyaW5nKHN0YXRlKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHVwZGF0ZUNoZWNrYm94VmlzdWFsKGN1cnJlbnRWYWx1ZSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm5Db21wb25lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudFN0YXRlID0gcmV0dXJuQ29tcG9uZW50LmRhdGFzZXQuc3RhdGU7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFN0YXRlOiBib29sZWFuIHwgdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGUgPT09ICdmYWxzZScpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50U3RhdGUgPT09ICd0cnVlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZSA9IHVuZGVmaW5lZDsgXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyBcclxuICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUgPSBmYWxzZTsgXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY2hhbmdlQ2FsbGJhY2socHJvcGVydHlJbmZvLCAgbmV4dFN0YXRlKTtcclxuXHJcbiAgICAgICAgICAgICAgICB1cGRhdGVDaGVja2JveFZpc3VhbChuZXh0U3RhdGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2RhdGUnOlxyXG4gICAgICAgICAgICByZXR1cm5Db21wb25lbnQgPSBuZXcgVGV4dENvbXBvbmVudChjb250YWluZXJFbClcclxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignWVlZWS1NTS1ERCcpXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUoY3VycmVudFZhbHVlIHx8ICcnKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUNhbGxiYWNrKHByb3BlcnR5SW5mbywgdmFsdWUgfHwgdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICByZXR1cm5Db21wb25lbnQuaW5wdXRFbC50eXBlID0gJ2RhdGUnO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdkYXRldGltZSc6XHJcbiAgICAgICAgICAgIHJldHVybkNvbXBvbmVudCA9IG5ldyBUZXh0Q29tcG9uZW50KGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdZWVlZLU1NLUREVEhIOm1tJylcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShjdXJyZW50VmFsdWUgfHwgJycpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlQ2FsbGJhY2socHJvcGVydHlJbmZvLCB2YWx1ZSB8fCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIHJldHVybkNvbXBvbmVudC5pbnB1dEVsLnR5cGUgPSAnZGF0ZXRpbWUtbG9jYWwnO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdhbGlhc2VzJzpcclxuICAgICAgICBjYXNlICd0YWdzJzpcclxuICAgICAgICBjYXNlICdtdWx0aXRleHQnOlxyXG4gICAgICAgICAgICByZXR1cm5Db21wb25lbnQgPSBuZXcgVGV4dENvbXBvbmVudChjb250YWluZXJFbClcclxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcigndmFsdWVzIChkaXZpZGVkIGJ5IGNvbW1hKScpXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUoQXJyYXkuaXNBcnJheShjdXJyZW50VmFsdWUpID8gY3VycmVudFZhbHVlLmpvaW4oJywgJykgOiAoY3VycmVudFZhbHVlIHx8ICcnKSlcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnJheVZhbHVlID0gdmFsdWUuc3BsaXQoJywnKS5tYXAocyA9PiBzLnRyaW0oKSkuZmlsdGVyKHMgPT4gcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlQ2FsbGJhY2socHJvcGVydHlJbmZvLCBhcnJheVZhbHVlLmxlbmd0aCA+IDAgPyBhcnJheVZhbHVlIDogdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICd0ZXh0JzpcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm5Db21wb25lbnQgPSBuZXcgVGV4dENvbXBvbmVudChjb250YWluZXJFbClcclxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcigndmFsdWUnKVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKGN1cnJlbnRWYWx1ZSB8fCAnJylcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VDYWxsYmFjayhwcm9wZXJ0eUluZm8sIHZhbHVlIHx8IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgaWYgKHR5cGUgIT09ICdjaGVja2JveCcpIHtcclxuICAgICAgICByZXR1cm5Db21wb25lbnQuaW5wdXRFbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAndHJhbnNwYXJlbnQnOyAvLyBtYWtlIGl0IGludmlzaWJsZVxyXG4gICAgICAgIHJldHVybkNvbXBvbmVudC5pbnB1dEVsLnN0eWxlLndpZHRoID0gJzEwMCUnO1xyXG4gICAgICAgIHJldHVybkNvbXBvbmVudC5pbnB1dEVsLnN0eWxlLmJvcmRlciA9ICdub25lJztcclxuICAgIH1cclxuICAgIHJldHVybiByZXR1cm5Db21wb25lbnQ7XHJcbn0gXHJcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVQcm9wZXJ0eUljb24oaWNvbkVsOiBIVE1MRWxlbWVudCwgdHlwZTogT2JzaWRpYW5Qcm9wZXJ0eVR5cGVzIHwgdW5kZWZpbmVkKSB7XHJcbiAgICBsZXQgaWNvbk5hbWUgPSAnaGFzaCc7XHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICBjYXNlICd0ZXh0JzogaWNvbk5hbWUgPSAnYWxpZ24tbGVmdCc7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ251bWJlcic6IGljb25OYW1lID0gJ2JpbmFyeSc7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ211bHRpdGV4dCc6IGljb25OYW1lID0gJ2xpc3QnOyBicmVhaztcclxuICAgICAgICBjYXNlICdkYXRlJzogaWNvbk5hbWUgPSAnY2FsZW5kYXInOyBicmVhaztcclxuICAgICAgICBjYXNlICdkYXRldGltZSc6IGljb25OYW1lID0gJ2Nsb2NrJzsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnY2hlY2tib3gnOiBpY29uTmFtZSA9ICdjaGVjay1zcXVhcmUnOyBicmVhaztcclxuICAgICAgICBjYXNlICd0YWdzJzogaWNvbk5hbWUgPSAndGFncyc7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2FsaWFzZXMnOiBpY29uTmFtZSA9ICdmb3J3YXJkJzsgYnJlYWs7XHJcbiBcclxuICAgICAgICBkZWZhdWx0OiBpY29uTmFtZSA9ICdoZWxwLWNpcmNsZSc7XHJcbiAgICB9XHJcbiAgICBzZXRJY29uKGljb25FbCwgaWNvbk5hbWUpO1xyXG59IiwgImltcG9ydCB7IFNldHRpbmcsIEV4dHJhQnV0dG9uQ29tcG9uZW50IH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB0eXBlIHsgUHJvcGVydHlUeXBlSW5mbyB9IGZyb20gXCIuL3R5cGVzXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgTXVsdGlQcm9wZXJ0eVNldHRpbmcge1xyXG4gICAgcHVibGljIHNldHRpbmdFbDogSFRNTEVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIG5hbWU6IHN0cmluZyA9IFwiXCI7XHJcbiAgICBwcml2YXRlIGRlc2M6IHN0cmluZyA9IFwiXCI7XHJcbiAgICBwcml2YXRlIHZhbHVlOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgcHJpdmF0ZSBvbkNoYW5nZUNiOiAodmFsOiBzdHJpbmdbXSkgPT4gdm9pZCA9ICgpID0+IHt9O1xyXG4gICAgcHJpdmF0ZSBvcHRpb25zOiBzdHJpbmdbXSB8IEFycmF5PHtpZDogc3RyaW5nLCBuYW1lOiBzdHJpbmd9PiA9IFtdO1xyXG4gICAgcHJpdmF0ZSBjb250YWluZXI6IEhUTUxFbGVtZW50O1xyXG4gICAgcHJpdmF0ZSBleHRyYUJ1dHRvbkNiczogKChzZXR0aW5nOiBTZXR0aW5nLCBpZHg6IG51bWJlcikgPT4gdm9pZClbXSA9IFtdO1xyXG4gICAgcHJpdmF0ZSBvblJlbmRlclJvd0NiPzogKFxyXG4gICAgICAgIHNldHRpbmc6IFNldHRpbmcsXHJcbiAgICAgICAgdmFsdWU6IHN0cmluZyxcclxuICAgICAgICBpZHg6IG51bWJlcixcclxuICAgICAgICBvbkNoYW5nZTogKHZhbDogc3RyaW5nKSA9PiB2b2lkXHJcbiAgICApID0+IHZvaWQ7XHJcbiAgICBcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lcjogSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgICAgICB0aGlzLnNldHRpbmdFbCA9IGNvbnRhaW5lci5jcmVhdGVEaXYoKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXROYW1lKG5hbWU6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0RGVzYyhkZXNjOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLmRlc2MgPSBkZXNjO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFZhbHVlKHZhbHVlOiBzdHJpbmdbXSkge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZS5sZW5ndGggPyBbLi4udmFsdWVdIDogW1wiXCJdO1xyXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0T3B0aW9ucyhvcHRpb25zOiBzdHJpbmdbXSB8IEFycmF5PHtpZDogc3RyaW5nLCBuYW1lOiBzdHJpbmd9Pikge1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBvbkNoYW5nZShjYjogKHZhbDogc3RyaW5nW10pID0+IHZvaWQpIHtcclxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2IgPSBjYjtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsbG93cyBhZGRpbmcgZXh0cmEgYnV0dG9ucyB0byBlYWNoIHJvdy5cclxuICAgICAqIFRoZSBjYWxsYmFjayByZWNlaXZlcyB0aGUgU2V0dGluZyBhbmQgdGhlIHJvdyBpbmRleC5cclxuICAgICAqL1xyXG4gICAgYWRkRXh0cmFCdXR0b24oY2I6IChzZXR0aW5nOiBTZXR0aW5nLCBpZHg6IG51bWJlcikgPT4gdm9pZCkge1xyXG4gICAgICAgIHRoaXMuZXh0cmFCdXR0b25DYnMucHVzaChjYik7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBzdHlsZURpc2FibGVkKGVsOiBFeHRyYUJ1dHRvbkNvbXBvbmVudCwgZGlzYWJsZWQ6IGJvb2xlYW4pIHtcclxuICAgICAgICBpZiAoZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgZWwuZXh0cmFTZXR0aW5nc0VsLmFkZENsYXNzKCdtb2QtZGlzYWJsZWQnKTtcclxuICAgICAgICAgICAgZWwuZXh0cmFTZXR0aW5nc0VsLnNldEF0dHIoJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpO1xyXG4gICAgICAgICAgICBlbC5leHRyYVNldHRpbmdzRWwudGFiSW5kZXggPSAtMTtcclxuICAgICAgICAgICAgZWwuZXh0cmFTZXR0aW5nc0VsLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGVsLmV4dHJhU2V0dGluZ3NFbC5yZW1vdmVDbGFzcygnbW9kLWRpc2FibGVkJyk7XHJcbiAgICAgICAgICAgIGVsLmV4dHJhU2V0dGluZ3NFbC5zZXRBdHRyKCdhcmlhLWRpc2FibGVkJywgJ2ZhbHNlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcmVuZGVyKCkge1xyXG4gICAgICAgIHRoaXMuc2V0dGluZ0VsLmVtcHR5KCk7XHJcbiAgICAgICAgY29uc3QgYXJyID0gdGhpcy52YWx1ZTtcclxuXHJcbiAgICAgICAgYXJyLmZvckVhY2goKHNlbGVjdGVkLCBpZHgpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2V0dGluZyA9IG5ldyBTZXR0aW5nKHRoaXMuc2V0dGluZ0VsKVxyXG4gICAgICAgICAgICAgICAgLnNldE5hbWUoaWR4ID09PSAwID8gdGhpcy5uYW1lIDogXCJcIilcclxuICAgICAgICAgICAgICAgIC5zZXREZXNjKGlkeCA9PT0gMCA/IHRoaXMuZGVzYyA6IFwiXCIpXHJcbiAgICAgICAgICAgICAgICAuYWRkRHJvcGRvd24oZGQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5mb3JFYWNoKChpdGVtKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRkLmFkZE9wdGlvbihpdGVtLCBpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRkLmFkZE9wdGlvbihpdGVtLmlkLCBpdGVtLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGQuc2V0VmFsdWUoc2VsZWN0ZWQgfHwgXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgZGQub25DaGFuZ2UoKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycltpZHhdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBhcnI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25DaGFuZ2VDYihbLi4uYXJyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGlkeCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmcuc2V0dGluZ0VsLnN0eWxlLmJvcmRlclRvcCA9ICdub25lJzsgLy8gUmVtb3ZlIGJvcmRlciBmb3IgYWxsIGJ1dCB0aGUgZmlyc3QgaXRlbVxyXG4gICAgICAgICAgICAgICAgc2V0dGluZy5zZXR0aW5nRWwuc3R5bGUucGFkZGluZyA9ICcwIDAgMC43NWVtJzsgLy8gUmVtb3ZlIG1hcmdpbiBmb3IgYWxsIGJ1dCB0aGUgZmlyc3QgaXRlbVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZy5zZXR0aW5nRWwuc3R5bGUuYm9yZGVyVG9wID0gJzFweCBzb2xpZCB2YXIoLS1iYWNrZ3JvdW5kLW1vZGlmaWVyLWJvcmRlciknOyAvLyBBZGQgYm9yZGVyIGZvciB0aGUgZmlyc3QgaXRlbVxyXG4gICAgICAgICAgICAgICAgc2V0dGluZy5zZXR0aW5nRWwuc3R5bGUucGFkZGluZyA9ICcwLjc1ZW0gMCc7IC8vIFJlbW92ZSBtYXJnaW4gZm9yIGFsbCBidXQgdGhlIGZpcnN0IGl0ZW1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nQ29udHJvbD0gc2V0dGluZy5jb250cm9sRWw7XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5nQ29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ0NvbnRyb2wuc3R5bGUuZ2FwID0gJzAuMWVtJzsgLy8gQWRkIGdhcCBiZXR3ZWVuIGJ1dHRvbnNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBNb3ZlIHVwXHJcbiAgICAgICAgICAgIHNldHRpbmcuYWRkRXh0cmFCdXR0b24oYnRuID0+IHtcclxuICAgICAgICAgICAgICAgIGJ0bi5zZXRJY29uKCdhcnJvdy11cCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoJ01vdmUgdXAnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXREaXNhYmxlZChpZHggPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXJyW2lkeCAtIDFdLCBhcnJbaWR4XV0gPSBbYXJyW2lkeF0sIGFycltpZHggLSAxXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBhcnI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25DaGFuZ2VDYihbLi4uYXJyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlRGlzYWJsZWQoYnRuLCBpZHggPT09IDApO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1vdmUgZG93blxyXG4gICAgICAgICAgICBzZXR0aW5nLmFkZEV4dHJhQnV0dG9uKGJ0biA9PiB7XHJcbiAgICAgICAgICAgICAgICBidG4uc2V0SWNvbignYXJyb3ctZG93bicpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoJ01vdmUgZG93bicpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldERpc2FibGVkKGlkeCA9PT0gYXJyLmxlbmd0aCAtIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXJyW2lkeF0sIGFycltpZHggKyAxXV0gPSBbYXJyW2lkeCArIDFdLCBhcnJbaWR4XV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBhcnI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25DaGFuZ2VDYihbLi4uYXJyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlRGlzYWJsZWQoYnRuLCBpZHggPT09IGFyci5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBNaW51cyAoYWx3YXlzIGVuYWJsZWQgdW5sZXNzIG9ubHkgb25lIGxlZnQpXHJcbiAgICAgICAgICAgIHNldHRpbmcuYWRkRXh0cmFCdXR0b24oYnRuID0+IHtcclxuICAgICAgICAgICAgICAgIGJ0bi5zZXRJY29uKCdtaW51cy1jaXJjbGUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRUb29sdGlwKCdSZW1vdmUgcHJvcGVydHknKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXREaXNhYmxlZChhcnIubGVuZ3RoID09PSAxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnNwbGljZShpZHgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gYXJyLmxlbmd0aCA/IGFyciA6IFtcIlwiXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNoYW5nZUNiKFsuLi50aGlzLnZhbHVlXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlRGlzYWJsZWQoYnRuLCBhcnIubGVuZ3RoID09PSAxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBDYWxsIGV4dHJhIGJ1dHRvbiBjYWxsYmFja3MgZm9yIHRoaXMgcm93XHJcbiAgICAgICAgICAgIHRoaXMuZXh0cmFCdXR0b25DYnMuZm9yRWFjaChjYiA9PiBjYihzZXR0aW5nLCBpZHgpKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gUGx1cyBidXR0b24gdW5kZXIgdGhlIGxhc3Qgcm93XHJcbiAgICAgICAgY29uc3QgcGx1c0J1dHRvbiA9IG5ldyBTZXR0aW5nKHRoaXMuc2V0dGluZ0VsKVxyXG4gICAgICAgICAgICAuYWRkRXh0cmFCdXR0b24oYnRuID0+IHtcclxuICAgICAgICAgICAgICAgIGJ0bi5zZXRJY29uKCdwbHVzLWNpcmNsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoJ0FkZCBwcm9wZXJ0eScpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldERpc2FibGVkKGFyclthcnIubGVuZ3RoIC0gMV0gPT09IFwiXCIgfHwgIWFyclthcnIubGVuZ3RoIC0gMV0pXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJyW2Fyci5sZW5ndGggLSAxXSAhPT0gXCJcIiAmJiBhcnJbYXJyLmxlbmd0aCAtIDFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBhcnI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ2hhbmdlQ2IoWy4uLmFycl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZURpc2FibGVkKGJ0biwgYXJyW2Fyci5sZW5ndGggLSAxXSA9PT0gXCJcIiB8fCAhYXJyW2Fyci5sZW5ndGggLSAxXSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICBwbHVzQnV0dG9uLnNldHRpbmdFbC5zdHlsZS5ib3JkZXJUb3AgPSAnbm9uZSc7IC8vIFJlbW92ZSBib3JkZXIgZm9yIGFsbCBidXQgdGhlIGZpcnN0IGl0ZW1cclxuICAgICAgICBwbHVzQnV0dG9uLnNldHRpbmdFbC5zdHlsZS5wYWRkaW5nID0gJzAgMCAwLjc1ZW0nOyAvLyBSZW1vdmUgbWFyZ2luIGZvciBhbGwgYnV0IHRoZSBmaXJzdCBpdGVtXHJcbiAgICB9XHJcbn0iLCAiaW1wb3J0IHsgU2V0dGluZywgRXh0cmFCdXR0b25Db21wb25lbnQsIFRleHRDb21wb25lbnQsIFNlYXJjaENvbXBvbmVudCB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgbG9nZ2VyLCBUUkFDRSB9IGZyb20gXCIuL0xvZ1wiO1xuXG5leHBvcnQgdHlwZSBUcmVlSGllcmFyY2h5Rm9sZGVyID0ge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIHBhcmVudElkPzogc3RyaW5nO1xuICAgIGRpc2FibGVkOiBib29sZWFuOyAvLyBBZGRlZCB0byBzdXBwb3J0IGRpc2FibGluZyBmb2xkZXJzXG4gICAgY29sbGFwc2VkOiBib29sZWFuOyAvLyBBZGQgdGhpcyBsaW5lXG59O1xuZXhwb3J0IHR5cGUgVHJlZUhpZXJhcmNoeVJvdyA9IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIGZvbGRlcklkPzogc3RyaW5nO1xuICAgIGtleXdvcmRzOiBzdHJpbmdbXTtcbiAgICBkaXNhYmxlZDogYm9vbGVhbjsgLy8gQWRkZWQgdG8gc3VwcG9ydCBkaXNhYmxpbmcgcm93c1xuICAgIHBheWxvYWQ/OiBhbnk7IC8vIE9wdGlvbmFsIHBheWxvYWQgZm9yIGN1c3RvbSBkYXRhXG59O1xudHlwZSBGTUFGb2xkZXJMaXN0RHJhZ1RhcmdldCA9IFwiZm9sZGVyXCIgfCBcInJvd1wiIHwgXCJyb290XCI7XG5cbmV4cG9ydCB0eXBlIFRyZWVIaWVyYXJjaHlEYXRhID0ge1xuICAgIGZvbGRlcnM6IFRyZWVIaWVyYXJjaHlGb2xkZXJbXTtcbiAgICByb3dzOiBUcmVlSGllcmFyY2h5Um93W107XG59O1xuXG5leHBvcnQgY29uc3QgUk9PVF9GT0xERVIgPSB1bmRlZmluZWQ7IC8vIFNwZWNpYWwgaWRlbnRpZmllciBmb3Igcm9vdCBmb2xkZXJcblxudHlwZSBSb3dSZW5kZXJDYWxsYmFjayA9IChyb3c6IFRyZWVIaWVyYXJjaHlSb3csIHJvd0VsOiBIVE1MRWxlbWVudCkgPT4gdm9pZDtcblxuZXhwb3J0IGNsYXNzIFRyZWVIaWVyYXJjaHlTb3J0YWJsZVNldHRpbmdzIHtcbiAgICBwdWJsaWMgc2V0dGluZ0VsOiBIVE1MRWxlbWVudDtcbiAgICBwcml2YXRlIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XG4gICAgcHJpdmF0ZSBkYXRhOiBUcmVlSGllcmFyY2h5RGF0YTtcbiAgICBwcml2YXRlIHRpdGxlOiBzdHJpbmcgPSBcIlwiO1xuICAgIHByaXZhdGUgZGVzY3JpcHRpb246IHN0cmluZyA9IFwiXCI7XG4gICAgcHJpdmF0ZSBmaWx0ZXI6IHN0cmluZyA9IFwiXCI7XG4gICAgcHJpdmF0ZSByb3dSZW5kZXJDYjogUm93UmVuZGVyQ2FsbGJhY2s7XG4gICAgcHJpdmF0ZSBvbkNoYW5nZUNiOiAoZGF0YTogVHJlZUhpZXJhcmNoeURhdGEsIHJvdz86IFRyZWVIaWVyYXJjaHlSb3cgfCB1bmRlZmluZWQgKSA9PiB2b2lkID0gKCkgPT4ge307XG4gICAgcHJpdmF0ZSBvblJvd0NyZWF0ZWRDYjogKHJvdzogVHJlZUhpZXJhcmNoeVJvdykgPT4gdm9pZCA9ICgpID0+IHt9O1xuICAgIHByaXZhdGUgb25Sb3dEZWxldGVkQ2I6IChyb3c6IFRyZWVIaWVyYXJjaHlSb3cpID0+IHZvaWQgPSAoKSA9PiB7fTtcbiAgICBwcml2YXRlIG9uRGVsZXRlQnRDYjogKCkgPT4gdm9pZCA9ICgpID0+IHt9O1xuICAgIHByaXZhdGUgb25SZW5kZXJlZENiOiAoKSA9PiB2b2lkID0gKCkgPT4ge307XG4gICAgcHJpdmF0ZSBleHRyYUJ1dHRvbkNiczogKChidG46IFNldHRpbmcpID0+IHZvaWQpW10gPSBbXTtcbiAgICBwcml2YXRlIHJvd01hdGNoZXNGaWx0ZXJGbjogKHJvdzogVHJlZUhpZXJhcmNoeVJvdywgZmlsdGVyOiBzdHJpbmcpID0+IGJvb2xlYW4gPSAocm93LCBmaWx0ZXIpID0+IHtcbiAgICAgICAgaWYgKCFmaWx0ZXIpIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gcm93LmtleXdvcmRzLnNvbWUoayA9PiBrLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoZmlsdGVyLnRvTG93ZXJDYXNlKCkpKTtcbiAgICB9O1xuICAgIFxuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsIGRhdGE6IFRyZWVIaWVyYXJjaHlEYXRhLCByb3dSZW5kZXJDYjogUm93UmVuZGVyQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuc2V0dGluZ0VsID0gY29udGFpbmVyLmNyZWF0ZURpdih7IGNsczogXCJGTUEtZm9sZGVyLWxpc3Qtc2V0dGluZ1wiIH0pO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IHsgZm9sZGVyczogW10sIHJvd3M6IFtdIH07XG4gICAgICAgIHRoaXMucm93UmVuZGVyQ2IgPSByb3dSZW5kZXJDYjtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgdGhpcy5vblJlbmRlcmVkQ2IgPSAoKSA9PiB7fTtcbiAgICB9XG4gICAgc2V0VGl0bGUodGl0bGU6IHN0cmluZykge1xuICAgICAgICB0aGlzLnRpdGxlID0gdGl0bGU7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXREZXNjcmlwdGlvbihkZXNjcmlwdGlvbjogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkZEV4dHJhQnV0dG9uVG9IZWFkZXIoY2I6IChidG46IFNldHRpbmcpID0+IHZvaWQpIHtcbiAgICAgICAgdGhpcy5leHRyYUJ1dHRvbkNicy5wdXNoKGNiKTtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9uRGVsZXRlQnQoY2I6ICgpID0+IHZvaWQpIHtcbiAgICAgICAgdGhpcy5vbkRlbGV0ZUJ0Q2IgPSBjYjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkZFJvdyhmb2xkZXJJZDogc3RyaW5nIHwgdW5kZWZpbmVkLCBrZXl3b3Jkczogc3RyaW5nW10gPSBbXSwgcGF5bG9hZD86IGFueSkge1xuICAgICAgICBjb25zdCBuZXdSb3c6IFRyZWVIaWVyYXJjaHlSb3cgPSB7XG4gICAgICAgICAgICBpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcbiAgICAgICAgICAgIGZvbGRlcklkLFxuICAgICAgICAgICAga2V5d29yZHMsXG4gICAgICAgICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWZvbGRlcklkKSB7XG4gICAgICAgICAgICAvLyBJZiBubyBmb2xkZXJJZCwgYWRkIHRvIHJvb3QgKHVuZGVmaW5lZCBmb2xkZXIpXG4gICAgICAgICAgICB0aGlzLmRhdGEucm93cy5wdXNoKG5ld1Jvdyk7XG4gICAgICAgICAgICB0aGlzLm9uUm93Q3JlYXRlZENiKG5ld1Jvdyk7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlQ2IodGhpcy5kYXRhLCBuZXdSb3cpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgdGhlIGxhc3Qgcm93IHdpdGggdGhlIHNhbWUgZm9sZGVySWRcbiAgICAgICAgY29uc3QgbGFzdElkeCA9IHRoaXMuZGF0YS5yb3dzLm1hcChyID0+IHIuZm9sZGVySWQpLmxhc3RJbmRleE9mKGZvbGRlcklkKTtcbiAgICAgICAgaWYgKGxhc3RJZHggPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBObyByb3dzIGluIHRoaXMgZm9sZGVyLCBpbnNlcnQgYXQgdGhlIHN0YXJ0XG4gICAgICAgICAgICB0aGlzLmRhdGEucm93cy51bnNoaWZ0KG5ld1Jvdyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJbnNlcnQgYWZ0ZXIgdGhlIGxhc3Qgcm93IGluIHRoaXMgZm9sZGVyXG4gICAgICAgICAgICB0aGlzLmRhdGEucm93cy5zcGxpY2UobGFzdElkeCArIDEsIDAsIG5ld1Jvdyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vblJvd0NyZWF0ZWRDYihuZXdSb3cpO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2IodGhpcy5kYXRhLCBuZXdSb3cpO1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkRm9sZGVyKG5hbWU6IHN0cmluZywgcGFyZW50SWQ/OiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgbmV3Rm9sZGVyOiBUcmVlSGllcmFyY2h5Rm9sZGVyID0ge1xuICAgICAgICAgICAgaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgcGFyZW50SWQsXG4gICAgICAgICAgICBkaXNhYmxlZDogZmFsc2UsIC8vIERlZmF1bHQgdG8gZW5hYmxlZFxuICAgICAgICAgICAgY29sbGFwc2VkOiBmYWxzZSwgLy8gRGVmYXVsdCB0byBleHBhbmRlZFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRhdGEuZm9sZGVycy5wdXNoKG5ld0ZvbGRlcik7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYih0aGlzLmRhdGEpO1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICBzZXREYXRhKGRhdGE6IFRyZWVIaWVyYXJjaHlEYXRhKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHB1YmxpYyBvbkNoYW5nZShjYjogKGRhdGE6IFRyZWVIaWVyYXJjaHlEYXRhLCByb3c6IFRyZWVIaWVyYXJjaHlSb3cgfCB1bmRlZmluZWQpID0+IHZvaWQpIHtcdFxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2IgPSBjYjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHB1YmxpYyBvblJvd0NyZWF0ZWQoY2I6IChyb3c6IFRyZWVIaWVyYXJjaHlSb3cpID0+IHZvaWQpIHtcbiAgICAgICAgdGhpcy5vblJvd0NyZWF0ZWRDYiA9IGNiO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcHVibGljIG9uUm93RGVsZXRlZChjYjogKHJvdzogVHJlZUhpZXJhcmNoeVJvdykgPT4gdm9pZCkge1xuICAgICAgICB0aGlzLm9uUm93RGVsZXRlZENiID0gY2I7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBwdWJsaWMgb25SZW5kZXJlZChjYjogKCkgPT4gdm9pZCkge1xuICAgICAgICB0aGlzLm9uUmVuZGVyZWRDYiA9IGNiO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcHVibGljIG9uRmlsdGVyKGNiOiAocm93OiBUcmVlSGllcmFyY2h5Um93LCBmaWx0ZXI6IHN0cmluZykgPT4gYm9vbGVhbikge1xuICAgICAgICB0aGlzLnJvd01hdGNoZXNGaWx0ZXJGbiA9IGNiO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcHJpdmF0ZSBtb3ZlUm93KHJvd0lkOiBzdHJpbmcsIHRhcmdldFJvd0lkPzogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGZyb21JZHggPSB0aGlzLmRhdGEucm93cy5maW5kSW5kZXgociA9PiByLmlkID09PSByb3dJZCk7XG4gICAgICAgIGlmIChmcm9tSWR4ID09PSAtMSkgcmV0dXJuO1xuICAgICAgICBpZiAocm93SWQgPT09IHRhcmdldFJvd0lkKSByZXR1cm47IC8vIERvbid0IG1vdmUgb250byBpdHNlbGZcblxuICAgICAgICBjb25zdCBtb3ZlZCA9IHRoaXMuZGF0YS5yb3dzW2Zyb21JZHhdO1xuICAgICAgICAvLyBSZW1vdmUgZnJvbSBvbGQgcG9zaXRpb25cbiAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5kYXRhLnJvd3NbZnJvbUlkeF07XG4gICAgICAgIHRoaXMub25Sb3dEZWxldGVkQ2Iocm93KTtcbiAgICAgICAgbG9nZ2VyLmxvZyhUUkFDRSxgcmVtb3ZpbmcgaWQke3Jvd0lkfSBmcm9tICR7ZnJvbUlkeH1gLCB0aGlzLmRhdGEucm93cyk7XG4gICAgICAgIHRoaXMuZGF0YS5yb3dzLnNwbGljZShmcm9tSWR4LCAxKTtcblxuICAgICAgICBsZXQgaW5zZXJ0SWR4OiBudW1iZXI7XG4gICAgICAgIGlmICh0YXJnZXRSb3dJZCkge1xuICAgICAgICAgICAgaW5zZXJ0SWR4ID0gdGhpcy5kYXRhLnJvd3MuZmluZEluZGV4KHIgPT4gci5pZCA9PT0gdGFyZ2V0Um93SWQpO1xuICAgICAgICAgICAgaWYgKGluc2VydElkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyB0YXJnZXRSb3dJZCBub3QgZm91bmQsIGluc2VydCBhdCBlbmRcbiAgICAgICAgICAgICAgICBpbnNlcnRJZHggPSB0aGlzLmRhdGEucm93cy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgZm9sZGVySWQgdG8gbWF0Y2ggdGhlIHRhcmdldCByb3dcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFJvdyA9IHRoaXMuZGF0YS5yb3dzW2luc2VydElkeF07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE9ubHkgaW5zZXJ0IGFmdGVyIGlmIG1vdmluZyBkb3duIGJ1dCBvbmx5IGluc2lkZSBhIGZvbGRlclxuICAgICAgICAgICAgaWYgKGZyb21JZHggPD0gaW5zZXJ0SWR4ICYmIG1vdmVkLmZvbGRlcklkID09PSB0YXJnZXRSb3c/LmZvbGRlcklkKSBpbnNlcnRJZHgrKztcbiAgICAgICAgICAgIG1vdmVkLmZvbGRlcklkID0gdGFyZ2V0Um93Py5mb2xkZXJJZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIHRhcmdldFJvd0lkOiBpbnNlcnQgYXQgZW5kXG4gICAgICAgICAgICBpbnNlcnRJZHggPSB0aGlzLmRhdGEucm93cy5sZW5ndGg7XG4gICAgICAgICAgICAvLyBPcHRpb25hbGx5LCBzZXQgZm9sZGVySWQgdG8gdW5kZWZpbmVkIG9yIGtlZXAgYXMgaXNcbiAgICAgICAgICAgIC8vIG1vdmVkLmZvbGRlcklkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5sb2coVFJBQ0UsYEluc2VydGluZyBtb3ZlZCByb3cgaWQke3Jvd0lkfSBhdCAke2luc2VydElkeH1gLCB0aGlzLmRhdGEucm93cyk7XG4gICAgICAgIHRoaXMuZGF0YS5yb3dzLnNwbGljZShpbnNlcnRJZHgsIDAsIG1vdmVkKTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNiKHRoaXMuZGF0YSk7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICAgIHByaXZhdGUgbW92ZVJvd1RvRm9sZGVyKHJvd0lkOiBzdHJpbmcsIGZvbGRlcklkOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZnJvbUlkeCA9IHRoaXMuZGF0YS5yb3dzLmZpbmRJbmRleChyID0+IHIuaWQgPT09IHJvd0lkKTtcbiAgICAgICAgaWYgKGZyb21JZHggPT09IC0xKSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgbW92ZWQgPSB0aGlzLmRhdGEucm93c1tmcm9tSWR4XTtcbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gb2xkIHBvc2l0aW9uXG4gICAgICAgIHRoaXMuZGF0YS5yb3dzLnNwbGljZShmcm9tSWR4LCAxKTtcblxuICAgICAgICAvLyBTZXQgbmV3IGZvbGRlcklkXG4gICAgICAgIG1vdmVkLmZvbGRlcklkID0gZm9sZGVySWQ7XG5cbiAgICAgICAgLy8gSW5zZXJ0IGF0IHRoZSBlbmQgb2YgdGhlIG5ldyBmb2xkZXIgb3Igcm9vdFxuICAgICAgICB0aGlzLmRhdGEucm93cy5wdXNoKG1vdmVkKTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNiKHRoaXMuZGF0YSk7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICAgIHByaXZhdGUgbW92ZUZvbGRlclRvRm9sZGVyKGZvbGRlcklkOiBzdHJpbmcsIHRhcmdldEZvbGRlcklkOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGZvbGRlcklkID09PSB0YXJnZXRGb2xkZXJJZCkgcmV0dXJuOyAvLyBEb24ndCBtb3ZlIG9udG8gaXRzZWxmXG4gICAgICAgIGNvbnN0IGZyb21JZHggPSB0aGlzLmRhdGEuZm9sZGVycy5maW5kSW5kZXgoZiA9PiBmLmlkID09PSBmb2xkZXJJZCk7XG4gICAgICAgIGlmIChmcm9tSWR4ID09PSAtMSkgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgbW92ZWQgPSB0aGlzLmRhdGEuZm9sZGVyc1tmcm9tSWR4XTtcbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gb2xkIHBvc2l0aW9uXG4gICAgICAgIHRoaXMuZGF0YS5mb2xkZXJzLnNwbGljZShmcm9tSWR4LCAxKTtcblxuICAgICAgICAvLyBTZXQgbmV3IHBhcmVudElkXG4gICAgICAgIG1vdmVkLnBhcmVudElkID0gdGFyZ2V0Rm9sZGVySWQ7XG5cbiAgICAgICAgLy8gSW5zZXJ0IGF0IHRoZSBlbmQgb2YgdGhlIG5ldyBmb2xkZXIgb3Igcm9vdFxuICAgICAgICB0aGlzLmRhdGEuZm9sZGVycy5wdXNoKG1vdmVkKTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNiKHRoaXMuZGF0YSk7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICAgIHByaXZhdGUgcHJvcGFnYXRlRm9sZGVyRGlzYWJsZWQoZm9sZGVySWQ6IHN0cmluZywgZGlzYWJsZWQ6IGJvb2xlYW4pIHtcbiAgICAgICAgLy8gRGlzYWJsZSBhbGwgY2hpbGQgZm9sZGVyc1xuICAgICAgICBmb3IgKGNvbnN0IGZvbGRlciBvZiB0aGlzLmRhdGEuZm9sZGVycykge1xuICAgICAgICAgICAgaWYgKGZvbGRlci5wYXJlbnRJZCA9PT0gZm9sZGVySWQpIHtcbiAgICAgICAgICAgICAgICBmb2xkZXIuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BhZ2F0ZUZvbGRlckRpc2FibGVkKGZvbGRlci5pZCwgZGlzYWJsZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIERpc2FibGUgYWxsIHJvd3MgaW4gdGhpcyBmb2xkZXJcbiAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGhpcy5kYXRhLnJvd3MpIHtcbiAgICAgICAgICAgIGlmIChyb3cuZm9sZGVySWQgPT09IGZvbGRlcklkKSB7XG4gICAgICAgICAgICAgICAgcm93LmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJpdmF0ZSByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuZGF0YS5yb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgIHRoaXMub25Sb3dDcmVhdGVkQ2Iocm93KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0dGluZ0VsLmVtcHR5KCk7XG5cbiAgICAgICAgLy8gLS0tIFJvb3QgSGVhZGVyIGFzIGEgU2V0dGluZyBSb3cgLS0tXG4gICAgICAgIGNvbnN0IGhlYWRlclNldHRpbmcgPSBuZXcgU2V0dGluZyh0aGlzLnNldHRpbmdFbClcbiAgICAgICAgICAgIC5zZXRDbGFzcyhcIkZNQS1mb2xkZXItbGlzdC1yb290LWhlYWRlclwiKTtcblxuICAgICAgICAvLyBEcmFnIGhhbmRsZSBwbGFjZWhvbGRlciAoZm9yIGFsaWdubWVudClcbiAgICAgICAgaGVhZGVyU2V0dGluZy5zZXR0aW5nRWwuY3JlYXRlU3Bhbih7IGNsczogXCJGTUEtZm9sZGVyLWxpc3QtZHJhZy1oYW5kbGVcIiwgdGV4dDogXCIgXCIgfSk7XG4gICAgICAgIGhlYWRlclNldHRpbmcuc2V0dGluZ0VsLnN0eWxlLmJvcmRlclRvcCA9IFwiMXB4IHNvbGlkIHZhcigtLWJhY2tncm91bmQtbW9kaWZpZXItYm9yZGVyKVwiOyAvLyBBZGQgYm90dG9tIGJvcmRlciBmb3Igc2VwYXJhdGlvblxuICAgICAgICBoZWFkZXJTZXR0aW5nLnNldHRpbmdFbC5zdHlsZS5wYWRkaW5nID0gXCIwLjc1ZW0gMFwiOyAvLyBBZGQgc29tZSBwYWRkaW5nIGZvciBiZXR0ZXIgc3BhY2luZ1xuXG4gICAgICAgIC8vIFRpdGxlIChjb3VsZCBiZSBcIlJvb3RcIiBvciB5b3VyIGN1c3RvbSBsYWJlbClcbiAgICAgICAgaGVhZGVyU2V0dGluZy5zZXROYW1lKHRoaXMudGl0bGUgfHwgXCJcIik7XG4gICAgICAgIGhlYWRlclNldHRpbmcuc2V0RGVzYyh0aGlzLmRlc2NyaXB0aW9uIHx8IFwiXCIpO1xuXG4gICAgICAgIC8vIEZpbHRlciBpbnB1dCAoaW5saW5lLCBsZWZ0IG9mIGJ1dHRvbnMpXG4gICAgICAgIGNvbnN0IGZpbHRlcklucHV0ID0gbmV3IFNlYXJjaENvbXBvbmVudChoZWFkZXJTZXR0aW5nLmNvbnRyb2xFbClcbiAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKFwiRmlsdGVyIGZvbGRlcnMvcm93cy4uLlwiKVxuICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5maWx0ZXIpXG4gICAgICAgICAgIC5vbkNoYW5nZSgodmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXIgPSB2YWw7XG4gICAgICAgICAgICAgICAgLy8gT25seSByZS1yZW5kZXIgdGhlIHJvd3MvZm9sZGVycywgbm90IHRoZSB3aG9sZSBVSVxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGlzdCgpO1xuICAgICAgICAgICAgfSk7IFxuICAgICAgICBmaWx0ZXJJbnB1dC5pbnB1dEVsLnN0eWxlLndpZHRoID0gXCIyMDBweFwiO1xuXG4gICAgICAgIC8vIEFkZCByb3cgYnV0dG9uIChyaWdodClcbiAgICAgICAgaGVhZGVyU2V0dGluZy5hZGRFeHRyYUJ1dHRvbihidG4gPT4ge1xuICAgICAgICAgICAgYnRuLnNldEljb24oXCJwbHVzLWNpcmNsZVwiKVxuICAgICAgICAgICAgICAgIC5zZXRUb29sdGlwKFwiQWRkIHJvdyB0byByb290XCIpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFJvdyh1bmRlZmluZWQsIFtdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQWRkIGZvbGRlciBidXR0b24gKHJpZ2h0KVxuICAgICAgICBoZWFkZXJTZXR0aW5nLmFkZEV4dHJhQnV0dG9uKGJ0biA9PiB7XG4gICAgICAgICAgICBidG4uc2V0SWNvbihcImZvbGRlclwiKVxuICAgICAgICAgICAgICAgIC5zZXRUb29sdGlwKFwiQWRkIGZvbGRlciB0byByb290XCIpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEZvbGRlcih0aGlzLmdldE5leHRGb2xkZXJOYW1lKCksIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaGVhZGVyU2V0dGluZy5hZGRFeHRyYUJ1dHRvbihidG4gPT4ge1xuICAgICAgICAgICAgYnRuLnNldEljb24oXCJ0cmFzaFwiKVxuICAgICAgICAgICAgICAgIC5zZXRUb29sdGlwKFwiRHJvcCBoZXJlIHRvIGRlbGV0ZSByb3cgb3IgZm9sZGVyXCIpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRGVsZXRlQnRDYigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ2hhbmdlQ2IodGhpcy5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGJpbkVsID0gYnRuLmV4dHJhU2V0dGluZ3NFbDtcblxuICAgICAgICAgICAgYmluRWwuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGJpbkVsLmNsYXNzTGlzdC5hZGQoXCJGTUEtYmluLWRyb3AtdGFyZ2V0XCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBiaW5FbC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2xlYXZlXCIsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgYmluRWwuY2xhc3NMaXN0LnJlbW92ZShcIkZNQS1iaW4tZHJvcC10YXJnZXRcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJpbkVsLmFkZEV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGJpbkVsLmNsYXNzTGlzdC5yZW1vdmUoXCJGTUEtYmluLWRyb3AtdGFyZ2V0XCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBlLmRhdGFUcmFuc2Zlcj8uZ2V0RGF0YShcInRleHQvcGxhaW5cIik7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhKSByZXR1cm47XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0eXBlLCBpZCB9ID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJyb3dcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEucm93cyA9IHRoaXMuZGF0YS5yb3dzLmZpbHRlcihyID0+IHIuaWQgIT09IGlkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiZm9sZGVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxldGVGb2xkZXJBbmRDb250ZW50cyhpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMub25DaGFuZ2VDYih0aGlzLmRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQWRkIGV4dHJhIGJ1dHRvbnMgdG8gdGhlIGhlYWRlclxuICAgICAgICB0aGlzLmV4dHJhQnV0dG9uQ2JzLmZvckVhY2goY2IgPT4ge1xuICAgICAgICAgICAgY2IoaGVhZGVyU2V0dGluZyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucmVuZGVyTGlzdCgpO1xuXG5cbiAgICB9XG5cbiAgICBwcml2YXRlIHJlbmRlckxpc3QoKSB7XG4gICAgICAgIC8vIFJlbW92ZSBvbGQgbGlzdCAoYnV0IGtlZXAgaGVhZGVyL2ZpbHRlcilcbiAgICAgICAgY29uc3Qgb2xkTGlzdCA9IHRoaXMuc2V0dGluZ0VsLnF1ZXJ5U2VsZWN0b3IoXCIuRk1BLWZvbGRlci1saXN0LWNvbnRlbnRcIik7XG4gICAgICAgIGlmIChvbGRMaXN0KSBvbGRMaXN0LnJlbW92ZSgpO1xuXG4gICAgICAgIGNvbnN0IGxpc3RFbCA9IHRoaXMuc2V0dGluZ0VsLmNyZWF0ZURpdih7IGNsczogXCJGTUEtZm9sZGVyLWxpc3QtY29udGVudFwiIH0pO1xuICAgICAgICB0aGlzLnJlbmRlckZvbGRlcih1bmRlZmluZWQsIGxpc3RFbCwgMCk7XG4gICAgICAgIHRoaXMucmVuZGVyUm93cyh1bmRlZmluZWQsIGxpc3RFbCwgMCk7XG5cbiAgICAgICAgLy8gUmVuZGVyIGEgZHJvcCB6b25lIGF0IHRoZSBlbmQgb2YgdGhlIGZvbGRlciBsaXN0XG4gICAgICAgIGNvbnN0IGRyb3Bab25lID0gbmV3IFNldHRpbmcobGlzdEVsKSAvLyA8LS0gQ0hBTkdFRCBmcm9tIHRoaXMuc2V0dGluZ0VsIHRvIGxpc3RFbFxuICAgICAgICAgICAgLnNldENsYXNzKFwiRk1BLWZvbGRlci1saXN0LWRyb3Atem9uZVwiKTtcbiAgICAgICAgZHJvcFpvbmUuc2V0dGluZ0VsLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnb3ZlclwiLCAoZSkgPT4gdGhpcy5vbkRyYWdPdmVyKGUsIFwicm9vdFwiLCBcImZvbGRlci1kcm9wem9uZVwiKSk7XG4gICAgICAgIGRyb3Bab25lLnNldHRpbmdFbC5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTsgLy8gUHJldmVudCBtdWx0aXBsZSBldmVudHNcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBlLmRhdGFUcmFuc2Zlcj8uZ2V0RGF0YShcInRleHQvcGxhaW5cIik7XG4gICAgICAgICAgICBpZiAoIWRhdGEpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSwgaWQgfSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJyb3dcIikge1xuICAgICAgICAgICAgICAgIC8vIE1vdmUgcm93IHRvIHRoaXMgZm9sZGVyXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlUm93VG9Gb2xkZXIoaWQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiZm9sZGVyXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIGZvbGRlciB0byB0aGlzIGZvbGRlclxuICAgICAgICAgICAgICAgIHRoaXMubW92ZUZvbGRlclRvRm9sZGVyKGlkLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZHJvcFpvbmUuc2V0dGluZ0VsLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnZW50ZXJcIiwgKGUpID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBkcm9wWm9uZS5zZXR0aW5nRWwuY2xhc3NMaXN0LmFkZChcIkZNQS1kcm9wem9uZS10YXJnZXRcIik7XG4gICAgICAgIH0pO1xuICAgICAgICBkcm9wWm9uZS5zZXR0aW5nRWwuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdsZWF2ZVwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGRyb3Bab25lLnNldHRpbmdFbC5jbGFzc0xpc3QucmVtb3ZlKFwiRk1BLWRyb3B6b25lLXRhcmdldFwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25SZW5kZXJlZENiKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZW5kZXJGb2xkZXIocGFyZW50SWQ6IHN0cmluZyB8IHVuZGVmaW5lZCwgcGFyZW50RWw6IEhUTUxFbGVtZW50LCBkZXB0aDogbnVtYmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5kYXRhIHx8ICF0aGlzLmRhdGEuZm9sZGVycykgcmV0dXJuO1xuICAgICAgICBjb25zdCBmb2xkZXJzID0gdGhpcy5kYXRhLmZvbGRlcnMuZmlsdGVyKGYgPT4gZi5wYXJlbnRJZCA9PT0gcGFyZW50SWQpO1xuICAgICAgICBmb2xkZXJzLmZvckVhY2goZm9sZGVyID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmcgPSBuZXcgU2V0dGluZyhwYXJlbnRFbClcbiAgICAgICAgICAgICAgICAuc2V0Q2xhc3MoXCJGTUEtZm9sZGVyLWxpc3QtZm9sZGVyLXNldHRpbmdcIik7XG5cbiAgICAgICAgICAgIC8vIC0tLSBMRUZUIFNJREU6IERyYWcgaGFuZGxlICsgZWRpdGFibGUgbmFtZSAtLS1cbiAgICAgICAgICAgIHNldHRpbmcubmFtZUVsLmVtcHR5KCk7XG5cbiAgICAgICAgICAgIC8vIEluZGVudCBmb2xkZXJzIGJ5IDIwcHggcGVyIGRlcHRoIChmcmFtZSBhbmQgY29udGVudClcbiAgICAgICAgICAgIHNldHRpbmcuc2V0dGluZ0VsLnN0eWxlLm1hcmdpbkxlZnQgPSBgJHtkZXB0aCAqIDIwfXB4YDtcblxuICAgICAgICAgICAgLy8gRHJhZyBoYW5kbGUgKGxlZnQpXG4gICAgICAgICAgICBjb25zdCBkcmFnSGFuZGxlID0gc2V0dGluZy5uYW1lRWwuY3JlYXRlU3Bhbih7IGNsczogXCJGTUEtZm9sZGVyLWxpc3QtZHJhZy1oYW5kbGVcIiB9KTtcbiAgICAgICAgICAgIGRyYWdIYW5kbGUuc2V0VGV4dChcIlx1MjYzMFwiKTtcbiAgICAgICAgICAgIGRyYWdIYW5kbGUuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGRyYWdIYW5kbGUuc3R5bGUubWFyZ2luUmlnaHQgPSBcIjAuNWVtXCI7XG4gICAgICAgICAgICBkcmFnSGFuZGxlLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnc3RhcnRcIiwgKGUpID0+IHRoaXMub25EcmFnU3RhcnQoZSwgXCJmb2xkZXJcIiwgZm9sZGVyLmlkKSk7XG4gICAgICAgICAgICBkcmFnSGFuZGxlLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnb3ZlclwiLCAoZSkgPT4gdGhpcy5vbkRyYWdPdmVyKGUsIFwiZm9sZGVyXCIsIGZvbGRlci5pZCkpO1xuICAgICAgICAgICAgZHJhZ0hhbmRsZS5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLCAoZSkgPT4gdGhpcy5vbkRyb3AoZSwgXCJmb2xkZXJcIiwgZm9sZGVyLmlkKSk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBjaGVja2JveCBmb3IgZGlzYWJsaW5nIGZvbGRlclxuICAgICAgICAgICAgc2V0dGluZy5hZGRUb2dnbGUodG9nZ2xlID0+IHtcbiAgICAgICAgICAgICAgICB0b2dnbGVcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKCFmb2xkZXIuZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZSgodmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2xkZXIuZGlzYWJsZWQgPSAhdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wYWdhdGVGb2xkZXJEaXNhYmxlZChmb2xkZXIuaWQsIGZvbGRlci5kaXNhYmxlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ2hhbmdlQ2IodGhpcy5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGlzdCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLnNldFRvb2x0aXAoXCJEaXNhYmxlIGFsbCBydWxlcyBpbiB0aGlzIGZvbGRlciBhbmQgc3ViZm9sZGVyc1wiKTtcblxuICAgICAgICAgICAgLy8gRWRpdGFibGUgZm9sZGVyIG5hbWVcbiAgICAgICAgICAgIGNvbnN0IG5hbWVJbnB1dCA9IG5ldyBUZXh0Q29tcG9uZW50KHNldHRpbmcubmFtZUVsKTtcbiAgICAgICAgICAgIG5hbWVJbnB1dC5zZXRWYWx1ZShmb2xkZXIubmFtZSk7XG4gICAgICAgICAgICBuYW1lSW5wdXQuaW5wdXRFbC5zdHlsZS5tYXhXaWR0aCA9IFwiMTAwJVwiO1xuICAgICAgICAgICAgbmFtZUlucHV0LmlucHV0RWwuc3R5bGUuYm9yZGVyID0gXCIwXCJcbiAgICAgICAgICAgIG5hbWVJbnB1dC5pbnB1dEVsLnN0eWxlLm1hcmdpblJpZ2h0ID0gXCIwLjVlbVwiO1xuICAgICAgICAgICAgbmFtZUlucHV0Lm9uQ2hhbmdlKCh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICBmb2xkZXIubmFtZSA9IHZhbDtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2hhbmdlQ2IodGhpcy5kYXRhKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyAtLS0gUklHSFQgU0lERTogQWN0aW9uIGJ1dHRvbnMgLS0tXG4gICAgICAgICAgICBzZXR0aW5nLmFkZEV4dHJhQnV0dG9uKGJ0biA9PiB7XG4gICAgICAgICAgICAgICAgYnRuLnNldEljb24oXCJwbHVzLWNpcmNsZVwiKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VG9vbHRpcChcIkFkZCByb3cgdG8gZm9sZGVyXCIpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkUm93KGZvbGRlci5pZCwgW10pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzZXR0aW5nLmFkZEV4dHJhQnV0dG9uKGJ0biA9PiB7XG4gICAgICAgICAgICAgICAgYnRuLnNldEljb24oXCJmb2xkZXJcIilcbiAgICAgICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoXCJBZGQgc3ViZm9sZGVyXCIpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRm9sZGVyKHRoaXMuZ2V0TmV4dEZvbGRlck5hbWUoKSwgZm9sZGVyLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc2V0dGluZy5hZGRFeHRyYUJ1dHRvbihidG4gPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQ29sbGFwc2VkID0gZm9sZGVyLmNvbGxhcHNlZCA/PyBmYWxzZTtcbiAgICAgICAgICAgICAgICBidG4uc2V0SWNvbihpc0NvbGxhcHNlZCA/IFwiY2hldnJvbi1yaWdodFwiIDogXCJjaGV2cm9uLWRvd25cIilcbiAgICAgICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoaXNDb2xsYXBzZWQgPyBcIkV4cGFuZFwiIDogXCJDb2xsYXBzZVwiKVxuICAgICAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2xkZXIuY29sbGFwc2VkID0gIWlzQ29sbGFwc2VkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNoYW5nZUNiKHRoaXMuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxpc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gSW4gcmVuZGVyRm9sZGVyLCBiZWZvcmUgYWRkaW5nIGV2ZW50IGxpc3RlbmVyczpcbiAgICAgICAgICAgIChzZXR0aW5nLnNldHRpbmdFbCBhcyBhbnkpLl9kcmFnRW50ZXJDb3VudCA9IDA7XG5cbiAgICAgICAgICAgIHNldHRpbmcuc2V0dGluZ0VsLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnZW50ZXJcIiwgKGUpID0+IHtcbiAgICAgICAgICAgICAgICAoc2V0dGluZy5zZXR0aW5nRWwgYXMgYW55KS5fZHJhZ0VudGVyQ291bnQrKztcbiAgICAgICAgICAgICAgICBzZXR0aW5nLnNldHRpbmdFbC5jbGFzc0xpc3QuYWRkKFwiRk1BLWRyb3AtdGFyZ2V0XCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXR0aW5nLnNldHRpbmdFbC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2xlYXZlXCIsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgKHNldHRpbmcuc2V0dGluZ0VsIGFzIGFueSkuX2RyYWdFbnRlckNvdW50LS07XG4gICAgICAgICAgICAgICAgaWYgKChzZXR0aW5nLnNldHRpbmdFbCBhcyBhbnkpLl9kcmFnRW50ZXJDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmcuc2V0dGluZ0VsLmNsYXNzTGlzdC5yZW1vdmUoXCJGTUEtZHJvcC10YXJnZXRcIik7XG4gICAgICAgICAgICAgICAgICAgIChzZXR0aW5nLnNldHRpbmdFbCBhcyBhbnkpLl9kcmFnRW50ZXJDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIERyYWcgZXZlbnRzIGZvciBmb2xkZXIgcm93XG4gICAgICAgICAgICBzZXR0aW5nLnNldHRpbmdFbC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIiwgKGUpID0+IHRoaXMub25EcmFnT3ZlcihlLCBcImZvbGRlclwiLCBmb2xkZXIuaWQpKTtcbiAgICAgICAgICAgIHNldHRpbmcuc2V0dGluZ0VsLmFkZEV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIChlKSA9PiB0aGlzLm9uRHJvcChlLCBcImZvbGRlclwiLCBmb2xkZXIuaWQpKTtcbiAgICAgICAgICAgIHNldHRpbmcuc2V0dGluZ0VsLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnbGVhdmVcIiwgKGUpID0+IHRoaXMub25EcmFnTGVhdmUoZSkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZm9sZGVyLmRpc2FibGVkKSBzZXR0aW5nLnNldHRpbmdFbC5jbGFzc0xpc3QuYWRkKFwiRk1BLW1vZC1Gb2xkZXJMaXN0LWRpc2FibGVkXCIpO1xuXG4gICAgICAgICAgICAvLyBSZW5kZXIgcm93cyBhbmQgc3ViZm9sZGVyc1xuICAgICAgICAgICAgaWYgKCFmb2xkZXIuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGb2xkZXIoZm9sZGVyLmlkLCBwYXJlbnRFbCwgZGVwdGggKyAxKTsgLy8gc3ViZm9sZGVyc1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUm93cyhmb2xkZXIuaWQsIHBhcmVudEVsLCBkZXB0aCArIDEpOyAvLyByb3dzIGluIHRoaXMgZm9sZGVyXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgcmVuZGVyUm93cyhmb2xkZXJJZDogc3RyaW5nIHwgdW5kZWZpbmVkLCBwYXJlbnRFbDogSFRNTEVsZW1lbnQsIGRlcHRoOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRhdGEgfHwgIXRoaXMuZGF0YS5yb3dzKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikge1xuICAgICAgICAgICAgLy8gQXBwbHkgZmlsdGVyaW5nIGxvZ2ljIGhlcmVcbiAgICAgICAgICAgIGxvZ2dlci5sb2coVFJBQ0UsYEZpbHRlcmluZyByb3dzIHdpdGggZmlsdGVyOiAke3RoaXMuZmlsdGVyfWAsIHRoaXMuZGF0YS5yb3dzLmZpbHRlcihyID0+IHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFRSQUNFLCBgUm93ICR7ci5pZH0gbWF0Y2hlcyBmaWx0ZXI6ICR7dGhpcy5yb3dNYXRjaGVzRmlsdGVyRm4ocix0aGlzLmZpbHRlcil9YCwgci5rZXl3b3Jkcyk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm93cyA9IHRoaXMuZGF0YS5yb3dzLmZpbHRlcihyID0+IHIuZm9sZGVySWQgPT09IGZvbGRlcklkICYmIHRoaXMucm93TWF0Y2hlc0ZpbHRlckZuKHIsIHRoaXMuZmlsdGVyKSk7XG4gICAgICAgIHJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZyA9IG5ldyBTZXR0aW5nKHBhcmVudEVsKVxuICAgICAgICAgICAgICAgIC5zZXRDbGFzcyhcIkZNQS1mb2xkZXItbGlzdC1yb3ctc2V0dGluZ1wiKTtcblxuICAgICAgICAgICAgLy8gLS0tIExFRlQgU0lERTogRHJhZyBoYW5kbGUgKyBrZXl3b3JkcyAtLS1cbiAgICAgICAgICAgIHNldHRpbmcubmFtZUVsLmVtcHR5KCk7XG5cbiAgICAgICAgICAgIC8vIEluZGVudCByb3dzIGJ5IDIwcHggcGVyIGRlcHRoIChmcmFtZSBhbmQgY29udGVudClcbiAgICAgICAgICAgIHNldHRpbmcuc2V0dGluZ0VsLnN0eWxlLm1hcmdpbkxlZnQgPSBgJHtkZXB0aCAqIDIwfXB4YDtcbiAgICAgICAgICAgIGlmIChzZXR0aW5nLm5hbWVFbC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZy5uYW1lRWwucGFyZW50RWxlbWVudC5zdHlsZS5tYXJnaW5JbmxpbmVFbmQgPSBcIjBweFwiO1xuICAgICAgICAgICAgICAgIHNldHRpbmcubmFtZUVsLnBhcmVudEVsZW1lbnQuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICAgICAgICAgICAgICBzZXR0aW5nLm5hbWVFbC5wYXJlbnRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcbiAgICAgICAgICAgICAgICBzZXR0aW5nLm5hbWVFbC5wYXJlbnRFbGVtZW50LnN0eWxlLmZsZXhEaXJlY3Rpb24gPSBcImNvbHVtblwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0dGluZy5uYW1lRWwuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xuICAgICAgICAgICAgc2V0dGluZy5uYW1lRWwuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcblxuICAgICAgICAgICAgLy8gRHJhZyBoYW5kbGUgKGxlZnQpXG4gICAgICAgICAgICBjb25zdCBkcmFnSGFuZGxlID0gc2V0dGluZy5uYW1lRWwuY3JlYXRlU3Bhbih7IGNsczogXCJGTUEtZm9sZGVyLWxpc3QtZHJhZy1oYW5kbGVcIiB9KTtcbiAgICAgICAgICAgIGRyYWdIYW5kbGUuc2V0VGV4dChcIlx1MjI2MVwiKTtcbiAgICAgICAgICAgIGRyYWdIYW5kbGUuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGRyYWdIYW5kbGUuc3R5bGUubWFyZ2luUmlnaHQgPSBcIjAuNWVtXCI7XG4gICAgICAgICAgICBkcmFnSGFuZGxlLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnc3RhcnRcIiwgKGUpID0+IHRoaXMub25EcmFnU3RhcnQoZSwgXCJyb3dcIiwgcm93LmlkKSk7XG4gICAgICAgICAgICBkcmFnSGFuZGxlLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnb3ZlclwiLCAoZSkgPT4gdGhpcy5vbkRyYWdPdmVyKGUsIFwicm93XCIsIHJvdy5pZCkpO1xuICAgICAgICAgICAgZHJhZ0hhbmRsZS5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLCAoZSkgPT4gdGhpcy5vbkRyb3AoZSwgXCJyb3dcIiwgcm93LmlkKSk7XG5cbiAgICAgICAgICAgIGlmIChyb3cuZGlzYWJsZWQpIHNldHRpbmcuc2V0dGluZ0VsLmFkZENsYXNzKFwiRk1BLW1vZC1Gb2xkZXJMaXN0LWRpc2FibGVkXCIpO1xuICAgICAgICAgICAgLy8gUm93IGNvbnRlbnQgKGN1c3RvbWl6YWJsZSwgZS5nLiBrZXl3b3JkcylcbiAgICAgICAgICAgIHRoaXMucm93UmVuZGVyQ2Iocm93LCBzZXR0aW5nLm5hbWVFbCk7ICBcblxuICAgICAgICAgICAgLy8gRHJhZyBldmVudHMgZm9yIHJvd1xuICAgICAgICAgICAgc2V0dGluZy5zZXR0aW5nRWwuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsIChlKSA9PiB0aGlzLm9uRHJhZ092ZXIoZSwgXCJyb3dcIiwgcm93LmlkKSk7XG4gICAgICAgICAgICBzZXR0aW5nLnNldHRpbmdFbC5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLCAoZSkgPT4gdGhpcy5vbkRyb3AoZSwgXCJyb3dcIiwgcm93LmlkKSk7XG4gICAgICAgICAgICBzZXR0aW5nLnNldHRpbmdFbC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2xlYXZlXCIsIChlKSA9PiB0aGlzLm9uRHJhZ0xlYXZlKGUpKTsgLy8gPC0tIEFERCBUSElTIExJTkVcblxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyAtLS0gRHJhZyAmIERyb3AgSGFuZGxlcnMgKHNpbXBsaWZpZWQsIGV4cGFuZCBhcyBuZWVkZWQpIC0tLVxuICAgIHByaXZhdGUgb25EcmFnU3RhcnQoZTogRHJhZ0V2ZW50LCB0eXBlOiBGTUFGb2xkZXJMaXN0RHJhZ1RhcmdldCwgaWQ6IHN0cmluZykge1xuICAgICAgICBlLmRhdGFUcmFuc2Zlcj8uc2V0RGF0YShcInRleHQvcGxhaW5cIiwgSlNPTi5zdHJpbmdpZnkoeyB0eXBlLCBpZCB9KSk7XG4gICAgfVxuICAgIHByaXZhdGUgb25EcmFnT3ZlcihlOiBEcmFnRXZlbnQsIHR5cGU6IEZNQUZvbGRlckxpc3REcmFnVGFyZ2V0LCBpZDogc3RyaW5nKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xuXG4gICAgICAgIC8vIFByZXZlbnQgZHJhZ2dpbmcgZm9sZGVycyBvbnRvIHJvd3NcbiAgICAgICAgY29uc3QgZGF0YSA9IGUuZGF0YVRyYW5zZmVyPy5nZXREYXRhKFwidGV4dC9wbGFpblwiKTtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwicm93XCIgJiYgZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgeyB0eXBlOiBkcmFnVHlwZSB9ID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGlmIChkcmFnVHlwZSA9PT0gXCJmb2xkZXJcIikge1xuICAgICAgICAgICAgICAgIC8vIERvbid0IGFsbG93IGZvbGRlciBkcm9wIG9uIHJvd1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvbGRlciBoaWdobGlnaHRcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiZm9sZGVyXCIpIHtcbiAgICAgICAgICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKFwiRk1BLWRyb3AtdGFyZ2V0XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUm93OiBzaG93IGFib3ZlL2JlbG93IGluZGljYXRvclxuICAgICAgICBpZiAodHlwZSA9PT0gXCJyb3dcIikge1xuICAgICAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoXCJGTUEtZHJvcC10YXJnZXRcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIG9uRHJhZ0xlYXZlKGU6IERyYWdFdmVudCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQgYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgIHRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKFwiRk1BLWRyb3AtdGFyZ2V0XCIpO1xuICAgIH1cblxuICAgIHByaXZhdGUgb25Ecm9wKGU6IERyYWdFdmVudCwgdHlwZTogRk1BRm9sZGVyTGlzdERyYWdUYXJnZXQsIHRhcmdldElkOiBzdHJpbmcpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpOyAvLyBQcmV2ZW50IG11bHRpcGxlIGV2ZW50c1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQgYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgIHRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKFwiRk1BLWRyb3AtdGFyZ2V0XCIpO1xuXG4gICAgICAgIGNvbnN0IGRhdGEgPSBlLmRhdGFUcmFuc2Zlcj8uZ2V0RGF0YShcInRleHQvcGxhaW5cIik7XG4gICAgICAgIGlmICghZGF0YSkgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IHR5cGU6IGRyYWdUeXBlLCBpZDogZHJhZ0lkIH0gPSBKU09OLnBhcnNlKGRhdGEpO1xuXG4gICAgICAgIGlmIChkcmFnVHlwZSA9PT0gXCJyb3dcIikge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiZm9sZGVyXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIHJvdyB0byB0aGlzIGZvbGRlclxuICAgICAgICAgICAgICAgIHRoaXMubW92ZVJvd1RvRm9sZGVyKGRyYWdJZCwgdGFyZ2V0SWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcInJvd1wiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlUm93KGRyYWdJZCwgdGFyZ2V0SWQpOyAvLyBNb3ZlIHJvdyB0byBuZXcgcG9zaXRpb25cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEcm9wcGluZyBvbiB0aGUgZHJvcCB6b25lIGF0IHRoZSBlbmRcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcInJvb3RcIiAmJiB0YXJnZXRJZCA9PT0gXCJyb3ctZHJvcHpvbmVcIikge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkcmFnVHlwZSA9PT0gXCJmb2xkZXJcIikge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiZm9sZGVyXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIGZvbGRlciB0byB0aGlzIGZvbGRlclxuICAgICAgICAgICAgICAgIHRoaXMubW92ZUZvbGRlclRvRm9sZGVyKGRyYWdJZCwgdGFyZ2V0SWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERyb3BwaW5nIG9uIHRoZSBkcm9wIHpvbmUgYXQgdGhlIGVuZFxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwicm9vdFwiICYmIHRhcmdldElkID09PSBcImZvbGRlci1kcm9wem9uZVwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlRm9sZGVyVG9Gb2xkZXIoZHJhZ0lkLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0TmV4dEZvbGRlck5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IGkgPSAxO1xuICAgICAgICBsZXQgbmFtZSA6IHN0cmluZztcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgbmFtZSA9IGBGb2xkZXIgJHtpKyt9YDtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5kYXRhLmZvbGRlcnMuc29tZShmID0+IGYubmFtZSA9PT0gbmFtZSkpO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGRlbGV0ZUZvbGRlckFuZENvbnRlbnRzKGZvbGRlcklkOiBzdHJpbmcpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBzdWJmb2xkZXJzIGFuZCByb3dzIHJlY3Vyc2l2ZWx5XG4gICAgICAgIGNvbnN0IHN1YmZvbGRlcnMgPSB0aGlzLmRhdGEuZm9sZGVycy5maWx0ZXIoZiA9PiBmLnBhcmVudElkID09PSBmb2xkZXJJZCk7XG4gICAgICAgIHN1YmZvbGRlcnMuZm9yRWFjaChmID0+IHRoaXMuZGVsZXRlRm9sZGVyQW5kQ29udGVudHMoZi5pZCkpO1xuXG4gICAgICAgIC8vIENhbGwgb25Sb3dEZWxldGVkQ2IgZm9yIGVhY2ggcm93IGluIHRoaXMgZm9sZGVyXG4gICAgICAgIGNvbnN0IHJvd3NUb0RlbGV0ZSA9IHRoaXMuZGF0YS5yb3dzLmZpbHRlcihyID0+IHIuZm9sZGVySWQgPT09IGZvbGRlcklkKTtcbiAgICAgICAgcm93c1RvRGVsZXRlLmZvckVhY2gocm93ID0+IHRoaXMub25Sb3dEZWxldGVkQ2Iocm93KSk7XG5cbiAgICAgICAgdGhpcy5kYXRhLmZvbGRlcnMgPSB0aGlzLmRhdGEuZm9sZGVycy5maWx0ZXIoZiA9PiBmLmlkICE9PSBmb2xkZXJJZCk7XG4gICAgICAgIHRoaXMuZGF0YS5yb3dzID0gdGhpcy5kYXRhLnJvd3MuZmlsdGVyKHIgPT4gci5mb2xkZXJJZCAhPT0gZm9sZGVySWQpO1xuICAgIH1cbn0iLCAiXHJcbmltcG9ydCB7IE1vZGFsLCBNYXJrZG93blJlbmRlcmVyLCBBcHAgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHsgRVJST1IsIGxvZ2dlciB9IGZyb20gXCIuL0xvZ1wiO1xyXG5cclxuZXhwb3J0IGNsYXNzIE1hcmtkb3duSGVscE1vZGFsIGV4dGVuZHMgTW9kYWwge1xyXG4gICAgbWFya2Rvd246IHN0cmluZyA9IFwiXCI7XHJcbiAgICBzb3VyY2VQYXRoOiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgYXBwOiBBcHA7XHJcbiAgICBwbHVnaW46IGFueTtcclxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IGFueSwgbWFya2Rvd246IHN0cmluZywgc291cmNlUGF0aDogc3RyaW5nKSB7XHJcbiAgICAgICAgc3VwZXIoYXBwKTtcclxuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcclxuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuICAgICAgICB0aGlzLm1hcmtkb3duID0gbWFya2Rvd247XHJcbiAgICAgICAgdGhpcy5zb3VyY2VQYXRoID0gc291cmNlUGF0aDtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uT3BlbigpIHtcclxuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCwgbW9kYWxFbCB9ID0gdGhpcztcclxuICAgICAgICBtb2RhbEVsLmFkZENsYXNzKFwiRk1BLW1hcmtkb3duLWhlbHAtbW9kYWwtLXdpZGVcIik7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy5tYXJrZG93biA9IGF3YWl0IHRoaXMucmVhZFBsdWdpbkRvY0ZpbGUodGhpcy5zb3VyY2VQYXRoKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBsb2dnZXIubG9nKEVSUk9SLFwiRXJyb3IgbG9hZGluZyBtYXJrZG93bjpcIiwgZXJyb3IpO1xyXG4gICAgICAgICAgICB0aGlzLm1hcmtkb3duID0gXCJDb3VsZCBub3QgbG9hZCBkb2N1bWVudGF0aW9uIGZpbGU6IFwiICsgdGhpcy5zb3VyY2VQYXRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb250ZW50RWwuZW1wdHkoKTtcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgYXdhaXQgTWFya2Rvd25SZW5kZXJlci5yZW5kZXIodGhpcy5hcHAsIHRoaXMubWFya2Rvd24sIGNvbnRlbnRFbCwgdGhpcy5zb3VyY2VQYXRoLCB0aGlzKTtcclxuXHJcbiAgICAgICAgY29udGVudEVsLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBhc3luYyAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQudGFnTmFtZSA9PT0gXCJBXCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGhyZWYgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChocmVmICYmIGhyZWYuZW5kc1dpdGgoXCIubWRcIikgJiYgIWhyZWYubWF0Y2goL15odHRwcz86XFwvXFwvLykgJiYgIWhyZWYuc3RhcnRzV2l0aChcIi9cIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwbHVnaW5JZCA9IHRoaXMucGx1Z2luLm1hbmlmZXN0LmlkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgLm9ic2lkaWFuL3BsdWdpbnMvJHtwbHVnaW5JZH0vZG9jLyBmcm9tIHNvdXJjZVBhdGggdG8gZ2V0IHJlbGF0aXZlIGRpclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkb2NSb290ID0gYC5vYnNpZGlhbi9wbHVnaW5zLyR7cGx1Z2luSWR9L2RvYy9gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVsYXRpdmVTb3VyY2UgPSB0aGlzLnNvdXJjZVBhdGguc3RhcnRzV2l0aChkb2NSb290KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnNvdXJjZVBhdGguc2xpY2UoZG9jUm9vdC5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuc291cmNlUGF0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnREaXIgPSByZWxhdGl2ZVNvdXJjZS5zcGxpdChcIi9cIikuc2xpY2UoMCwgLTEpLmpvaW4oXCIvXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzb2x2ZWRQYXRoID0gKGN1cnJlbnREaXIgPyBjdXJyZW50RGlyICsgXCIvXCIgOiBcIlwiKSArIGhyZWY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vcm1hbGl6ZTogcmVtb3ZlIGFueSAnLi8nIG9yICcuLi8nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiByZXNvbHZlZFBhdGguc3BsaXQoXCIvXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydCA9PT0gXCIuLlwiKSBwYXJ0cy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnQgIT09IFwiLlwiICYmIHBhcnQgIT09IFwiXCIpIHBhcnRzLnB1c2gocGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRQYXRoID0gcGFydHMuam9pbihcIi9cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdyByZXNvbHZlZFBhdGggaXMgcmVsYXRpdmUgdG8gZG9jUm9vdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdNYXJrZG93biA9IGF3YWl0IHRoaXMucmVhZFBsdWdpbkRvY0ZpbGUocmVzb2x2ZWRQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXJrZG93biA9IG5ld01hcmtkb3duO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZVBhdGggPSBkb2NSb290ICsgcmVzb2x2ZWRQYXRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWwuZW1wdHkoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBNYXJrZG93blJlbmRlcmVyLnJlbmRlcih0aGlzLmFwcCwgdGhpcy5tYXJrZG93biwgY29udGVudEVsLCB0aGlzLnNvdXJjZVBhdGgsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsLmVtcHR5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IFwiQ291bGQgbm90IGxvYWQ6IFwiICsgaHJlZiB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBmZXRjaE1hcmtkb3duRnJvbUdpdEh1Yih1cmw6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xyXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBsb2FkIGZpbGUgZnJvbSBHaXRIdWJcIik7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyByZWFkUGx1Z2luRG9jRmlsZShmaWxlbmFtZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICAgICAgICBjb25zdCBwbHVnaW5JZCA9IHRoaXMucGx1Z2luLm1hbmlmZXN0LmlkO1xyXG4gICAgICAgIC8vIEVuc3VyZSBubyBsZWFkaW5nIHNsYXNoIGluIGZpbGVuYW1lXHJcbiAgICAgICAgY29uc3QgY2xlYW5GaWxlbmFtZSA9IGZpbGVuYW1lLnJlcGxhY2UoL15cXC8rLywgXCJcIik7XHJcbiAgICAgICAgY29uc3QgZmlsZVBhdGggPSBgLm9ic2lkaWFuL3BsdWdpbnMvJHtwbHVnaW5JZH0vZG9jLyR7Y2xlYW5GaWxlbmFtZX1gO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLnJlYWQoZmlsZVBhdGgpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcmVhZCBmaWxlICcke2ZpbGVQYXRofSc6ICR7bWVzc2FnZX1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEFwcCwgU2V0dGluZywgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBBIHJ1bGUgY2xhc3MgdGhhdCBhZGRzIGEgY29uZmlndXJhYmxlIHByZWZpeCB0byBhbiBpbnB1dCB2YWx1ZS5cclxuICogXHJcbiAqIEByZW1hcmtzXHJcbiAqIFRoaXMgcnVsZSBpcyBpbnRlbmRlZCBmb3IgdXNlIGluIGZvcm1hdHRpbmcgb3BlcmF0aW9ucywgc3VjaCBhcyBhZGRpbmcgYSBwcmVmaXggdG8gdGV4dCwgdGFncywgYWxpYXNlcywgb3IgbXVsdGktdGV4dCBmaWVsZHMuXHJcbiAqIFRoZSBwcmVmaXggdmFsdWUgaXMgY29uZmlndXJhYmxlIHZpYSB0aGUgcGx1Z2luJ3Mgc2V0dGluZ3MgVUkuXHJcbiAqIFxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBVc2FnZSBpbiBhIGZvcm1hdHRpbmcgcGlwZWxpbmU6XHJcbiAqIGNvbnN0IHJlc3VsdCA9IHJ1bGVBZGRQcmVmaXguZngoYXBwLCBmaWxlLCB0b29scywgXCJleGFtcGxlXCIpO1xyXG4gKiAvLyBJZiBwcmVmaXggaXMgc2V0IHRvIFwicHJlLVwiLCByZXN1bHQgd2lsbCBiZSBcInByZS1leGFtcGxlXCJcclxuICogXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHJ1bGUgKCdhZGRQcmVmaXgnKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgZGlzcGxheSBuYW1lIGZvciB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uIC0gQSBzaG9ydCBkZXNjcmlwdGlvbiBvZiB3aGF0IHRoZSBydWxlIGRvZXMuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBydWxlVHlwZSAtIFRoZSB0eXBlIG9mIHJ1bGUgKCdmb3JtYXR0ZXInKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZSAtIFRoZSBzb3VyY2UgY29kZSBmb3IgdGhlIHJ1bGUgYXMgYSBzdHJpbmcuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHR5cGUgLSBUaGUgdHlwZXMgb2YgZmllbGRzIHRoaXMgcnVsZSBjYW4gYmUgYXBwbGllZCB0by5cclxuICogQHByb3BlcnR5IHthbnl9IGNvbmZpZ0VsZW1lbnRzIC0gVGhlIGNvbmZpZ3VyYXRpb24gZWxlbWVudHMgZm9yIHRoZSBydWxlLlxyXG4gKiBcclxuICogQG1ldGhvZCBmeFxyXG4gKiBBZGRzIHRoZSBjb25maWd1cmVkIHByZWZpeCB0byB0aGUgcHJvdmlkZWQgaW5wdXQgdmFsdWUuXHJcbiAqIFxyXG4gKiBAbWV0aG9kIGNvbmZpZ1RhYlxyXG4gKiBSZW5kZXJzIHRoZSBjb25maWd1cmF0aW9uIFVJIGZvciBzZXR0aW5nIHRoZSBwcmVmaXggdmFsdWUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZUFkZFByZWZpeCBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlkID0gJ2FkZFByZWZpeCc7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ0FkZCBhIFByZWZpeCc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdBZGRzIGEgcHJlZml4IHRvIHRoZSBpbnB1dCB2YWx1ZS4nO1xyXG4gICAgICAgIHRoaXMucnVsZVR5cGUgPSAnZm9ybWF0dGVyJztcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBsZXQgcmVzdWx0ID0gJyc7XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIjtcclxuICAgICAgICB0aGlzLnR5cGUgPSBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddO1xyXG4gICAgICAgIHRoaXMuY29uZmlnRWxlbWVudHMgPSB0aGlzLmRlZmF1bHRDb25maWdFbGVtZW50cyh7fSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IGFueSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzLCBpbnB1dD86YW55KSB7IC8vIERlZmF1bHQgZnVuY3Rpb24gc2lnbmF0dXJlXHJcbiAgICAgICAgY29uc3QgcHJlZml4ID0gdG9vbHMuZ2V0T3B0aW9uQ29uZmlnKHRvb2xzLmdldFJ1bGUoKT8uaWQsICdwcmVmaXgnKTtcclxuICAgICAgICByZXR1cm4gYCR7cHJlZml4fSR7aW5wdXR9YDsgLy8gUmV0dXJuIHRoZSBpbnB1dCB3aXRoIGEgcHJlZml4IGFkZGVkXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbmZpZ1RhYihvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIHRoYXQ6IGFueSwgcHJldmlld0NvbXBvbmVudDogYW55KSB7XHJcbiAgICAgICAgb3B0aW9uRUwuZW1wdHkoKTtcclxuICAgICAgICAvLyBDcmVhdGUgYSBzZXR0aW5nIGZvciB0aGUgc21hbGwgd29yZHNcclxuICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZ0RlZmF1bHRzKHJ1bGUuaWQsIHtcclxuICAgICAgICAgICAgcHJlZml4IDogJycsIC8vIERlZmF1bHQgcHJlZml4XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgbmV3IFNldHRpbmcob3B0aW9uRUwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdQcmVmaXgnKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnRW50ZXIgYSBwcmVmaXggdG8gYmUgYWRkZWQgYXQgdGhlIGJlZ2lubmluZy4nKVxyXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignZS5nLiBcInByZS1cIicpXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhhdC5nZXRPcHRpb25Db25maWcocnVsZS5pZCAsJ3ByZWZpeCcpIHx8ICcnKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQsJ3ByZWZpeCcsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZVByZXZpZXcocnVsZSwgcHJldmlld0NvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgfTtcclxufSIsICJpbXBvcnQgeyBSdWxlUHJvdG90eXBlLCBydWxlc01hbmFnZXIgfSBmcm9tIFwiLi9ydWxlc1wiO1xyXG5pbXBvcnQgeyBTY3JpcHRpbmdUb29scyB9IGZyb20gXCIuLi90b29sc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFNldHRpbmcsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MgfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuXHJcbi8qKlxyXG4gKiBBIHJ1bGUgY2xhc3MgdGhhdCBhcHBlbmRzIGEgY29uZmlndXJhYmxlIHN1ZmZpeCB0byB0aGUgaW5wdXQgdmFsdWUuXHJcbiAqIFxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUaGlzIHJ1bGUgaXMgaW50ZW5kZWQgZm9yIHVzZSB3aXRoaW4gdGhlIEZvbGRlciB0byBUYWdzIHBsdWdpbiwgYWxsb3dpbmcgdXNlcnMgdG8gZm9ybWF0IHRleHQsIHRhZ3MsIGFsaWFzZXMsIG9yIG11bHRpdGV4dCBmaWVsZHMgYnkgYWRkaW5nIGEgc3BlY2lmaWVkIHN1ZmZpeC5cclxuICogXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICogXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIFVzYWdlIGluIGEgcnVsZSBjaGFpblxyXG4gKiBjb25zdCByZXN1bHQgPSBydWxlQWRkU3VmZml4LmZ4KGFwcCwgZmlsZSwgdG9vbHMsIFwibm90ZVwiKTtcclxuICogLy8gSWYgc3VmZml4IGlzIFwiX2RvbmVcIiwgcmVzdWx0IHdpbGwgYmUgXCJub3RlX2RvbmVcIlxyXG4gKiBcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcnVsZSAoXCJhZGRTdWZmaXhcIikuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIGRpc3BsYXkgbmFtZSBmb3IgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXNjcmlwdGlvbiAtIEEgYnJpZWYgZGVzY3JpcHRpb24gb2YgdGhlIHJ1bGUncyBwdXJwb3NlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcnVsZVR5cGUgLSBUaGUgdHlwZSBvZiBydWxlIChcImZvcm1hdHRlclwiKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZSAtIFRoZSBzb3VyY2UgY29kZSBmb3IgdGhlIHJ1bGUgYXMgYSBzdHJpbmcuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHR5cGUgLSBUaGUgdHlwZXMgb2YgZmllbGRzIHRoaXMgcnVsZSBjYW4gYmUgYXBwbGllZCB0by5cclxuICogQHByb3BlcnR5IHthbnl9IGNvbmZpZ0VsZW1lbnRzIC0gVGhlIGNvbmZpZ3VyYXRpb24gZWxlbWVudHMgZm9yIHRoZSBydWxlLlxyXG4gKiBcclxuICogQG1ldGhvZCBmeFxyXG4gKiBBcHBlbmRzIHRoZSBjb25maWd1cmVkIHN1ZmZpeCB0byB0aGUgcHJvdmlkZWQgaW5wdXQgdmFsdWUuXHJcbiAqIFxyXG4gKiBAbWV0aG9kIGNvbmZpZ1RhYlxyXG4gKiBSZW5kZXJzIHRoZSBjb25maWd1cmF0aW9uIFVJIGZvciBzZXR0aW5nIHRoZSBzdWZmaXggaW4gdGhlIHBsdWdpbidzIHNldHRpbmdzIHRhYi5cclxuICogXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZUFkZFN1ZmZpeCBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlkID0gJ2FkZFN1ZmZpeCc7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ0FkZCBhIFN1ZmZpeCc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdBZGRzIGEgc3VmZml4IHRvIHRoZSBpbnB1dCB2YWx1ZS4nO1xyXG4gICAgICAgIHRoaXMucnVsZVR5cGUgPSAnZm9ybWF0dGVyJztcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBsZXQgcmVzdWx0ID0gJyc7XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIjtcclxuICAgICAgICB0aGlzLnR5cGUgPSBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddO1xyXG4gICAgICAgIHRoaXMuY29uZmlnRWxlbWVudHMgPSB0aGlzLmRlZmF1bHRDb25maWdFbGVtZW50cyh7fSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IGFueSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzLCBpbnB1dD86YW55KSB7IC8vIERlZmF1bHQgZnVuY3Rpb24gc2lnbmF0dXJlXHJcbiAgICAgICAgY29uc3Qgc3VmZml4ID0gdG9vbHMuZ2V0T3B0aW9uQ29uZmlnKHRvb2xzLmdldFJ1bGUoKT8uaWQsICdzdWZmaXgnKTtcclxuICAgICAgICByZXR1cm4gYCR7aW5wdXR9JHtzdWZmaXh9YDsgLy8gUmV0dXJuIHRoZSBpbnB1dCB3aXRoIGEgc3VmZml4IGFkZGVkXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbmZpZ1RhYihvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIHRoYXQ6IGFueSwgcHJldmlld0NvbXBvbmVudDogYW55KSB7XHJcbiAgICAgICAgb3B0aW9uRUwuZW1wdHkoKTtcclxuICAgICAgICAvLyBDcmVhdGUgYSBzZXR0aW5nIGZvciB0aGUgc21hbGwgd29yZHNcclxuICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZ0RlZmF1bHRzKHJ1bGUuaWQsIHtcclxuICAgICAgICAgICAgc3VmZml4IDogJycsIC8vIERlZmF1bHQgc3VmZml4XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgbmV3IFNldHRpbmcob3B0aW9uRUwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdTdWZmaXgnKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnRW50ZXIgYSBzdWZmaXggdG8gYmUgYWRkZWQgYXQgdGhlIGVuZC4nKVxyXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignZS5nLiBcIl9kb25lXCInKVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoYXQuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQgLCdzdWZmaXgnKSB8fCAnJylcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZyhydWxlLmlkLCdzdWZmaXgnLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC51cGRhdGVQcmV2aWV3KHJ1bGUsIHByZXZpZXdDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgIH07XHJcbn0iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFNlYXJjaENvbXBvbmVudCwgU2V0dGluZywgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHsgRm9sZGVyU3VnZ2VzdCB9IGZyb20gXCIuLi9zdWdnZXN0ZXJzL0ZvbGRlclN1Z2dlc3RlclwiO1xyXG5pbXBvcnQgeyBEaXJlY3RvcnlTZWxlY3Rpb25SZXN1bHQsIG9wZW5EaXJlY3RvcnlTZWxlY3Rpb25Nb2RhbCB9IGZyb20gXCIuLi9kaXJlY3RvcnlTZWxlY3Rpb25Nb2RhbFwiO1xyXG5pbXBvcnQgeyBGaWxlU3VnZ2VzdCB9IGZyb20gXCIuLi9zdWdnZXN0ZXJzL0ZpbGVTdWdnZXN0ZXJcIjtcclxuaW1wb3J0IHsgQWxlcnRNb2RhbCB9IGZyb20gXCIuLi9hbGVydEJveFwiO1xyXG5pbXBvcnQgeyBERUJVRywgRVJST1IsIGxvZ2dlciwgVFJBQ0UgfSBmcm9tIFwiLi4vTG9nXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgUnVsZUF1dG9tYXRpb25BdXRvTGluayBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlkID0gJ2F1dG9MaW5rJztcclxuICAgICAgICB0aGlzLm5hbWUgPSAnQXV0byBMaW5rIChhZHZhbmNlZCknO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnQ2hlY2tzIGlmIGEgbGluayBleGlzdHMgaW4gYSBzcGVjaWZpZWQgZm9sZGVyLiBJZiBub3QsIGl0IGNyZWF0ZXMgYSBuZXcgZmlsZSBiYXNlZCBvbiBhIHNwZWNpZmllZCB0ZW1wbGF0ZSBhbmQgYWRkcyBhIGxpbmsgdG8gaXQuJztcclxuICAgICAgICB0aGlzLnJ1bGVUeXBlID0gJ2F1dG9tYXRpb24nO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIGxldCByZXN1bHQgPSAnJztcXG4gIHJldHVybiByZXN1bHQ7XFxufVwiO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICdtdWx0aXRleHQnXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe3JlbW92ZUNvbnRlbnQ6IGZhbHNlLCAgaW5wdXRQcm9wZXJ0eTogZmFsc2UsIGFkZFByZWZpeDogZmFsc2UsIHNwYWNlUmVwbGFjZW1lbnQ6IGZhbHNlLCBzcGVjaWFsQ2hhcmFjdGVyUmVwbGFjZW1lbnQ6IGZhbHNlLCBjb252ZXJ0VG9Mb3dlckNhc2U6IGZhbHNlLCByZXN1bHRBc0xpbms6IGZhbHNlLCBzY3JpcHQ6IGZhbHNlfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGFzeW5jIGNyZWF0ZU5ld0ZpbGUgKGFwcDogQXBwLCBmaWxlOiBURmlsZSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIHRvIGNyZWF0ZSBhIGxpbmsgdG8gYSBmaWxlLiBJZiB0aGUgZmlsZSBkb2VzIG5vdCBleGlzdCwgaXQgY3JlYXRlcyBhIG5ldyBmaWxlIGJhc2VkIG9uIGEgdGVtcGxhdGUuXHJcbiAgICAgKiBAcGFyYW0gYXBwIC0gVGhlIE9ic2lkaWFuIGFwcCBpbnN0YW5jZS5cclxuICAgICAqIEBwYXJhbSBmaWxlIC0gVGhlIGN1cnJlbnQgZmlsZS5cclxuICAgICAqIEBwYXJhbSB0b29scyAtIFRoZSBzY3JpcHRpbmcgdG9vbHMgaW5zdGFuY2UuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3IGNvbnRlbnQgZm9yIHRoZSBmcm9udG1hdHRlciBwcm9wZXJ0eS5cclxuICAgICAqL1xyXG4gICAgZnggKGFwcDpBcHAsIGZpbGU6VEZpbGUsIHRvb2xzOlNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRDb250ZW50ID0gdG9vbHMuZ2V0Q3VycmVudENvbnRlbnQoKTtcclxuICAgICAgICBsZXQgbmV3Q29udGVudCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XHJcbiAgICAgICAgY29uc3QgcnVsZSA9IHRvb2xzLmdldFJ1bGUoKTtcclxuICAgICAgICBpZiAoIXJ1bGUpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmxvZyhFUlJPUixgYXV0b0xpbms6IHJ1bGUgbm90IGZvdW5kLCByZXR1cm5pbmcgY3VycmVudCBjb250ZW50ICR7Y3VycmVudENvbnRlbnR9YCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50Q29udGVudDtcclxuICAgICAgICB9IFxyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0b29scy5nZXRPcHRpb25Db25maWcocnVsZS5pZCk7XHJcbiAgICAgICAgY29uc3QgZmlsZXNUb0NoZWNrID0gdG9vbHMuZ2V0RmlsZXNJblZhdWx0KG9wdGlvbnMuZGVzdGluYXRpb25Gb2xkZXIpO1xyXG4gICAgICAgIGxldCBsaW5rcyA9IGN1cnJlbnRDb250ZW50IHx8IFtdO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbGlua3MgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGxpbmtzKSkge1xyXG4gICAgICAgICAgICBsaW5rcyA9IFtdOyAvLyBjb252ZXJ0IG9iamVjdCB0byBhcnJheVxyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpbmtzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBsaW5rcyA9IFtsaW5rc107IC8vIGNvbnZlcnQgdG8gYXJyYXkgaWYgbm90IGFscmVhZHkgYW4gYXJyYXlcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbG9nZ2VyLmxvZyhERUJVRyxgYXV0b0xpbms6IGxpbmtzIHRvIGNoZWNrYCwgbGlua3MsIGZpbGVzVG9DaGVjayk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIGxpbmtzKSAge1xyXG4gICAgICAgICAgICBsZXQgbGluayA9IHRvb2xzLmV4dHJhY3RMaW5rUGFydHMocGFydCk7XHJcbiAgICAgICAgICAgIGxldCBsaW5rRmlsZSA9IHRvb2xzLmdldFRGaWxlRnJvbVBhdGgobGluay5wYXRoLCBmaWxlc1RvQ2hlY2spO1xyXG4gICAgICAgICAgICBpZiAoIWxpbmtGaWxlKSB7IC8vIGNyZWF0ZSBuZXcgRmlsZVxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXNrQ29uZmlybWF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IEFsZXJ0TW9kYWwoYXBwLCAnQ3JlYXRlIG5ldyBmaWxlJywgYEZpbGUgJHtsaW5rLnBhdGh9IGRvZXMgbm90IGV4aXN0LiBEbyB5b3Ugd2FudCB0byBjcmVhdGUgaXQ/YCwgJ0NyZWF0ZScsICdDYW5jZWwnLCBcIkRvbid0IGFzayBhZ2Fpbi5cIikub3BlbkFuZEdldFZhbHVlKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgKHJlc3VsdDogeyBwcm9jZWVkOiBib29sZWFuLCBkYXRhOiB7IGFza0NvbmZpcm1hdGlvbjogYm9vbGVhbiB9IH0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coREVCVUcsYGF1dG9MaW5rOiB1c2VyIGNvbmZpcm1lZCB0byBjcmVhdGUgbmV3IGZpbGUgXCIke2xpbmsucGF0aH1cImAsIHJlc3VsdCk7IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHJldHVybjsgLy8gdXNlciBjYW5jZWxsZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LnByb2NlZWQpIHJldHVybjsgLy8gZG8gbm90IGNyZWF0ZSB0aGUgZmlsZSBpZiB0aGUgdXNlciBkb2VzIG5vdCBjb25maXJtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmFza0NvbmZpcm1hdGlvbiA9ICFyZXN1bHQuZGF0YS5hc2tDb25maXJtYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rLnBhdGggPSBvcHRpb25zLmRlc3RpbmF0aW9uRm9sZGVyICsgJy8nICsgbGluay50aXRsZSArICcubWQnOyAvLyBhZGQgdGhlIGRlc3RpbmF0aW9uIGZvbGRlciB0byB0aGUgbGluayBwYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rRmlsZSA9IGF3YWl0IHRvb2xzLmNyZWF0ZUZpbGVGcm9tUGF0aChsaW5rLnBhdGgsIG9wdGlvbnMuYWRkVGVtcGxhdGUgPyBvcHRpb25zLnRlbXBsYXRlRmlsZSA6IHVuZGVmaW5lZCk7IC8vIGNyZWF0ZSB0aGUgZmlsZSBpZiBpdCBkb2VzIG5vdCBleGlzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29udGVudC5wdXNoKGBbWyR7dG9vbHMucmVtb3ZlTGVhZGluZ1NsYXNoKGxpbmsucGF0aCl9fCR7bGluay50aXRsZX1dXWApOyAvLyBhZGQgdGhlIGZpbGUgcGF0aCB0byB0aGUgbmV3IGNvbnRlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coREVCVUcsYGF1dG9MaW5rOiByZXR1cm5pbmcgKGFmdGVyIGFza0NvbmZpcm1hdGlvbikgXCIke25ld0NvbnRlbnR9XCJgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdDb250ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBsaW5rLnBhdGggPSBvcHRpb25zLmRlc3RpbmF0aW9uRm9sZGVyICsgJy8nICsgbGluay50aXRsZSArICcubWQnOyAvLyBhZGQgdGhlIGRlc3RpbmF0aW9uIGZvbGRlciB0byB0aGUgbGluayBwYXRoXHJcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFRSQUNFLGBhdXRvTGluazogY3JlYXRpbmcgbmV3IGZpbGUgXCIke2xpbmsucGF0aH1cImApO1xyXG4gICAgICAgICAgICAgICAgdG9vbHMuY3JlYXRlRmlsZUZyb21QYXRoKGxpbmsucGF0aCwgb3B0aW9ucy5hZGRUZW1wbGF0ZSA/IG9wdGlvbnMudGVtcGxhdGVGaWxlIDogdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChuZXdGaWxlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbnRlbnQucHVzaChgW1ske3Rvb2xzLnJlbW92ZUxlYWRpbmdTbGFzaChuZXdGaWxlLnBhdGgpfXwke25ld0ZpbGUubmFtZX1dXWApOyAvLyBhZGQgdGhlIGZpbGUgcGF0aCB0byB0aGUgbmV3IGNvbnRlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhERUJVRyxgYXV0b0xpbms6IG5ldyBmaWxlIGNyZWF0ZWQgXCIke25ld0ZpbGUucGF0aH1cIiByZXR1cm5pbmcgXCIke25ld0NvbnRlbnR9XCJgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0NvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxpbmtGaWxlKSB7XHJcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKERFQlVHLGBhdXRvTGluazogY3JlYXRpbmcgTGluayB0byBleGlzdGluZyBGaWxlIFwiJHtsaW5rRmlsZS5wYXRofVwiYCk7XHJcbiAgICAgICAgICAgICAgICBsaW5rLnBhdGggPSBsaW5rRmlsZS5wYXRoO1xyXG4gICAgICAgICAgICAgICAgbmV3Q29udGVudC5wdXNoKGBbWyR7dG9vbHMucmVtb3ZlTGVhZGluZ1NsYXNoKGxpbmsucGF0aCl9fCR7bGluay50aXRsZX1dXWApOyAvLyBhZGQgdGhlIGZpbGUgcGF0aCB0byB0aGUgbmV3IGNvbnRlbnRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsb2dnZXIubG9nKERFQlVHLGBhdXRvTGluazogcmV0dXJuaW5nIFwiJHtuZXdDb250ZW50fVwiYCk7XHJcbiAgICAgICAgcmV0dXJuIG5ld0NvbnRlbnQ7ICAgIFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25maWdUYWIgKG9wdGlvbkVMOiBIVE1MRWxlbWVudCwgcnVsZTpGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCB0aGF0OmFueSwgcHJldmlld0NvbXBvbmVudDogYW55KSB7XHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgc2V0dGluZyBmb3IgdGhlIGF1dG8gbGlua1xyXG4gICAgICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnRGVmYXVsdHMocnVsZS5pZCwge1xyXG4gICAgICAgICAgICBhZGRUZW1wbGF0ZTogdHJ1ZSxcclxuICAgICAgICAgICAgYXNrQ29uZmlybWF0aW9uOiB0cnVlLFxyXG4gICAgICAgICAgICBkZXN0aW5hdGlvbkZvbGRlcjogJy8nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZUZpbGU6ICcnLFxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnQWRkIHRlbXBsYXRlIHRvIG5ldyBmaWxlcycpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdBdXRvbWF0aWNhbGx5IGFkZCB0ZW1wbGF0ZSB0byBuZXcgZmlsZXMnKVxyXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGF0LmdldE9wdGlvbkNvbmZpZyhydWxlLmlkICwnYWRkVGVtcGxhdGUnKSB8fCBmYWxzZSlcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZyhydWxlLmlkLCdhZGRUZW1wbGF0ZScsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgbmV3IFNldHRpbmcob3B0aW9uRUwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdBc2sgZm9yIGNvbmZpcm1hdGlvbicpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdBc2sgZm9yIGNvbmZpcm1hdGlvbiBiZWZvcmUgY3JlYXRpbmcgbmV3IGZpbGVzJylcclxuICAgICAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhhdC5nZXRPcHRpb25Db25maWcocnVsZS5pZCAsJ2Fza0NvbmZpcm1hdGlvbicpIHx8IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQsJ2Fza0NvbmZpcm1hdGlvbicsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgbGV0IGRlc3RpbmF0aW9uRm9sZGVyRWw6U2VhcmNoQ29tcG9uZW50OyAgXHJcbiAgICAgICAgbmV3IFNldHRpbmcob3B0aW9uRUwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdEZXN0aW5hdGlvbiBGb2xkZXInKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnRm9sZGVyIHRvIHBsYWNlIG5ldyBmaWxlcycpXHJcbiAgICAgICAgICAgIC5hZGRTZWFyY2goKGNiKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbkZvbGRlckVsID0gY2I7XHJcbiAgICAgICAgICAgICAgICBuZXcgRm9sZGVyU3VnZ2VzdCh0aGF0LmFwcCwgY2IuaW5wdXRFbCk7XHJcbiAgICAgICAgICAgICAgICBjYi5zZXRQbGFjZWhvbGRlcihcImVudGVyIGZvbGRlciBvciBicm93c2UgLi4uXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoYXQuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQgLCdkZXN0aW5hdGlvbkZvbGRlcicpIHx8ICcnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZSgobmV3Rm9sZGVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0ZvbGRlciA9IG5ld0ZvbGRlci50cmltKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Rm9sZGVyID0gbmV3Rm9sZGVyLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWcocnVsZS5pZCwnZGVzdGluYXRpb25Gb2xkZXInLCBuZXdGb2xkZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICAgICAgY2IuY29udGFpbmVyRWwuYWRkQ2xhc3MoXCJmcm9udG1hdHRlci1hdXRvbWF0ZS1zZWFyY2hcIik7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hZGRFeHRyYUJ1dHRvbigoYnV0dG9uKSA9PlxyXG4gICAgICAgICAgICBidXR0b25cclxuICAgICAgICAgICAgICAgIC5zZXRJY29uKCdmb2xkZXItdHJlZScpXHJcbiAgICAgICAgICAgICAgICAuc2V0VG9vbHRpcCgnU2VsZWN0IHRlbXBsYXRlIGZvbGRlcicpXHJcbiAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBvcGVuRGlyZWN0b3J5U2VsZWN0aW9uTW9kYWwoXHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5hcHAsXHJcbiAgICAgICAgICAgICAgICAgICAgW3RoYXQuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQgLCdkZXN0aW5hdGlvbkZvbGRlcicpXSxcclxuICAgICAgICAgICAgICAgICAgICBbXSxcclxuICAgICAgICAgICAgICAgICAgICB7IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1NlbGVjdCBmb2xkZXIgdG8gcGxhY2UgbmV3IGZpbGVzJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uTW9kZTogJ2luY2x1ZGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TW9kZTogJ2ZvbGRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvblNlbGVjdGlvbk1vZGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25TaG93RmlsZXM6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdDogRGlyZWN0b3J5U2VsZWN0aW9uUmVzdWx0IHwgbnVsbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmZvbGRlcnMubGVuZ3RoID09PSAwIHx8ICFyZXN1bHQuZm9sZGVyc1swXSB8fCB0eXBlb2YgcmVzdWx0LmZvbGRlcnNbMF0gIT09ICdzdHJpbmcnKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzZWxlY3RlZEZvbGRlciA9IHJlc3VsdC5mb2xkZXJzWzBdLnRyaW0oKS5yZXBsYWNlKC9cXC8kLywgXCJcIik7IC8vIHJlbW92ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzICgvXlxcL3xcXC8kL2csIFwiXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZEZvbGRlciA9PT0gJycpIHNlbGVjdGVkRm9sZGVyID0gJy8nOyAvLyBpZiBlbXB0eSwgc2V0IHRvIHJvb3QgZm9sZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VsZWN0ZWRGb2xkZXIpIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25Gb2xkZXJFbC5zZXRWYWx1ZShzZWxlY3RlZEZvbGRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQsJ2Rlc3RpbmF0aW9uRm9sZGVyJywgc2VsZWN0ZWRGb2xkZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGxldCBkZXN0aW5hdGlvbkZpbGVFbDpTZWFyY2hDb21wb25lbnQ7ICBcclxuICAgICAgICBuZXcgU2V0dGluZyhvcHRpb25FTClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ1RlbXBsYXRlIEZpbGUnKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnU2VsZWN0IGEgdGVtcGxhdGUgZmlsZSB0byBhZGQgdG8gbmV3IGZpbGVzJylcclxuICAgICAgICAgICAgLmFkZFNlYXJjaCgoY2IpID0+IHtcclxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uRmlsZUVsID0gY2I7XHJcbiAgICAgICAgICAgICAgICBuZXcgRmlsZVN1Z2dlc3QoY2IuaW5wdXRFbCwgdGhhdC5wbHVnaW4sICcnKTtcclxuICAgICAgICAgICAgICAgIGNiLnNldFBsYWNlaG9sZGVyKFwiZW50ZXIgZm9sZGVyIG9yIGJyb3dzZSAuLi5cIilcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhhdC5nZXRPcHRpb25Db25maWcocnVsZS5pZCAsJ3RlbXBsYXRlRmlsZScpIHx8ICcnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZSgobmV3RmlsZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdGaWxlID0gbmV3RmlsZS50cmltKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RmlsZSA9IG5ld0ZpbGUucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZyhydWxlLmlkLCd0ZW1wbGF0ZUZpbGUnLCBuZXdGaWxlKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgICAgIGNiLmNvbnRhaW5lckVsLmFkZENsYXNzKFwiZnJvbnRtYXR0ZXItYXV0b21hdGUtc2VhcmNoXCIpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYWRkRXh0cmFCdXR0b24oKGJ1dHRvbikgPT5cclxuICAgICAgICAgICAgICAgIGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgLnNldEljb24oJ2ZvbGRlci10cmVlJylcclxuICAgICAgICAgICAgICAgIC5zZXRUb29sdGlwKCdTZWxlY3QgdGVtcGxhdGUgZmlsZScpXHJcbiAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBvcGVuRGlyZWN0b3J5U2VsZWN0aW9uTW9kYWwoXHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5hcHAsXHJcbiAgICAgICAgICAgICAgICAgICAgW10sXHJcbiAgICAgICAgICAgICAgICAgICAgW3RoYXQuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQsJ3RlbXBsYXRlRmlsZScpXSxcclxuICAgICAgICAgICAgICAgICAgICB7IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1NlbGVjdCB0ZW1wbGF0ZSBmb3IgbmV3IGZpbGVzJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uTW9kZTogJ2luY2x1ZGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TW9kZTogJ2ZpbGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25TZWxlY3Rpb25Nb2RlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uU2hvd0ZpbGVzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdDogRGlyZWN0b3J5U2VsZWN0aW9uUmVzdWx0IHwgbnVsbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmZpbGVzLmxlbmd0aCA9PT0gMCB8fCAhcmVzdWx0LmZpbGVzWzBdIHx8IHR5cGVvZiByZXN1bHQuZmlsZXNbMF0gIT09ICdzdHJpbmcnKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzZWxlY3RlZEZpbGUgPSByZXN1bHQuZmlsZXNbMF0udHJpbSgpLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxlY3RlZEZpbGUpIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25GaWxlRWwuc2V0VmFsdWUoc2VsZWN0ZWRGaWxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWcocnVsZS5pZCwndGVtcGxhdGVGaWxlJywgc2VsZWN0ZWRGaWxlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG4iLCAiLy8gQ3JlZGl0cyBnbyB0byBMaWFtJ3MgUGVyaW9kaWMgTm90ZXMgUGx1Z2luOiBodHRwczovL2dpdGh1Yi5jb20vbGlhbWNhaW4vb2JzaWRpYW4tcGVyaW9kaWMtbm90ZXNcbi8vIGFuZCBUZW1wbGF0ZXIgcGx1Z2luOiBodHRwczovL2dpdGh1Yi5jb20vU2lsZW50Vm9pZDEzL1RlbXBsYXRlciB3aGVyZSBJIGdvdCB0aGUgY29kZSBmb3IgdGhlIHN1Z2dlc3RlcnNcblxuaW1wb3J0IHsgQXBwLCBUQWJzdHJhY3RGaWxlLCBURm9sZGVyIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBUZXh0SW5wdXRTdWdnZXN0IH0gZnJvbSBcIi4vc3VnZ2VzdFwiO1xuXG5leHBvcnQgY2xhc3MgRm9sZGVyU3VnZ2VzdCBleHRlbmRzIFRleHRJbnB1dFN1Z2dlc3Q8VEZvbGRlcj4ge1xuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBpbnB1dEVsOiBIVE1MSW5wdXRFbGVtZW50IHwgSFRNTFRleHRBcmVhRWxlbWVudCkge1xuICAgICAgICBzdXBlcihhcHAsIGlucHV0RWwpO1xuICAgIH1cblxuICAgIGdldFN1Z2dlc3Rpb25zKGlucHV0U3RyOiBzdHJpbmcpOiBURm9sZGVyW10ge1xuICAgICAgICBjb25zdCBhYnN0cmFjdEZpbGVzID0gdGhpcy5hcHAudmF1bHQuZ2V0QWxsTG9hZGVkRmlsZXMoKTtcbiAgICAgICAgY29uc3QgZm9sZGVyczogVEZvbGRlcltdID0gW107XG4gICAgICAgIGNvbnN0IGxvd2VyQ2FzZUlucHV0U3RyID0gaW5wdXRTdHIudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBhYnN0cmFjdEZpbGVzLmZvckVhY2goKGZvbGRlcjogVEFic3RyYWN0RmlsZSkgPT4ge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGZvbGRlciBpbnN0YW5jZW9mIFRGb2xkZXIgJiZcbiAgICAgICAgICAgICAgICBmb2xkZXIucGF0aC50b0xvd2VyQ2FzZSgpLmNvbnRhaW5zKGxvd2VyQ2FzZUlucHV0U3RyKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZm9sZGVycy5wdXNoKGZvbGRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmb2xkZXJzLnNsaWNlKDAsIDEwMDApO1xuICAgIH1cblxuICAgIHJlbmRlclN1Z2dlc3Rpb24oZmlsZTogVEZvbGRlciwgZWw6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgICAgIGVsLnNldFRleHQoZmlsZS5wYXRoLnJlcGxhY2UoL14oPyFcXC8pLywgXCIvXCIpKTtcbiAgICB9XG5cbiAgICBzZWxlY3RTdWdnZXN0aW9uKGZpbGU6IFRGb2xkZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5pbnB1dEVsLnZhbHVlID0gZmlsZS5wYXRoLnJlcGxhY2UoL14oPyFcXC8pLywgXCIvXCIpO1xuICAgICAgICB0aGlzLmlucHV0RWwudHJpZ2dlcihcImlucHV0XCIpO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxufVxuIiwgIi8vIENyZWRpdHMgZ28gdG8gTGlhbSdzIFBlcmlvZGljIE5vdGVzIFBsdWdpbjogaHR0cHM6Ly9naXRodWIuY29tL2xpYW1jYWluL29ic2lkaWFuLXBlcmlvZGljLW5vdGVzXG4vLyBhbmQgVGVtcGxhdGVyIHBsdWdpbjogaHR0cHM6Ly9naXRodWIuY29tL1NpbGVudFZvaWQxMy9UZW1wbGF0ZXIgd2hlcmUgSSBnb3QgdGhlIGNvZGUgZm9yIHRoZSBzdWdnZXN0ZXJzXG5cbmltcG9ydCB7IEFwcCwgSVN1Z2dlc3RPd25lciwgU2NvcGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IGNyZWF0ZVBvcHBlciwgSW5zdGFuY2UgYXMgUG9wcGVySW5zdGFuY2UgfSBmcm9tIFwiQHBvcHBlcmpzL2NvcmVcIjtcblxuY29uc3Qgd3JhcEFyb3VuZCA9ICh2YWx1ZTogbnVtYmVyLCBzaXplOiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICAgIHJldHVybiAoKHZhbHVlICUgc2l6ZSkgKyBzaXplKSAlIHNpemU7XG59O1xuXG5jbGFzcyBTdWdnZXN0PFQ+IHtcbiAgICBwcml2YXRlIG93bmVyOiBJU3VnZ2VzdE93bmVyPFQ+O1xuICAgIHByaXZhdGUgdmFsdWVzITogVFtdO1xuICAgIHByaXZhdGUgc3VnZ2VzdGlvbnMhOiBIVE1MRGl2RWxlbWVudFtdO1xuICAgIHByaXZhdGUgc2VsZWN0ZWRJdGVtITogbnVtYmVyO1xuICAgIHByaXZhdGUgY29udGFpbmVyRWw6IEhUTUxFbGVtZW50O1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIG93bmVyOiBJU3VnZ2VzdE93bmVyPFQ+LFxuICAgICAgICBjb250YWluZXJFbDogSFRNTEVsZW1lbnQsXG4gICAgICAgIHNjb3BlOiBTY29wZVxuICAgICkge1xuICAgICAgICB0aGlzLm93bmVyID0gb3duZXI7XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWwgPSBjb250YWluZXJFbDtcblxuICAgICAgICBjb250YWluZXJFbC5vbihcbiAgICAgICAgICAgIFwiY2xpY2tcIixcbiAgICAgICAgICAgIFwiLnN1Z2dlc3Rpb24taXRlbVwiLFxuICAgICAgICAgICAgdGhpcy5vblN1Z2dlc3Rpb25DbGljay5iaW5kKHRoaXMpXG4gICAgICAgICk7XG4gICAgICAgIGNvbnRhaW5lckVsLm9uKFxuICAgICAgICAgICAgXCJtb3VzZW1vdmVcIixcbiAgICAgICAgICAgIFwiLnN1Z2dlc3Rpb24taXRlbVwiLFxuICAgICAgICAgICAgdGhpcy5vblN1Z2dlc3Rpb25Nb3VzZW92ZXIuYmluZCh0aGlzKVxuICAgICAgICApO1xuXG4gICAgICAgIHNjb3BlLnJlZ2lzdGVyKFtdLCBcIkFycm93VXBcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50LmlzQ29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3RlZEl0ZW0odGhpcy5zZWxlY3RlZEl0ZW0gLSAxLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNjb3BlLnJlZ2lzdGVyKFtdLCBcIkFycm93RG93blwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICghZXZlbnQuaXNDb21wb3NpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGVkSXRlbSh0aGlzLnNlbGVjdGVkSXRlbSArIDEsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2NvcGUucmVnaXN0ZXIoW10sIFwiRW50ZXJcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50LmlzQ29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51c2VTZWxlY3RlZEl0ZW0oZXZlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb25TdWdnZXN0aW9uQ2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQsIGVsOiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLnN1Z2dlc3Rpb25zLmluZGV4T2YoZWwgYXMgSFRNTERpdkVsZW1lbnQpO1xuICAgICAgICB0aGlzLnNldFNlbGVjdGVkSXRlbShpdGVtLCBmYWxzZSk7XG4gICAgICAgIHRoaXMudXNlU2VsZWN0ZWRJdGVtKGV2ZW50KTtcbiAgICB9XG5cbiAgICBvblN1Z2dlc3Rpb25Nb3VzZW92ZXIoX2V2ZW50OiBNb3VzZUV2ZW50LCBlbDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuc3VnZ2VzdGlvbnMuaW5kZXhPZihlbCBhcyBIVE1MRGl2RWxlbWVudCk7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0ZWRJdGVtKGl0ZW0sIGZhbHNlKTtcbiAgICB9XG5cbiAgICBzZXRTdWdnZXN0aW9ucyh2YWx1ZXM6IFRbXSkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lckVsLmVtcHR5KCk7XG4gICAgICAgIGNvbnN0IHN1Z2dlc3Rpb25FbHM6IEhUTUxEaXZFbGVtZW50W10gPSBbXTtcblxuICAgICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN1Z2dlc3Rpb25FbCA9IHRoaXMuY29udGFpbmVyRWwuY3JlYXRlRGl2KFwic3VnZ2VzdGlvbi1pdGVtXCIpO1xuICAgICAgICAgICAgdGhpcy5vd25lci5yZW5kZXJTdWdnZXN0aW9uKHZhbHVlLCBzdWdnZXN0aW9uRWwpO1xuICAgICAgICAgICAgc3VnZ2VzdGlvbkVscy5wdXNoKHN1Z2dlc3Rpb25FbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgICB0aGlzLnN1Z2dlc3Rpb25zID0gc3VnZ2VzdGlvbkVscztcbiAgICAgICAgdGhpcy5zZXRTZWxlY3RlZEl0ZW0oMCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHVzZVNlbGVjdGVkSXRlbShldmVudDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy52YWx1ZXNbdGhpcy5zZWxlY3RlZEl0ZW1dO1xuICAgICAgICBpZiAoY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLm93bmVyLnNlbGVjdFN1Z2dlc3Rpb24oY3VycmVudFZhbHVlLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRTZWxlY3RlZEl0ZW0oc2VsZWN0ZWRJbmRleDogbnVtYmVyLCBzY3JvbGxJbnRvVmlldzogYm9vbGVhbikge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkSW5kZXggPSB3cmFwQXJvdW5kKFxuICAgICAgICAgICAgc2VsZWN0ZWRJbmRleCxcbiAgICAgICAgICAgIHRoaXMuc3VnZ2VzdGlvbnMubGVuZ3RoXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHByZXZTZWxlY3RlZFN1Z2dlc3Rpb24gPSB0aGlzLnN1Z2dlc3Rpb25zW3RoaXMuc2VsZWN0ZWRJdGVtXTtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRTdWdnZXN0aW9uID0gdGhpcy5zdWdnZXN0aW9uc1tub3JtYWxpemVkSW5kZXhdO1xuXG4gICAgICAgIHByZXZTZWxlY3RlZFN1Z2dlc3Rpb24/LnJlbW92ZUNsYXNzKFwiaXMtc2VsZWN0ZWRcIik7XG4gICAgICAgIHNlbGVjdGVkU3VnZ2VzdGlvbj8uYWRkQ2xhc3MoXCJpcy1zZWxlY3RlZFwiKTtcblxuICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbSA9IG5vcm1hbGl6ZWRJbmRleDtcblxuICAgICAgICBpZiAoc2Nyb2xsSW50b1ZpZXcpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkU3VnZ2VzdGlvbi5zY3JvbGxJbnRvVmlldyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBUZXh0SW5wdXRTdWdnZXN0PFQ+IGltcGxlbWVudHMgSVN1Z2dlc3RPd25lcjxUPiB7XG4gICAgcHJvdGVjdGVkIGFwcDogQXBwO1xuICAgIHByb3RlY3RlZCBpbnB1dEVsOiBIVE1MSW5wdXRFbGVtZW50IHwgSFRNTFRleHRBcmVhRWxlbWVudDtcblxuICAgIHByaXZhdGUgcG9wcGVyITogUG9wcGVySW5zdGFuY2U7XG4gICAgcHJpdmF0ZSBzY29wZTogU2NvcGU7XG4gICAgcHJpdmF0ZSBzdWdnZXN0RWw6IEhUTUxFbGVtZW50O1xuICAgIHByaXZhdGUgc3VnZ2VzdDogU3VnZ2VzdDxUPjtcblxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBpbnB1dEVsOiBIVE1MSW5wdXRFbGVtZW50IHwgSFRNTFRleHRBcmVhRWxlbWVudCkge1xuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICAgICAgdGhpcy5pbnB1dEVsID0gaW5wdXRFbDtcbiAgICAgICAgdGhpcy5zY29wZSA9IG5ldyBTY29wZSgpO1xuXG4gICAgICAgIHRoaXMuc3VnZ2VzdEVsID0gY3JlYXRlRGl2KFwic3VnZ2VzdGlvbi1jb250YWluZXJcIik7XG4gICAgICAgIGNvbnN0IHN1Z2dlc3Rpb24gPSB0aGlzLnN1Z2dlc3RFbC5jcmVhdGVEaXYoXCJzdWdnZXN0aW9uXCIpO1xuICAgICAgICB0aGlzLnN1Z2dlc3QgPSBuZXcgU3VnZ2VzdCh0aGlzLCBzdWdnZXN0aW9uLCB0aGlzLnNjb3BlKTtcblxuICAgICAgICB0aGlzLnNjb3BlLnJlZ2lzdGVyKFtdLCBcIkVzY2FwZVwiLCB0aGlzLmNsb3NlLmJpbmQodGhpcykpO1xuXG4gICAgICAgIHRoaXMuaW5wdXRFbC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy5vbklucHV0Q2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5pbnB1dEVsLmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLm9uSW5wdXRDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmlucHV0RWwuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5jbG9zZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5zdWdnZXN0RWwub24oXG4gICAgICAgICAgICBcIm1vdXNlZG93blwiLFxuICAgICAgICAgICAgXCIuc3VnZ2VzdGlvbi1jb250YWluZXJcIixcbiAgICAgICAgICAgIChldmVudDogTW91c2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgb25JbnB1dENoYW5nZWQoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGlucHV0U3RyID0gdGhpcy5pbnB1dEVsLnZhbHVlO1xuICAgICAgICBjb25zdCBzdWdnZXN0aW9ucyA9IHRoaXMuZ2V0U3VnZ2VzdGlvbnMoaW5wdXRTdHIpO1xuXG4gICAgICAgIGlmICghc3VnZ2VzdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdWdnZXN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnN1Z2dlc3Quc2V0U3VnZ2VzdGlvbnMoc3VnZ2VzdGlvbnMpO1xuICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICB0aGlzLm9wZW4odGhpcy5hcHAuZG9tLmFwcENvbnRhaW5lckVsLCB0aGlzLmlucHV0RWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3Blbihjb250YWluZXI6IEhUTUxFbGVtZW50LCBpbnB1dEVsOiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLmFwcC5rZXltYXAucHVzaFNjb3BlKHRoaXMuc2NvcGUpO1xuXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnN1Z2dlc3RFbCk7XG4gICAgICAgIHRoaXMucG9wcGVyID0gY3JlYXRlUG9wcGVyKGlucHV0RWwsIHRoaXMuc3VnZ2VzdEVsLCB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IFwiYm90dG9tLXN0YXJ0XCIsXG4gICAgICAgICAgICBtb2RpZmllcnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwic2FtZVdpZHRoXCIsXG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGZuOiAoeyBzdGF0ZSwgaW5zdGFuY2UgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogcG9zaXRpb25pbmcgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZCB0d2ljZSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXJzdCBwYXNzIC0gcG9zaXRpb25pbmcgaXQgYWNjb3JkaW5nIHRvIHRoZSB3aWR0aCBvZiB0aGUgcG9wcGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWNvbmQgcGFzcyAtIHBvc2l0aW9uIGl0IHdpdGggdGhlIHdpZHRoIGJvdW5kIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBlYXJseSBleGl0IHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFdpZHRoID0gYCR7c3RhdGUucmVjdHMucmVmZXJlbmNlLndpZHRofXB4YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zdHlsZXMucG9wcGVyLndpZHRoID09PSB0YXJnZXRXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnN0eWxlcy5wb3BwZXIud2lkdGggPSB0YXJnZXRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwaGFzZTogXCJiZWZvcmVXcml0ZVwiLFxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlczogW1wiY29tcHV0ZVN0eWxlc1wiXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2xvc2UoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYXBwLmtleW1hcC5wb3BTY29wZSh0aGlzLnNjb3BlKTtcblxuICAgICAgICB0aGlzLnN1Z2dlc3Quc2V0U3VnZ2VzdGlvbnMoW10pO1xuICAgICAgICBpZiAodGhpcy5wb3BwZXIpIHRoaXMucG9wcGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5zdWdnZXN0RWwuZGV0YWNoKCk7XG4gICAgfVxuXG4gICAgYWJzdHJhY3QgZ2V0U3VnZ2VzdGlvbnMoaW5wdXRTdHI6IHN0cmluZyk6IFRbXTtcbiAgICBhYnN0cmFjdCByZW5kZXJTdWdnZXN0aW9uKGl0ZW06IFQsIGVsOiBIVE1MRWxlbWVudCk6IHZvaWQ7XG4gICAgYWJzdHJhY3Qgc2VsZWN0U3VnZ2VzdGlvbihpdGVtOiBUKTogdm9pZDtcbn1cbiIsICJleHBvcnQgdmFyIHRvcCA9ICd0b3AnO1xuZXhwb3J0IHZhciBib3R0b20gPSAnYm90dG9tJztcbmV4cG9ydCB2YXIgcmlnaHQgPSAncmlnaHQnO1xuZXhwb3J0IHZhciBsZWZ0ID0gJ2xlZnQnO1xuZXhwb3J0IHZhciBhdXRvID0gJ2F1dG8nO1xuZXhwb3J0IHZhciBiYXNlUGxhY2VtZW50cyA9IFt0b3AsIGJvdHRvbSwgcmlnaHQsIGxlZnRdO1xuZXhwb3J0IHZhciBzdGFydCA9ICdzdGFydCc7XG5leHBvcnQgdmFyIGVuZCA9ICdlbmQnO1xuZXhwb3J0IHZhciBjbGlwcGluZ1BhcmVudHMgPSAnY2xpcHBpbmdQYXJlbnRzJztcbmV4cG9ydCB2YXIgdmlld3BvcnQgPSAndmlld3BvcnQnO1xuZXhwb3J0IHZhciBwb3BwZXIgPSAncG9wcGVyJztcbmV4cG9ydCB2YXIgcmVmZXJlbmNlID0gJ3JlZmVyZW5jZSc7XG5leHBvcnQgdmFyIHZhcmlhdGlvblBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovYmFzZVBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTtcbmV4cG9ydCB2YXIgcGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9bXS5jb25jYXQoYmFzZVBsYWNlbWVudHMsIFthdXRvXSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50LCBwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pOyAvLyBtb2RpZmllcnMgdGhhdCBuZWVkIHRvIHJlYWQgdGhlIERPTVxuXG5leHBvcnQgdmFyIGJlZm9yZVJlYWQgPSAnYmVmb3JlUmVhZCc7XG5leHBvcnQgdmFyIHJlYWQgPSAncmVhZCc7XG5leHBvcnQgdmFyIGFmdGVyUmVhZCA9ICdhZnRlclJlYWQnOyAvLyBwdXJlLWxvZ2ljIG1vZGlmaWVyc1xuXG5leHBvcnQgdmFyIGJlZm9yZU1haW4gPSAnYmVmb3JlTWFpbic7XG5leHBvcnQgdmFyIG1haW4gPSAnbWFpbic7XG5leHBvcnQgdmFyIGFmdGVyTWFpbiA9ICdhZnRlck1haW4nOyAvLyBtb2RpZmllciB3aXRoIHRoZSBwdXJwb3NlIHRvIHdyaXRlIHRvIHRoZSBET00gKG9yIHdyaXRlIGludG8gYSBmcmFtZXdvcmsgc3RhdGUpXG5cbmV4cG9ydCB2YXIgYmVmb3JlV3JpdGUgPSAnYmVmb3JlV3JpdGUnO1xuZXhwb3J0IHZhciB3cml0ZSA9ICd3cml0ZSc7XG5leHBvcnQgdmFyIGFmdGVyV3JpdGUgPSAnYWZ0ZXJXcml0ZSc7XG5leHBvcnQgdmFyIG1vZGlmaWVyUGhhc2VzID0gW2JlZm9yZVJlYWQsIHJlYWQsIGFmdGVyUmVhZCwgYmVmb3JlTWFpbiwgbWFpbiwgYWZ0ZXJNYWluLCBiZWZvcmVXcml0ZSwgd3JpdGUsIGFmdGVyV3JpdGVdOyIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXROb2RlTmFtZShlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50ID8gKGVsZW1lbnQubm9kZU5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xufSIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmIChub2RlLnRvU3RyaW5nKCkgIT09ICdbb2JqZWN0IFdpbmRvd10nKSB7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdyA6IHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufSIsICJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuXG5mdW5jdGlvbiBpc0VsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5FbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5IVE1MRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNTaGFkb3dSb290KG5vZGUpIHtcbiAgLy8gSUUgMTEgaGFzIG5vIFNoYWRvd1Jvb3RcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLlNoYWRvd1Jvb3Q7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdDtcbn1cblxuZXhwb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBpc1NoYWRvd1Jvb3QgfTsiLCAiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjsgLy8gVGhpcyBtb2RpZmllciB0YWtlcyB0aGUgc3R5bGVzIHByZXBhcmVkIGJ5IHRoZSBgY29tcHV0ZVN0eWxlc2AgbW9kaWZpZXJcbi8vIGFuZCBhcHBsaWVzIHRoZW0gdG8gdGhlIEhUTUxFbGVtZW50cyBzdWNoIGFzIHBvcHBlciBhbmQgYXJyb3dcblxuZnVuY3Rpb24gYXBwbHlTdHlsZXMoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlO1xuICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnN0eWxlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgIWdldE5vZGVOYW1lKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGbG93IGRvZXNuJ3Qgc3VwcG9ydCB0byBleHRlbmQgdGhpcyBwcm9wZXJ0eSwgYnV0IGl0J3MgdGhlIG1vc3RcbiAgICAvLyBlZmZlY3RpdmUgd2F5IHRvIGFwcGx5IHN0eWxlcyB0byBhbiBIVE1MRWxlbWVudFxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuXG5cbiAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUgPT09IHRydWUgPyAnJyA6IHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZTtcbiAgdmFyIGluaXRpYWxTdHlsZXMgPSB7XG4gICAgcG9wcGVyOiB7XG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGxlZnQ6ICcwJyxcbiAgICAgIHRvcDogJzAnLFxuICAgICAgbWFyZ2luOiAnMCdcbiAgICB9LFxuICAgIGFycm93OiB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgIH0sXG4gICAgcmVmZXJlbmNlOiB7fVxuICB9O1xuICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLnBvcHBlci5zdHlsZSwgaW5pdGlhbFN0eWxlcy5wb3BwZXIpO1xuICBzdGF0ZS5zdHlsZXMgPSBpbml0aWFsU3R5bGVzO1xuXG4gIGlmIChzdGF0ZS5lbGVtZW50cy5hcnJvdykge1xuICAgIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMuYXJyb3cuc3R5bGUsIGluaXRpYWxTdHlsZXMuYXJyb3cpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICAgIHZhciBzdHlsZVByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhzdGF0ZS5zdHlsZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBzdGF0ZS5zdHlsZXNbbmFtZV0gOiBpbml0aWFsU3R5bGVzW25hbWVdKTsgLy8gU2V0IGFsbCB2YWx1ZXMgdG8gYW4gZW1wdHkgc3RyaW5nIHRvIHVuc2V0IHRoZW1cblxuICAgICAgdmFyIHN0eWxlID0gc3R5bGVQcm9wZXJ0aWVzLnJlZHVjZShmdW5jdGlvbiAoc3R5bGUsIHByb3BlcnR5KSB7XG4gICAgICAgIHN0eWxlW3Byb3BlcnR5XSA9ICcnO1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9LCB7fSk7IC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuXG4gICAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgIWdldE5vZGVOYW1lKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnYXBwbHlTdHlsZXMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46IGFwcGx5U3R5bGVzLFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgcmVxdWlyZXM6IFsnY29tcHV0ZVN0eWxlcyddXG59OyIsICJpbXBvcnQgeyBhdXRvIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG59IiwgImV4cG9ydCB2YXIgbWF4ID0gTWF0aC5tYXg7XG5leHBvcnQgdmFyIG1pbiA9IE1hdGgubWluO1xuZXhwb3J0IHZhciByb3VuZCA9IE1hdGgucm91bmQ7IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFVBU3RyaW5nKCkge1xuICB2YXIgdWFEYXRhID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG5cbiAgaWYgKHVhRGF0YSAhPSBudWxsICYmIHVhRGF0YS5icmFuZHMgJiYgQXJyYXkuaXNBcnJheSh1YURhdGEuYnJhbmRzKSkge1xuICAgIHJldHVybiB1YURhdGEuYnJhbmRzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0uYnJhbmQgKyBcIi9cIiArIGl0ZW0udmVyc2lvbjtcbiAgICB9KS5qb2luKCcgJyk7XG4gIH1cblxuICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbn0iLCAiaW1wb3J0IGdldFVBU3RyaW5nIGZyb20gXCIuLi91dGlscy91c2VyQWdlbnQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzTGF5b3V0Vmlld3BvcnQoKSB7XG4gIHJldHVybiAhL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChnZXRVQVN0cmluZygpKTtcbn0iLCAiaW1wb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IHsgcm91bmQgfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBpc0xheW91dFZpZXdwb3J0IGZyb20gXCIuL2lzTGF5b3V0Vmlld3BvcnQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBpbmNsdWRlU2NhbGUsIGlzRml4ZWRTdHJhdGVneSkge1xuICBpZiAoaW5jbHVkZVNjYWxlID09PSB2b2lkIDApIHtcbiAgICBpbmNsdWRlU2NhbGUgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc0ZpeGVkU3RyYXRlZ3kgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWRTdHJhdGVneSA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGNsaWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc2NhbGVYID0gMTtcbiAgdmFyIHNjYWxlWSA9IDE7XG5cbiAgaWYgKGluY2x1ZGVTY2FsZSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgc2NhbGVYID0gZWxlbWVudC5vZmZzZXRXaWR0aCA+IDAgPyByb3VuZChjbGllbnRSZWN0LndpZHRoKSAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMSA6IDE7XG4gICAgc2NhbGVZID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgPiAwID8gcm91bmQoY2xpZW50UmVjdC5oZWlnaHQpIC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMSA6IDE7XG4gIH1cblxuICB2YXIgX3JlZiA9IGlzRWxlbWVudChlbGVtZW50KSA/IGdldFdpbmRvdyhlbGVtZW50KSA6IHdpbmRvdyxcbiAgICAgIHZpc3VhbFZpZXdwb3J0ID0gX3JlZi52aXN1YWxWaWV3cG9ydDtcblxuICB2YXIgYWRkVmlzdWFsT2Zmc2V0cyA9ICFpc0xheW91dFZpZXdwb3J0KCkgJiYgaXNGaXhlZFN0cmF0ZWd5O1xuICB2YXIgeCA9IChjbGllbnRSZWN0LmxlZnQgKyAoYWRkVmlzdWFsT2Zmc2V0cyAmJiB2aXN1YWxWaWV3cG9ydCA/IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQgOiAwKSkgLyBzY2FsZVg7XG4gIHZhciB5ID0gKGNsaWVudFJlY3QudG9wICsgKGFkZFZpc3VhbE9mZnNldHMgJiYgdmlzdWFsVmlld3BvcnQgPyB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3AgOiAwKSkgLyBzY2FsZVk7XG4gIHZhciB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGggLyBzY2FsZVg7XG4gIHZhciBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodCAvIHNjYWxlWTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgdG9wOiB5LFxuICAgIHJpZ2h0OiB4ICsgd2lkdGgsXG4gICAgYm90dG9tOiB5ICsgaGVpZ2h0LFxuICAgIGxlZnQ6IHgsXG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG59IiwgImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7IC8vIFJldHVybnMgdGhlIGxheW91dCByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC4gTGF5b3V0XG4vLyBtZWFucyBpdCBkb2Vzbid0IHRha2UgaW50byBhY2NvdW50IHRyYW5zZm9ybXMuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldExheW91dFJlY3QoZWxlbWVudCkge1xuICB2YXIgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTsgLy8gVXNlIHRoZSBjbGllbnRSZWN0IHNpemVzIGlmIGl0J3Mgbm90IGJlZW4gdHJhbnNmb3JtZWQuXG4gIC8vIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTIyM1xuXG4gIHZhciB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcblxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC53aWR0aCAtIHdpZHRoKSA8PSAxKSB7XG4gICAgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3QuaGVpZ2h0IC0gaGVpZ2h0KSA8PSAxKSB7XG4gICAgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IGVsZW1lbnQub2Zmc2V0TGVmdCxcbiAgICB5OiBlbGVtZW50Lm9mZnNldFRvcCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn0iLCAiaW1wb3J0IHsgaXNTaGFkb3dSb290IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBjaGlsZCkge1xuICB2YXIgcm9vdE5vZGUgPSBjaGlsZC5nZXRSb290Tm9kZSAmJiBjaGlsZC5nZXRSb290Tm9kZSgpOyAvLyBGaXJzdCwgYXR0ZW1wdCB3aXRoIGZhc3RlciBuYXRpdmUgbWV0aG9kXG5cbiAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyB0aGVuIGZhbGxiYWNrIHRvIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiB3aXRoIFNoYWRvdyBET00gc3VwcG9ydFxuICBlbHNlIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgICB2YXIgbmV4dCA9IGNoaWxkO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuZXh0ICYmIHBhcmVudC5pc1NhbWVOb2RlKG5leHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddOiBuZWVkIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcy4uLlxuXG5cbiAgICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XG4gICAgICB9IHdoaWxlIChuZXh0KTtcbiAgICB9IC8vIEdpdmUgdXAsIHRoZSByZXN1bHQgaXMgZmFsc2VcblxuXG4gIHJldHVybiBmYWxzZTtcbn0iLCAiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59IiwgImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gWyd0YWJsZScsICd0ZCcsICd0aCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpID49IDA7XG59IiwgImltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSB7XG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgcmV0dXJuICgoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudC5vd25lckRvY3VtZW50IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gIGVsZW1lbnQuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkuZG9jdW1lbnRFbGVtZW50O1xufSIsICJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgeyBpc1NoYWRvd1Jvb3QgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGdldE5vZGVOYW1lKGVsZW1lbnQpID09PSAnaHRtbCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiAoLy8gdGhpcyBpcyBhIHF1aWNrZXIgKGJ1dCBsZXNzIHR5cGUgc2FmZSkgd2F5IHRvIHNhdmUgcXVpdGUgc29tZSBieXRlcyBmcm9tIHRoZSBidW5kbGVcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgZWxlbWVudC5hc3NpZ25lZFNsb3QgfHwgLy8gc3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGVcbiAgICBlbGVtZW50LnBhcmVudE5vZGUgfHwgKCAvLyBET00gRWxlbWVudCBkZXRlY3RlZFxuICAgIGlzU2hhZG93Um9vdChlbGVtZW50KSA/IGVsZW1lbnQuaG9zdCA6IG51bGwpIHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWRcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogSFRNTEVsZW1lbnQgaXMgYSBOb2RlXG4gICAgZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIC8vIGZhbGxiYWNrXG5cbiAgKTtcbn0iLCAiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCwgaXNTaGFkb3dSb290IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGlzVGFibGVFbGVtZW50IGZyb20gXCIuL2lzVGFibGVFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgZ2V0VUFTdHJpbmcgZnJvbSBcIi4uL3V0aWxzL3VzZXJBZ2VudC5qc1wiO1xuXG5mdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvODM3XG4gIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50Lm9mZnNldFBhcmVudDtcbn0gLy8gYC5vZmZzZXRQYXJlbnRgIHJlcG9ydHMgYG51bGxgIGZvciBmaXhlZCBlbGVtZW50cywgd2hpbGUgYWJzb2x1dGUgZWxlbWVudHNcbi8vIHJldHVybiB0aGUgY29udGFpbmluZyBibG9ja1xuXG5cbmZ1bmN0aW9uIGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XG4gIHZhciBpc0ZpcmVmb3ggPSAvZmlyZWZveC9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XG4gIHZhciBpc0lFID0gL1RyaWRlbnQvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xuXG4gIGlmIChpc0lFICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAvLyBJbiBJRSA5LCAxMCBhbmQgMTEgZml4ZWQgZWxlbWVudHMgY29udGFpbmluZyBibG9jayBpcyBhbHdheXMgZXN0YWJsaXNoZWQgYnkgdGhlIHZpZXdwb3J0XG4gICAgdmFyIGVsZW1lbnRDc3MgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gICAgaWYgKGVsZW1lbnRDc3MucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG5cbiAgaWYgKGlzU2hhZG93Um9vdChjdXJyZW50Tm9kZSkpIHtcbiAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLmhvc3Q7XG4gIH1cblxuICB3aGlsZSAoaXNIVE1MRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgWydodG1sJywgJ2JvZHknXS5pbmRleE9mKGdldE5vZGVOYW1lKGN1cnJlbnROb2RlKSkgPCAwKSB7XG4gICAgdmFyIGNzcyA9IGdldENvbXB1dGVkU3R5bGUoY3VycmVudE5vZGUpOyAvLyBUaGlzIGlzIG5vbi1leGhhdXN0aXZlIGJ1dCBjb3ZlcnMgdGhlIG1vc3QgY29tbW9uIENTUyBwcm9wZXJ0aWVzIHRoYXRcbiAgICAvLyBjcmVhdGUgYSBjb250YWluaW5nIGJsb2NrLlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrI2lkZW50aWZ5aW5nX3RoZV9jb250YWluaW5nX2Jsb2NrXG5cbiAgICBpZiAoY3NzLnRyYW5zZm9ybSAhPT0gJ25vbmUnIHx8IGNzcy5wZXJzcGVjdGl2ZSAhPT0gJ25vbmUnIHx8IGNzcy5jb250YWluID09PSAncGFpbnQnIHx8IFsndHJhbnNmb3JtJywgJ3BlcnNwZWN0aXZlJ10uaW5kZXhPZihjc3Mud2lsbENoYW5nZSkgIT09IC0xIHx8IGlzRmlyZWZveCAmJiBjc3Mud2lsbENoYW5nZSA9PT0gJ2ZpbHRlcicgfHwgaXNGaXJlZm94ICYmIGNzcy5maWx0ZXIgJiYgY3NzLmZpbHRlciAhPT0gJ25vbmUnKSB7XG4gICAgICByZXR1cm4gY3VycmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn0gLy8gR2V0cyB0aGUgY2xvc2VzdCBhbmNlc3RvciBwb3NpdGlvbmVkIGVsZW1lbnQuIEhhbmRsZXMgc29tZSBlZGdlIGNhc2VzLFxuLy8gc3VjaCBhcyB0YWJsZSBhbmNlc3RvcnMgYW5kIGNyb3NzIGJyb3dzZXIgYnVncy5cblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICB2YXIgd2luZG93ID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KTtcblxuICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIGlzVGFibGVFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgfVxuXG4gIGlmIChvZmZzZXRQYXJlbnQgJiYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdodG1sJyB8fCBnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnYm9keScgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkgfHwgd2luZG93O1xufSIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgPj0gMCA/ICd4JyA6ICd5Jztcbn0iLCAiaW1wb3J0IHsgbWF4IGFzIG1hdGhNYXgsIG1pbiBhcyBtYXRoTWluIH0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhpbihtaW4sIHZhbHVlLCBtYXgpIHtcbiAgcmV0dXJuIG1hdGhNYXgobWluLCBtYXRoTWluKHZhbHVlLCBtYXgpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3aXRoaW5NYXhDbGFtcChtaW4sIHZhbHVlLCBtYXgpIHtcbiAgdmFyIHYgPSB3aXRoaW4obWluLCB2YWx1ZSwgbWF4KTtcbiAgcmV0dXJuIHYgPiBtYXggPyBtYXggOiB2O1xufSIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRGcmVzaFNpZGVPYmplY3QoKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH07XG59IiwgImltcG9ydCBnZXRGcmVzaFNpZGVPYmplY3QgZnJvbSBcIi4vZ2V0RnJlc2hTaWRlT2JqZWN0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZVBhZGRpbmdPYmplY3QocGFkZGluZ09iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZ2V0RnJlc2hTaWRlT2JqZWN0KCksIHBhZGRpbmdPYmplY3QpO1xufSIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBleHBhbmRUb0hhc2hNYXAodmFsdWUsIGtleXMpIHtcbiAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChoYXNoTWFwLCBrZXkpIHtcbiAgICBoYXNoTWFwW2tleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gaGFzaE1hcDtcbiAgfSwge30pO1xufSIsICJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgY29udGFpbnMgZnJvbSBcIi4uL2RvbS11dGlscy9jb250YWlucy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyB3aXRoaW4gfSBmcm9tIFwiLi4vdXRpbHMvd2l0aGluLmpzXCI7XG5pbXBvcnQgbWVyZ2VQYWRkaW5nT2JqZWN0IGZyb20gXCIuLi91dGlscy9tZXJnZVBhZGRpbmdPYmplY3QuanNcIjtcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSBcIi4uL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qc1wiO1xuaW1wb3J0IHsgbGVmdCwgcmlnaHQsIGJhc2VQbGFjZW1lbnRzLCB0b3AsIGJvdHRvbSB9IGZyb20gXCIuLi9lbnVtcy5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciB0b1BhZGRpbmdPYmplY3QgPSBmdW5jdGlvbiB0b1BhZGRpbmdPYmplY3QocGFkZGluZywgc3RhdGUpIHtcbiAgcGFkZGluZyA9IHR5cGVvZiBwYWRkaW5nID09PSAnZnVuY3Rpb24nID8gcGFkZGluZyhPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pKSA6IHBhZGRpbmc7XG4gIHJldHVybiBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xufTtcblxuZnVuY3Rpb24gYXJyb3coX3JlZikge1xuICB2YXIgX3N0YXRlJG1vZGlmaWVyc0RhdGEkO1xuXG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciBheGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgaXNWZXJ0aWNhbCA9IFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwO1xuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBpZiAoIWFycm93RWxlbWVudCB8fCAhcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gdG9QYWRkaW5nT2JqZWN0KG9wdGlvbnMucGFkZGluZywgc3RhdGUpO1xuICB2YXIgYXJyb3dSZWN0ID0gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpO1xuICB2YXIgbWluUHJvcCA9IGF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gIHZhciBtYXhQcm9wID0gYXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gIHZhciBlbmREaWZmID0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2xlbl0gKyBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc10gLSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucG9wcGVyW2xlbl07XG4gIHZhciBzdGFydERpZmYgPSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdO1xuICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoYXJyb3dFbGVtZW50KTtcbiAgdmFyIGNsaWVudFNpemUgPSBhcnJvd09mZnNldFBhcmVudCA/IGF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudEhlaWdodCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggfHwgMCA6IDA7XG4gIHZhciBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjsgLy8gTWFrZSBzdXJlIHRoZSBhcnJvdyBkb2Vzbid0IG92ZXJmbG93IHRoZSBwb3BwZXIgaWYgdGhlIGNlbnRlciBwb2ludCBpc1xuICAvLyBvdXRzaWRlIG9mIHRoZSBwb3BwZXIgYm91bmRzXG5cbiAgdmFyIG1pbiA9IHBhZGRpbmdPYmplY3RbbWluUHJvcF07XG4gIHZhciBtYXggPSBjbGllbnRTaXplIC0gYXJyb3dSZWN0W2xlbl0gLSBwYWRkaW5nT2JqZWN0W21heFByb3BdO1xuICB2YXIgY2VudGVyID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd1JlY3RbbGVuXSAvIDIgKyBjZW50ZXJUb1JlZmVyZW5jZTtcbiAgdmFyIG9mZnNldCA9IHdpdGhpbihtaW4sIGNlbnRlciwgbWF4KTsgLy8gUHJldmVudHMgYnJlYWtpbmcgc3ludGF4IGhpZ2hsaWdodGluZy4uLlxuXG4gIHZhciBheGlzUHJvcCA9IGF4aXM7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSAoX3N0YXRlJG1vZGlmaWVyc0RhdGEkID0ge30sIF9zdGF0ZSRtb2RpZmllcnNEYXRhJFtheGlzUHJvcF0gPSBvZmZzZXQsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJC5jZW50ZXJPZmZzZXQgPSBvZmZzZXQgLSBjZW50ZXIsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJCk7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudCxcbiAgICAgIGFycm93RWxlbWVudCA9IF9vcHRpb25zJGVsZW1lbnQgPT09IHZvaWQgMCA/ICdbZGF0YS1wb3BwZXItYXJyb3ddJyA6IF9vcHRpb25zJGVsZW1lbnQ7XG5cbiAgaWYgKGFycm93RWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIENTUyBzZWxlY3RvclxuXG5cbiAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3dFbGVtZW50KTtcblxuICAgIGlmICghYXJyb3dFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb250YWlucyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIsIGFycm93RWxlbWVudCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdGF0ZS5lbGVtZW50cy5hcnJvdyA9IGFycm93RWxlbWVudDtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2Fycm93JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IGFycm93LFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddXG59OyIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcbn0iLCAiaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLCBlbmQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4uL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IHsgcm91bmQgfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciB1bnNldFNpZGVzID0ge1xuICB0b3A6ICdhdXRvJyxcbiAgcmlnaHQ6ICdhdXRvJyxcbiAgYm90dG9tOiAnYXV0bycsXG4gIGxlZnQ6ICdhdXRvJ1xufTsgLy8gUm91bmQgdGhlIG9mZnNldHMgdG8gdGhlIG5lYXJlc3Qgc3VpdGFibGUgc3VicGl4ZWwgYmFzZWQgb24gdGhlIERQUi5cbi8vIFpvb21pbmcgY2FuIGNoYW5nZSB0aGUgRFBSLCBidXQgaXQgc2VlbXMgdG8gcmVwb3J0IGEgdmFsdWUgdGhhdCB3aWxsXG4vLyBjbGVhbmx5IGRpdmlkZSB0aGUgdmFsdWVzIGludG8gdGhlIGFwcHJvcHJpYXRlIHN1YnBpeGVscy5cblxuZnVuY3Rpb24gcm91bmRPZmZzZXRzQnlEUFIoX3JlZiwgd2luKSB7XG4gIHZhciB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcbiAgdmFyIGRwciA9IHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gIHJldHVybiB7XG4gICAgeDogcm91bmQoeCAqIGRwcikgLyBkcHIgfHwgMCxcbiAgICB5OiByb3VuZCh5ICogZHByKSAvIGRwciB8fCAwXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb1N0eWxlcyhfcmVmMikge1xuICB2YXIgX09iamVjdCRhc3NpZ24yO1xuXG4gIHZhciBwb3BwZXIgPSBfcmVmMi5wb3BwZXIsXG4gICAgICBwb3BwZXJSZWN0ID0gX3JlZjIucG9wcGVyUmVjdCxcbiAgICAgIHBsYWNlbWVudCA9IF9yZWYyLnBsYWNlbWVudCxcbiAgICAgIHZhcmlhdGlvbiA9IF9yZWYyLnZhcmlhdGlvbixcbiAgICAgIG9mZnNldHMgPSBfcmVmMi5vZmZzZXRzLFxuICAgICAgcG9zaXRpb24gPSBfcmVmMi5wb3NpdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9yZWYyLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGFkYXB0aXZlID0gX3JlZjIuYWRhcHRpdmUsXG4gICAgICByb3VuZE9mZnNldHMgPSBfcmVmMi5yb3VuZE9mZnNldHMsXG4gICAgICBpc0ZpeGVkID0gX3JlZjIuaXNGaXhlZDtcbiAgdmFyIF9vZmZzZXRzJHggPSBvZmZzZXRzLngsXG4gICAgICB4ID0gX29mZnNldHMkeCA9PT0gdm9pZCAwID8gMCA6IF9vZmZzZXRzJHgsXG4gICAgICBfb2Zmc2V0cyR5ID0gb2Zmc2V0cy55LFxuICAgICAgeSA9IF9vZmZzZXRzJHkgPT09IHZvaWQgMCA/IDAgOiBfb2Zmc2V0cyR5O1xuXG4gIHZhciBfcmVmMyA9IHR5cGVvZiByb3VuZE9mZnNldHMgPT09ICdmdW5jdGlvbicgPyByb3VuZE9mZnNldHMoe1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9KSA6IHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcblxuICB4ID0gX3JlZjMueDtcbiAgeSA9IF9yZWYzLnk7XG4gIHZhciBoYXNYID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneCcpO1xuICB2YXIgaGFzWSA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3knKTtcbiAgdmFyIHNpZGVYID0gbGVmdDtcbiAgdmFyIHNpZGVZID0gdG9wO1xuICB2YXIgd2luID0gd2luZG93O1xuXG4gIGlmIChhZGFwdGl2ZSkge1xuICAgIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKTtcbiAgICB2YXIgaGVpZ2h0UHJvcCA9ICdjbGllbnRIZWlnaHQnO1xuICAgIHZhciB3aWR0aFByb3AgPSAnY2xpZW50V2lkdGgnO1xuXG4gICAgaWYgKG9mZnNldFBhcmVudCA9PT0gZ2V0V2luZG93KHBvcHBlcikpIHtcbiAgICAgIG9mZnNldFBhcmVudCA9IGdldERvY3VtZW50RWxlbWVudChwb3BwZXIpO1xuXG4gICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uICE9PSAnc3RhdGljJyAmJiBwb3NpdGlvbiA9PT0gJ2Fic29sdXRlJykge1xuICAgICAgICBoZWlnaHRQcm9wID0gJ3Njcm9sbEhlaWdodCc7XG4gICAgICAgIHdpZHRoUHJvcCA9ICdzY3JvbGxXaWR0aCc7XG4gICAgICB9XG4gICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYXN0XTogZm9yY2UgdHlwZSByZWZpbmVtZW50LCB3ZSBjb21wYXJlIG9mZnNldFBhcmVudCB3aXRoIHdpbmRvdyBhYm92ZSwgYnV0IEZsb3cgZG9lc24ndCBkZXRlY3QgaXRcblxuXG4gICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50O1xuXG4gICAgaWYgKHBsYWNlbWVudCA9PT0gdG9wIHx8IChwbGFjZW1lbnQgPT09IGxlZnQgfHwgcGxhY2VtZW50ID09PSByaWdodCkgJiYgdmFyaWF0aW9uID09PSBlbmQpIHtcbiAgICAgIHNpZGVZID0gYm90dG9tO1xuICAgICAgdmFyIG9mZnNldFkgPSBpc0ZpeGVkICYmIG9mZnNldFBhcmVudCA9PT0gd2luICYmIHdpbi52aXN1YWxWaWV3cG9ydCA/IHdpbi52aXN1YWxWaWV3cG9ydC5oZWlnaHQgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgIG9mZnNldFBhcmVudFtoZWlnaHRQcm9wXTtcbiAgICAgIHkgLT0gb2Zmc2V0WSAtIHBvcHBlclJlY3QuaGVpZ2h0O1xuICAgICAgeSAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XG4gICAgfVxuXG4gICAgaWYgKHBsYWNlbWVudCA9PT0gbGVmdCB8fCAocGxhY2VtZW50ID09PSB0b3AgfHwgcGxhY2VtZW50ID09PSBib3R0b20pICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XG4gICAgICBzaWRlWCA9IHJpZ2h0O1xuICAgICAgdmFyIG9mZnNldFggPSBpc0ZpeGVkICYmIG9mZnNldFBhcmVudCA9PT0gd2luICYmIHdpbi52aXN1YWxWaWV3cG9ydCA/IHdpbi52aXN1YWxWaWV3cG9ydC53aWR0aCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgb2Zmc2V0UGFyZW50W3dpZHRoUHJvcF07XG4gICAgICB4IC09IG9mZnNldFggLSBwb3BwZXJSZWN0LndpZHRoO1xuICAgICAgeCAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbW1vblN0eWxlcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICB9LCBhZGFwdGl2ZSAmJiB1bnNldFNpZGVzKTtcblxuICB2YXIgX3JlZjQgPSByb3VuZE9mZnNldHMgPT09IHRydWUgPyByb3VuZE9mZnNldHNCeURQUih7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH0sIGdldFdpbmRvdyhwb3BwZXIpKSA6IHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcblxuICB4ID0gX3JlZjQueDtcbiAgeSA9IF9yZWY0Lnk7XG5cbiAgaWYgKGdwdUFjY2VsZXJhdGlvbikge1xuICAgIHZhciBfT2JqZWN0JGFzc2lnbjtcblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbiA9IHt9LCBfT2JqZWN0JGFzc2lnbltzaWRlWV0gPSBoYXNZID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduW3NpZGVYXSA9IGhhc1ggPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ24udHJhbnNmb3JtID0gKHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIDw9IDEgPyBcInRyYW5zbGF0ZShcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4KVwiIDogXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4LCAwKVwiLCBfT2JqZWN0JGFzc2lnbikpO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduMiA9IHt9LCBfT2JqZWN0JGFzc2lnbjJbc2lkZVldID0gaGFzWSA/IHkgKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yW3NpZGVYXSA9IGhhc1ggPyB4ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMi50cmFuc2Zvcm0gPSAnJywgX09iamVjdCRhc3NpZ24yKSk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZXMoX3JlZjUpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjUuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjUub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZ3B1QWNjZWxlcmF0LFxuICAgICAgX29wdGlvbnMkYWRhcHRpdmUgPSBvcHRpb25zLmFkYXB0aXZlLFxuICAgICAgYWRhcHRpdmUgPSBfb3B0aW9ucyRhZGFwdGl2ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFkYXB0aXZlLFxuICAgICAgX29wdGlvbnMkcm91bmRPZmZzZXRzID0gb3B0aW9ucy5yb3VuZE9mZnNldHMsXG4gICAgICByb3VuZE9mZnNldHMgPSBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyb3VuZE9mZnNldHM7XG4gIHZhciBjb21tb25TdHlsZXMgPSB7XG4gICAgcGxhY2VtZW50OiBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCksXG4gICAgdmFyaWF0aW9uOiBnZXRWYXJpYXRpb24oc3RhdGUucGxhY2VtZW50KSxcbiAgICBwb3BwZXI6IHN0YXRlLmVsZW1lbnRzLnBvcHBlcixcbiAgICBwb3BwZXJSZWN0OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiBncHVBY2NlbGVyYXRpb24sXG4gICAgaXNGaXhlZDogc3RhdGUub3B0aW9ucy5zdHJhdGVneSA9PT0gJ2ZpeGVkJ1xuICB9O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMucG9wcGVyLCBtYXBUb1N0eWxlcyhPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIHtcbiAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyxcbiAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgYWRhcHRpdmU6IGFkYXB0aXZlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3cgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5hcnJvdyA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5hcnJvdywgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93LFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBhZGFwdGl2ZTogZmFsc2UsXG4gICAgICByb3VuZE9mZnNldHM6IHJvdW5kT2Zmc2V0c1xuICAgIH0pKSk7XG4gIH1cblxuICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgJ2RhdGEtcG9wcGVyLXBsYWNlbWVudCc6IHN0YXRlLnBsYWNlbWVudFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2NvbXB1dGVTdHlsZXMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ2JlZm9yZVdyaXRlJyxcbiAgZm46IGNvbXB1dGVTdHlsZXMsXG4gIGRhdGE6IHt9XG59OyIsICJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHBhc3NpdmUgPSB7XG4gIHBhc3NpdmU6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2UsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkc2Nyb2xsID0gb3B0aW9ucy5zY3JvbGwsXG4gICAgICBzY3JvbGwgPSBfb3B0aW9ucyRzY3JvbGwgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRzY3JvbGwsXG4gICAgICBfb3B0aW9ucyRyZXNpemUgPSBvcHRpb25zLnJlc2l6ZSxcbiAgICAgIHJlc2l6ZSA9IF9vcHRpb25zJHJlc2l6ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHJlc2l6ZTtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIpO1xuICB2YXIgc2Nyb2xsUGFyZW50cyA9IFtdLmNvbmNhdChzdGF0ZS5zY3JvbGxQYXJlbnRzLnJlZmVyZW5jZSwgc3RhdGUuc2Nyb2xsUGFyZW50cy5wb3BwZXIpO1xuXG4gIGlmIChzY3JvbGwpIHtcbiAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgc2Nyb2xsUGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAocmVzaXplKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzY3JvbGwpIHtcbiAgICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsUGFyZW50KSB7XG4gICAgICAgIHNjcm9sbFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHJlc2l6ZSkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgfVxuICB9O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnZXZlbnRMaXN0ZW5lcnMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46IGZ1bmN0aW9uIGZuKCkge30sXG4gIGVmZmVjdDogZWZmZWN0LFxuICBkYXRhOiB7fVxufTsiLCAidmFyIGhhc2ggPSB7XG4gIGxlZnQ6ICdyaWdodCcsXG4gIHJpZ2h0OiAnbGVmdCcsXG4gIGJvdHRvbTogJ3RvcCcsXG4gIHRvcDogJ2JvdHRvbSdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59IiwgInZhciBoYXNoID0ge1xuICBzdGFydDogJ2VuZCcsXG4gIGVuZDogJ3N0YXJ0J1xufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn0iLCAiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbChub2RlKSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3cobm9kZSk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gd2luLnBhZ2VYT2Zmc2V0O1xuICB2YXIgc2Nyb2xsVG9wID0gd2luLnBhZ2VZT2Zmc2V0O1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IHNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBzY3JvbGxUb3BcbiAgfTtcbn0iLCAiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KSB7XG4gIC8vIElmIDxodG1sPiBoYXMgYSBDU1Mgd2lkdGggZ3JlYXRlciB0aGFuIHRoZSB2aWV3cG9ydCwgdGhlbiB0aGlzIHdpbGwgYmVcbiAgLy8gaW5jb3JyZWN0IGZvciBSVEwuXG4gIC8vIFBvcHBlciAxIGlzIGJyb2tlbiBpbiB0aGlzIGNhc2UgYW5kIG5ldmVyIGhhZCBhIGJ1ZyByZXBvcnQgc28gbGV0J3MgYXNzdW1lXG4gIC8vIGl0J3Mgbm90IGFuIGlzc3VlLiBJIGRvbid0IHRoaW5rIGFueW9uZSBldmVyIHNwZWNpZmllcyB3aWR0aCBvbiA8aHRtbD5cbiAgLy8gYW55d2F5LlxuICAvLyBCcm93c2VycyB3aGVyZSB0aGUgbGVmdCBzY3JvbGxiYXIgZG9lc24ndCBjYXVzZSBhbiBpc3N1ZSByZXBvcnQgYDBgIGZvclxuICAvLyB0aGlzIChlLmcuIEVkZ2UgMjAxOSwgSUUxMSwgU2FmYXJpKVxuICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkubGVmdCArIGdldFdpbmRvd1Njcm9sbChlbGVtZW50KS5zY3JvbGxMZWZ0O1xufSIsICJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjtcbmltcG9ydCBpc0xheW91dFZpZXdwb3J0IGZyb20gXCIuL2lzTGF5b3V0Vmlld3BvcnQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgdmFyIHZpc3VhbFZpZXdwb3J0ID0gd2luLnZpc3VhbFZpZXdwb3J0O1xuICB2YXIgd2lkdGggPSBodG1sLmNsaWVudFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gaHRtbC5jbGllbnRIZWlnaHQ7XG4gIHZhciB4ID0gMDtcbiAgdmFyIHkgPSAwO1xuXG4gIGlmICh2aXN1YWxWaWV3cG9ydCkge1xuICAgIHdpZHRoID0gdmlzdWFsVmlld3BvcnQud2lkdGg7XG4gICAgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQuaGVpZ2h0O1xuICAgIHZhciBsYXlvdXRWaWV3cG9ydCA9IGlzTGF5b3V0Vmlld3BvcnQoKTtcblxuICAgIGlmIChsYXlvdXRWaWV3cG9ydCB8fCAhbGF5b3V0Vmlld3BvcnQgJiYgc3RyYXRlZ3kgPT09ICdmaXhlZCcpIHtcbiAgICAgIHggPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0O1xuICAgICAgeSA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB4OiB4ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KSxcbiAgICB5OiB5XG4gIH07XG59IiwgImltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuaW1wb3J0IHsgbWF4IH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjsgLy8gR2V0cyB0aGUgZW50aXJlIHNpemUgb2YgdGhlIHNjcm9sbGFibGUgZG9jdW1lbnQgYXJlYSwgZXZlbiBleHRlbmRpbmcgb3V0c2lkZVxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgd2luU2Nyb2xsID0gZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpO1xuICB2YXIgYm9keSA9IChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keTtcbiAgdmFyIHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LnNjcm9sbFdpZHRoIDogMCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKTtcbiAgdmFyIGhlaWdodCA9IG1heChodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGJvZHkgPyBib2R5LnNjcm9sbEhlaWdodCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudEhlaWdodCA6IDApO1xuICB2YXIgeCA9IC13aW5TY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gIHZhciB5ID0gLXdpblNjcm9sbC5zY3JvbGxUb3A7XG5cbiAgaWYgKGdldENvbXB1dGVkU3R5bGUoYm9keSB8fCBodG1sKS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKSAtIHdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG59IiwgImltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzU2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gRmlyZWZveCB3YW50cyB1cyB0byBjaGVjayBgLXhgIGFuZCBgLXlgIHZhcmlhdGlvbnMgYXMgd2VsbFxuICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLFxuICAgICAgb3ZlcmZsb3cgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvdyxcbiAgICAgIG92ZXJmbG93WCA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WCxcbiAgICAgIG92ZXJmbG93WSA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WTtcblxuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVuLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKTtcbn0iLCAiaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQobm9kZSkge1xuICBpZiAoWydodG1sJywgJ2JvZHknLCAnI2RvY3VtZW50J10uaW5kZXhPZihnZXROb2RlTmFtZShub2RlKSkgPj0gMCkge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50LmJvZHk7XG4gIH1cblxuICBpZiAoaXNIVE1MRWxlbWVudChub2RlKSAmJiBpc1Njcm9sbFBhcmVudChub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKG5vZGUpKTtcbn0iLCAiaW1wb3J0IGdldFNjcm9sbFBhcmVudCBmcm9tIFwiLi9nZXRTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbi8qXG5naXZlbiBhIERPTSBlbGVtZW50LCByZXR1cm4gdGhlIGxpc3Qgb2YgYWxsIHNjcm9sbCBwYXJlbnRzLCB1cCB0aGUgbGlzdCBvZiBhbmNlc29yc1xudW50aWwgd2UgZ2V0IHRvIHRoZSB0b3Agd2luZG93IG9iamVjdC4gVGhpcyBsaXN0IGlzIHdoYXQgd2UgYXR0YWNoIHNjcm9sbCBsaXN0ZW5lcnNcbnRvLCBiZWNhdXNlIGlmIGFueSBvZiB0aGVzZSBwYXJlbnQgZWxlbWVudHMgc2Nyb2xsLCB3ZSdsbCBuZWVkIHRvIHJlLWNhbGN1bGF0ZSB0aGVcbnJlZmVyZW5jZSBlbGVtZW50J3MgcG9zaXRpb24uXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaXN0U2Nyb2xsUGFyZW50cyhlbGVtZW50LCBsaXN0KSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuXG4gIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCk7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQgPT09ICgoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHkpO1xuICB2YXIgd2luID0gZ2V0V2luZG93KHNjcm9sbFBhcmVudCk7XG4gIHZhciB0YXJnZXQgPSBpc0JvZHkgPyBbd2luXS5jb25jYXQod2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc1Njcm9sbFBhcmVudChzY3JvbGxQYXJlbnQpID8gc2Nyb2xsUGFyZW50IDogW10pIDogc2Nyb2xsUGFyZW50O1xuICB2YXIgdXBkYXRlZExpc3QgPSBsaXN0LmNvbmNhdCh0YXJnZXQpO1xuICByZXR1cm4gaXNCb2R5ID8gdXBkYXRlZExpc3QgOiAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogaXNCb2R5IHRlbGxzIHVzIHRhcmdldCB3aWxsIGJlIGFuIEhUTUxFbGVtZW50IGhlcmVcbiAgdXBkYXRlZExpc3QuY29uY2F0KGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUodGFyZ2V0KSkpO1xufSIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJlY3QsIHtcbiAgICBsZWZ0OiByZWN0LngsXG4gICAgdG9wOiByZWN0LnksXG4gICAgcmlnaHQ6IHJlY3QueCArIHJlY3Qud2lkdGgsXG4gICAgYm90dG9tOiByZWN0LnkgKyByZWN0LmhlaWdodFxuICB9KTtcbn0iLCAiaW1wb3J0IHsgdmlld3BvcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRWaWV3cG9ydFJlY3QgZnJvbSBcIi4vZ2V0Vmlld3BvcnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRSZWN0IGZyb20gXCIuL2dldERvY3VtZW50UmVjdC5qc1wiO1xuaW1wb3J0IGxpc3RTY3JvbGxQYXJlbnRzIGZyb20gXCIuL2xpc3RTY3JvbGxQYXJlbnRzLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgY29udGFpbnMgZnJvbSBcIi4vY29udGFpbnMuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHJlY3RUb0NsaWVudFJlY3QgZnJvbSBcIi4uL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCB7IG1heCwgbWluIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcblxuZnVuY3Rpb24gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgZmFsc2UsIHN0cmF0ZWd5ID09PSAnZml4ZWQnKTtcbiAgcmVjdC50b3AgPSByZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50VG9wO1xuICByZWN0LmxlZnQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudExlZnQ7XG4gIHJlY3QuYm90dG9tID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC5yaWdodCA9IHJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIHJlY3Qud2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LmhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICByZWN0LnggPSByZWN0LmxlZnQ7XG4gIHJlY3QueSA9IHJlY3QudG9wO1xuICByZXR1cm4gcmVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSB7XG4gIHJldHVybiBjbGlwcGluZ1BhcmVudCA9PT0gdmlld3BvcnQgPyByZWN0VG9DbGllbnRSZWN0KGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSkpIDogaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSA/IGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkgOiByZWN0VG9DbGllbnRSZWN0KGdldERvY3VtZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpKTtcbn0gLy8gQSBcImNsaXBwaW5nIHBhcmVudFwiIGlzIGFuIG92ZXJmbG93YWJsZSBjb250YWluZXIgd2l0aCB0aGUgY2hhcmFjdGVyaXN0aWMgb2Zcbi8vIGNsaXBwaW5nIChvciBoaWRpbmcpIG92ZXJmbG93aW5nIGVsZW1lbnRzIHdpdGggYSBwb3NpdGlvbiBkaWZmZXJlbnQgZnJvbVxuLy8gYGluaXRpYWxgXG5cblxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIHtcbiAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xuICB2YXIgY2FuRXNjYXBlQ2xpcHBpbmcgPSBbJ2Fic29sdXRlJywgJ2ZpeGVkJ10uaW5kZXhPZihnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uKSA+PSAwO1xuICB2YXIgY2xpcHBlckVsZW1lbnQgPSBjYW5Fc2NhcGVDbGlwcGluZyAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpID8gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIDogZWxlbWVudDtcblxuICBpZiAoIWlzRWxlbWVudChjbGlwcGVyRWxlbWVudCkpIHtcbiAgICByZXR1cm4gW107XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzE0MTRcblxuXG4gIHJldHVybiBjbGlwcGluZ1BhcmVudHMuZmlsdGVyKGZ1bmN0aW9uIChjbGlwcGluZ1BhcmVudCkge1xuICAgIHJldHVybiBpc0VsZW1lbnQoY2xpcHBpbmdQYXJlbnQpICYmIGNvbnRhaW5zKGNsaXBwaW5nUGFyZW50LCBjbGlwcGVyRWxlbWVudCkgJiYgZ2V0Tm9kZU5hbWUoY2xpcHBpbmdQYXJlbnQpICE9PSAnYm9keSc7XG4gIH0pO1xufSAvLyBHZXRzIHRoZSBtYXhpbXVtIGFyZWEgdGhhdCB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIGluIGR1ZSB0byBhbnkgbnVtYmVyIG9mXG4vLyBjbGlwcGluZyBwYXJlbnRzXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KGVsZW1lbnQsIGJvdW5kYXJ5LCByb290Qm91bmRhcnksIHN0cmF0ZWd5KSB7XG4gIHZhciBtYWluQ2xpcHBpbmdQYXJlbnRzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ1BhcmVudHMnID8gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIDogW10uY29uY2F0KGJvdW5kYXJ5KTtcbiAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IFtdLmNvbmNhdChtYWluQ2xpcHBpbmdQYXJlbnRzLCBbcm9vdEJvdW5kYXJ5XSk7XG4gIHZhciBmaXJzdENsaXBwaW5nUGFyZW50ID0gY2xpcHBpbmdQYXJlbnRzWzBdO1xuICB2YXIgY2xpcHBpbmdSZWN0ID0gY2xpcHBpbmdQYXJlbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjUmVjdCwgY2xpcHBpbmdQYXJlbnQpIHtcbiAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSk7XG4gICAgYWNjUmVjdC50b3AgPSBtYXgocmVjdC50b3AsIGFjY1JlY3QudG9wKTtcbiAgICBhY2NSZWN0LnJpZ2h0ID0gbWluKHJlY3QucmlnaHQsIGFjY1JlY3QucmlnaHQpO1xuICAgIGFjY1JlY3QuYm90dG9tID0gbWluKHJlY3QuYm90dG9tLCBhY2NSZWN0LmJvdHRvbSk7XG4gICAgYWNjUmVjdC5sZWZ0ID0gbWF4KHJlY3QubGVmdCwgYWNjUmVjdC5sZWZ0KTtcbiAgICByZXR1cm4gYWNjUmVjdDtcbiAgfSwgZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgZmlyc3RDbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpKTtcbiAgY2xpcHBpbmdSZWN0LndpZHRoID0gY2xpcHBpbmdSZWN0LnJpZ2h0IC0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC5oZWlnaHQgPSBjbGlwcGluZ1JlY3QuYm90dG9tIC0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgY2xpcHBpbmdSZWN0LnggPSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LnkgPSBjbGlwcGluZ1JlY3QudG9wO1xuICByZXR1cm4gY2xpcHBpbmdSZWN0O1xufSIsICJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgc3RhcnQsIGVuZCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZU9mZnNldHMoX3JlZikge1xuICB2YXIgcmVmZXJlbmNlID0gX3JlZi5yZWZlcmVuY2UsXG4gICAgICBlbGVtZW50ID0gX3JlZi5lbGVtZW50LFxuICAgICAgcGxhY2VtZW50ID0gX3JlZi5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50ID8gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIDogbnVsbDtcbiAgdmFyIHZhcmlhdGlvbiA9IHBsYWNlbWVudCA/IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIDogbnVsbDtcbiAgdmFyIGNvbW1vblggPSByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCAvIDIgLSBlbGVtZW50LndpZHRoIC8gMjtcbiAgdmFyIGNvbW1vblkgPSByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gZWxlbWVudC5oZWlnaHQgLyAyO1xuICB2YXIgb2Zmc2V0cztcblxuICBzd2l0Y2ggKGJhc2VQbGFjZW1lbnQpIHtcbiAgICBjYXNlIHRvcDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55IC0gZWxlbWVudC5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgYm90dG9tOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHJpZ2h0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgbGVmdDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54IC0gZWxlbWVudC53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54LFxuICAgICAgICB5OiByZWZlcmVuY2UueVxuICAgICAgfTtcbiAgfVxuXG4gIHZhciBtYWluQXhpcyA9IGJhc2VQbGFjZW1lbnQgPyBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCkgOiBudWxsO1xuXG4gIGlmIChtYWluQXhpcyAhPSBudWxsKSB7XG4gICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICBzd2l0Y2ggKHZhcmlhdGlvbikge1xuICAgICAgY2FzZSBzdGFydDpcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSAtIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgZW5kOlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdICsgKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn0iLCAiaW1wb3J0IGdldENsaXBwaW5nUmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldENsaXBwaW5nUmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGNvbXB1dGVPZmZzZXRzIGZyb20gXCIuL2NvbXB1dGVPZmZzZXRzLmpzXCI7XG5pbXBvcnQgcmVjdFRvQ2xpZW50UmVjdCBmcm9tIFwiLi9yZWN0VG9DbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgeyBjbGlwcGluZ1BhcmVudHMsIHJlZmVyZW5jZSwgcG9wcGVyLCBib3R0b20sIHRvcCwgcmlnaHQsIGJhc2VQbGFjZW1lbnRzLCB2aWV3cG9ydCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4uL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgbWVyZ2VQYWRkaW5nT2JqZWN0IGZyb20gXCIuL21lcmdlUGFkZGluZ09iamVjdC5qc1wiO1xuaW1wb3J0IGV4cGFuZFRvSGFzaE1hcCBmcm9tIFwiLi9leHBhbmRUb0hhc2hNYXAuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIF9vcHRpb25zJHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcbiAgICAgIHBsYWNlbWVudCA9IF9vcHRpb25zJHBsYWNlbWVudCA9PT0gdm9pZCAwID8gc3RhdGUucGxhY2VtZW50IDogX29wdGlvbnMkcGxhY2VtZW50LFxuICAgICAgX29wdGlvbnMkc3RyYXRlZ3kgPSBfb3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIHN0cmF0ZWd5ID0gX29wdGlvbnMkc3RyYXRlZ3kgPT09IHZvaWQgMCA/IHN0YXRlLnN0cmF0ZWd5IDogX29wdGlvbnMkc3RyYXRlZ3ksXG4gICAgICBfb3B0aW9ucyRib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucyRib3VuZGFyeSA9PT0gdm9pZCAwID8gY2xpcHBpbmdQYXJlbnRzIDogX29wdGlvbnMkYm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRyb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucyRyb290Qm91bmRhcnkgPT09IHZvaWQgMCA/IHZpZXdwb3J0IDogX29wdGlvbnMkcm9vdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZWxlbWVudENvbnRlID0gX29wdGlvbnMuZWxlbWVudENvbnRleHQsXG4gICAgICBlbGVtZW50Q29udGV4dCA9IF9vcHRpb25zJGVsZW1lbnRDb250ZSA9PT0gdm9pZCAwID8gcG9wcGVyIDogX29wdGlvbnMkZWxlbWVudENvbnRlLFxuICAgICAgX29wdGlvbnMkYWx0Qm91bmRhcnkgPSBfb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMkYWx0Qm91bmRhcnkgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucyRwYWRkaW5nID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkcGFkZGluZztcbiAgdmFyIHBhZGRpbmdPYmplY3QgPSBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xuICB2YXIgYWx0Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyByZWZlcmVuY2UgOiBwb3BwZXI7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW2FsdEJvdW5kYXJ5ID8gYWx0Q29udGV4dCA6IGVsZW1lbnRDb250ZXh0XTtcbiAgdmFyIGNsaXBwaW5nQ2xpZW50UmVjdCA9IGdldENsaXBwaW5nUmVjdChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50IDogZWxlbWVudC5jb250ZXh0RWxlbWVudCB8fCBnZXREb2N1bWVudEVsZW1lbnQoc3RhdGUuZWxlbWVudHMucG9wcGVyKSwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSwgc3RyYXRlZ3kpO1xuICB2YXIgcmVmZXJlbmNlQ2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChzdGF0ZS5lbGVtZW50cy5yZWZlcmVuY2UpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHJlZmVyZW5jZUNsaWVudFJlY3QsXG4gICAgZWxlbWVudDogcG9wcGVyUmVjdCxcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICB9KTtcbiAgdmFyIHBvcHBlckNsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KE9iamVjdC5hc3NpZ24oe30sIHBvcHBlclJlY3QsIHBvcHBlck9mZnNldHMpKTtcbiAgdmFyIGVsZW1lbnRDbGllbnRSZWN0ID0gZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHBvcHBlckNsaWVudFJlY3QgOiByZWZlcmVuY2VDbGllbnRSZWN0OyAvLyBwb3NpdGl2ZSA9IG92ZXJmbG93aW5nIHRoZSBjbGlwcGluZyByZWN0XG4gIC8vIDAgb3IgbmVnYXRpdmUgPSB3aXRoaW4gdGhlIGNsaXBwaW5nIHJlY3RcblxuICB2YXIgb3ZlcmZsb3dPZmZzZXRzID0ge1xuICAgIHRvcDogY2xpcHBpbmdDbGllbnRSZWN0LnRvcCAtIGVsZW1lbnRDbGllbnRSZWN0LnRvcCArIHBhZGRpbmdPYmplY3QudG9wLFxuICAgIGJvdHRvbTogZWxlbWVudENsaWVudFJlY3QuYm90dG9tIC0gY2xpcHBpbmdDbGllbnRSZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tLFxuICAgIGxlZnQ6IGNsaXBwaW5nQ2xpZW50UmVjdC5sZWZ0IC0gZWxlbWVudENsaWVudFJlY3QubGVmdCArIHBhZGRpbmdPYmplY3QubGVmdCxcbiAgICByaWdodDogZWxlbWVudENsaWVudFJlY3QucmlnaHQgLSBjbGlwcGluZ0NsaWVudFJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0XG4gIH07XG4gIHZhciBvZmZzZXREYXRhID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQ7IC8vIE9mZnNldHMgY2FuIGJlIGFwcGxpZWQgb25seSB0byB0aGUgcG9wcGVyIGVsZW1lbnRcblxuICBpZiAoZWxlbWVudENvbnRleHQgPT09IHBvcHBlciAmJiBvZmZzZXREYXRhKSB7XG4gICAgdmFyIG9mZnNldCA9IG9mZnNldERhdGFbcGxhY2VtZW50XTtcbiAgICBPYmplY3Qua2V5cyhvdmVyZmxvd09mZnNldHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIG11bHRpcGx5ID0gW3JpZ2h0LCBib3R0b21dLmluZGV4T2Yoa2V5KSA+PSAwID8gMSA6IC0xO1xuICAgICAgdmFyIGF4aXMgPSBbdG9wLCBib3R0b21dLmluZGV4T2Yoa2V5KSA+PSAwID8gJ3knIDogJ3gnO1xuICAgICAgb3ZlcmZsb3dPZmZzZXRzW2tleV0gKz0gb2Zmc2V0W2F4aXNdICogbXVsdGlwbHk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gb3ZlcmZsb3dPZmZzZXRzO1xufSIsICJpbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IHsgdmFyaWF0aW9uUGxhY2VtZW50cywgYmFzZVBsYWNlbWVudHMsIHBsYWNlbWVudHMgYXMgYWxsUGxhY2VtZW50cyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChzdGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMuZmxpcFZhcmlhdGlvbnMsXG4gICAgICBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPSBfb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHMsXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPT09IHZvaWQgMCA/IGFsbFBsYWNlbWVudHMgOiBfb3B0aW9ucyRhbGxvd2VkQXV0b1A7XG4gIHZhciB2YXJpYXRpb24gPSBnZXRWYXJpYXRpb24ocGxhY2VtZW50KTtcbiAgdmFyIHBsYWNlbWVudHMgPSB2YXJpYXRpb24gPyBmbGlwVmFyaWF0aW9ucyA/IHZhcmlhdGlvblBsYWNlbWVudHMgOiB2YXJpYXRpb25QbGFjZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSB2YXJpYXRpb247XG4gIH0pIDogYmFzZVBsYWNlbWVudHM7XG4gIHZhciBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gYWxsb3dlZEF1dG9QbGFjZW1lbnRzLmluZGV4T2YocGxhY2VtZW50KSA+PSAwO1xuICB9KTtcblxuICBpZiAoYWxsb3dlZFBsYWNlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzO1xuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdOiBGbG93IHNlZW1zIHRvIGhhdmUgcHJvYmxlbXMgd2l0aCB0d28gYXJyYXkgdW5pb25zLi4uXG5cblxuICB2YXIgb3ZlcmZsb3dzID0gYWxsb3dlZFBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIGFjY1twbGFjZW1lbnRdID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgfSlbZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpXTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvdmVyZmxvd3MpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3dzW2FdIC0gb3ZlcmZsb3dzW2JdO1xuICB9KTtcbn0iLCAiaW1wb3J0IGdldE9wcG9zaXRlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBjb21wdXRlQXV0b1BsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IGJvdHRvbSwgdG9wLCBzdGFydCwgcmlnaHQsIGxlZnQsIGF1dG8gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4uL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmZ1bmN0aW9uIGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBpZiAoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgcmV0dXJuIFtnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpXTtcbn1cblxuZnVuY3Rpb24gZmxpcChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyA9IG9wdGlvbnMuZmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZmxpcFZhcmlhdGlvID0gb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMkZmxpcFZhcmlhdGlvID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZmxpcFZhcmlhdGlvLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHM7XG4gIHZhciBwcmVmZXJyZWRQbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSBiYXNlUGxhY2VtZW50ID09PSBwcmVmZXJyZWRQbGFjZW1lbnQ7XG4gIHZhciBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcFZhcmlhdGlvbnMgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwcmVmZXJyZWRQbGFjZW1lbnQpKTtcbiAgdmFyIHBsYWNlbWVudHMgPSBbcHJlZmVycmVkUGxhY2VtZW50XS5jb25jYXQoZmFsbGJhY2tQbGFjZW1lbnRzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvID8gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnM6IGZsaXBWYXJpYXRpb25zLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzOiBhbGxvd2VkQXV0b1BsYWNlbWVudHNcbiAgICB9KSA6IHBsYWNlbWVudCk7XG4gIH0sIFtdKTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgY2hlY2tzTWFwID0gbmV3IE1hcCgpO1xuICB2YXIgbWFrZUZhbGxiYWNrQ2hlY2tzID0gdHJ1ZTtcbiAgdmFyIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHNbMF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbGFjZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBsYWNlbWVudCA9IHBsYWNlbWVudHNbaV07XG5cbiAgICB2YXIgX2Jhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICB2YXIgaXNTdGFydFZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSBzdGFydDtcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihfYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KTtcbiAgICB2YXIgbWFpblZhcmlhdGlvblNpZGUgPSBpc1ZlcnRpY2FsID8gaXNTdGFydFZhcmlhdGlvbiA/IHJpZ2h0IDogbGVmdCA6IGlzU3RhcnRWYXJpYXRpb24gPyBib3R0b20gOiB0b3A7XG5cbiAgICBpZiAocmVmZXJlbmNlUmVjdFtsZW5dID4gcG9wcGVyUmVjdFtsZW5dKSB7XG4gICAgICBtYWluVmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB9XG5cbiAgICB2YXIgYWx0VmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB2YXIgY2hlY2tzID0gW107XG5cbiAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbX2Jhc2VQbGFjZW1lbnRdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W21haW5WYXJpYXRpb25TaWRlXSA8PSAwLCBvdmVyZmxvd1thbHRWYXJpYXRpb25TaWRlXSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tzLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgcmV0dXJuIGNoZWNrO1xuICAgIH0pKSB7XG4gICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICBtYWtlRmFsbGJhY2tDaGVja3MgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNoZWNrc01hcC5zZXQocGxhY2VtZW50LCBjaGVja3MpO1xuICB9XG5cbiAgaWYgKG1ha2VGYWxsYmFja0NoZWNrcykge1xuICAgIC8vIGAyYCBtYXkgYmUgZGVzaXJlZCBpbiBzb21lIGNhc2VzIFx1MjAxMyByZXNlYXJjaCBsYXRlclxuICAgIHZhciBudW1iZXJPZkNoZWNrcyA9IGZsaXBWYXJpYXRpb25zID8gMyA6IDE7XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfaSkge1xuICAgICAgdmFyIGZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzLmZpbmQoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgICAgICB2YXIgY2hlY2tzID0gY2hlY2tzTWFwLmdldChwbGFjZW1lbnQpO1xuXG4gICAgICAgIGlmIChjaGVja3MpIHtcbiAgICAgICAgICByZXR1cm4gY2hlY2tzLnNsaWNlKDAsIF9pKS5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVjaztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChmaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IGZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pID0gbnVtYmVyT2ZDaGVja3M7IF9pID4gMDsgX2ktLSkge1xuICAgICAgdmFyIF9yZXQgPSBfbG9vcChfaSk7XG5cbiAgICAgIGlmIChfcmV0ID09PSBcImJyZWFrXCIpIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5wbGFjZW1lbnQgIT09IGZpcnN0Rml0dGluZ1BsYWNlbWVudCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXAgPSB0cnVlO1xuICAgIHN0YXRlLnBsYWNlbWVudCA9IGZpcnN0Rml0dGluZ1BsYWNlbWVudDtcbiAgICBzdGF0ZS5yZXNldCA9IHRydWU7XG4gIH1cbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2ZsaXAnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogZmxpcCxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXSxcbiAgZGF0YToge1xuICAgIF9za2lwOiBmYWxzZVxuICB9XG59OyIsICJpbXBvcnQgeyB0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcblxuZnVuY3Rpb24gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3QsIHByZXZlbnRlZE9mZnNldHMpIHtcbiAgaWYgKHByZXZlbnRlZE9mZnNldHMgPT09IHZvaWQgMCkge1xuICAgIHByZXZlbnRlZE9mZnNldHMgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvcDogb3ZlcmZsb3cudG9wIC0gcmVjdC5oZWlnaHQgLSBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgcmlnaHQ6IG92ZXJmbG93LnJpZ2h0IC0gcmVjdC53aWR0aCArIHByZXZlbnRlZE9mZnNldHMueCxcbiAgICBib3R0b206IG92ZXJmbG93LmJvdHRvbSAtIHJlY3QuaGVpZ2h0ICsgcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIGxlZnQ6IG92ZXJmbG93LmxlZnQgLSByZWN0LndpZHRoIC0gcHJldmVudGVkT2Zmc2V0cy54XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvdmVyZmxvdykge1xuICByZXR1cm4gW3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdF0uc29tZShmdW5jdGlvbiAoc2lkZSkge1xuICAgIHJldHVybiBvdmVyZmxvd1tzaWRlXSA+PSAwO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaGlkZShfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBwcmV2ZW50ZWRPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wcmV2ZW50T3ZlcmZsb3c7XG4gIHZhciByZWZlcmVuY2VPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgZWxlbWVudENvbnRleHQ6ICdyZWZlcmVuY2UnXG4gIH0pO1xuICB2YXIgcG9wcGVyQWx0T3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGFsdEJvdW5kYXJ5OiB0cnVlXG4gIH0pO1xuICB2YXIgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocmVmZXJlbmNlT3ZlcmZsb3csIHJlZmVyZW5jZVJlY3QpO1xuICB2YXIgcG9wcGVyRXNjYXBlT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHBvcHBlckFsdE92ZXJmbG93LCBwb3BwZXJSZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKTtcbiAgdmFyIGlzUmVmZXJlbmNlSGlkZGVuID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyk7XG4gIHZhciBoYXNQb3BwZXJFc2NhcGVkID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHBvcHBlckVzY2FwZU9mZnNldHMpO1xuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0ge1xuICAgIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0czogcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzLFxuICAgIHBvcHBlckVzY2FwZU9mZnNldHM6IHBvcHBlckVzY2FwZU9mZnNldHMsXG4gICAgaXNSZWZlcmVuY2VIaWRkZW46IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgIGhhc1BvcHBlckVzY2FwZWQ6IGhhc1BvcHBlckVzY2FwZWRcbiAgfTtcbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1yZWZlcmVuY2UtaGlkZGVuJzogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgJ2RhdGEtcG9wcGVyLWVzY2FwZWQnOiBoYXNQb3BwZXJFc2NhcGVkXG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnaGlkZScsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J10sXG4gIGZuOiBoaWRlXG59OyIsICJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgcGxhY2VtZW50cyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHJlY3RzLCBvZmZzZXQpIHtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciBpbnZlcnREaXN0YW5jZSA9IFtsZWZ0LCB0b3BdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IC0xIDogMTtcblxuICB2YXIgX3JlZiA9IHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicgPyBvZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgcmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICB9KSkgOiBvZmZzZXQsXG4gICAgICBza2lkZGluZyA9IF9yZWZbMF0sXG4gICAgICBkaXN0YW5jZSA9IF9yZWZbMV07XG5cbiAgc2tpZGRpbmcgPSBza2lkZGluZyB8fCAwO1xuICBkaXN0YW5jZSA9IChkaXN0YW5jZSB8fCAwKSAqIGludmVydERpc3RhbmNlO1xuICByZXR1cm4gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyB7XG4gICAgeDogZGlzdGFuY2UsXG4gICAgeTogc2tpZGRpbmdcbiAgfSA6IHtcbiAgICB4OiBza2lkZGluZyxcbiAgICB5OiBkaXN0YW5jZVxuICB9O1xufVxuXG5mdW5jdGlvbiBvZmZzZXQoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmMi5uYW1lO1xuICB2YXIgX29wdGlvbnMkb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQsXG4gICAgICBvZmZzZXQgPSBfb3B0aW9ucyRvZmZzZXQgPT09IHZvaWQgMCA/IFswLCAwXSA6IF9vcHRpb25zJG9mZnNldDtcbiAgdmFyIGRhdGEgPSBwbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgc3RhdGUucmVjdHMsIG9mZnNldCk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICB2YXIgX2RhdGEkc3RhdGUkcGxhY2VtZW50ID0gZGF0YVtzdGF0ZS5wbGFjZW1lbnRdLFxuICAgICAgeCA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC54LFxuICAgICAgeSA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC55O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy54ICs9IHg7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgKz0geTtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnb2Zmc2V0JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICBmbjogb2Zmc2V0XG59OyIsICJpbXBvcnQgY29tcHV0ZU9mZnNldHMgZnJvbSBcIi4uL3V0aWxzL2NvbXB1dGVPZmZzZXRzLmpzXCI7XG5cbmZ1bmN0aW9uIHBvcHBlck9mZnNldHMoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgLy8gT2Zmc2V0cyBhcmUgdGhlIGFjdHVhbCBwb3NpdGlvbiB0aGUgcG9wcGVyIG5lZWRzIHRvIGhhdmUgdG8gYmVcbiAgLy8gcHJvcGVybHkgcG9zaXRpb25lZCBuZWFyIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUaGlzIGlzIHRoZSBtb3N0IGJhc2ljIHBsYWNlbWVudCwgYW5kIHdpbGwgYmUgYWRqdXN0ZWQgYnlcbiAgLy8gdGhlIG1vZGlmaWVycyBpbiB0aGUgbmV4dCBzdGVwXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiBzdGF0ZS5yZWN0cy5yZWZlcmVuY2UsXG4gICAgZWxlbWVudDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAncG9wcGVyT2Zmc2V0cycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAncmVhZCcsXG4gIGZuOiBwb3BwZXJPZmZzZXRzLFxuICBkYXRhOiB7fVxufTsiLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QWx0QXhpcyhheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneCcgPyAneScgOiAneCc7XG59IiwgImltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgc3RhcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRBbHRBeGlzIGZyb20gXCIuLi91dGlscy9nZXRBbHRBeGlzLmpzXCI7XG5pbXBvcnQgeyB3aXRoaW4sIHdpdGhpbk1heENsYW1wIH0gZnJvbSBcIi4uL3V0aWxzL3dpdGhpbi5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCBnZXRGcmVzaFNpZGVPYmplY3QgZnJvbSBcIi4uL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qc1wiO1xuaW1wb3J0IHsgbWluIGFzIG1hdGhNaW4sIG1heCBhcyBtYXRoTWF4IH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcblxuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxuICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXG4gICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgX29wdGlvbnMkdGV0aGVyID0gb3B0aW9ucy50ZXRoZXIsXG4gICAgICB0ZXRoZXIgPSBfb3B0aW9ucyR0ZXRoZXIgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyR0ZXRoZXIsXG4gICAgICBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPSBvcHRpb25zLnRldGhlck9mZnNldCxcbiAgICAgIHRldGhlck9mZnNldCA9IF9vcHRpb25zJHRldGhlck9mZnNldCA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHRldGhlck9mZnNldDtcbiAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgcGFkZGluZzogcGFkZGluZyxcbiAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnlcbiAgfSk7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSAhdmFyaWF0aW9uO1xuICB2YXIgbWFpbkF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBhbHRBeGlzID0gZ2V0QWx0QXhpcyhtYWluQXhpcyk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciB0ZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXQgPT09ICdmdW5jdGlvbicgPyB0ZXRoZXJPZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiB0ZXRoZXJPZmZzZXQ7XG4gIHZhciBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0VmFsdWUgPT09ICdudW1iZXInID8ge1xuICAgIG1haW5BeGlzOiB0ZXRoZXJPZmZzZXRWYWx1ZSxcbiAgICBhbHRBeGlzOiB0ZXRoZXJPZmZzZXRWYWx1ZVxuICB9IDogT2JqZWN0LmFzc2lnbih7XG4gICAgbWFpbkF4aXM6IDAsXG4gICAgYWx0QXhpczogMFxuICB9LCB0ZXRoZXJPZmZzZXRWYWx1ZSk7XG4gIHZhciBvZmZzZXRNb2RpZmllclN0YXRlID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQgPyBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldFtzdGF0ZS5wbGFjZW1lbnRdIDogbnVsbDtcbiAgdmFyIGRhdGEgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKCFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICB2YXIgX29mZnNldE1vZGlmaWVyU3RhdGUkO1xuXG4gICAgdmFyIG1haW5TaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gICAgdmFyIGFsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgdmFyIG9mZnNldCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdO1xuICAgIHZhciBtaW4gPSBvZmZzZXQgKyBvdmVyZmxvd1ttYWluU2lkZV07XG4gICAgdmFyIG1heCA9IG9mZnNldCAtIG92ZXJmbG93W2FsdFNpZGVdO1xuICAgIHZhciBhZGRpdGl2ZSA9IHRldGhlciA/IC1wb3BwZXJSZWN0W2xlbl0gLyAyIDogMDtcbiAgICB2YXIgbWluTGVuID0gdmFyaWF0aW9uID09PSBzdGFydCA/IHJlZmVyZW5jZVJlY3RbbGVuXSA6IHBvcHBlclJlY3RbbGVuXTtcbiAgICB2YXIgbWF4TGVuID0gdmFyaWF0aW9uID09PSBzdGFydCA/IC1wb3BwZXJSZWN0W2xlbl0gOiAtcmVmZXJlbmNlUmVjdFtsZW5dOyAvLyBXZSBuZWVkIHRvIGluY2x1ZGUgdGhlIGFycm93IGluIHRoZSBjYWxjdWxhdGlvbiBzbyB0aGUgYXJyb3cgZG9lc24ndCBnb1xuICAgIC8vIG91dHNpZGUgdGhlIHJlZmVyZW5jZSBib3VuZHNcblxuICAgIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgICB2YXIgYXJyb3dSZWN0ID0gdGV0aGVyICYmIGFycm93RWxlbWVudCA/IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KSA6IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nT2JqZWN0ID0gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddID8gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddLnBhZGRpbmcgOiBnZXRGcmVzaFNpZGVPYmplY3QoKTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nTWluID0gYXJyb3dQYWRkaW5nT2JqZWN0W21haW5TaWRlXTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nTWF4ID0gYXJyb3dQYWRkaW5nT2JqZWN0W2FsdFNpZGVdOyAvLyBJZiB0aGUgcmVmZXJlbmNlIGxlbmd0aCBpcyBzbWFsbGVyIHRoYW4gdGhlIGFycm93IGxlbmd0aCwgd2UgZG9uJ3Qgd2FudFxuICAgIC8vIHRvIGluY2x1ZGUgaXRzIGZ1bGwgc2l6ZSBpbiB0aGUgY2FsY3VsYXRpb24uIElmIHRoZSByZWZlcmVuY2UgaXMgc21hbGxcbiAgICAvLyBhbmQgbmVhciB0aGUgZWRnZSBvZiBhIGJvdW5kYXJ5LCB0aGUgcG9wcGVyIGNhbiBvdmVyZmxvdyBldmVuIGlmIHRoZVxuICAgIC8vIHJlZmVyZW5jZSBpcyBub3Qgb3ZlcmZsb3dpbmcgYXMgd2VsbCAoZS5nLiB2aXJ0dWFsIGVsZW1lbnRzIHdpdGggbm9cbiAgICAvLyB3aWR0aCBvciBoZWlnaHQpXG5cbiAgICB2YXIgYXJyb3dMZW4gPSB3aXRoaW4oMCwgcmVmZXJlbmNlUmVjdFtsZW5dLCBhcnJvd1JlY3RbbGVuXSk7XG4gICAgdmFyIG1pbk9mZnNldCA9IGlzQmFzZVBsYWNlbWVudCA/IHJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgLSBhZGRpdGl2ZSAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzIDogbWluTGVuIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXM7XG4gICAgdmFyIG1heE9mZnNldCA9IGlzQmFzZVBsYWNlbWVudCA/IC1yZWZlcmVuY2VSZWN0W2xlbl0gLyAyICsgYWRkaXRpdmUgKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcyA6IG1heExlbiArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzO1xuICAgIHZhciBhcnJvd09mZnNldFBhcmVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93ICYmIGdldE9mZnNldFBhcmVudChzdGF0ZS5lbGVtZW50cy5hcnJvdyk7XG4gICAgdmFyIGNsaWVudE9mZnNldCA9IGFycm93T2Zmc2V0UGFyZW50ID8gbWFpbkF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFRvcCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50TGVmdCB8fCAwIDogMDtcbiAgICB2YXIgb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IChfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQgPSBvZmZzZXRNb2RpZmllclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXRNb2RpZmllclN0YXRlW21haW5BeGlzXSkgIT0gbnVsbCA/IF9vZmZzZXRNb2RpZmllclN0YXRlJCA6IDA7XG4gICAgdmFyIHRldGhlck1pbiA9IG9mZnNldCArIG1pbk9mZnNldCAtIG9mZnNldE1vZGlmaWVyVmFsdWUgLSBjbGllbnRPZmZzZXQ7XG4gICAgdmFyIHRldGhlck1heCA9IG9mZnNldCArIG1heE9mZnNldCAtIG9mZnNldE1vZGlmaWVyVmFsdWU7XG4gICAgdmFyIHByZXZlbnRlZE9mZnNldCA9IHdpdGhpbih0ZXRoZXIgPyBtYXRoTWluKG1pbiwgdGV0aGVyTWluKSA6IG1pbiwgb2Zmc2V0LCB0ZXRoZXIgPyBtYXRoTWF4KG1heCwgdGV0aGVyTWF4KSA6IG1heCk7XG4gICAgcG9wcGVyT2Zmc2V0c1ttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQ7XG4gICAgZGF0YVttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQgLSBvZmZzZXQ7XG4gIH1cblxuICBpZiAoY2hlY2tBbHRBeGlzKSB7XG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclN0YXRlJDI7XG5cbiAgICB2YXIgX21haW5TaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IHRvcCA6IGxlZnQ7XG5cbiAgICB2YXIgX2FsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gYm90dG9tIDogcmlnaHQ7XG5cbiAgICB2YXIgX29mZnNldCA9IHBvcHBlck9mZnNldHNbYWx0QXhpc107XG5cbiAgICB2YXIgX2xlbiA9IGFsdEF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIHZhciBfbWluID0gX29mZnNldCArIG92ZXJmbG93W19tYWluU2lkZV07XG5cbiAgICB2YXIgX21heCA9IF9vZmZzZXQgLSBvdmVyZmxvd1tfYWx0U2lkZV07XG5cbiAgICB2YXIgaXNPcmlnaW5TaWRlID0gW3RvcCwgbGVmdF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgICB2YXIgX29mZnNldE1vZGlmaWVyVmFsdWUgPSAoX29mZnNldE1vZGlmaWVyU3RhdGUkMiA9IG9mZnNldE1vZGlmaWVyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IG9mZnNldE1vZGlmaWVyU3RhdGVbYWx0QXhpc10pICE9IG51bGwgPyBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyIDogMDtcblxuICAgIHZhciBfdGV0aGVyTWluID0gaXNPcmlnaW5TaWRlID8gX21pbiA6IF9vZmZzZXQgLSByZWZlcmVuY2VSZWN0W19sZW5dIC0gcG9wcGVyUmVjdFtfbGVuXSAtIF9vZmZzZXRNb2RpZmllclZhbHVlICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLmFsdEF4aXM7XG5cbiAgICB2YXIgX3RldGhlck1heCA9IGlzT3JpZ2luU2lkZSA/IF9vZmZzZXQgKyByZWZlcmVuY2VSZWN0W19sZW5dICsgcG9wcGVyUmVjdFtfbGVuXSAtIF9vZmZzZXRNb2RpZmllclZhbHVlIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLmFsdEF4aXMgOiBfbWF4O1xuXG4gICAgdmFyIF9wcmV2ZW50ZWRPZmZzZXQgPSB0ZXRoZXIgJiYgaXNPcmlnaW5TaWRlID8gd2l0aGluTWF4Q2xhbXAoX3RldGhlck1pbiwgX29mZnNldCwgX3RldGhlck1heCkgOiB3aXRoaW4odGV0aGVyID8gX3RldGhlck1pbiA6IF9taW4sIF9vZmZzZXQsIHRldGhlciA/IF90ZXRoZXJNYXggOiBfbWF4KTtcblxuICAgIHBvcHBlck9mZnNldHNbYWx0QXhpc10gPSBfcHJldmVudGVkT2Zmc2V0O1xuICAgIGRhdGFbYWx0QXhpc10gPSBfcHJldmVudGVkT2Zmc2V0IC0gX29mZnNldDtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IHByZXZlbnRPdmVyZmxvdyxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXVxufTsiLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0SFRNTEVsZW1lbnRTY3JvbGwoZWxlbWVudCkge1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsVG9wXG4gIH07XG59IiwgImltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRIVE1MRWxlbWVudFNjcm9sbCBmcm9tIFwiLi9nZXRIVE1MRWxlbWVudFNjcm9sbC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChub2RlKSB7XG4gIGlmIChub2RlID09PSBnZXRXaW5kb3cobm9kZSkgfHwgIWlzSFRNTEVsZW1lbnQobm9kZSkpIHtcbiAgICByZXR1cm4gZ2V0V2luZG93U2Nyb2xsKG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXRIVE1MRWxlbWVudFNjcm9sbChub2RlKTtcbiAgfVxufSIsICJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldE5vZGVTY3JvbGwgZnJvbSBcIi4vZ2V0Tm9kZVNjcm9sbC5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuaW1wb3J0IHsgcm91bmQgfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBpc0VsZW1lbnRTY2FsZWQoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzY2FsZVggPSByb3VuZChyZWN0LndpZHRoKSAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMTtcbiAgdmFyIHNjYWxlWSA9IHJvdW5kKHJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDE7XG4gIHJldHVybiBzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxO1xufSAvLyBSZXR1cm5zIHRoZSBjb21wb3NpdGUgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuXG4vLyBDb21wb3NpdGUgbWVhbnMgaXQgdGFrZXMgaW50byBhY2NvdW50IHRyYW5zZm9ybXMgYXMgd2VsbCBhcyBsYXlvdXQuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29tcG9zaXRlUmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50LCBpc0ZpeGVkKSB7XG4gIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkID0gZmFsc2U7XG4gIH1cblxuICB2YXIgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIHZhciBvZmZzZXRQYXJlbnRJc1NjYWxlZCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBpc0VsZW1lbnRTY2FsZWQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50SXNTY2FsZWQsIGlzRml4ZWQpO1xuICB2YXIgc2Nyb2xsID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH07XG4gIHZhciBvZmZzZXRzID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTA3OFxuICAgIGlzU2Nyb2xsUGFyZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBvZmZzZXRzID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCwgdHJ1ZSk7XG4gICAgICBvZmZzZXRzLnggKz0gb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgKz0gb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgb2Zmc2V0cy54ID0gZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLngsXG4gICAgeTogcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfTtcbn0iLCAiaW1wb3J0IHsgbW9kaWZpZXJQaGFzZXMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjsgLy8gc291cmNlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTg3NTI1NVxuXG5mdW5jdGlvbiBvcmRlcihtb2RpZmllcnMpIHtcbiAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgbWFwLnNldChtb2RpZmllci5uYW1lLCBtb2RpZmllcik7XG4gIH0pOyAvLyBPbiB2aXNpdGluZyBvYmplY3QsIGNoZWNrIGZvciBpdHMgZGVwZW5kZW5jaWVzIGFuZCB2aXNpdCB0aGVtIHJlY3Vyc2l2ZWx5XG5cbiAgZnVuY3Rpb24gc29ydChtb2RpZmllcikge1xuICAgIHZpc2l0ZWQuYWRkKG1vZGlmaWVyLm5hbWUpO1xuICAgIHZhciByZXF1aXJlcyA9IFtdLmNvbmNhdChtb2RpZmllci5yZXF1aXJlcyB8fCBbXSwgbW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cyB8fCBbXSk7XG4gICAgcmVxdWlyZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKGRlcCkpIHtcbiAgICAgICAgdmFyIGRlcE1vZGlmaWVyID0gbWFwLmdldChkZXApO1xuXG4gICAgICAgIGlmIChkZXBNb2RpZmllcikge1xuICAgICAgICAgIHNvcnQoZGVwTW9kaWZpZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzdWx0LnB1c2gobW9kaWZpZXIpO1xuICB9XG5cbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgaWYgKCF2aXNpdGVkLmhhcyhtb2RpZmllci5uYW1lKSkge1xuICAgICAgLy8gY2hlY2sgZm9yIHZpc2l0ZWQgb2JqZWN0XG4gICAgICBzb3J0KG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvcmRlck1vZGlmaWVycyhtb2RpZmllcnMpIHtcbiAgLy8gb3JkZXIgYmFzZWQgb24gZGVwZW5kZW5jaWVzXG4gIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXIobW9kaWZpZXJzKTsgLy8gb3JkZXIgYmFzZWQgb24gcGhhc2VcblxuICByZXR1cm4gbW9kaWZpZXJQaGFzZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBoYXNlKSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQob3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICByZXR1cm4gbW9kaWZpZXIucGhhc2UgPT09IHBoYXNlO1xuICAgIH0pKTtcbiAgfSwgW10pO1xufSIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWJvdW5jZShmbikge1xuICB2YXIgcGVuZGluZztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgIHBlbmRpbmcgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwZW5kaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHJlc29sdmUoZm4oKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBlbmRpbmc7XG4gIH07XG59IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlQnlOYW1lKG1vZGlmaWVycykge1xuICB2YXIgbWVyZ2VkID0gbW9kaWZpZXJzLnJlZHVjZShmdW5jdGlvbiAobWVyZ2VkLCBjdXJyZW50KSB7XG4gICAgdmFyIGV4aXN0aW5nID0gbWVyZ2VkW2N1cnJlbnQubmFtZV07XG4gICAgbWVyZ2VkW2N1cnJlbnQubmFtZV0gPSBleGlzdGluZyA/IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLCBjdXJyZW50LCB7XG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5vcHRpb25zLCBjdXJyZW50Lm9wdGlvbnMpLFxuICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcuZGF0YSwgY3VycmVudC5kYXRhKVxuICAgIH0pIDogY3VycmVudDtcbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9LCB7fSk7IC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QudmFsdWVzXG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1lcmdlZCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gbWVyZ2VkW2tleV07XG4gIH0pO1xufSIsICJpbXBvcnQgZ2V0Q29tcG9zaXRlUmVjdCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanNcIjtcbmltcG9ydCBsaXN0U2Nyb2xsUGFyZW50cyBmcm9tIFwiLi9kb20tdXRpbHMvbGlzdFNjcm9sbFBhcmVudHMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IG9yZGVyTW9kaWZpZXJzIGZyb20gXCIuL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzXCI7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSBcIi4vdXRpbHMvZGVib3VuY2UuanNcIjtcbmltcG9ydCBtZXJnZUJ5TmFtZSBmcm9tIFwiLi91dGlscy9tZXJnZUJ5TmFtZS5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiO1xudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgbW9kaWZpZXJzOiBbXSxcbiAgc3RyYXRlZ3k6ICdhYnNvbHV0ZSdcbn07XG5cbmZ1bmN0aW9uIGFyZVZhbGlkRWxlbWVudHMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gIWFyZ3Muc29tZShmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiAhKGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID09PSAnZnVuY3Rpb24nKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3BwZXJHZW5lcmF0b3IoZ2VuZXJhdG9yT3B0aW9ucykge1xuICBpZiAoZ2VuZXJhdG9yT3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgZ2VuZXJhdG9yT3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9nZW5lcmF0b3JPcHRpb25zID0gZ2VuZXJhdG9yT3B0aW9ucyxcbiAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRNb2RpZmllcnMsXG4gICAgICBkZWZhdWx0TW9kaWZpZXJzID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmID09PSB2b2lkIDAgPyBbXSA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZixcbiAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIGRlZmF1bHRPcHRpb25zID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9PT0gdm9pZCAwID8gREVGQVVMVF9PUFRJT05TIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmMjtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVBvcHBlcihyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICB9XG5cbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgb3JkZXJlZE1vZGlmaWVyczogW10sXG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIGRlZmF1bHRPcHRpb25zKSxcbiAgICAgIG1vZGlmaWVyc0RhdGE6IHt9LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlOiByZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlcjogcG9wcGVyXG4gICAgICB9LFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfTtcbiAgICB2YXIgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIHZhciBpc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHZhciBpbnN0YW5jZSA9IHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uIHNldE9wdGlvbnMoc2V0T3B0aW9uc0FjdGlvbikge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzZXRPcHRpb25zQWN0aW9uID09PSAnZnVuY3Rpb24nID8gc2V0T3B0aW9uc0FjdGlvbihzdGF0ZS5vcHRpb25zKSA6IHNldE9wdGlvbnNBY3Rpb247XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgc3RhdGUub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBzdGF0ZS5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGlzRWxlbWVudChyZWZlcmVuY2UpID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlKSA6IHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCkgOiBbXSxcbiAgICAgICAgICBwb3BwZXI6IGxpc3RTY3JvbGxQYXJlbnRzKHBvcHBlcilcbiAgICAgICAgfTsgLy8gT3JkZXJzIHRoZSBtb2RpZmllcnMgYmFzZWQgb24gdGhlaXIgZGVwZW5kZW5jaWVzIGFuZCBgcGhhc2VgXG4gICAgICAgIC8vIHByb3BlcnRpZXNcblxuICAgICAgICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyTW9kaWZpZXJzKG1lcmdlQnlOYW1lKFtdLmNvbmNhdChkZWZhdWx0TW9kaWZpZXJzLCBzdGF0ZS5vcHRpb25zLm1vZGlmaWVycykpKTsgLy8gU3RyaXAgb3V0IGRpc2FibGVkIG1vZGlmaWVyc1xuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHJldHVybiBtLmVuYWJsZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBydW5Nb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgfSxcbiAgICAgIC8vIFN5bmMgdXBkYXRlIFx1MjAxMyBpdCB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCwgZXZlbiBpZiBub3QgbmVjZXNzYXJ5LiBUaGlzXG4gICAgICAvLyBpcyB1c2VmdWwgZm9yIGxvdyBmcmVxdWVuY3kgdXBkYXRlcyB3aGVyZSBzeW5jIGJlaGF2aW9yIHNpbXBsaWZpZXMgdGhlXG4gICAgICAvLyBsb2dpYy5cbiAgICAgIC8vIEZvciBoaWdoIGZyZXF1ZW5jeSB1cGRhdGVzIChlLmcuIGByZXNpemVgIGFuZCBgc2Nyb2xsYCBldmVudHMpLCBhbHdheXNcbiAgICAgIC8vIHByZWZlciB0aGUgYXN5bmMgUG9wcGVyI3VwZGF0ZSBtZXRob2RcbiAgICAgIGZvcmNlVXBkYXRlOiBmdW5jdGlvbiBmb3JjZVVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKGlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9zdGF0ZSRlbGVtZW50cyA9IHN0YXRlLmVsZW1lbnRzLFxuICAgICAgICAgICAgcmVmZXJlbmNlID0gX3N0YXRlJGVsZW1lbnRzLnJlZmVyZW5jZSxcbiAgICAgICAgICAgIHBvcHBlciA9IF9zdGF0ZSRlbGVtZW50cy5wb3BwZXI7IC8vIERvbid0IHByb2NlZWQgaWYgYHJlZmVyZW5jZWAgb3IgYHBvcHBlcmAgYXJlIG5vdCB2YWxpZCBlbGVtZW50c1xuICAgICAgICAvLyBhbnltb3JlXG5cbiAgICAgICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBTdG9yZSB0aGUgcmVmZXJlbmNlIGFuZCBwb3BwZXIgcmVjdHMgdG8gYmUgcmVhZCBieSBtb2RpZmllcnNcblxuXG4gICAgICAgIHN0YXRlLnJlY3RzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogZ2V0Q29tcG9zaXRlUmVjdChyZWZlcmVuY2UsIGdldE9mZnNldFBhcmVudChwb3BwZXIpLCBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnKSxcbiAgICAgICAgICBwb3BwZXI6IGdldExheW91dFJlY3QocG9wcGVyKVxuICAgICAgICB9OyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byByZXNldCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUuIFRoZVxuICAgICAgICAvLyBtb3N0IGNvbW1vbiB1c2UgY2FzZSBmb3IgdGhpcyBpcyB0aGUgYGZsaXBgIG1vZGlmaWVyIGNoYW5naW5nIHRoZVxuICAgICAgICAvLyBwbGFjZW1lbnQsIHdoaWNoIHRoZW4gbmVlZHMgdG8gcmUtcnVuIGFsbCB0aGUgbW9kaWZpZXJzLCBiZWNhdXNlIHRoZVxuICAgICAgICAvLyBsb2dpYyB3YXMgcHJldmlvdXNseSByYW4gZm9yIHRoZSBwcmV2aW91cyBwbGFjZW1lbnQgYW5kIGlzIHRoZXJlZm9yZVxuICAgICAgICAvLyBzdGFsZS9pbmNvcnJlY3RcblxuICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5wbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDsgLy8gT24gZWFjaCB1cGRhdGUgY3ljbGUsIHRoZSBgbW9kaWZpZXJzRGF0YWAgcHJvcGVydHkgZm9yIGVhY2ggbW9kaWZpZXJcbiAgICAgICAgLy8gaXMgZmlsbGVkIHdpdGggdGhlIGluaXRpYWwgZGF0YSBzcGVjaWZpZWQgYnkgdGhlIG1vZGlmaWVyLiBUaGlzIG1lYW5zXG4gICAgICAgIC8vIGl0IGRvZXNuJ3QgcGVyc2lzdCBhbmQgaXMgZnJlc2ggb24gZWFjaCB1cGRhdGUuXG4gICAgICAgIC8vIFRvIGVuc3VyZSBwZXJzaXN0ZW50IGRhdGEsIHVzZSBgJHtuYW1lfSNwZXJzaXN0ZW50YFxuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUubW9kaWZpZXJzRGF0YVttb2RpZmllci5uYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIG1vZGlmaWVyLmRhdGEpO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBpZiAoc3RhdGUucmVzZXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZSA9IHN0YXRlLm9yZGVyZWRNb2RpZmllcnNbaW5kZXhdLFxuICAgICAgICAgICAgICBmbiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5mbixcbiAgICAgICAgICAgICAgX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5vcHRpb25zLFxuICAgICAgICAgICAgICBfb3B0aW9ucyA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPT09IHZvaWQgMCA/IHt9IDogX3N0YXRlJG9yZGVyZWRNb2RpZmllMixcbiAgICAgICAgICAgICAgbmFtZSA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5uYW1lO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3RhdGUgPSBmbih7XG4gICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgb3B0aW9uczogX29wdGlvbnMsXG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZVxuICAgICAgICAgICAgfSkgfHwgc3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gQXN5bmMgYW5kIG9wdGltaXN0aWNhbGx5IG9wdGltaXplZCB1cGRhdGUgXHUyMDEzIGl0IHdpbGwgbm90IGJlIGV4ZWN1dGVkIGlmXG4gICAgICAvLyBub3QgbmVjZXNzYXJ5IChkZWJvdW5jZWQgdG8gcnVuIGF0IG1vc3Qgb25jZS1wZXItdGljaylcbiAgICAgIHVwZGF0ZTogZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgIHJlc29sdmUoc3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICBpc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICBpZiAoIWlzRGVzdHJveWVkICYmIG9wdGlvbnMub25GaXJzdFVwZGF0ZSkge1xuICAgICAgICBvcHRpb25zLm9uRmlyc3RVcGRhdGUoc3RhdGUpO1xuICAgICAgfVxuICAgIH0pOyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIGJlZm9yZSB0aGUgZmlyc3RcbiAgICAvLyB1cGRhdGUgY3ljbGUgcnVucy4gVGhleSB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSB1cGRhdGVcbiAgICAvLyBjeWNsZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIG1vZGlmaWVyIGFkZHMgc29tZSBwZXJzaXN0ZW50IGRhdGEgdGhhdFxuICAgIC8vIG90aGVyIG1vZGlmaWVycyBuZWVkIHRvIHVzZSwgYnV0IHRoZSBtb2RpZmllciBpcyBydW4gYWZ0ZXIgdGhlIGRlcGVuZGVudFxuICAgIC8vIG9uZS5cblxuICAgIGZ1bmN0aW9uIHJ1bk1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgICAgICAgIF9yZWYkb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfcmVmJG9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX3JlZiRvcHRpb25zLFxuICAgICAgICAgICAgZWZmZWN0ID0gX3JlZi5lZmZlY3Q7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgY2xlYW51cEZuID0gZWZmZWN0KHtcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgbm9vcEZuID0gZnVuY3Rpb24gbm9vcEZuKCkge307XG5cbiAgICAgICAgICBlZmZlY3RDbGVhbnVwRm5zLnB1c2goY2xlYW51cEZuIHx8IG5vb3BGbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSk7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xufVxuZXhwb3J0IHZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgZGV0ZWN0T3ZlcmZsb3cgfTsiLCAiaW1wb3J0IHsgcG9wcGVyR2VuZXJhdG9yLCBkZXRlY3RPdmVyZmxvdyB9IGZyb20gXCIuL2NyZWF0ZVBvcHBlci5qc1wiO1xuaW1wb3J0IGV2ZW50TGlzdGVuZXJzIGZyb20gXCIuL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qc1wiO1xuaW1wb3J0IHBvcHBlck9mZnNldHMgZnJvbSBcIi4vbW9kaWZpZXJzL3BvcHBlck9mZnNldHMuanNcIjtcbmltcG9ydCBjb21wdXRlU3R5bGVzIGZyb20gXCIuL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzXCI7XG5pbXBvcnQgYXBwbHlTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzXCI7XG5pbXBvcnQgb2Zmc2V0IGZyb20gXCIuL21vZGlmaWVycy9vZmZzZXQuanNcIjtcbmltcG9ydCBmbGlwIGZyb20gXCIuL21vZGlmaWVycy9mbGlwLmpzXCI7XG5pbXBvcnQgcHJldmVudE92ZXJmbG93IGZyb20gXCIuL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBhcnJvdyBmcm9tIFwiLi9tb2RpZmllcnMvYXJyb3cuanNcIjtcbmltcG9ydCBoaWRlIGZyb20gXCIuL21vZGlmaWVycy9oaWRlLmpzXCI7XG52YXIgZGVmYXVsdE1vZGlmaWVycyA9IFtldmVudExpc3RlbmVycywgcG9wcGVyT2Zmc2V0cywgY29tcHV0ZVN0eWxlcywgYXBwbHlTdHlsZXMsIG9mZnNldCwgZmxpcCwgcHJldmVudE92ZXJmbG93LCBhcnJvdywgaGlkZV07XG52YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcih7XG4gIGRlZmF1bHRNb2RpZmllcnM6IGRlZmF1bHRNb2RpZmllcnNcbn0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGNyZWF0ZVBvcHBlciwgcG9wcGVyR2VuZXJhdG9yLCBkZWZhdWx0TW9kaWZpZXJzLCBkZXRlY3RPdmVyZmxvdyB9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGNyZWF0ZVBvcHBlciBhcyBjcmVhdGVQb3BwZXJMaXRlIH0gZnJvbSBcIi4vcG9wcGVyLWxpdGUuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgKiBmcm9tIFwiLi9tb2RpZmllcnMvaW5kZXguanNcIjsiLCAiLy8gQ3JlZGl0cyBnbyB0byBMaWFtJ3MgUGVyaW9kaWMgTm90ZXMgUGx1Z2luOiBodHRwczovL2dpdGh1Yi5jb20vbGlhbWNhaW4vb2JzaWRpYW4tcGVyaW9kaWMtbm90ZXNcbi8vIGFuZCBUZW1wbGF0ZXIgcGx1Z2luOiBodHRwczovL2dpdGh1Yi5jb20vU2lsZW50Vm9pZDEzL1RlbXBsYXRlciB3aGVyZSBJIGdvdCB0aGUgY29kZSBmb3IgdGhlIHN1Z2dlc3RlcnNcblxuaW1wb3J0IHsgVEFic3RyYWN0RmlsZSwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IFRleHRJbnB1dFN1Z2dlc3QgfSBmcm9tIFwiLi9zdWdnZXN0XCI7XG5pbXBvcnQgeyBnZXRGaWxlc0Zyb21Gb2xkZXIgfSBmcm9tIFwiLi4vdG9vbHNcIjtcbmltcG9ydCBGb2xkZXJUYWdQbHVnaW4gZnJvbSBcIi4uLy4uL21haW5cIjtcbmltcG9ydCB7IGVycm9yV3JhcHBlclN5bmMgfSBmcm9tIFwiLi4vRXJyb3JcIjtcblxuZXhwb3J0IGVudW0gRmlsZVN1Z2dlc3RNb2RlIHtcbiAgICBUZW1wbGF0ZUZpbGVzLFxuICAgIFNjcmlwdEZpbGVzLFxufVxuXG5leHBvcnQgY2xhc3MgRmlsZVN1Z2dlc3QgZXh0ZW5kcyBUZXh0SW5wdXRTdWdnZXN0PFRGaWxlPiB7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHVibGljIGlucHV0RWw6IEhUTUxJbnB1dEVsZW1lbnQsXG4gICAgICAgIHByaXZhdGUgcGx1Z2luOiBGb2xkZXJUYWdQbHVnaW4sXG4gICAgICAgIHByaXZhdGUgZm9sZGVyOiBzdHJpbmdcbiAgICApIHtcbiAgICAgICAgc3VwZXIocGx1Z2luLmFwcCwgaW5wdXRFbCk7XG4gICAgfVxuXG4gICAgZ2V0X2Vycm9yX21zZygpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gYEZvbGRlciAke3RoaXMuZm9sZGVyfSBkb2Vzbid0IGV4aXN0YDtcbiAgICB9XG5cbiAgICBnZXRTdWdnZXN0aW9ucyhpbnB1dF9zdHI6IHN0cmluZyk6IFRGaWxlW10ge1xuICAgICAgICBjb25zdCBhbGxfZmlsZXMgPSBlcnJvcldyYXBwZXJTeW5jKFxuICAgICAgICAgICAgKCkgPT4gZ2V0RmlsZXNGcm9tRm9sZGVyKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5hcHAsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9sZGVyXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHRoaXMuZ2V0X2Vycm9yX21zZygpXG4gICAgICAgICk7XG4gICAgICAgIGlmICghYWxsX2ZpbGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmaWxlczogVEZpbGVbXSA9IFtdO1xuICAgICAgICBjb25zdCBsb3dlcl9pbnB1dF9zdHIgPSBpbnB1dF9zdHIudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBhbGxfZmlsZXMuZm9yRWFjaCgoZmlsZTogVEFic3RyYWN0RmlsZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBURmlsZSAmJlxuICAgICAgICAgICAgICAgIGZpbGUuZXh0ZW5zaW9uID09PSBcIm1kXCIgJiZcbiAgICAgICAgICAgICAgICBmaWxlLnBhdGgudG9Mb3dlckNhc2UoKS5jb250YWlucyhsb3dlcl9pbnB1dF9zdHIpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZpbGVzLnB1c2goZmlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmaWxlcy5zbGljZSgwLCAxMDAwKTtcbiAgICB9XG5cbiAgICByZW5kZXJTdWdnZXN0aW9uKGZpbGU6IFRGaWxlLCBlbDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAgICAgZWwuc2V0VGV4dChmaWxlLnBhdGgpO1xuICAgIH1cblxuICAgIHNlbGVjdFN1Z2dlc3Rpb24oZmlsZTogVEZpbGUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5pbnB1dEVsLnZhbHVlID0gZmlsZS5wYXRoO1xuICAgICAgICB0aGlzLmlucHV0RWwudHJpZ2dlcihcImlucHV0XCIpO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MgfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuaW1wb3J0IHsgQXBwLCBTZXR0aW5nLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgeyBvcGVuQXV0b2NvbXBsZXRlTW9kYWwgfSBmcm9tIFwiLi4vYXV0b2NvbXBsZXRlTW9kYWxcIjtcclxuaW1wb3J0IHsgREVCVUcsIEVSUk9SLCBsb2dnZXIgfSBmcm9tIFwiLi4vTG9nXCI7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFJ1bGVCdWlsZEluQXV0b0NvbXBsZXRlTW9kYWwgZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9ICdhdXRvQ29tcGxldGVNb2RhbCc7XHJcbiAgICAgICAgdGhpcy5ydWxlVHlwZSA9ICdhdXRvY29tcGxldGUubW9kYWwnO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdBdXRvLUNvbXBsZXRlIE1vZGFsJztcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gJ0Rpc3BsYXlzIGFuIGF1dG8tY29tcGxldGUgbW9kYWwgZm9yIHRoZSBmcm9udG1hdHRlciBwYXJhbWV0ZXIuJztcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBjb25zdCBpbnB1dCA9IHRvb2xzLmdldEN1cnJlbnRDb250ZW50KCk7IC8vIEdldCB0aGUgY3VycmVudCBjb250ZW50IG9mIHByb3BlcnR5XFxuICByZXR1cm4gaW5wdXQ7IC8vIFJldHVybiB0aGUgaW5wdXQgdW5hbHRlcmVkXFxufTtcIjtcclxuICAgICAgICB0aGlzLnR5cGUgPSBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddO1xyXG4gICAgICAgIHRoaXMuY29uZmlnRWxlbWVudHMgPSB0aGlzLmRlZmF1bHRDb25maWdFbGVtZW50cyh7fSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ4IChhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogVEZpbGUsIHRvb2xzOiBTY3JpcHRpbmdUb29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgICAgICBsb2dnZXIubG9nKERFQlVHLGBhdXRvY29tcGxldGUgbW9kYWwsIHdvcmsgaW4gcHJvZ3Jlc3MuLi5gKTtcclxuICAgICAgICBjb25zdCBjdXJyZW50Q29udGVudCA9IHRvb2xzLmdldEN1cnJlbnRDb250ZW50KCk7XHJcbiAgICAgICAgY29uc3QgcnVsZSA9IHRvb2xzLmdldFJ1bGUoKTtcclxuICAgICAgICBpZiAoIXJ1bGUpIHJldHVybiBjdXJyZW50Q29udGVudDtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0gdG9vbHMuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQpO1xyXG4gICAgICAgIGlmICghcnVsZSkgcmV0dXJuIHRvb2xzLmdldEN1cnJlbnRDb250ZW50KCkgfHwgJ2F1dG9jb21wbGV0ZS5tb2RhbCc7IC8vIHJldHVybiBjdXJyZW50IGNvbnRlbnQgaWYgbm90IGltcGxlbWVudGVkIHlldFxyXG4gICAgICAgIGNvbnN0IGZyb250bWF0dGVyID0gdG9vbHMuZ2V0RnJvbnRtYXR0ZXIoKTtcclxuICAgICAgICBjb25zdCBoYXNBdXRvY29tcGxldGVQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoZnJvbnRtYXR0ZXIpLnNvbWUoa2V5ID0+IFxyXG4gICAgICAgICAgICBrZXkuc3RhcnRzV2l0aChydWxlLnByb3BlcnR5ICsgb3B0aW9ucy5wcm9wZXJ0eURlbGltaXRlcikgJiZcclxuICAgICAgICAgICAgKGZyb250bWF0dGVyW2tleV0gPT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgICAgICBmcm9udG1hdHRlcltrZXldID09PSBudWxsIHx8XHJcbiAgICAgICAgICAgIGZyb250bWF0dGVyW2tleV0gPT09ICcnKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKCFoYXNBdXRvY29tcGxldGVQcm9wZXJ0aWVzKSByZXR1cm4gdG9vbHMuZ2V0Q3VycmVudENvbnRlbnQoKSB8fCAnYXV0b2NvbXBsZXRlLm1vZGFsJzsgLy8gcmV0dXJuIGN1cnJlbnQgY29udGVudCBpZiBub3QgaW1wbGVtZW50ZWQgeWV0XHJcbiAgICAgICAgb3BlbkF1dG9jb21wbGV0ZU1vZGFsKFxyXG4gICAgICAgICAgICB0b29scy5hcHAsXHJcbiAgICAgICAgICAgIHRvb2xzLnBsdWdpbixcclxuICAgICAgICAgICAgcnVsZSxcclxuICAgICAgICAgICAgb3B0aW9ucyxcclxuICAgICAgICAgICAgdG9vbHMuZ2V0QWN0aXZlRmlsZSgpLFxyXG4gICAgICAgICAgICB0b29scy5nZXRGcm9udG1hdHRlcigpXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhERUJVRywnYXV0b2NvbXBsZXRlIG1vZGFsIHJlc3VsdCcsIHJlc3VsdCwgdG9vbHMuZ2V0RnJvbnRtYXR0ZXIoKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Py52YWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRvb2xzLmFwcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKEVSUk9SLCdBcHAgaXMgbm90IGRlZmluZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xzLmdldEN1cnJlbnRDb250ZW50KCkgfHwgJ2F1dG9jb21wbGV0ZS5tb2RhbCBFcnJvci4gU2VlIGNvbnNvbGUgZm9yIGRldGFpbHMuJzsgLy8gcmV0dXJuIGN1cnJlbnQgY29udGVudCBpZiBub3QgaW1wbGVtZW50ZWQgeWV0ICBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdG9vbHMuYXBwLmZpbGVNYW5hZ2VyLnByb2Nlc3NGcm9udE1hdHRlcihmaWxlLCAoZnJvbnRtYXR0ZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmVzdWx0LnZhbHVlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb250bWF0dGVyW2tleV0gPSB2YWx1ZTsgLy8gc2V0IHRoZSBmcm9udG1hdHRlciB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgeydtdGltZSc6IGZpbGUuc3RhdC5tdGltZX0pOyAvLyBkbyBub3QgY2hhbmdlIHRoZSBtb2RpZnkgdGltZS5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0b29scy5nZXRDdXJyZW50Q29udGVudCgpOyAvLyByZXR1cm4gY3VycmVudCBjb250ZW50LiBGcm9udG1hdHRlciBpcyBhbHJlYWR5IHVwZGF0ZWQuXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coRVJST1IsJ0Vycm9yIG9wZW5pbmcgYXV0b2NvbXBsZXRlIG1vZGFsOicsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0b29scy5nZXRDdXJyZW50Q29udGVudCgpIHx8ICdhdXRvY29tcGxldGUubW9kYWwgRXJyb3IuIFNlZSBjb25zb2xlIGZvciBkZXRhaWxzLic7IC8vIHJldHVybiBjdXJyZW50IGNvbnRlbnQgaWYgbm90IGltcGxlbWVudGVkIHlldFxyXG4gICAgICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgY29uZmlnVGFiIChvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6RnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDphbnksIHByZXZpZXdDb21wb25lbnQ6IGFueSkge1xyXG4gICAgICAgIG9wdGlvbkVMLmVtcHR5KCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWdEZWZhdWx0cyhydWxlLmlkLCB7XHJcbiAgICAgICAgICAgIHByb3BlcnR5RGVsaW1pdGVyOiAnLicsXHJcbiAgICAgICAgfSlcclxuICAgIFxyXG4gICAgICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgIC5zZXROYW1lKCdEZWxpbWl0ZXInKVxyXG4gICAgICAgIC5zZXREZXNjKCdDaGFyYWN0ZXIgdG8gZGV0ZXJtaW5lIHdoaWNoIHByb3BlcnR5IHNob3VsZCBhcHBlYXIgaW4gdGhlIG1vZGFsJylcclxuICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuICAgICAgICAgICAgLnNldFZhbHVlKHRoYXQuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQgLCdwcm9wZXJ0eURlbGltaXRlcicpIHx8ICcuJylcclxuICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWcocnVsZS5pZCwncHJvcGVydHlEZWxpbWl0ZXInLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgIH07XHJcbn0iLCAiXHJcbmltcG9ydCB7IEFwcCwgTW9kYWwsIFNldHRpbmcsIFRBYnN0cmFjdEZpbGUsIFRGaWxlLCBURm9sZGVyLCBWYXVsdCwgc2V0SWNvbixCdXR0b25Db21wb25lbnQsIFRleHRDb21wb25lbnQsIENvbnN0cnVjdG9yIH0gZnJvbSAnb2JzaWRpYW4nOyAvLyBBZGRlZCBzZXRJY29uXHJcbmltcG9ydCB7IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIE9ic2lkaWFuUHJvcGVydHlUeXBlcywgUHJvcGVydHlJbmZvIH0gZnJvbSAnLi90eXBlcyc7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSAnLi90b29scyc7XHJcbmltcG9ydCB7IHJlbmRlclZhbHVlSW5wdXQsIHVwZGF0ZVByb3BlcnR5SWNvbiB9IGZyb20gJy4vdWlFbGVtZW50cyc7IC8vIEltcG9ydCB0aGUgZnVuY3Rpb24gdG8gcmVuZGVyIHZhbHVlIGlucHV0XHJcbmltcG9ydCB7IERFQlVHLCBFUlJPUiwgbG9nZ2VyIH0gZnJvbSAnLi9Mb2cnO1xyXG5cclxuXHJcbi8vIERlZmluZSB0aGUgcmVzdWx0IHN0cnVjdHVyZSByZXR1cm5lZCBieSB0aGUgbW9kYWxcclxuZXhwb3J0IGludGVyZmFjZSBhdXRvY29tcGxldGVNb2RhbFJlc3VsdCB7XHJcbiAgICB2YWx1ZXM6IHt9O1xyXG59XHJcblxyXG4vKipcclxuICogT2JzaWRpYW4gTW9kYWwgZm9yIHNlbGVjdGluZyBkaXJlY3RvcmllcyBhbmQgZmlsZXMgZnJvbSB0aGUgdmF1bHQgc3RydWN0dXJlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEF1dG9jb21wbGV0ZU1vZGFsIGV4dGVuZHMgTW9kYWwge1xyXG5cclxuICAgIFxyXG4gICAgcHJpdmF0ZSByZXNvbHZlUHJvbWlzZSE6IChyZXN1bHQ6IGF1dG9jb21wbGV0ZU1vZGFsUmVzdWx0IHwgbnVsbCkgPT4gdm9pZDtcclxuICAgIHByaXZhdGUgcHJvbWlzZTogUHJvbWlzZTxhdXRvY29tcGxldGVNb2RhbFJlc3VsdCB8IG51bGw+O1xyXG5cclxuICAgIC8vIEluaXRpYWwgc3RhdGUgcGFzc2VkIHRvIHRoZSBtb2RhbCAoc3RvcmVkIGZvciByZXNldCBmdW5jdGlvbmFsaXR5KVxyXG4gICAgcHJpdmF0ZSByZWFkb25seSBva0NhbGxiYWNrITogKHJlc3VsdDogYXV0b2NvbXBsZXRlTW9kYWxSZXN1bHQgfCBudWxsKSA9PiB2b2lkO1xyXG4gICAgcHJpdmF0ZSBwbHVnaW46IGFueTtcclxuICAgIHByaXZhdGUgb3B0aW9uczogYW55O1xyXG4gICAgcHJpdmF0ZSB0b29sczogU2NyaXB0aW5nVG9vbHM7XHJcbiAgICBwcml2YXRlIGV4cGVjdGVkVHlwZTogT2JzaWRpYW5Qcm9wZXJ0eVR5cGVzO1xyXG4gICAgcHJpdmF0ZSBydWxlOiBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzO1xyXG4gICAgcHJpdmF0ZSBrbm93blByb3BlcnRpZXM6IFJlY29yZDxzdHJpbmcsIFByb3BlcnR5SW5mbz4gPSB7fTtcclxuXHJcbiAgICAvLyBDdXJyZW50IHN0YXRlIGJlaW5nIG1vZGlmaWVkIHdpdGhpbiB0aGUgbW9kYWxcclxuICAgIHByaXZhdGUgYWN0aXZlRmlsZTogVEZpbGUgfCBURm9sZGVyIHwgdW5kZWZpbmVkXHJcbiAgICBwcml2YXRlIGZyb250bWF0dGVyOiBhbnk7IC8vIEZyb250bWF0dGVyIGRhdGEgZm9yIHRoZSBhY3RpdmUgZmlsZVxyXG5cclxuICAgIC8vIFVJIEVsZW1lbnRzXHJcbiAgICBwcml2YXRlIGNvbnRlbnRSb290RWxlbWVudCE6IEhUTUxFbGVtZW50O1xyXG4gICAgcHJpdmF0ZSBmdW5jdGlvblRlc3RCdXR0b24hOiBCdXR0b25Db21wb25lbnQ7XHJcbiAgICBwcml2YXRlIGZ1bmN0aW9uUmVzdWx0VGV4dENvbXBvbmVudCE6IFRleHRDb21wb25lbnQgfCB1bmRlZmluZWQ7XHJcbiAgICBwcml2YXRlIHJlc3VsdDogYW55ID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoZSBEaXJlY3RvcnlTZWxlY3Rpb25Nb2RhbC5cclxuICAgICAqIEBwYXJhbSBhcHAgLSBUaGUgT2JzaWRpYW4gQXBwIGluc3RhbmNlLlxyXG4gICAgICogQHBhcmFtIHBsdWdpbiAtIFRoZSBwbHVnaW4gaW5zdGFuY2UuXHJcbiAgICAgKiBAcGFyYW0gZXhwZWN0ZWRUeXBlIC0gRXhwZWN0ZWQgcmV0dXJuIHR5cGUuXHJcbiAgICAgKiBAcGFyYW0gYWN0aXZlRmlsZSAtIFRoZSBjdXJyZW50bHkgYWN0aXZlIGZpbGUgb3IgZm9sZGVyLlxyXG4gICAgICogQHBhcmFtIGZyb250bWF0dGVyIC0gRnJvbnRtYXR0ZXIgZGF0YSBmb3IgdGhlIGFjdGl2ZSBmaWxlLlxyXG4gICAgICogQHBhcmFtIG9rQ2FsbGJhY2sgLSBGdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHVzZXIgY2xpY2tzIFwiT0tcIi4gUmVjZWl2ZXMgdGhlIHNlbGVjdGlvbiByZXN1bHQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIGFwcDogQXBwLFxyXG4gICAgICAgIHBsdWdpbjogYW55LFxyXG4gICAgICAgIHJ1bGU6IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsXHJcbiAgICAgICAgb3B0aW9uczogYW55LFxyXG4gICAgICAgIGFjdGl2ZUZpbGU6IFRGaWxlIHwgVEZvbGRlciB8IHVuZGVmaW5lZCxcclxuICAgICAgICBmcm9udG1hdHRlcjogYW55LCAgIFxyXG4gICAgICAgIG9rQ2FsbGJhY2s/OiAocmVzdWx0OiBhdXRvY29tcGxldGVNb2RhbFJlc3VsdCB8IG51bGwpID0+IHZvaWRcclxuICAgICkge1xyXG4gICAgICAgIHN1cGVyKGFwcCk7XHJcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICAgICAgLy8gU3RvcmUgaW5pdGlhbCBzdGF0ZSBmb3IgcmVzZXRcclxuICAgICAgICB0aGlzLnRvb2xzPSBuZXcgU2NyaXB0aW5nVG9vbHMoYXBwLCB0aGlzLnBsdWdpbiwgdGhpcy5mcm9udG1hdHRlcik7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVGaWxlID0gYWN0aXZlRmlsZTtcclxuICAgICAgICB0aGlzLmZyb250bWF0dGVyID0gZnJvbnRtYXR0ZXI7IC8vIFN0b3JlIGZyb250bWF0dGVyIGRhdGFcclxuXHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICAgICAgdGhpcy5ydWxlID0gcnVsZTtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zOyAvLyBTdG9yZSBvcHRpb25zIGZvciB0aGUgbW9kYWxcclxuICAgICAgICB0aGlzLmV4cGVjdGVkVHlwZSA9IHJ1bGUudHlwZTsgLy8gRXhwZWN0ZWQgdHlwZSBmb3IgdGhlIG1vZGFsXHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHByb21pc2VcclxuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAob2tDYWxsYmFjaykgdGhpcy5va0NhbGxiYWNrID0gb2tDYWxsYmFjaztcclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBjdXJyZW50IHN0YXRlIGZyb20gaW5pdGlhbCBzdGF0ZSBmb3IgZWRpdGluZ1xyXG4gICAgICAgIHRoaXMucmVzZXRUb0luaXRpYWwoKTsgLy8gVXNlIGEgbWV0aG9kIGZvciBpbml0aWFsaXphdGlvbiBhbmQgcmVzZXRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGUgY3VycmVudCBzZWxlY3Rpb24gc3RhdGUgdG8gdGhlIGluaXRpYWwgc3RhdGUgcHJvdmlkZWQgYXQgY29uc3RydWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlc2V0VG9Jbml0aWFsKCk6IHZvaWQge1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBzdGF0ZSB0byBlbXB0eS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZXNldFRvRW1wdHkoKTogdm9pZCB7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgbW9kYWwgaXMgb3BlbmVkLiBCdWlsZHMgdGhlIFVJLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBvbk9wZW4oKSB7XHJcbiAgICAgICAgdGhpcy5rbm93blByb3BlcnRpZXMgPSBhd2FpdCB0aGlzLnRvb2xzLmZldGNoS25vd25Qcm9wZXJ0aWVzKHRoaXMuYXBwKTsgLy8gSW5pdGlhbGl6ZSBrbm93biBwcm9wZXJ0aWVzXHJcbiAgICAgICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGNvbnRlbnRFbC5wYXJlbnRFbGVtZW50KSBjb250ZW50RWwucGFyZW50RWxlbWVudC5zdHlsZS53aWR0aCA9ICc5MDBweCc7XHJcbiAgICAgICAgY29udGVudEVsLmVtcHR5KCk7IC8vIENsZWFyIHByZXZpb3VzIFxyXG4gICAgICAgIGNvbnRlbnRFbC5hZGRDbGFzcygnY29kZUVkaXRvci1tb2RhbCcpOyBcclxuXHJcbiAgICAgICAgLy8gLS0tIE1vZGFsIFRpdGxlIC0tLVxyXG4gICAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdQbGVhc2UgY29tcGxldGUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzJyB9KTsgICAgXHJcbiAgICAgICAgY29udGVudEVsLmNyZWF0ZUVsKCdib2R5JywgeyB0ZXh0OiBgRmlsZTogJHt0aGlzLmFjdGl2ZUZpbGU/LnBhdGh9YCB9KTsgXHJcblxyXG4gICAgICAgIC8vIC0tLSBUcmVlIENvbnRhaW5lciAtLS1cclxuICAgICAgICB0aGlzLmNvbnRlbnRSb290RWxlbWVudCA9IGNvbnRlbnRFbC5jcmVhdGVEaXYoeyBjbHM6ICdjb2RlRWRpdG9yLWNvbnRhaW5lcicgfSk7XHJcbiAgICAgICAgLy8gQmFzaWMgc3R5bGluZyBmb3IgdGhlIHNjcm9sbGFibGUgdHJlZSBhcmVhXHJcbiAgICAgICAgLy8gdGhpcy5lZGl0b3JSb290RWxlbWVudC5zdHlsZS53aWR0aCA9ICc2MDBweCc7XHJcbiAgICAgICAgLy8gdGhpcy5jb250ZW50Um9vdEVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJzYwMHB4JztcclxuICAgICAgICB0aGlzLmNvbnRlbnRSb290RWxlbWVudC5zdHlsZS5vdmVyZmxvd1kgPSAnYXV0byc7XHJcbiAgICAgICAgLy90aGlzLmVkaXRvclJvb3RFbGVtZW50LnN0eWxlLmJvcmRlciA9ICcxcHggc29saWQgdmFyKC0tYmFja2dyb3VuZC1tb2RpZmllci1ib3JkZXIpJztcclxuICAgICAgICB0aGlzLmNvbnRlbnRSb290RWxlbWVudC5zdHlsZS5wYWRkaW5nID0gJzEwcHgnO1xyXG4gICAgICAgIHRoaXMuY29udGVudFJvb3RFbGVtZW50LnN0eWxlLm1hcmdpblRvcCA9ICcxMHB4JztcclxuICAgICAgICB0aGlzLmNvbnRlbnRSb290RWxlbWVudC5zdHlsZS5tYXJnaW5Cb3R0b20gPSAnMTBweCc7XHJcblxyXG5cclxuICAgICAgICBjb25zdCBwcm9wZXJ0eUNvbnRhaW5lckVsID0gY29udGVudEVsLmNyZWF0ZURpdih7IGNsczogXCJjb2RlRWRpdG9yLW9wdGlvbnNcIiB9KTtcclxuICAgICAgICBwcm9wZXJ0eUNvbnRhaW5lckVsLnN0eWxlLmZsZXhEaXJlY3Rpb24gPSAnY29sdW1uJzsgLy8gU3RhY2sgaXRlbXMgdmVydGljYWxseVxyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmZyb250bWF0dGVyKSkge1xyXG4gICAgICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgodGhpcy5ydWxlLnByb3BlcnR5ICsgdGhpcy5vcHRpb25zLnByb3BlcnR5RGVsaW1pdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgcm93RWwgPSBwcm9wZXJ0eUNvbnRhaW5lckVsLmNyZWF0ZURpdih7IGNsczogJ3Byb3BlcnR5LXNldHRpbmctcm93IHNldHRpbmctaXRlbScgfSk7XHJcbiAgICAgICAgICAgICAgICByb3dFbC5zdHlsZS53aWR0aCA9ICcxMDAlJzsgLy8gRnVsbCB3aWR0aFxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xFbCA9IHJvd0VsLmNyZWF0ZURpdih7IGNsczogJ3NldHRpbmctaXRlbS1jb250cm9sJyB9KTtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xFbC5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xyXG4gICAgICAgICAgICAgICAgY29udHJvbEVsLnN0eWxlLmFsaWduSXRlbXMgPSAnY2VudGVyJztcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xFbC5zdHlsZS5qdXN0aWZ5Q29udGVudCA9ICdzcGFjZS1iZXR3ZWVuJztcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xFbC5zdHlsZS53aWR0aCA9ICcxMDAlJztcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xFbC5zdHlsZS5nYXAgPSAnMHB4JzsgLy8gUHJldmVudCBnYXAgZnJvbSBiZWluZyBhZGRlZCB0byB0aGUgbGVmdCBzaWRlXHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdENvbnRhaW5lciA9IGNvbnRyb2xFbC5jcmVhdGVEaXYoeyBjbHM6ICdwcm9wZXJ0eS1sZWZ0LWNvbnRhaW5lcicgfSk7XHJcbiAgICAgICAgICAgICAgICBsZWZ0Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XHJcbiAgICAgICAgICAgICAgICBsZWZ0Q29udGFpbmVyLnN0eWxlLmFsaWduSXRlbXMgPSAnY2VudGVyJztcclxuICAgICAgICAgICAgICAgIGxlZnRDb250YWluZXIuc3R5bGUubWluV2lkdGggPSAnMjUwcHgnOyBcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBpY29uRWwgPSBsZWZ0Q29udGFpbmVyLmNyZWF0ZVNwYW4oeyBjbHM6ICdwcm9wZXJ0eS1pY29uIHNldHRpbmctaXRlbS1pY29uJyB9KTtcclxuICAgICAgICAgICAgICAgIGljb25FbC5zdHlsZS5tYXJnaW5SaWdodCA9ICc4cHgnO1xyXG5cclxuICAgICAgICAgICAgICAgIHVwZGF0ZVByb3BlcnR5SWNvbihpY29uRWwsIHRoaXMua25vd25Qcm9wZXJ0aWVzW2tleV0udHlwZSk7IC8vIFVwZGF0ZSBpY29uIGJhc2VkIG9uIHR5cGVcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlYXJjaENvbnRhaW5lciA9IGxlZnRDb250YWluZXIuY3JlYXRlRGl2KHsgY2xzOiAncHJvcGVydHktc2VhcmNoLWNvbnRhaW5lcicgfSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lSW5wdXQgPSBuZXcgVGV4dENvbXBvbmVudChzZWFyY2hDb250YWluZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKGtleSlcclxuICAgICAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ1Byb3BlcnR5IG5hbWUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXREaXNhYmxlZCh0cnVlKTsgLy8gRGlzYWJsZSB0aGUgaW5wdXQgZmllbGRcclxuICAgICAgICAgICAgICAgIG5hbWVJbnB1dC5pbnB1dEVsLnN0eWxlLmJvcmRlciA9ICdub25lJzsgLy8gbWFrZSBib3JkZXIgaW52aXNpYmxlXHJcbiAgICAgICAgICAgICAgICBjb25zdCBtaWRkbGVDb250YWluZXIgPSBjb250cm9sRWwuY3JlYXRlRGl2KHsgY2xzOiAncHJvcGVydHktbWlkZGxlLWNvbnRhaW5lcicgfSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUNvbnRhaW5lciA9IG1pZGRsZUNvbnRhaW5lci5jcmVhdGVEaXYoeyBjbHM6ICdwcm9wZXJ0eS12YWx1ZS1jb250YWluZXInIH0pO1xyXG4gICAgICAgICAgICAgICAgdmFsdWVDb250YWluZXIuc3R5bGUud2lkdGggPSAnMTAwJSc7IC8vIEZ1bGwgd2lkdGggZm9yIHZhbHVlIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgbGV0IHByZXZpZXdDb21wb25lbnQgPSByZW5kZXJWYWx1ZUlucHV0KHZhbHVlQ29udGFpbmVyLCB0aGlzLmtub3duUHJvcGVydGllc1trZXldLCB0aGlzLmZyb250bWF0dGVyW2tleV0sIHRoaXMuY2hhbmdlQ2FsbGJhY2spO1xyXG5cclxuICAgICAgICAgICAgICAgIHByZXZpZXdDb21wb25lbnQuaW5wdXRFbC5zdHlsZS53aWR0aCA9ICcxMDAlJzsgLy8gTWFrZSB0aGUgaW5wdXQgZmllbGQgdGFrZSBmdWxsIHdpZHRoXHJcbiAgICAgICAgICAgICAgICBwcmV2aWV3Q29tcG9uZW50LmlucHV0RWwuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3RyYW5zcGFyZW50JzsgLy8gbWFrZSBpdCBpbnZpc2libGVcclxuICAgICAgICAgICAgICAgIC8vIC0tLSByaWdodCBwYXJ0IC0tLVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZGVsZXRlQnV0dG9uQ29udGFpbmVyID0gY29udHJvbEVsLmNyZWF0ZURpdih7IGNsczogJ3Byb3BlcnR5LXJpZ2h0LWNvbnRhaW5lcicgfSk7XHJcbiAgICAgICAgICAgICAgICBkZWxldGVCdXR0b25Db250YWluZXIuc3R5bGUubWFyZ2luTGVmdCA9ICdhdXRvJzsgLy8gUHVzaCB0byB0aGUgcmlnaHRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gLS0tIEFjdGlvbiBCdXR0b25zIC0tLVxyXG4gICAgICAgIHRoaXMuY3JlYXRlQWN0aW9uQnV0dG9ucyhjb250ZW50RWwpOyAvLyBDcmVhdGUgT0sgYW5kIFJlc2V0IGJ1dHRvbnNcclxuICAgIH1cclxuXHJcbiAgICBjaGFuZ2VDYWxsYmFjayA9IChwcm9wZXJ0eUluZm86IFByb3BlcnR5SW5mbyB8IHVuZGVmaW5lZCwgdmFsdWU6YW55KSA9PiB7XHJcbiAgICAgICAgLy8gU2F2ZSB0aGUgcmVzdWx0IHRvIHRoZSBjdXJyZW50IHN0YXRlXHJcbiAgICAgICAgaWYgKHByb3BlcnR5SW5mbykge1xyXG4gICAgICAgICAgICB0aGlzLnJlc3VsdFtwcm9wZXJ0eUluZm8ubmFtZV0gPSB2YWx1ZTsgLy8gVXBkYXRlIHRoZSByZXN1bHQgd2l0aCB0aGUgbmV3IHZhbHVlXHJcbiAgICAgICAgfVxyXG4gICAgfSAgIFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgXCJPS1wiIGFuZCBcIlJlc2V0XCIgYnV0dG9ucy5cclxuICAgICAqIEBwYXJhbSBjb250YWluZXJFbCAtIFRoZSBIVE1MIGVsZW1lbnQgdG8gYXBwZW5kIHRoZSBidXR0b25zIHRvLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNyZWF0ZUFjdGlvbkJ1dHRvbnMoY29udGFpbmVyRWw6IEhUTUxFbGVtZW50KTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgYnV0dG9uc0VsID0gY29udGFpbmVyRWwuY3JlYXRlRGl2KHsgY2xzOiAnbW9kYWwtYnV0dG9ucycgfSk7XHJcbiAgICAgICAgYnV0dG9uc0VsLnN0eWxlLm1hcmdpblRvcCA9ICcxNXB4JztcclxuICAgICAgICBidXR0b25zRWwuc3R5bGUuZGlzcGxheSA9ICdmbGV4JzsgLy8gVXNlIGZsZXggZm9yIGFsaWdubWVudFxyXG4gICAgICAgIGJ1dHRvbnNFbC5zdHlsZS5qdXN0aWZ5Q29udGVudCA9ICdmbGV4LWVuZCc7IC8vIEFsaWduIGJ1dHRvbnMgdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgYnV0dG9uc0VsLnN0eWxlLmdhcCA9ICcxMHB4JzsgLy8gU3BhY2UgYmV0d2VlbiBidXR0b25zXHJcblxyXG4gICAgICAgIC8vIFJlc2V0IEJ1dHRvbiAoVW5kbyBcdTIxQUFcdUZFMEYpXHJcbiAgICAgICAgY29uc3QgcmVzZXRCdXR0b24gPSBidXR0b25zRWwuY3JlYXRlRWwoJ2J1dHRvbicpO1xyXG4gICAgICAgIC8vIFVzZSBPYnNpZGlhbidzIHNldEljb24gZm9yIGNvbnNpc3RlbmN5LCBvciB1c2UgdGV4dFxyXG4gICAgICAgIHNldEljb24ocmVzZXRCdXR0b24sICdyZXNldCcpOyAvLyBVc2UgYSBzdWl0YWJsZSBpY29uIGxpa2UgJ3Jlc2V0JyBvciAndW5kbydcclxuICAgICAgICByZXNldEJ1dHRvbi5hcmlhTGFiZWwgPSAnUmVzZXQgc2VsZWN0aW9uJzsgLy8gQWNjZXNzaWJpbGl0eVxyXG4gICAgICAgIHJlc2V0QnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzZXRUb0luaXRpYWwoKTsgLy8gUmVzZXQgaW50ZXJuYWwgc3RhdGVcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBDbGVhciBCdXR0b24gKENsZWFyIFx1RDgzRFx1REVBRSlcclxuICAgICAgICBjb25zdCBlbXB0eUJ1dHRvbiA9IGJ1dHRvbnNFbC5jcmVhdGVFbCgnYnV0dG9uJyk7XHJcbiAgICAgICAgLy8gVXNlIE9ic2lkaWFuJ3Mgc2V0SWNvbiBmb3IgY29uc2lzdGVuY3ksIG9yIHVzZSB0ZXh0XHJcbiAgICAgICAgc2V0SWNvbihlbXB0eUJ1dHRvbiwgJ2VyYXNlcicpOyAvLyBVc2UgYSBzdWl0YWJsZSBpY29uIGxpa2UgJ3Jlc2V0JyBvciAndW5kbydcclxuICAgICAgICBlbXB0eUJ1dHRvbi5hcmlhTGFiZWwgPSAnQ2xlYXIgc2VsZWN0aW9uJzsgLy8gQWNjZXNzaWJpbGl0eVxyXG4gICAgICAgIGVtcHR5QnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzZXRUb0VtcHR5KCk7IC8vIENsZWFyIHN0YXRlXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gY2FuY2VsIEJ1dHRvblxyXG4gICAgICAgIGNvbnN0IGNhbmNlbEJ1dHRvbiA9IGJ1dHRvbnNFbC5jcmVhdGVFbCgnYnV0dG9uJywgeyB0ZXh0OiAnQ2FuY2VsJyB9KTtcclxuICAgICAgICBjYW5jZWxCdXR0b24uYXJpYUxhYmVsID0gJ2Nsb3NlIGFuZCBkaXNjYXJkIGNoYW5nZXMnOyAvLyBBY2Nlc3NpYmlsaXR5XHJcbiAgICAgICAgY2FuY2VsQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5sb2coREVCVUcsXCJDYW5jZWwgQ2xpY2tlZCAtIFJldHVybmluZ1wiKTsgLy8gRGVidWcgbG9nXHJcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZVByb21pc2UobnVsbCk7IC8vIFJlc29sdmUgdGhlIHByb21pc2Ugd2l0aCBudWxsXHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBPSyBCdXR0b25cclxuICAgICAgICBjb25zdCBva0J1dHRvbiA9IGJ1dHRvbnNFbC5jcmVhdGVFbCgnYnV0dG9uJywgeyB0ZXh0OiAnT0snLCBjbHM6ICdtb2QtY3RhJyB9KTtcclxuICAgICAgICBjYW5jZWxCdXR0b24uYXJpYUxhYmVsID0gJ2Nsb3NlIGFuZCBzYXZlIGNoYW5nZXMnOyAvLyBBY2Nlc3NpYmlsaXR5XHJcbiAgICAgICAgb2tCdXR0b24ub25jbGljayA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlUHJvbWlzZSh7IHZhbHVlczogdGhpcy5yZXN1bHQgfSk7IC8vIFJlc29sdmUgdGhlIHByb21pc2Ugd2l0aCB0aGUgcmVzdWx0XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgbW9kYWwgaXMgY2xvc2VkLiBDbGVhbnMgdXAgcmVzb3VyY2VzLlxyXG4gICAgICovXHJcbiAgICBvbkNsb3NlKCkge1xyXG4gICAgICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnRlbnRFbC5lbXB0eSgpOyAvLyBDbGVhciB0aGUgbW9kYWwncyBjb250ZW50XHJcbiAgICB9XHJcblxyXG4gICAgb3BlbkFuZEdldFZhbHVlcygpOiBQcm9taXNlPGF1dG9jb21wbGV0ZU1vZGFsUmVzdWx0IHwgbnVsbD4ge1xyXG4gICAgICAgIHRoaXMub3BlbigpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2U7IC8vIFJldHVybiB0aGUgcHJvbWlzZVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIE9wZW5zIGFuIGF1dG9jb21wbGV0ZSBtb2RhbCBmb3Igc2VsZWN0aW5nIG9yIGVudGVyaW5nIHZhbHVlcyBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgcGFyYW1ldGVycy5cclxuICpcclxuICogQHBhcmFtIGFwcCAtIFRoZSBPYnNpZGlhbiBhcHBsaWNhdGlvbiBpbnN0YW5jZS5cclxuICogQHBhcmFtIHBsdWdpbiAtIFRoZSBwbHVnaW4gaW5zdGFuY2UgdGhhdCBpcyBpbnZva2luZyB0aGUgbW9kYWwuXHJcbiAqIEBwYXJhbSBydWxlIC0gVGhlIGZvbGRlci10by10YWcgcnVsZSBkZWZpbml0aW9uIHRvIGJlIHVzZWQgaW4gdGhlIG1vZGFsLlxyXG4gKiBAcGFyYW0gYWN0aXZlRmlsZSAtIFRoZSBjdXJyZW50bHkgYWN0aXZlIGZpbGUgb3IgZm9sZGVyLCBpZiBhbnkuXHJcbiAqIEBwYXJhbSBmcm9udG1hdHRlciAtIFRoZSBmcm9udG1hdHRlciBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgYWN0aXZlIGZpbGUuXHJcbiAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSByZXN1bHQgb2YgdGhlIGF1dG9jb21wbGV0ZSBtb2RhbCwgb3IgYG51bGxgIGlmIG5vIHNlbGVjdGlvbiB3YXMgbWFkZS5cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBvcGVuQXV0b2NvbXBsZXRlTW9kYWwoXHJcbiAgICBhcHA6IEFwcCB8IHVuZGVmaW5lZCxcclxuICAgIHBsdWdpbjogYW55LFxyXG4gICAgcnVsZTogRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyxcclxuICAgIG9wdGlvbnM6IGFueSxcclxuICAgIGFjdGl2ZUZpbGU6IFRGaWxlIHwgVEZvbGRlciB8IHVuZGVmaW5lZCxcclxuICAgIGZyb250bWF0dGVyOiBhbnlcclxuKTogUHJvbWlzZTxhdXRvY29tcGxldGVNb2RhbFJlc3VsdCB8IG51bGw+IHtcclxuICAgIC8vIENyZWF0ZSBhbmQgb3BlbiB0aGUgbW9kYWwgaW5zdGFuY2VcclxuICAgIGlmICghYXBwKSB7XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhFUlJPUixcIkFwcCBpcyB1bmRlZmluZWRcIik7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCBtb2RhbCA9IG5ldyBBdXRvY29tcGxldGVNb2RhbChhcHAsIHBsdWdpbiwgcnVsZSwgb3B0aW9ucywgYWN0aXZlRmlsZSwgZnJvbnRtYXR0ZXIpO1xyXG4gICAgcmV0dXJuIGF3YWl0IG1vZGFsLm9wZW5BbmRHZXRWYWx1ZXMoKTsgLy8gV2FpdCBmb3IgdGhlIHByb21pc2UgdG8gcmVzb2x2ZVxyXG59XHJcbiIsICJpbXBvcnQgeyBSdWxlUHJvdG90eXBlLCBydWxlc01hbmFnZXIgfSBmcm9tIFwiLi9ydWxlc1wiO1xyXG5pbXBvcnQgeyBTY3JpcHRpbmdUb29scyB9IGZyb20gXCIuLi90b29sc1wiO1xyXG5pbXBvcnQgeyBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCBQcm9wZXJ0eVR5cGVJbmZvIH0gZnJvbSBcIi4uL3R5cGVzXCI7XHJcbmltcG9ydCB7IEFwcCwgRXh0cmFCdXR0b25Db21wb25lbnQsIFNldHRpbmcsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7IGRlbGltaXRlciB9IGZyb20gXCJwYXRoXCI7XHJcbmltcG9ydCB7IE11bHRpUHJvcGVydHlTZXR0aW5nIH0gZnJvbSBcIi4uL3VpTXVsdGlQcm9wZXJ0eVNldHRpbmdcIjtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgYnVpbHQtaW4gcnVsZSBmb3IgcmV0cmlldmluZyBhIHByb3BlcnR5IHZhbHVlIGZyb20gdGhlIGZyb250bWF0dGVyIG9mIGEgZmlsZS5cclxuICogXHJcbiAqIFRoaXMgcnVsZSBhbGxvd3MgdXNlcnMgdG8gc2VsZWN0IGEgcHJvcGVydHkgKHN1Y2ggYXMgdGV4dCwgdGFncywgYWxpYXNlcywgb3IgbXVsdGl0ZXh0KSBhbmQgcmV0cmlldmUgaXRzIHZhbHVlXHJcbiAqIGZyb20gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBmaWxlJ3MgZnJvbnRtYXR0ZXIuIFRoZSBydWxlIHByb3ZpZGVzIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3Igc2VsZWN0aW5nIHRoZSBwcm9wZXJ0eSxcclxuICogYW5kIGV4cG9zZXMgYSBmdW5jdGlvbiAoYGZ4YCkgdGhhdCBwZXJmb3JtcyB0aGUgcmV0cmlldmFsLlxyXG4gKiBcclxuICogQGV4dGVuZHMgUnVsZVByb3RvdHlwZVxyXG4gKiBcclxuICogQHJlbWFya3NcclxuICogLSBUaGUgcnVsZSBpcyBpZGVudGlmaWVkIGJ5IHRoZSBJRCAnZ2V0UHJvcGVydHknIGFuZCBpcyBjYXRlZ29yaXplZCBhcyBhIGJ1aWx0LWluIHJ1bGUuXHJcbiAqIC0gVGhlIGNvbmZpZ3VyYXRpb24gdGFiIGFsbG93cyB1c2VycyB0byBzZWxlY3Qgd2hpY2ggcHJvcGVydHkgdG8gcmV0cmlldmUuXHJcbiAqIC0gVGhlIGBmeGAgbWV0aG9kIGlzIHRoZSBtYWluIGxvZ2ljIGZvciBleHRyYWN0aW5nIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cclxuICogXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIFVzYWdlIHdpdGhpbiB0aGUgcGx1Z2luJ3MgcnVsZSBzeXN0ZW06XHJcbiAqIGNvbnN0IHJ1bGUgPSBuZXcgUnVsZUJ1aWxkSW5HZXRQcm9wZXJ0eSgpO1xyXG4gKiBjb25zdCB2YWx1ZSA9IHJ1bGUuZngoYXBwLCBmaWxlLCB0b29scyk7XHJcbiAqIFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBydWxlICgnZ2V0UHJvcGVydHknKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJ1bGVUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIHJ1bGUgKCdidWlsZEluJykuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uIC0gQSBicmllZiBkZXNjcmlwdGlvbiBvZiB0aGUgcnVsZSdzIHB1cnBvc2UuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHR5cGUgLSBUaGUgdHlwZXMgb2YgcHJvcGVydGllcyB0aGlzIHJ1bGUgY2FuIGhhbmRsZS5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZnggLSBUaGUgZnVuY3Rpb24gdGhhdCByZXRyaWV2ZXMgdGhlIHByb3BlcnR5IHZhbHVlLlxyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBjb25maWdUYWIgLSBUaGUgZnVuY3Rpb24gdGhhdCByZW5kZXJzIHRoZSBjb25maWd1cmF0aW9uIFVJIGZvciB0aGUgcnVsZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlQnVpbGRJbkNvbmNhdFByb3BlcnRpZXMgZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLmlkID0gJ2NvbmNhdFByb3BlcnRpZXMnO1xyXG4gICAgdGhpcy5ydWxlVHlwZSA9ICdidWlsZEluJztcclxuICAgIHRoaXMubmFtZSA9ICdDb25jYXQgUHJvcGVydGllcyc7XHJcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gJ0NvbmNhdGVuYXRlcyBtdWx0aXBsZSBwcm9wZXJ0aWVzIGZyb20gdGhlIGZyb250bWF0dGVyLic7XHJcbiAgICB0aGlzLnNvdXJjZSA9IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBjb25zdCBwcm9wZXJ0eUlkcyA9IHRvb2xzLmdldE9wdGlvbkNvbmZpZyh0b29scy5nZXRSdWxlKCk/LmlkLCdpbnB1dFByb3BlcnRpZXMnKTtcXG4gIGlmICghQXJyYXkuaXNBcnJheShwcm9wZXJ0eUlkcykgfHwgcHJvcGVydHlJZHMubGVuZ3RoID09PSAwKSB7XFxuICAgIHJldHVybiAnTm8gcHJvcGVydGllcyBzZWxlY3RlZCc7XFxuICB9XFxuICBjb25zdCBkZWxpbWl0ZXIgPSB0b29scy5nZXRPcHRpb25Db25maWcodG9vbHMuZ2V0UnVsZSgpPy5pZCwnZGVsaW1pdGVyJyk7XFxuICBjb25zdCBvbmx5V2hlbkFsbFByb3BlcnRpZXNFeGlzdCA9IHRvb2xzLmdldE9wdGlvbkNvbmZpZyh0b29scy5nZXRSdWxlKCk/LmlkLCAnb25seVdoZW5BbGxQcm9wZXJ0aWVzRXhpc3QnKSB8fCBmYWxzZTtcXG4gIGlmIChvbmx5V2hlbkFsbFByb3BlcnRpZXNFeGlzdCkge1xcbiAgICAvLyBDaGVjayBpZiBhbGwgcHJvcGVydGllcyBleGlzdFxcbiAgICBjb25zdCBhbGxFeGlzdCA9IHByb3BlcnR5SWRzLmV2ZXJ5KGlkID0+IHsgXFxuICAgICAgaWYgKGlkID09PSB1bmRlZmluZWQgfHwgaWQgPT09IG51bGwgfHwgaWQgPT09ICcnKSB7XFxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gU2tpcCBlbXB0eSBvciB1bmRlZmluZWQgcHJvcGVydHkgSURzXFxuICAgICAgfVxcbiAgICAgIGNvbnN0IHByb3BlcnR5VmFsdWUgPSB0b29scy5nZXRGcm9udG1hdHRlclByb3BlcnR5KGlkKTtcXG4gICAgICBjb25zdCByZXN1bHQgPSBwcm9wZXJ0eVZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcGVydHlWYWx1ZSAhPT0gbnVsbCAmJiBwcm9wZXJ0eVZhbHVlICE9PSAnJztcXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9KTtcXG4gICAgaWYgKCFhbGxFeGlzdCkge1xcbiAgICAgIHJldHVybiAnJztcXG4gICAgfVxcbiAgfVxcbiAgY29uc3QgcmVzdWx0ID0gcHJvcGVydHlJZHMubWFwKGlkID0+IHtcXG4gICAgbGV0IHZhbHVlID0gdG9vbHMuZ2V0RnJvbnRtYXR0ZXJQcm9wZXJ0eShpZCk7XFxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAnJykge1xcbiAgICAgIHJldHVybiAnJzsgLy8gU2tpcCBlbXB0eSBvciB1bmRlZmluZWQgcHJvcGVydGllc1xcbiAgICB9XFxuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xcbiAgfSkuZmlsdGVyKHJlcyA9PiByZXMgIT09IHVuZGVmaW5lZCkuam9pbihkZWxpbWl0ZXIpO1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1wiO1xyXG4gICAgdGhpcy50eXBlID0gWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXTtcclxuICAgIHRoaXMuY29uZmlnRWxlbWVudHMgPSB0aGlzLmRlZmF1bHRDb25maWdFbGVtZW50cyh7fSk7XHJcbiAgfVxyXG4gIFxyXG4gIGZ4IChhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogVEZpbGUsIHRvb2xzOiBTY3JpcHRpbmdUb29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgIGNvbnN0IHByb3BlcnR5SWRzID0gdG9vbHMuZ2V0T3B0aW9uQ29uZmlnKHRvb2xzLmdldFJ1bGUoKT8uaWQsJ2lucHV0UHJvcGVydGllcycpO1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BlcnR5SWRzKSB8fCBwcm9wZXJ0eUlkcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuICdObyBwcm9wZXJ0aWVzIHNlbGVjdGVkJztcclxuICAgIH1cclxuICAgIGNvbnN0IGRlbGltaXRlciA9IHRvb2xzLmdldE9wdGlvbkNvbmZpZyh0b29scy5nZXRSdWxlKCk/LmlkLCdkZWxpbWl0ZXInKTtcclxuICAgIGNvbnN0IG9ubHlXaGVuQWxsUHJvcGVydGllc0V4aXN0ID0gdG9vbHMuZ2V0T3B0aW9uQ29uZmlnKHRvb2xzLmdldFJ1bGUoKT8uaWQsICdvbmx5V2hlbkFsbFByb3BlcnRpZXNFeGlzdCcpIHx8IGZhbHNlO1xyXG4gICAgaWYgKG9ubHlXaGVuQWxsUHJvcGVydGllc0V4aXN0KSB7XHJcbiAgICAgIC8vIENoZWNrIGlmIGFsbCBwcm9wZXJ0aWVzIGV4aXN0XHJcbiAgICAgIGNvbnN0IGFsbEV4aXN0ID0gcHJvcGVydHlJZHMuZXZlcnkoaWQgPT4geyBcclxuICAgICAgICBpZiAoaWQgPT09IHVuZGVmaW5lZCB8fCBpZCA9PT0gbnVsbCB8fCBpZCA9PT0gJycpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBTa2lwIGVtcHR5IG9yIHVuZGVmaW5lZCBwcm9wZXJ0eSBJRHNcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcHJvcGVydHlWYWx1ZSA9IHRvb2xzLmdldEZyb250bWF0dGVyUHJvcGVydHkoaWQpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHByb3BlcnR5VmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wZXJ0eVZhbHVlICE9PSBudWxsICYmIHByb3BlcnR5VmFsdWUgIT09ICcnO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoIWFsbEV4aXN0KSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXN1bHQgPSBwcm9wZXJ0eUlkcy5tYXAoaWQgPT4ge1xyXG4gICAgICBsZXQgdmFsdWUgPSB0b29scy5nZXRGcm9udG1hdHRlclByb3BlcnR5KGlkKTtcclxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICcnKSB7XHJcbiAgICAgICAgcmV0dXJuICcnOyAvLyBTa2lwIGVtcHR5IG9yIHVuZGVmaW5lZCBwcm9wZXJ0aWVzXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICB9KS5maWx0ZXIocmVzID0+IHJlcyAhPT0gdW5kZWZpbmVkKS5qb2luKGRlbGltaXRlcik7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgY29uZmlnVGFiKG9wdGlvbkVMOiBIVE1MRWxlbWVudCwgcnVsZTogRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDogYW55LCBwcmV2aWV3Q29tcG9uZW50OiBhbnkpIHtcclxuICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnRGVmYXVsdHMocnVsZS5pZCwge1xyXG4gICAgICAgIGRlbGltaXRlcjogJyAnLCAvLyBEZWZhdWx0IGRlbGltaXRlciBmb3IgY29uY2F0ZW5hdGlvblxyXG4gICAgICAgIGlucHV0UHJvcGVydGllczogW10sXHJcbiAgICAgICAgb25seVdoZW5BbGxQcm9wZXJ0aWVzRXhpc3Q6IHRydWUsIC8vIERlZmF1bHQgdG8gZmFsc2VcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBjb25zdCBtdWx0aVByb3AgPSBuZXcgTXVsdGlQcm9wZXJ0eVNldHRpbmcob3B0aW9uRUwpXHJcbiAgICAgIC5zZXROYW1lKFwiSW5wdXQgUHJvcGVydGllc1wiKVxyXG4gICAgICAuc2V0RGVzYyhcIlNlbGVjdCBwcm9wZXJ0aWVzIGFzIGlucHV0LiBVc2UgJ1NwYWNlIHJlcGxhY2VtZW50JyBhcyBkZWxpbWl0ZXIuXCIpXHJcbiAgICAgIC5zZXRPcHRpb25zKE9iamVjdC5rZXlzKHRoYXQua25vd25Qcm9wZXJ0aWVzKS5tYXAoKGtleSkgPT4ga2V5KSlcclxuICAgICAgLnNldFZhbHVlKHRoYXQuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQsICdpbnB1dFByb3BlcnRpZXMnKSB8fCBbXSlcclxuICAgICAgLm9uQ2hhbmdlKChhcnIpID0+IHtcclxuICAgICAgICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQsICdpbnB1dFByb3BlcnRpZXMnLCBhcnIpO1xyXG4gICAgICAgICAgdGhhdC51cGRhdGVQcmV2aWV3KHJ1bGUsIHByZXZpZXdDb21wb25lbnQpO1xyXG4gICAgICB9KTtcclxuICAgIFxyXG4gICAgbmV3IFNldHRpbmcob3B0aW9uRUwpXHJcbiAgICAgICAgLnNldE5hbWUoJ0RlbGltaXRlcicpXHJcbiAgICAgICAgLnNldERlc2MoJ1NwZWNpZnkgYSBkZWxpbWl0ZXIgdG8gdXNlIHdoZW4gY29uY2F0ZW5hdGluZyBwcm9wZXJ0aWVzLiBEZWZhdWx0IGlzIGEgc3BhY2UuJylcclxuICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuICAgICAgICAgICAgLnNldFZhbHVlKHRoYXQuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQgLCdkZWxpbWl0ZXInKSB8fCAnJylcclxuICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdFbnRlciBkZWxpbWl0ZXInKVxyXG4gICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZyhydWxlLmlkLCdkZWxpbWl0ZXInLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZVByZXZpZXcocnVsZSwgcHJldmlld0NvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgKTtcclxuICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgIC5zZXROYW1lKCdPbmx5IHdoZW4gYWxsIHByb3BlcnRpZXMgZXhpc3QnKVxyXG4gICAgICAgIC5zZXREZXNjKCdJZiBlbmFibGVkLCB0aGUgcnVsZSB3aWxsIG9ubHkgcmV0dXJuIGEgdmFsdWUgaWYgYWxsIHNlbGVjdGVkIHByb3BlcnRpZXMgZXhpc3QgYW5kIG5vdCBlbXB0eS4nKVxyXG4gICAgICAgIC5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxyXG4gICAgICAgICAgICAuc2V0VmFsdWUodGhhdC5nZXRPcHRpb25Db25maWcocnVsZS5pZCwgJ29ubHlXaGVuQWxsUHJvcGVydGllc0V4aXN0JykpXHJcbiAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQsICdvbmx5V2hlbkFsbFByb3BlcnRpZXNFeGlzdCcsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHRoYXQudXBkYXRlUHJldmlldyhydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICApO1xyXG4gIH07XHJcbn0iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFNldHRpbmcsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGJ1aWx0LWluIHJ1bGUgdGhhdCByZXR1cm5zIGEgY29uc3RhbnQgdmFsdWUgaW5zdGVhZCBvZiBleHRyYWN0aW5nIGEgdmFsdWUgZnJvbSB0aGUgZnJvbnRtYXR0ZXIuXHJcbiAqXHJcbiAqIFRoaXMgcnVsZSBhbGxvd3MgdXNlcnMgdG8gc3BlY2lmeSBhIGNvbnN0YW50IHZhbHVlIHRoYXQgd2lsbCBhbHdheXMgYmUgcmV0dXJuZWQgd2hlbiB0aGUgcnVsZSBpcyBleGVjdXRlZC5cclxuICogVGhlIHZhbHVlIGNhbiBiZSBjb25maWd1cmVkIHZpYSB0aGUgcGx1Z2luJ3Mgc2V0dGluZ3MgVUkuXHJcbiAqXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICpcclxuICogQHJlbWFya3NcclxuICogLSBUaGUgcnVsZSB0eXBlIGlzIHNldCB0byBgJ2J1aWxkSW4nYC5cclxuICogLSBUaGUgY29uc3RhbnQgdmFsdWUgaXMgY29uZmlndXJlZCB1c2luZyB0aGUgYGNvbnN0YW50VmFsdWVgIG9wdGlvbi5cclxuICogLSBUaGUgcnVsZSBzdXBwb3J0cyBtdWx0aXBsZSB0eXBlczogYCd0ZXh0J2AsIGAndGFncydgLCBgJ2FsaWFzZXMnYCwgYW5kIGAnbXVsdGl0ZXh0J2AuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY29uc3QgcnVsZSA9IG5ldyBSdWxlQnVpbGRJbkNvbnN0YW50KCk7XHJcbiAqIGNvbnN0IHZhbHVlID0gcnVsZS5meChhcHAsIGZpbGUsIHRvb2xzKTsgLy8gUmV0dXJucyB0aGUgY29uZmlndXJlZCBjb25zdGFudCB2YWx1ZVxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlQnVpbGRJbkNvbnN0YW50IGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaWQgPSAnY29uc3RhbnQnO1xyXG4gICAgICAgIHRoaXMucnVsZVR5cGUgPSAnYnVpbGRJbic7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ0NvbnN0YW50IHZhbHVlJztcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gJ1JldHVybnMgYSBjb25zdGFudCB2YWx1ZSBpbnN0ZWFkIG9mIHRoZSBmcm9udG1hdHRlciBwYXJhbWV0ZXIuJztcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBjb25zdCByZXN1bHQgPSB0b29scy5nZXRPcHRpb25Db25maWcodG9vbHMuZ2V0UnVsZSgpPy5pZCwnY29uc3RhbnRWYWx1ZScpO1xcbiAgcmV0dXJuIHJlc3VsdDsgLy8gUmV0dXJuIHRoZSBjb25zdGFudCB2YWx1ZVxcbn07XCI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gICAgfVxyXG4gICAgZngoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdG9vbHMuZ2V0T3B0aW9uQ29uZmlnKHRvb2xzLmdldFJ1bGUoKT8uaWQsJ2NvbnN0YW50VmFsdWUnKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0OyAvLyBSZXR1cm4gdGhlIGNvbnN0YW50IHZhbHVlXHJcbiAgICB9O1xyXG4gICAgY29uZmlnVGFiKG9wdGlvbkVMOiBIVE1MRWxlbWVudCwgcnVsZTogRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDogYW55LCBwcmV2aWV3Q29tcG9uZW50OiBhbnkpIHtcclxuICAgICAgICBvcHRpb25FTC5lbXB0eSgpO1xyXG4gICAgICAgIC8vIENyZWF0ZSBhIHNldHRpbmcgZm9yIHRoZSBjb25zdGFudCB2YWx1ZVxyXG4gICAgICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnRGVmYXVsdHMocnVsZS5pZCwge1xyXG4gICAgICAgICAgICBjb25zdGFudFZhbHVlOiAnJyxcclxuICAgICAgICB9KVxyXG4gICAgICAgIC8vIENyZWF0ZSBhIHNldHRpbmcgZm9yIHRoZSBjb25zdGFudCB2YWx1ZVxyXG4gICAgICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnQ29uc3RhbnQgdmFsdWUnKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnRW50ZXIgYSBjb25zdGFudCB2YWx1ZSB0byBiZSB1c2VkIGluIHRoZSBydWxlJylcclxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhhdC5nZXRPcHRpb25Db25maWcocnVsZS5pZCAsJ2NvbnN0YW50VmFsdWUnKSB8fCAnJylcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZyhydWxlLmlkLCdjb25zdGFudFZhbHVlJywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudXBkYXRlUHJldmlldyhydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICk7XHJcbiAgICB9O1xyXG59IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MgfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgYnVpbHQtaW4gcnVsZSB0aGF0IHJldHVybnMgdGhlIGRhdGUgYW5kIHRpbWUgd2hlbiBhIGZpbGUgd2FzIGNyZWF0ZWQuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFRoaXMgcnVsZSBjYWxjdWxhdGVzIHRoZSBmaWxlIGNyZWF0aW9uIGRhdGUgYW5kIHRpbWUsIGFkanVzdGVkIGZvciB0aGUgbG9jYWwgdGltZXpvbmUsXHJcbiAqIGFuZCByZXR1cm5zIGl0IGFzIGFuIElTTyBzdHJpbmcgd2l0aG91dCB0aGUgdHJhaWxpbmcgJ1onIChVVEMgc3ltYm9sKS5cclxuICpcclxuICogQGV4dGVuZHMgUnVsZVByb3RvdHlwZVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNvbnN0IHJ1bGUgPSBuZXcgUnVsZUJ1aWxkSW5EYXRlVGltZUNyZWF0ZWQoKTtcclxuICogY29uc3QgY3JlYXRlZERhdGUgPSBydWxlLmZ4KGFwcCwgZmlsZSwgdG9vbHMpO1xyXG4gKiAvLyBjcmVhdGVkRGF0ZSB3aWxsIGJlIGEgc3RyaW5nIGxpa2UgXCIyMDI0LTA2LTAxVDEyOjM0OjU2Ljc4OVwiXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcHJvcGVydHkgaWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBydWxlICgnZGF0ZVRpbWVDcmVhdGVkJykuXHJcbiAqIEBwcm9wZXJ0eSBydWxlVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBydWxlICgnYnVpbGRJbicpLlxyXG4gKiBAcHJvcGVydHkgbmFtZSAtIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSBkZXNjcmlwdGlvbiAtIEEgZGVzY3JpcHRpb24gb2Ygd2hhdCB0aGUgcnVsZSBkb2VzLlxyXG4gKiBAcHJvcGVydHkgc291cmNlIC0gVGhlIHNvdXJjZSBjb2RlIG9mIHRoZSBydWxlJ3MgbWFpbiBmdW5jdGlvbiBhcyBhIHN0cmluZy5cclxuICogQHByb3BlcnR5IHR5cGUgLSBUaGUgdHlwZXMgb2YgZGF0YSByZXR1cm5lZCBieSB0aGUgcnVsZSAoWydkYXRlJywgJ2RhdGV0aW1lJ10pLlxyXG4gKiBAcHJvcGVydHkgY29uZmlnRWxlbWVudHMgLSBUaGUgY29uZmlndXJhdGlvbiBlbGVtZW50cyBmb3IgdGhlIHJ1bGUuXHJcbiAqXHJcbiAqIEBtZXRob2QgZnggLSBSZXR1cm5zIHRoZSBmaWxlIGNyZWF0aW9uIGRhdGUgYW5kIHRpbWUgYXMgYSBsb2NhbCBJU08gc3RyaW5nLlxyXG4gKiBAbWV0aG9kIGNvbmZpZ1RhYiAtIChPcHRpb25hbCkgQWRkcyBjb25maWd1cmF0aW9uIFVJIGVsZW1lbnRzIGZvciB0aGUgcnVsZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlQnVpbGRJbkRhdGVUaW1lQ3JlYXRlZCBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlkID0gJ2RhdGVUaW1lQ3JlYXRlZCc7XHJcbiAgICAgICAgdGhpcy5ydWxlVHlwZSA9ICdidWlsZEluJztcclxuICAgICAgICB0aGlzLm5hbWUgPSAnRGF0ZSAoYW5kIFRpbWUpIGNyZWF0ZWQnO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnVGhpcyBydWxlIHJldHVybnMgdGhlIGRhdGUgYW5kIHRpbWUgd2hlbiB0aGUgZmlsZSB3YXMgY3JlYXRlZCwgYWRqdXN0ZWQgZm9yIGxvY2FsIHRpbWV6b25lLic7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBURmlsZSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lISBcXG4gY29uc3QgdGltZU9mZnNldCA9IG5ldyBEYXRlKERhdGUubm93KCkpLmdldFRpbWV6b25lT2Zmc2V0KCkqNjAwMDA7IC8vIGdldCBsb2NhbCB0aW1lIG9mZnNldCBcXG4gY29uc3QgcmVzdWx0ID0gbmV3IERhdGUoZmlsZS5zdGF0LmN0aW1lLXRpbWVPZmZzZXQpOyBcXG4gcmV0dXJuIHJlc3VsdC50b0lTT1N0cmluZygpLnNwbGl0KCdaJylbMF07IC8vIHJlbW92ZSBVVEMgc3ltYm9sIFxcbiB9XCI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gWydkYXRlJywgJ2RhdGV0aW1lJ107XHJcbiAgICAgICAgdGhpcy5jb25maWdFbGVtZW50cyA9IHRoaXMuZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnggKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBURmlsZSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIGNvbnN0IHRpbWVPZmZzZXQgPSBuZXcgRGF0ZShEYXRlLm5vdygpKS5nZXRUaW1lem9uZU9mZnNldCgpKjYwMDAwOyAvLyBnZXQgbG9jYWwgdGltZSBvZmZzZXRcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRGF0ZShmaWxlLnN0YXQuY3RpbWUtdGltZU9mZnNldCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC50b0lTT1N0cmluZygpLnNwbGl0KCdaJylbMF07IC8vIHJlbW92ZSBVVEMgc3ltYm9sXHJcbiAgICAgIH1cclxuXHJcbiAgICBjb25maWdUYWIgKG9wdGlvbkVMOiBIVE1MRWxlbWVudCwgcnVsZTpGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCB0aGF0OmFueSwgcHJldmlld0NvbXBvbmVudDogYW55KSB7XHJcbiAgICAgICAgLy8gQ29uZmlndXJhdGlvbiB0YWIgbG9naWMgY2FuIGJlIGFkZGVkIGhlcmUgaWYgbmVlZGVkXHJcbiAgICB9O1xyXG4gICAgXHJcbn0iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBidWlsdC1pbiBydWxlIHRoYXQgcmV0dXJucyB0aGUgZGF0ZSBhbmQgdGltZSB3aGVuIGEgZmlsZSB3YXMgY3JlYXRlZC5cclxuICpcclxuICogQHJlbWFya3NcclxuICogVGhpcyBydWxlIGNhbGN1bGF0ZXMgdGhlIGZpbGUgY3JlYXRpb24gZGF0ZSBhbmQgdGltZSwgYWRqdXN0ZWQgZm9yIHRoZSBsb2NhbCB0aW1lem9uZSxcclxuICogYW5kIHJldHVybnMgaXQgYXMgYW4gSVNPIHN0cmluZyB3aXRob3V0IHRoZSB0cmFpbGluZyAnWicgKFVUQyBzeW1ib2wpLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY29uc3QgcnVsZSA9IG5ldyBSdWxlQnVpbGRJbkRhdGVUaW1lQ3JlYXRlZCgpO1xyXG4gKiBjb25zdCBjcmVhdGVkRGF0ZSA9IHJ1bGUuZngoYXBwLCBmaWxlLCB0b29scyk7XHJcbiAqIC8vIGNyZWF0ZWREYXRlIHdpbGwgYmUgYSBzdHJpbmcgbGlrZSBcIjIwMjQtMDYtMDFUMTI6MzQ6NTYuNzg5XCJcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSBpZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHJ1bGUgKCdkYXRlVGltZUNyZWF0ZWQnKS5cclxuICogQHByb3BlcnR5IHJ1bGVUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIHJ1bGUgKCdidWlsZEluJykuXHJcbiAqIEBwcm9wZXJ0eSBuYW1lIC0gVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IGRlc2NyaXB0aW9uIC0gQSBkZXNjcmlwdGlvbiBvZiB3aGF0IHRoZSBydWxlIGRvZXMuXHJcbiAqIEBwcm9wZXJ0eSBzb3VyY2UgLSBUaGUgc291cmNlIGNvZGUgb2YgdGhlIHJ1bGUncyBtYWluIGZ1bmN0aW9uIGFzIGEgc3RyaW5nLlxyXG4gKiBAcHJvcGVydHkgdHlwZSAtIFRoZSB0eXBlcyBvZiBkYXRhIHJldHVybmVkIGJ5IHRoZSBydWxlIChbJ2RhdGUnLCAnZGF0ZXRpbWUnXSkuXHJcbiAqIEBwcm9wZXJ0eSBjb25maWdFbGVtZW50cyAtIFRoZSBjb25maWd1cmF0aW9uIGVsZW1lbnRzIGZvciB0aGUgcnVsZS5cclxuICpcclxuICogQG1ldGhvZCBmeCAtIFJldHVybnMgdGhlIGZpbGUgY3JlYXRpb24gZGF0ZSBhbmQgdGltZSBhcyBhIGxvY2FsIElTTyBzdHJpbmcuXHJcbiAqIEBtZXRob2QgY29uZmlnVGFiIC0gKE9wdGlvbmFsKSBBZGRzIGNvbmZpZ3VyYXRpb24gVUkgZWxlbWVudHMgZm9yIHRoZSBydWxlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVCdWlsZEluRGF0ZVRpbWVNb2RpZmllZCBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlkID0gJ2RhdGVUaW1lTW9kaWZpZWQnO1xyXG4gICAgICAgIHRoaXMucnVsZVR5cGUgPSAnYnVpbGRJbic7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ0RhdGUgKGFuZCBUaW1lKSBtb2RpZmllZCc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdUaGlzIHJ1bGUgcmV0dXJucyB0aGUgZGF0ZSBhbmQgdGltZSB3aGVuIHRoZSBmaWxlIHdhcyBsYXN0IG1vZGlmaWVkLCBhZGp1c3RlZCBmb3IgbG9jYWwgdGltZXpvbmUuJztcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IFwiZnVuY3Rpb24oYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhIFxcbiBjb25zdCB0aW1lT2Zmc2V0ID0gbmV3IERhdGUoRGF0ZS5ub3coKSkuZ2V0VGltZXpvbmVPZmZzZXQoKSo2MDAwMDsgLy8gZ2V0IGxvY2FsIHRpbWUgb2Zmc2V0IFxcbiBjb25zdCByZXN1bHQgPSBuZXcgRGF0ZShmaWxlLnN0YXQubXRpbWUtdGltZU9mZnNldCk7IFxcbiByZXR1cm4gcmVzdWx0LnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1onKVswXTsgLy8gcmVtb3ZlIFVUQyBzeW1ib2wgXFxuIH1cIjtcclxuICAgICAgICB0aGlzLnR5cGUgPSBbJ2RhdGUnLCAnZGF0ZXRpbWUnXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAgICAgY29uc3QgdGltZU9mZnNldCA9IG5ldyBEYXRlKERhdGUubm93KCkpLmdldFRpbWV6b25lT2Zmc2V0KCkqNjAwMDA7IC8vIGdldCBsb2NhbCB0aW1lIG9mZnNldFxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBEYXRlKGZpbGUuc3RhdC5tdGltZS10aW1lT2Zmc2V0KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1onKVswXTsgLy8gcmVtb3ZlIFVUQyBzeW1ib2xcclxuICAgICAgfVxyXG5cclxuICAgIGNvbmZpZ1RhYiAob3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOkZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIHRoYXQ6YW55LCBwcmV2aWV3Q29tcG9uZW50OiBhbnkpIHtcclxuICAgICAgICAvLyBDb25maWd1cmF0aW9uIHRhYiBsb2dpYyBjYW4gYmUgYWRkZWQgaGVyZSBpZiBuZWVkZWRcclxuICAgIH07XHJcbiAgICBcclxufSIsICJpbXBvcnQgeyBSdWxlUHJvdG90eXBlLCBydWxlc01hbmFnZXIgfSBmcm9tIFwiLi9ydWxlc1wiO1xyXG5pbXBvcnQgeyBTY3JpcHRpbmdUb29scyB9IGZyb20gXCIuLi90b29sc1wiO1xyXG5pbXBvcnQgeyBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzIH0gZnJvbSBcIi4uL3R5cGVzXCI7XHJcbmltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgYnVpbHQtaW4gcnVsZSB0aGF0IHBhc3NlcyB0aGUgY29udGVudCBvZiBhIGZyb250bWF0dGVyIHBhcmFtZXRlciB1bmFsdGVyZWQuXHJcbiAqIFRoaXMgcnVsZSBpcyB1c2VkIHRvIHJldHVybiB0aGUgaW5wdXQgY29udGVudCB3aXRob3V0IGFueSBtb2RpZmljYXRpb25zLlxyXG4gKiBcclxuICogQGV4dGVuZHMgUnVsZVByb3RvdHlwZVxyXG4gKiBcclxuICogQHJlbWFya3NcclxuICogLSBUaGUgYGZ4YCBmdW5jdGlvbiBhbmQgYHNvdXJjZWAgcHJvcGVydHkgYXJlIGRlc2lnbmVkIHRvIHByb2Nlc3MgdGhlIGlucHV0IGNvbnRlbnQgYW5kIHJldHVybiBpdCBhcy1pcy5cclxuICogLSBUaGlzIHJ1bGUgc3VwcG9ydHMgbXVsdGlwbGUgdHlwZXMgaW5jbHVkaW5nIGB0ZXh0YCwgYHRhZ3NgLCBgYWxpYXNlc2AsIGFuZCBgbXVsdGl0ZXh0YC5cclxuICogLSBUaGUgYGNvbmZpZ1RhYmAgbWV0aG9kIGlzIGN1cnJlbnRseSBhIHBsYWNlaG9sZGVyIGZvciBjb25maWd1cmF0aW9uIFVJIGVsZW1lbnRzLlxyXG4gKiBcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcnVsZSwgc2V0IHRvIGAnZGVmYXVsdCdgLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcnVsZVR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgcnVsZSwgc2V0IHRvIGAnYnVpbGRJbidgLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIHJ1bGUsIHNldCB0byBgJ1Bhc3MgcGFyYW1ldGVyIHVuYWx0ZXJlZCdgLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGVzY3JpcHRpb24gLSBBIGJyaWVmIGRlc2NyaXB0aW9uIG9mIHRoZSBydWxlJ3MgZnVuY3Rpb25hbGl0eS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZSAtIFRoZSBzb3VyY2UgY29kZSBvZiB0aGUgcnVsZSBhcyBhIHN0cmluZywgdXNlZCBmb3Igc2NyaXB0aW5nIHB1cnBvc2VzLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSB0eXBlIC0gVGhlIHN1cHBvcnRlZCB0eXBlcyBmb3IgdGhpcyBydWxlLCBpbmNsdWRpbmcgYHRleHRgLCBgdGFnc2AsIGBhbGlhc2VzYCwgYW5kIGBtdWx0aXRleHRgLlxyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBmeCAtIFRoZSBtYWluIGZ1bmN0aW9uIHRoYXQgcHJvY2Vzc2VzIHRoZSBpbnB1dCBjb250ZW50IGFuZCByZXR1cm5zIGl0IHVuYWx0ZXJlZC5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gY29uZmlnVGFiIC0gQSBtZXRob2QgZm9yIHJlbmRlcmluZyB0aGUgY29uZmlndXJhdGlvbiB0YWIgZm9yIHRoZSBydWxlLlxyXG4gKiBcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgUnVsZUJ1aWxkSW5EZWZhdWx0YCBjbGFzcy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlQnVpbGRJbkRlZmF1bHQgZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9ICdkZWZhdWx0JztcclxuICAgICAgICB0aGlzLnJ1bGVUeXBlID0gJ2J1aWxkSW4nO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdQYXNzIHBhcmFtZXRlciB1bmFsdGVyZWQnO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnUGFzcyB0aGUgY29udGVudCBvZiB0aGUgZnJvbnRtYXR0ZXIgcGFyYW1ldGVyIHVuYWx0ZXJlZC4nO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIGNvbnN0IGlucHV0ID0gdG9vbHMuZ2V0Q3VycmVudENvbnRlbnQoKTsgLy8gR2V0IHRoZSBjdXJyZW50IGNvbnRlbnQgb2YgcHJvcGVydHlcXG4gIHJldHVybiBpbnB1dDsgLy8gUmV0dXJuIHRoZSBpbnB1dCB1bmFsdGVyZWRcXG59O1wiO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICAgICAgdGhpcy5jb25maWdFbGVtZW50cyA9IHRoaXMuZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnggKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBURmlsZSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIGNvbnN0IGlucHV0ID0gdG9vbHMuZ2V0Q3VycmVudENvbnRlbnQoKTsgLy8gR2V0IHRoZSBjdXJyZW50IGNvbnRlbnQgb2YgcHJvcGVydHlcclxuICAgICAgICByZXR1cm4gaW5wdXQ7IC8vIFJldHVybiB0aGUgaW5wdXQgdW5hbHRlcmVkXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbmZpZ1RhYiAob3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOkZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIHRoYXQ6YW55LCBwcmV2aWV3Q29tcG9uZW50OiBhbnkpIHtcclxuICAgICAgICAvLyBDb25maWd1cmF0aW9uIHRhYiBsb2dpYyBjYW4gYmUgYWRkZWQgaGVyZSBpZiBuZWVkZWRcclxuICAgIH07XHJcbiAgICBcclxufSIsICJpbXBvcnQgeyBSdWxlUHJvdG90eXBlLCBydWxlc01hbmFnZXIgfSBmcm9tIFwiLi9ydWxlc1wiO1xyXG5pbXBvcnQgeyBTY3JpcHRpbmdUb29scyB9IGZyb20gXCIuLi90b29sc1wiO1xyXG5pbXBvcnQgeyBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzIH0gZnJvbSBcIi4uL3R5cGVzXCI7XHJcbmltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGJ1aWx0LWluIHJ1bGUgdGhhdCByZXRyaWV2ZXMgdGhlIHNpemUgb2YgYSBmaWxlIGluIGJ5dGVzLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUaGlzIHJ1bGUgaXMgaW50ZW5kZWQgZm9yIHVzZSB3aXRoaW4gdGhlIEZvbGRlciB0byBUYWdzIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqIEl0IGV4dGVuZHMgdGhlIHtAbGluayBSdWxlUHJvdG90eXBlfSBjbGFzcyBhbmQgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSB0byByZXR1cm5cclxuICogdGhlIGZpbGUgc2l6ZSBpbiBieXRlcyB1c2luZyB0aGUgYGZpbGUuc3RhdC5zaXplYCBwcm9wZXJ0eS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjb25zdCBydWxlID0gbmV3IFJ1bGVCdWlsZEluRmlsZVNpemVCeXRlcygpO1xyXG4gKiBjb25zdCBzaXplID0gcnVsZS5meChhcHAsIGZpbGUsIHRvb2xzKTsgLy8gUmV0dXJucyB0aGUgZmlsZSBzaXplIGluIGJ5dGVzXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlQnVpbGRJbkZpbGVTaXplQnl0ZXMgZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9ICdmaWxlU2l6ZUJ5dGVzJztcclxuICAgICAgICB0aGlzLnJ1bGVUeXBlID0gJ2J1aWxkSW4nO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdGaWxlIFNpemUgaW4gQnl0ZXMnO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnVGhpcyBydWxlIHJldHVybnMgdGhlIHNpemUgb2YgdGhlIGZpbGUgaW4gYnl0ZXMuJztcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IFwiZnVuY3Rpb24oYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhIFxcbiBjb25zdCByZXN1bHQgPSBmaWxlLnN0YXQuc2l6ZTsgXFxuIHJldHVybiByZXN1bHQ7IC8vIHJldHVybiB5b3UgcmVzdWx0LiBcXG4gfVwiO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFsnbnVtYmVyJ107XHJcbiAgICAgICAgdGhpcy5jb25maWdFbGVtZW50cyA9IHRoaXMuZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnggKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBURmlsZSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIC8vIGFjcXVpcmUgZmlsZSBzaXplXHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZmlsZS5zdGF0LnNpemU7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDsgLy8gcmV0dXJuIHlvdSByZXN1bHQuXHJcbiAgICB9XHJcblxyXG4gICAgY29uZmlnVGFiIChvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6RnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDphbnksIHByZXZpZXdDb21wb25lbnQ6IGFueSkge1xyXG4gICAgICAgIC8vIENvbmZpZ3VyYXRpb24gdGFiIGxvZ2ljIGNhbiBiZSBhZGRlZCBoZXJlIGlmIG5lZWRlZFxyXG4gICAgfTtcclxuICAgIFxyXG59IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MgfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBidWlsdC1pbiBydWxlIHRoYXQgcmV0dXJucyB0aGUgc2l6ZSBvZiBhIGZpbGUgYXMgYSBodW1hbi1yZWFkYWJsZSBzdHJpbmcuXHJcbiAqXHJcbiAqIFRoaXMgcnVsZSBjb252ZXJ0cyB0aGUgZmlsZSBzaXplIGZyb20gYnl0ZXMgdG8gS0IsIE1CLCBvciBHQiBhcyBhcHByb3ByaWF0ZSxcclxuICogZm9ybWF0dGluZyB0aGUgcmVzdWx0IHdpdGggYSBmaXhlZCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIC0gVGhlIHJ1bGUgaXMgaWRlbnRpZmllZCBieSB0aGUgSUQgYCdmaWxlU2l6ZVN0cmluZydgLlxyXG4gKiAtIFRoZSBgZnhgIG1ldGhvZCBwZXJmb3JtcyB0aGUgZmlsZSBzaXplIGNvbnZlcnNpb24gYW5kIGZvcm1hdHRpbmcuXHJcbiAqIC0gVGhlIHJ1bGUgaXMgaW50ZW5kZWQgZm9yIHVzZSB3aXRoaW4gdGhlIEZvbGRlciB0byBUYWdzIHBsdWdpbiBmb3IgT2JzaWRpYW4uXHJcbiAqXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICpcclxuICogQGV4YW1wbGVcclxuICogLy8gUmV0dXJucyBcIjUxMiBCeXRlc1wiIGZvciBhIDUxMi1ieXRlIGZpbGVcclxuICogLy8gUmV0dXJucyBcIjEuMjMgS0JcIiBmb3IgYSBmaWxlIG9mIHNpemUgMTI1OSBieXRlc1xyXG4gKiAvLyBSZXR1cm5zIFwiMi4zNCBNQlwiIGZvciBhIGZpbGUgb2Ygc2l6ZSAyLDQ1MywxMjMgYnl0ZXNcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVCdWlsZEluRmlsZVNpemVTdHJpbmcgZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9ICdmaWxlU2l6ZVN0cmluZyc7XHJcbiAgICAgICAgdGhpcy5ydWxlVHlwZSA9ICdidWlsZEluJztcclxuICAgICAgICB0aGlzLm5hbWUgPSAnRmlsZSBTaXplIGFzIFN0cmluZyc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdDb252ZXJ0cyB0aGUgZmlsZSBzaXplIHRvIGEgaHVtYW4tcmVhZGFibGUgc3RyaW5nIChlLmcuLCBLQiwgTUIsIEdCKSB3aXRoIDIgZGVjaW1hbCBwbGFjZXMgcHJlY2lzaW9uLic7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBURmlsZSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lISBcXG4gbGV0IHNpemUgPWZpbGUuc3RhdC5zaXplOyBcXG4gY29uc3QgcHJlY2lzaW9uID0gMjsgLy8gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIFxcbiBpZiAoc2l6ZSA+IDEwMjQpIHsgXFxuICAgc2l6ZSA9IHNpemUgLyAxMDI0OyBcXG4gICBpZiAoc2l6ZSA+IDEwMjQpIHsgXFxuICAgICBzaXplID0gc2l6ZSAvIDEwMjQ7IFxcbiAgICAgaWYgKHNpemUgPiAxMDI0KSB7IFxcbiAgICAgICBzaXplID0gc2l6ZSAvIDEwMjQ7IFxcbiAgICAgICByZXR1cm4gc2l6ZS50b0ZpeGVkKHByZWNpc2lvbikgKyAnIEdCJzsgXFxuICAgICB9IFxcbiAgICAgcmV0dXJuIHNpemUudG9GaXhlZChwcmVjaXNpb24pICsgJyBNQic7IFxcbiAgIH0gXFxuICAgcmV0dXJuIHNpemUudG9GaXhlZChwcmVjaXNpb24pICsgJyBLQic7IFxcbiB9ICAgXFxuIHJldHVybiBzaXplICsgJyBCeXRlcyc7IC8vIHJldHVybiB5b3UgcmVzdWx0LiBcXG4gfVwiO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFsndGV4dCddO1xyXG4gICAgICAgIHRoaXMuY29uZmlnRWxlbWVudHMgPSB0aGlzLmRlZmF1bHRDb25maWdFbGVtZW50cyh7fSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ4IChhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogVEZpbGUsIHRvb2xzOiBTY3JpcHRpbmdUb29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgICAgIC8vIGFjcXVpcmUgZmlsZSBzaXplXHJcbiAgICAgICAgbGV0IHNpemUgPWZpbGUuc3RhdC5zaXplO1xyXG4gICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IDI7IC8vIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xyXG4gICAgICAgIGlmIChzaXplID4gMTAyNCkge1xyXG4gICAgICAgICAgc2l6ZSA9IHNpemUgLyAxMDI0O1xyXG4gICAgICAgICAgaWYgKHNpemUgPiAxMDI0KSB7XHJcbiAgICAgICAgICAgIHNpemUgPSBzaXplIC8gMTAyNDtcclxuICAgICAgICAgICAgaWYgKHNpemUgPiAxMDI0KSB7XHJcbiAgICAgICAgICAgICAgc2l6ZSA9IHNpemUgLyAxMDI0O1xyXG4gICAgICAgICAgICAgIHJldHVybiBzaXplLnRvRml4ZWQocHJlY2lzaW9uKSArICcgR0InO1xyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICByZXR1cm4gc2l6ZS50b0ZpeGVkKHByZWNpc2lvbikgKyAnIE1CJztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBzaXplLnRvRml4ZWQocHJlY2lzaW9uKSArICcgS0InO1xyXG4gICAgICAgIH0gICBcclxuICAgICAgICByZXR1cm4gc2l6ZSArICcgQnl0ZXMnOyAvLyByZXR1cm4geW91IHJlc3VsdC5cclxuICAgIH1cclxuXHJcbiAgICBjb25maWdUYWIgKG9wdGlvbkVMOiBIVE1MRWxlbWVudCwgcnVsZTpGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCB0aGF0OmFueSwgcHJldmlld0NvbXBvbmVudDogYW55KSB7XHJcbiAgICAgICAgLy8gQ29uZmlndXJhdGlvbiB0YWIgbG9naWMgY2FuIGJlIGFkZGVkIGhlcmUgaWYgbmVlZGVkXHJcbiAgICB9O1xyXG4gICAgXHJcbn0iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBidWlsdC1pbiBydWxlIHRoYXQgZXh0cmFjdHMgdGhlIHBhcmVudCBmb2xkZXIgb2YgYSBmaWxlLlxyXG4gKiBUaGlzIHJ1bGUgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGZvbGRlciBuYW1lIHRoYXQgZGlyZWN0bHkgY29udGFpbnMgdGhlIGZpbGUuXHJcbiAqIFxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqIFxyXG4gKiBAcmVtYXJrc1xyXG4gKiAtIFRoZSBgZnhgIG1ldGhvZCBjYWxjdWxhdGVzIHRoZSBwYXJlbnQgZm9sZGVyIGJ5IGFuYWx5emluZyB0aGUgZmlsZSBwYXRoLlxyXG4gKiAtIFRoZSBgc291cmNlYCBwcm9wZXJ0eSBjb250YWlucyBhIGRlZmF1bHQgZnVuY3Rpb24gdGVtcGxhdGUgZm9yIHNjcmlwdGluZyBwdXJwb3Nlcy5cclxuICogLSBUaGUgYHR5cGVgIHByb3BlcnR5IHNwZWNpZmllcyB0aGUgc3VwcG9ydGVkIGRhdGEgdHlwZXMgZm9yIHRoaXMgcnVsZS5cclxuICogLSBUaGUgYGNvbmZpZ1RhYmAgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIGRlZmluZSBhIGNvbmZpZ3VyYXRpb24gVUkgZm9yIHRoZSBydWxlLCBpZiBuZWVkZWQuXHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBFeGFtcGxlIHVzYWdlIG9mIHRoZSBgZnhgIG1ldGhvZDpcclxuICogY29uc3QgcGFyZW50Rm9sZGVyID0gcnVsZS5meChhcHAsIGZpbGUsIHRvb2xzKTtcclxuICogY29uc29sZS5sb2cocGFyZW50Rm9sZGVyKTsgLy8gT3V0cHV0cyB0aGUgbmFtZSBvZiB0aGUgcGFyZW50IGZvbGRlclxyXG4gKiBcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcnVsZSwgc2V0IHRvICdmb2xkZXInLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcnVsZVR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgcnVsZSwgc2V0IHRvICdidWlsZEluJy5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSBydWxlLCBzZXQgdG8gJ1BhcmVudCBmb2xkZXInLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGVzY3JpcHRpb24gLSBBIGJyaWVmIGRlc2NyaXB0aW9uIG9mIHRoZSBydWxlJ3MgZnVuY3Rpb25hbGl0eS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZSAtIEEgZGVmYXVsdCBmdW5jdGlvbiB0ZW1wbGF0ZSBmb3Igc2NyaXB0aW5nLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSB0eXBlIC0gVGhlIHN1cHBvcnRlZCBkYXRhIHR5cGVzIGZvciB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gY29uZmlnRWxlbWVudHMgLSBBIG1ldGhvZCB0byBkZWZpbmUgZGVmYXVsdCBjb25maWd1cmF0aW9uIGVsZW1lbnRzLlxyXG4gKiBcclxuICogQG1ldGhvZCBmeFxyXG4gKiBAcGFyYW0ge0FwcCB8IHVuZGVmaW5lZH0gYXBwIC0gVGhlIGFwcGxpY2F0aW9uIGluc3RhbmNlIChvcHRpb25hbCkuXHJcbiAqIEBwYXJhbSB7VEZpbGV9IGZpbGUgLSBUaGUgZmlsZSBvYmplY3QgZm9yIHdoaWNoIHRoZSBwYXJlbnQgZm9sZGVyIGlzIGRldGVybWluZWQuXHJcbiAqIEBwYXJhbSB7U2NyaXB0aW5nVG9vbHN9IHRvb2xzIC0gVXRpbGl0eSB0b29scyBmb3Igc2NyaXB0aW5nLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgcGFyZW50IGZvbGRlciwgb3IgYW4gZW1wdHkgc3RyaW5nIGlmIG5vIHBhcmVudCBleGlzdHMuXHJcbiAqIFxyXG4gKiBAbWV0aG9kIGNvbmZpZ1RhYlxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBvcHRpb25FTCAtIFRoZSBIVE1MIGVsZW1lbnQgZm9yIHRoZSBjb25maWd1cmF0aW9uIHRhYi5cclxuICogQHBhcmFtIHtGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzfSBydWxlIC0gVGhlIHJ1bGUgc2V0dGluZ3Mgb2JqZWN0LlxyXG4gKiBAcGFyYW0ge2FueX0gdGhhdCAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGNvbnRleHQuXHJcbiAqIEBwYXJhbSB7YW55fSBwcmV2aWV3Q29tcG9uZW50IC0gQSBjb21wb25lbnQgZm9yIHByZXZpZXdpbmcgY2hhbmdlcy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlQnVpbGRJbkZvbGRlciBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuaWQgPSAnZm9sZGVyJztcclxuICAgIHRoaXMucnVsZVR5cGUgPSAnYnVpbGRJbic7XHJcbiAgICB0aGlzLm5hbWUgPSAnUGFyZW50IGZvbGRlcic7XHJcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gJ1JldHVybnMgdGhlIHBhcmVudCBmb2xkZXIgb2YgdGhlIGZpbGUuJztcclxuICAgIHRoaXMuc291cmNlID0gXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIGNvbnN0IGlucHV0ID0gdG9vbHMuZ2V0Q3VycmVudENvbnRlbnQoKTsgLy8gR2V0IHRoZSBjdXJyZW50IGNvbnRlbnQgb2YgcHJvcGVydHlcXG4gIHJldHVybiBpbnB1dDsgLy8gUmV0dXJuIHRoZSBpbnB1dCB1bmFsdGVyZWRcXG59O1wiO1xyXG4gICAgdGhpcy50eXBlID0gWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXTtcclxuICAgIHRoaXMuY29uZmlnRWxlbWVudHMgPSB0aGlzLmRlZmF1bHRDb25maWdFbGVtZW50cyh7fSk7XHJcbiAgfVxyXG4gIFxyXG4gIGZ4IChhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogVEZpbGUsIHRvb2xzOiBTY3JpcHRpbmdUb29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgIC8vIGFjcXVpcmUgZmlsZSBwYXRoXHJcbiAgICBjb25zdCBwYXRoID0gZmlsZS5wYXRoO1xyXG4gICAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XHJcbiAgICBsZXQgcmVzdWx0ID0gJyc7XHJcbiAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xyXG4gICAgICByZXN1bHQgPSBwYXJ0c1twYXJ0cy5sZW5ndGgtMl07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgY29uZmlnVGFiIChvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6RnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDphbnksIHByZXZpZXdDb21wb25lbnQ6IGFueSkge1xyXG4gICAgLy8gQ29uZmlndXJhdGlvbiB0YWIgbG9naWMgY2FuIGJlIGFkZGVkIGhlcmUgaWYgbmVlZGVkXHJcbiAgfTtcclxuICAgIFxyXG59IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MgfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBidWlsdC1pbiBydWxlIHRoYXQgcmV0dXJucyB0aGUgcGFyZW50IGZvbGRlciBvZiBhIGZpbGUsXHJcbiAqIGNvbXBhdGlibGUgd2l0aCB0aGUgXCJGb2xkZXIgTm90ZXNcIiBjb252ZW50aW9uIGluIE9ic2lkaWFuLlxyXG4gKlxyXG4gKiBUaGlzIHJ1bGUgZGV0ZXJtaW5lcyB0aGUgcGFyZW50IGZvbGRlciBuYW1lIGZvciBhIGdpdmVuIGZpbGUsIHRha2luZyBpbnRvIGFjY291bnRcclxuICogdGhlIHNwZWNpYWwgY2FzZSB3aGVyZSB0aGUgZmlsZSBpcyBhIGZvbGRlciBub3RlIChpLmUuLCBpdHMgbmFtZSBtYXRjaGVzIGl0cyBwYXJlbnQgZm9sZGVyKS5cclxuICogSWYgdGhlIGZpbGUgaXMgbG9jYXRlZCBpbiB0aGUgcm9vdCBkaXJlY3RvcnksIHRoZSB2YXVsdCBuYW1lIGlzIHJldHVybmVkIGluc3RlYWQuXHJcbiAqXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICpcclxuICogQHJlbWFya3NcclxuICogLSBUaGUgcnVsZSBpcyBpZGVudGlmaWVkIGJ5IHRoZSBJRCAnZm9sZGVyRm9sZGVyTm90ZXMnLlxyXG4gKiAtIFRoZSBydWxlIHR5cGUgaXMgJ2J1aWxkSW4nLlxyXG4gKiAtIFRoZSBgZnhgIG1ldGhvZCBzaG91bGQgbm90IGhhdmUgaXRzIHNpZ25hdHVyZSBjaGFuZ2VkLCBhcyBpdCBpcyB1c2VkIGJ5IHRoZSBydWxlIGVuZ2luZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogLy8gRm9yIGEgZmlsZSBhdCAnUHJvamVjdHMvTm90ZXMvTm90ZXMubWQnICh3aGVyZSAnTm90ZXMnIGlzIGEgZm9sZGVyIG5vdGUpOlxyXG4gKiAvLyBSZXR1cm5zICdQcm9qZWN0cydcclxuICpcclxuICogLy8gRm9yIGEgZmlsZSBhdCAnUHJvamVjdHMvTm90ZXMvTWVldGluZy5tZCc6XHJcbiAqIC8vIFJldHVybnMgJ05vdGVzJ1xyXG4gKlxyXG4gKiAvLyBGb3IgYSBmaWxlIGF0IHRoZSB2YXVsdCByb290OlxyXG4gKiAvLyBSZXR1cm5zIHRoZSB2YXVsdCBuYW1lXHJcbiAqXHJcbiAqIEBwYXJhbSBhcHAgLSBUaGUgT2JzaWRpYW4gQXBwIGluc3RhbmNlIChtYXkgYmUgdW5kZWZpbmVkKS5cclxuICogQHBhcmFtIGZpbGUgLSBUaGUgdGFyZ2V0IFRGaWxlIGZvciB3aGljaCB0aGUgcGFyZW50IGZvbGRlciBpcyBkZXRlcm1pbmVkLlxyXG4gKiBAcGFyYW0gdG9vbHMgLSBVdGlsaXR5IHRvb2xzLCBpbmNsdWRpbmcgYWNjZXNzIHRvIHRoZSB2YXVsdC5cclxuICogQHJldHVybnMgVGhlIG5hbWUgb2YgdGhlIHBhcmVudCBmb2xkZXIsIG9yIHRoZSB2YXVsdCBuYW1lIGlmIHRoZSBmaWxlIGlzIGluIHRoZSByb290LlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVCdWlsZEluRm9sZGVyRm9sZGVyTm90ZXMgZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmlkID0gJ2ZvbGRlckZvbGRlck5vdGVzJztcclxuICAgICAgdGhpcy5ydWxlVHlwZSA9ICdidWlsZEluJztcclxuICAgICAgdGhpcy5uYW1lID0gJ1BhcmVudCBGb2xkZXIgKGNvbXBsaWVzIHdpdGggXCJmb2xkZXIgbm90ZXNcIiknO1xyXG4gICAgICB0aGlzLmRlc2NyaXB0aW9uID0gJ1JldHVybnMgdGhlIHBhcmVudCBmb2xkZXIgb2YgdGhlIGZpbGUgY29tcGF0aWJsZSB3aXRoIEZvbGRlciBOb3Rlcy4nO1xyXG4gICAgICB0aGlzLnNvdXJjZSA9IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICAvLyBhY3F1aXJlIGZpbGUgcGF0aFxcbiAgY29uc3QgcGF0aCA9IGZpbGUucGF0aDtjb25zdCBwYXJ0cyA9IGZpbGUucGF0aC5zcGxpdCgnLycpO1xcbiAgbGV0IGluZGV4ID0gcGFydHMubGVuZ3RoLTI7IC8vIGluZGV4IG9mIHBhcmVudCBmb2xkZXJcXG4gIGlmIChwYXJ0c1twYXJ0cy5sZW5ndGgtMl09PT1maWxlLmJhc2VuYW1lKSB7XFxuICAgICAgaW5kZXgtLTsgLy8gZm9sZGVyIG5vdGUgcGFyZW50IGlzIHRoZSBjaGlsZFxcbiAgfVxcbiAgaWYgKGluZGV4ID49IDApIHtcXG4gICAgcmV0dXJuIHBhcnRzW2luZGV4XTsgLy8gZmlsZSBpbiBmb2xkZXJcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiB0b29scy5hcHA/LnZhdWx0Py5nZXROYW1lKCkgfHwgJ1ZhdWx0JzsgLy8gZmlsZSBpbiByb290ID0gdmF1bHRcXG4gIH1cXG59XCI7XHJcbiAgICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICAgIHRoaXMuY29uZmlnRWxlbWVudHMgPSB0aGlzLmRlZmF1bHRDb25maWdFbGVtZW50cyh7fSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ4IChhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogVEZpbGUsIHRvb2xzOiBTY3JpcHRpbmdUb29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgICAgLy8gYWNxdWlyZSBmaWxlIHBhdGhcclxuICAgICAgY29uc3QgcGF0aCA9IGZpbGUucGF0aDtjb25zdCBwYXJ0cyA9IGZpbGUucGF0aC5zcGxpdCgnLycpO1xyXG4gICAgICBsZXQgaW5kZXggPSBwYXJ0cy5sZW5ndGgtMjsgLy8gaW5kZXggb2YgcGFyZW50IGZvbGRlclxyXG4gICAgICBpZiAocGFydHNbcGFydHMubGVuZ3RoLTJdPT09ZmlsZS5iYXNlbmFtZSkge1xyXG4gICAgICAgICAgaW5kZXgtLTsgLy8gZm9sZGVyIG5vdGUgcGFyZW50IGlzIHRoZSBjaGlsZFxyXG4gICAgICB9XHJcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzW2luZGV4XTsgLy8gZmlsZSBpbiBmb2xkZXJcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdG9vbHMuYXBwPy52YXVsdD8uZ2V0TmFtZSgpIHx8ICdWYXVsdCc7IC8vIGZpbGUgaW4gcm9vdCA9IHZhdWx0XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25maWdUYWIgKG9wdGlvbkVMOiBIVE1MRWxlbWVudCwgcnVsZTpGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCB0aGF0OmFueSwgcHJldmlld0NvbXBvbmVudDogYW55KSB7XHJcbiAgICAgICAgLy8gQ29uZmlndXJhdGlvbiB0YWIgbG9naWMgY2FuIGJlIGFkZGVkIGhlcmUgaWYgbmVlZGVkXHJcbiAgICB9O1xyXG4gICAgXHJcbn0iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG4vKipcclxuICogQSBidWlsdC1pbiBydWxlIHRoYXQgZXh0cmFjdHMgYWxsIGZvbGRlcnMgZnJvbSB0aGUgcGF0aCBvZiBhIGdpdmVuIGZpbGUgYW5kIHJldHVybnMgdGhlbSBhcyBhIGxpc3QuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFRoaXMgcnVsZSBpcyBpbnRlbmRlZCBmb3IgdXNlIHdpdGhpbiB0aGUgRm9sZGVyLXRvLVRhZ3MgT2JzaWRpYW4gcGx1Z2luLlxyXG4gKiBJdCBwcm92aWRlcyBhIHdheSB0byByZXRyaWV2ZSBhbGwgZm9sZGVyIG5hbWVzIChhcyBhIHN0cmluZyBhcnJheSkgdGhhdCBhIGZpbGUgaXMgc3RvcmVkIGluLFxyXG4gKiBleGNsdWRpbmcgdGhlIGZpbGUgbmFtZSBpdHNlbGYuXHJcbiAqXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICpcclxuICogQGV4YW1wbGVcclxuICogLy8gSWYgZmlsZS5wYXRoIGlzICdmb2xkZXIxL2ZvbGRlcjIvbXlmaWxlLm1kJywgdGhlIHJlc3VsdCB3aWxsIGJlIFsnZm9sZGVyMScsICdmb2xkZXIyJ11cclxuICpcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcnVsZSAoJ2ZvbGRlcnMnKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJ1bGVUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIHJ1bGUgKCdidWlsZEluJykuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uIC0gQSBkZXNjcmlwdGlvbiBvZiB3aGF0IHRoZSBydWxlIGRvZXMuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBUaGUgc291cmNlIG9mIHRoZSBydWxlIChlbXB0eSBmb3IgYnVpbHQtaW4pLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSB0eXBlIC0gVGhlIHR5cGVzIHRoaXMgcnVsZSBhcHBsaWVzIHRvIChlLmcuLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCcpLlxyXG4gKiBAcHJvcGVydHkge2FueVtdfSBjb25maWdFbGVtZW50cyAtIFRoZSBjb25maWd1cmF0aW9uIGVsZW1lbnRzIGZvciB0aGlzIHJ1bGUuXHJcbiAqXHJcbiAqIEBtZXRob2QgZnhcclxuICogUmV0dXJucyBhbGwgZm9sZGVycyB0aGUgZmlsZSBpcyBzdG9yZWQgaW4gYXMgYSBsaXN0LlxyXG4gKiBAcGFyYW0gYXBwIC0gVGhlIE9ic2lkaWFuIGFwcCBpbnN0YW5jZSAob3B0aW9uYWwpLlxyXG4gKiBAcGFyYW0gZmlsZSAtIFRoZSBmaWxlIHdob3NlIGZvbGRlcnMgYXJlIHRvIGJlIGV4dHJhY3RlZC5cclxuICogQHBhcmFtIHRvb2xzIC0gU2NyaXB0aW5nIHRvb2xzIHByb3ZpZGVkIGJ5IHRoZSBwbHVnaW4uXHJcbiAqIEByZXR1cm5zIHtzdHJpbmdbXX0gQW4gYXJyYXkgb2YgZm9sZGVyIG5hbWVzLlxyXG4gKlxyXG4gKiBAbWV0aG9kIGNvbmZpZ1RhYlxyXG4gKiBPcHRpb25hbCBjb25maWd1cmF0aW9uIHRhYiBsb2dpYyBmb3IgdGhlIHJ1bGUuXHJcbiAqIEBwYXJhbSBvcHRpb25FTCAtIFRoZSBIVE1MIGVsZW1lbnQgZm9yIHRoZSBjb25maWd1cmF0aW9uIHRhYi5cclxuICogQHBhcmFtIHJ1bGUgLSBUaGUgcnVsZSBzZXR0aW5ncy5cclxuICogQHBhcmFtIHRoYXQgLSBUaGUgY29udGV4dCBvYmplY3QuXHJcbiAqIEBwYXJhbSBwcmV2aWV3Q29tcG9uZW50IC0gVGhlIHByZXZpZXcgY29tcG9uZW50IGZvciB0aGUgY29uZmlndXJhdGlvbiBVSS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlQnVpbGRJbkZvbGRlcnMgZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmlkID0gJ2ZvbGRlcnMnO1xyXG4gICAgICB0aGlzLnJ1bGVUeXBlID0gJ2J1aWxkSW4nO1xyXG4gICAgICB0aGlzLm5hbWUgPSAnQWxsIGZvbGRlcnMgb2YgdGhlIGZpbGUgYXMgYSBsaXN0JztcclxuICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdSZXR1cm5zIGFsbCBmb2xkZXJzIHRoZSBmaWxlIGlzIHN0b3JlZCBpbiBhcyBhIGxpc3QuJztcclxuICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgLy8gYWNxdWlyZSBmaWxlIHBhdGhcXG4gIGNvbnN0IHBhdGggPSBmaWxlLnBhdGg7XFxuICBjb25zdCByZXN1bHQgPSBwYXRoLnNwbGl0KCcvJyk7XFxuICByZXN1bHQucG9wKCk7IC8vIHJlbW92ZSB0aGUgZmlsZSBuYW1lXFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIjtcclxuICAgICAgdGhpcy50eXBlID0gWyd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICAgIHRoaXMuY29uZmlnRWxlbWVudHMgPSB0aGlzLmRlZmF1bHRDb25maWdFbGVtZW50cyh7fSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ4IChhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogVEZpbGUsIHRvb2xzOiBTY3JpcHRpbmdUb29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgICAgLy8gYWNxdWlyZSBmaWxlIHBhdGhcclxuICAgICAgY29uc3QgcGF0aCA9IGZpbGUucGF0aDtcclxuICAgICAgY29uc3QgcmVzdWx0ID0gcGF0aC5zcGxpdCgnLycpO1xyXG4gICAgICByZXN1bHQucG9wKCk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgY29uZmlnVGFiIChvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6RnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDphbnksIHByZXZpZXdDb21wb25lbnQ6IGFueSkge1xyXG4gICAgICAgIC8vIENvbmZpZ3VyYXRpb24gdGFiIGxvZ2ljIGNhbiBiZSBhZGRlZCBoZXJlIGlmIG5lZWRlZFxyXG4gICAgfTtcclxuICAgIFxyXG59IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MgfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgcnVsZSB0aGF0IGdlbmVyYXRlcyB0aGUgZnVsbCBwYXRoIG9mIGEgZmlsZSwgaW5jbHVkaW5nIGl0cyBmaWxlbmFtZS5cclxuICogVGhpcyBydWxlIGlzIGJ1aWx0LWluIGFuZCBjYW4gYmUgdXNlZCB0byByZXRyaWV2ZSB0aGUgY29tcGxldGUgZmlsZSBwYXRoIGFzIGEgc3RyaW5nLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIC0gVGhlIGBmeGAgZnVuY3Rpb24gc3BsaXRzIHRoZSBmaWxlIHBhdGgsIHJlbW92ZXMgdGhlIGxhc3QgcGFydCAoYXNzdW1lZCB0byBiZSB0aGUgZmlsZW5hbWUpLFxyXG4gKiAgIGFwcGVuZHMgdGhlIGZpbGUncyBiYXNlbmFtZSwgYW5kIHRoZW4gam9pbnMgdGhlIHBhcnRzIGJhY2sgdG9nZXRoZXIgdG8gZm9ybSB0aGUgZnVsbCBwYXRoLlxyXG4gKiAtIFRoaXMgcnVsZSBjYW4gYmUgdXNlZCBmb3IgbXVsdGlwbGUgcHJvcGVydHkgdHlwZXM6IGB0ZXh0YCwgYHRhZ3NgLCBgYWxpYXNlc2AsIGFuZCBgbXVsdGl0ZXh0YC5cclxuICpcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcnVsZSAoYCdmdWxsUGF0aCdgKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJ1bGVUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIHJ1bGUgKGAnYnVpbGRJbidgKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSBydWxlIChgJ0Z1bGwgcGF0aCwgZmlsZW5hbWUnYCkuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXNjcmlwdGlvbiAtIEEgYnJpZWYgZGVzY3JpcHRpb24gb2YgdGhlIHJ1bGUncyBmdW5jdGlvbmFsaXR5LlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc291cmNlIC0gVGhlIHNvdXJjZSBjb2RlIG9mIHRoZSBydWxlJ3MgZnVuY3Rpb24gYXMgYSBzdHJpbmcuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHR5cGUgLSBUaGUgcHJvcGVydHkgdHlwZXMgdGhlIHJ1bGUgY2FuIGJlIHVzZWQgZm9yLlxyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBmeCAtIFRoZSBmdW5jdGlvbiB0aGF0IGltcGxlbWVudHMgdGhlIHJ1bGUncyBsb2dpYy5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gY29uZmlnVGFiIC0gQSBwbGFjZWhvbGRlciBmdW5jdGlvbiBmb3IgY29uZmlndXJpbmcgdGhlIHJ1bGUgaW4gdGhlIFVJLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBFeGFtcGxlIHVzYWdlIG9mIHRoZSBgZnhgIGZ1bmN0aW9uOlxyXG4gKiBjb25zdCBmdWxsUGF0aCA9IHJ1bGUuZngoYXBwLCBmaWxlLCB0b29scyk7XHJcbiAqIGNvbnNvbGUubG9nKGZ1bGxQYXRoKTsgLy8gT3V0cHV0cyB0aGUgZnVsbCBwYXRoIG9mIHRoZSBmaWxlLCBpbmNsdWRpbmcgaXRzIGZpbGVuYW1lLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVCdWlsZEluRnVsbFBhdGggZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9ICdmdWxsUGF0aCc7XHJcbiAgICAgICAgdGhpcy5ydWxlVHlwZSA9ICdidWlsZEluJztcclxuICAgICAgICB0aGlzLm5hbWUgPSAnRnVsbCBwYXRoLCBmaWxlbmFtZSc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdSZXR1cm5zIHRoZSBmdWxsIHBhdGggb2YgdGhlIGZpbGUsIGluY2x1ZGluZyB0aGUgZmlsZW5hbWUuJztcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBsZXQgcGFydHMgPSBmaWxlLnBhdGguc3BsaXQoJy8nKTtcXG4gIHBhcnRzLnBvcCgpO1xcbiAgcGFydHMucHVzaChmaWxlLmJhc2VuYW1lKTtcXG4gIHJldHVybiBwYXJ0cy5qb2luKCcvJyk7XFxufTtcIjtcclxuICAgICAgICB0aGlzLnR5cGUgPSBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddO1xyXG4gICAgICAgIHRoaXMuY29uZmlnRWxlbWVudHMgPSB0aGlzLmRlZmF1bHRDb25maWdFbGVtZW50cyh7fSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ4IChhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogVEZpbGUsIHRvb2xzOiBTY3JpcHRpbmdUb29scyl7XHJcbiAgICAgICAgbGV0IHBhcnRzID0gZmlsZS5wYXRoLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgcGFydHMucG9wKCk7XHJcbiAgICAgICAgcGFydHMucHVzaChmaWxlLmJhc2VuYW1lKTtcclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbignLycpO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25maWdUYWIob3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOiBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCB0aGF0OiBhbnksIHByZXZpZXdDb21wb25lbnQ6IGFueSkge1xyXG4gICAgfTtcclxuXHJcbn0iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBidWlsdC1pbiBydWxlIHRoYXQgcmV0dXJucyB0aGUgZnVsbCBwYXRoIG9mIGEgZmlsZSwgaW5jbHVkaW5nIGl0cyBmaWxlbmFtZSBhbmQgZXh0ZW5zaW9uLlxyXG4gKiBcclxuICogVGhpcyBydWxlIGlzIHBhcnQgb2YgdGhlIFwiZm9sZGVyLXRvLXRhZ3MtcGx1Z2luXCIgYW5kIGlzIHVzZWQgdG8gZ2VuZXJhdGUgb3IgbWFuaXB1bGF0ZSBtZXRhZGF0YVxyXG4gKiBiYXNlZCBvbiB0aGUgZnVsbCBwYXRoIG9mIGEgZmlsZS4gSXQgZXh0ZW5kcyB0aGUgYFJ1bGVQcm90b3R5cGVgIGNsYXNzIGFuZCBwcm92aWRlcyBjb25maWd1cmF0aW9uXHJcbiAqIG9wdGlvbnMsIGEgZGVzY3JpcHRpb24sIGFuZCBhIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgdGhlIHJ1bGUgbG9naWMuXHJcbiAqIFxyXG4gKiBAY2xhc3MgUnVsZUJ1aWxkSW5GdWxsUGF0aEV4dFxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqIFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgcnVsZSAoYGZ1bGxQYXRoRXh0YCkuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBydWxlVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBydWxlIChgYnVpbGRJbmApLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIHJ1bGUgKGBGdWxsIHBhdGgsIGZpbGVuYW1lIGFuZCBleHRlbnNpb25gKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uIC0gQSBicmllZiBkZXNjcmlwdGlvbiBvZiB0aGUgcnVsZSdzIGZ1bmN0aW9uYWxpdHkuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBUaGUgc291cmNlIGNvZGUgb2YgdGhlIHJ1bGUncyBsb2dpYyBhcyBhIHN0cmluZy5cclxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gdHlwZSAtIFRoZSB0eXBlcyBvZiBtZXRhZGF0YSB0aGlzIHJ1bGUgY2FuIGJlIGFwcGxpZWQgdG8gKGB0ZXh0YCwgYHRhZ3NgLCBgYWxpYXNlc2AsIGBtdWx0aXRleHRgKS5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZnggLSBUaGUgZnVuY3Rpb24gdGhhdCBpbXBsZW1lbnRzIHRoZSBydWxlIGxvZ2ljLCByZXR1cm5pbmcgdGhlIGZ1bGwgcGF0aCBvZiB0aGUgZmlsZS5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gY29uZmlnVGFiIC0gQSBmdW5jdGlvbiB0byByZW5kZXIgdGhlIGNvbmZpZ3VyYXRpb24gdGFiIGZvciB0aGlzIHJ1bGUuXHJcbiAqIFxyXG4gKiBAbWV0aG9kIGRlZmF1bHRDb25maWdFbGVtZW50cyAtIEluaGVyaXRlZCBmcm9tIGBSdWxlUHJvdG90eXBlYCwgdXNlZCB0byBkZWZpbmUgZGVmYXVsdCBjb25maWd1cmF0aW9uIGVsZW1lbnRzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVCdWlsZEluRnVsbFBhdGhFeHQgZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9ICdmdWxsUGF0aEV4dCc7XHJcbiAgICAgICAgdGhpcy5ydWxlVHlwZSA9ICdidWlsZEluJztcclxuICAgICAgICB0aGlzLm5hbWUgPSAnRnVsbCBwYXRoLCBmaWxlbmFtZSBhbmQgZXh0ZW5zaW9uJztcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gJ1JldHVybnMgdGhlIGZ1bGwgcGF0aCBvZiB0aGUgZmlsZSwgaW5jbHVkaW5nIGl0cyBmaWxlbmFtZSBhbmQgZXh0ZW5zaW9uLic7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgcmV0dXJuIGAke2ZpbGUucGF0aH1gO1xcbn07XCI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gICAgfTtcclxuXHJcbiAgICBmeChhcHA6IEFwcCwgZmlsZTogVEZpbGUsIHRvb2xzOiBTY3JpcHRpbmdUb29scykge1xyXG4gICAgICAgIHJldHVybiBgJHtmaWxlLnBhdGh9YDtcclxuICAgIH07XHJcblxyXG4gICAgY29uZmlnVGFiKG9wdGlvbkVMOiBIVE1MRWxlbWVudCwgcnVsZTogRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDogYW55LCBwcmV2aWV3Q29tcG9uZW50OiBhbnkpIHtcclxuICAgICAgICAvLyBDb25maWd1cmF0aW9uIHRhYiBsb2dpYyBjYW4gYmUgYWRkZWQgaGVyZSBpZiBuZWVkZWRcclxuICAgICAgICAvLyBGb3IgZXhhbXBsZSwgeW91IGNhbiBjcmVhdGUgc2V0dGluZ3MgZm9yIHRoZSBydWxlIGhlcmVcclxuICAgIH07XHJcbiAgICBcclxufSIsICJpbXBvcnQgeyBSdWxlUHJvdG90eXBlLCBydWxlc01hbmFnZXIgfSBmcm9tIFwiLi9ydWxlc1wiO1xyXG5pbXBvcnQgeyBTY3JpcHRpbmdUb29scyB9IGZyb20gXCIuLi90b29sc1wiO1xyXG5pbXBvcnQgeyBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzIH0gZnJvbSBcIi4uL3R5cGVzXCI7XHJcbmltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgcnVsZSBmb3IgZ2VuZXJhdGluZyBhIGZ1bGwgcGF0aCB3aXRoIGV4dGVuc2lvbnMgY29tcGF0aWJsZSB3aXRoIFwiZm9sZGVyIG5vdGVzXCIuXHJcbiAqIFRoaXMgcnVsZSBtb2RpZmllcyB0aGUgZmlsZSBwYXRoIHRvIGVuc3VyZSBjb21wYXRpYmlsaXR5IHdpdGggZm9sZGVyIG5vdGVzIGJ5IGFkanVzdGluZ1xyXG4gKiB0aGUgcGF0aCBzdHJ1Y3R1cmUgYmFzZWQgb24gdGhlIGZpbGUncyBiYXNlbmFtZSBhbmQgcGFyZW50IGZvbGRlci5cclxuICogXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICogXHJcbiAqIEByZW1hcmtzXHJcbiAqIC0gVGhlIGBzb3VyY2VgIHByb3BlcnR5IGNvbnRhaW5zIGEgc3RyaW5naWZpZWQgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyB0aGUgcGF0aCB0cmFuc2Zvcm1hdGlvbi5cclxuICogLSBUaGUgYGZ4YCBtZXRob2QgaW1wbGVtZW50cyB0aGUgc2FtZSBsb2dpYyBhcyB0aGUgYHNvdXJjZWAgZnVuY3Rpb24gYnV0IGlzIGRpcmVjdGx5IGV4ZWN1dGFibGUuXHJcbiAqIC0gVGhpcyBydWxlIGlzIGNhdGVnb3JpemVkIGFzIGEgYnVpbHQtaW4gcnVsZSAoYHJ1bGVUeXBlOiAnYnVpbGRJbidgKS5cclxuICogXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcnVsZSAoYGZ1bGxQYXRoRXh0Rm9sZGVyTm90ZXNgKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJ1bGVUeXBlIC0gVHlwZSBvZiB0aGUgcnVsZSAoYGJ1aWxkSW5gKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBEaXNwbGF5IG5hbWUgb2YgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXNjcmlwdGlvbiAtIERlc2NyaXB0aW9uIG9mIHRoZSBydWxlJ3MgcHVycG9zZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZSAtIFN0cmluZ2lmaWVkIGZ1bmN0aW9uIGRlZmluaW5nIHRoZSBydWxlJ3MgbG9naWMuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHR5cGUgLSBBcHBsaWNhYmxlIHR5cGVzIGZvciB0aGUgcnVsZSAoYFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J11gKS5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZnggLSBGdW5jdGlvbiBpbXBsZW1lbnRpbmcgdGhlIHJ1bGUncyBsb2dpYy5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gY29uZmlnVGFiIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvbiB0YWIgbG9naWMgZm9yIHRoZSBydWxlLlxyXG4gKiBcclxuICogQG1ldGhvZCBmeFxyXG4gKiBAcGFyYW0ge0FwcCB8IHVuZGVmaW5lZH0gYXBwIC0gVGhlIGFwcGxpY2F0aW9uIGluc3RhbmNlIChvcHRpb25hbCkuXHJcbiAqIEBwYXJhbSB7VEZpbGV9IGZpbGUgLSBUaGUgZmlsZSBvYmplY3QgY29udGFpbmluZyBwYXRoIGFuZCBiYXNlbmFtZSBpbmZvcm1hdGlvbi5cclxuICogQHBhcmFtIHtTY3JpcHRpbmdUb29sc30gdG9vbHMgLSBVdGlsaXR5IHRvb2xzIGZvciBzY3JpcHRpbmcuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIHRyYW5zZm9ybWVkIGZpbGUgcGF0aC5cclxuICogXHJcbiAqIEBtZXRob2QgY29uZmlnVGFiXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9wdGlvbkVMIC0gVGhlIEhUTUwgZWxlbWVudCBmb3IgdGhlIGNvbmZpZ3VyYXRpb24gdGFiLlxyXG4gKiBAcGFyYW0ge0Zyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3N9IHJ1bGUgLSBUaGUgcnVsZSBzZXR0aW5ncyBvYmplY3QuXHJcbiAqIEBwYXJhbSB7YW55fSB0aGF0IC0gUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGNvbnRleHQuXHJcbiAqIEBwYXJhbSB7YW55fSBwcmV2aWV3Q29tcG9uZW50IC0gQ29tcG9uZW50IGZvciBwcmV2aWV3aW5nIGNoYW5nZXMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZUJ1aWxkSW5GdWxsUGF0aEV4dEZvbGRlck5vdGVzIGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaWQgPSAnZnVsbFBhdGhFeHRGb2xkZXJOb3Rlcyc7XHJcbiAgICAgICAgdGhpcy5ydWxlVHlwZSA9ICdidWlsZEluJztcclxuICAgICAgICB0aGlzLm5hbWUgPSAnRnVsbCBQYXRoIHdpdGggRXh0ZW5zaW9uIChjb21wbHkgd2l0aCBcImZvbGRlciBub3Rlc1wiKSc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdQYXRoIHdpdGggRXh0ZW5zaW9ucyBjb21wYXRpYmxlIHdpdGggZm9sZGVyIG5vdGVzLic7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgbGV0IHBhcnRzID0gZmlsZS5wYXRoLnNwbGl0KCcvJyk7XFxuICBwYXJ0cy5wb3AoKTtcXG4gIGlmIChwYXJ0c1twYXJ0cy5sZW5ndGgtMV0gPT09IGZpbGUuYmFzZW5hbWUpIHBhcnRzLnBvcCgpO1xcbiAgcGFydHMucHVzaChmaWxlLmJhc2VuYW1lKTtcXG4gIHJldHVybiBwYXJ0cy5qb2luKCcvJyk7XFxufTtcIjtcclxuICAgICAgICB0aGlzLnR5cGUgPSBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddO1xyXG4gICAgICAgIHRoaXMuY29uZmlnRWxlbWVudHMgPSB0aGlzLmRlZmF1bHRDb25maWdFbGVtZW50cyh7fSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ4IChhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogVEZpbGUsIHRvb2xzOiBTY3JpcHRpbmdUb29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgICAgICBsZXQgcGFydHMgPSBmaWxlLnBhdGguc3BsaXQoJy8nKTtcclxuICAgICAgICBwYXJ0cy5wb3AoKTsgLy8gcmVtb3ZlIGZpbGUgbmFtZVxyXG4gICAgICAgIGlmIChwYXJ0c1twYXJ0cy5sZW5ndGgtMV0gPT09IGZpbGUuYmFzZW5hbWUpIHBhcnRzLnBvcCgpOyAvLyByZW1vdmUgcGFyZW50IGZvbGRlciBpZiBzYW1lIG5hbWUgYXMgdGhlIGZpbGVcclxuICAgICAgICBwYXJ0cy5wdXNoKGZpbGUubmFtZSk7IC8vIGFkZCB0aGUgZmlsZSBuYW1lIGJhY2tcclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbignLycpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbmZpZ1RhYiAob3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOkZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIHRoYXQ6YW55LCBwcmV2aWV3Q29tcG9uZW50OiBhbnkpIHtcclxuICAgICAgICAvLyBDb25maWd1cmF0aW9uIHRhYiBsb2dpYyBjYW4gYmUgYWRkZWQgaGVyZSBpZiBuZWVkZWRcclxuICAgIH07XHJcbiAgICBcclxufSIsICJpbXBvcnQgeyBSdWxlUHJvdG90eXBlLCBydWxlc01hbmFnZXIgfSBmcm9tIFwiLi9ydWxlc1wiO1xyXG5pbXBvcnQgeyBTY3JpcHRpbmdUb29scyB9IGZyb20gXCIuLi90b29sc1wiO1xyXG5pbXBvcnQgeyBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzIH0gZnJvbSBcIi4uL3R5cGVzXCI7XHJcbmltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbi8qKlxyXG4gKiBBIGJ1aWx0LWluIHJ1bGUgZm9yIGdlbmVyYXRpbmcgYSBmdWxsIHBhdGggY29tcGF0aWJsZSB3aXRoIFwiZm9sZGVyIG5vdGVzXCIgcGx1Z2luLlxyXG4gKiBcclxuICogVGhpcyBydWxlIHByb2Nlc3NlcyBhIGZpbGUncyBwYXRoIHN1Y2ggdGhhdDpcclxuICogLSBUaGUgZmlsZSBuYW1lIGlzIHJlbW92ZWQgZnJvbSB0aGUgcGF0aC5cclxuICogLSBJZiB0aGUgcGFyZW50IGZvbGRlciBoYXMgdGhlIHNhbWUgbmFtZSBhcyB0aGUgZmlsZSwgaXQgaXMgYWxzbyByZW1vdmVkLlxyXG4gKiAtIFRoZSBmaWxlJ3MgYmFzZSBuYW1lIGlzIGFwcGVuZGVkIHRvIHRoZSByZXN1bHRpbmcgcGF0aC5cclxuICogXHJcbiAqIFRoZSByZXN1bHRpbmcgcGF0aCBpcyBzdWl0YWJsZSBmb3IgdXNlIGNhc2VzIHdoZXJlIGZvbGRlciBub3RlcyBhcmUgdXNlZCwgZW5zdXJpbmcgY29tcGF0aWJpbGl0eS5cclxuICogXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICogXHJcbiAqIEByZW1hcmtzXHJcbiAqIC0gVGhlIGBmeGAgbWV0aG9kIGltcGxlbWVudHMgdGhlIGNvcmUgbG9naWMgZm9yIHBhdGggdHJhbnNmb3JtYXRpb24uXHJcbiAqIC0gVGhlIGBjb25maWdUYWJgIG1ldGhvZCBjYW4gYmUgZXh0ZW5kZWQgdG8gcHJvdmlkZSBhIGNvbmZpZ3VyYXRpb24gVUkuXHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBGb3IgYSBmaWxlIGF0IFwiZm9sZGVyMS9mb2xkZXIyL25vdGUvbm90ZS5tZFwiXHJcbiAqIC8vIFRoZSByZXN1bHRpbmcgcGF0aCB3aWxsIGJlIFwiZm9sZGVyMS9mb2xkZXIyL25vdGVcIlxyXG4gKiBcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcnVsZVR5cGUgLSBUeXBlIG9mIHRoZSBydWxlLCBzZXQgdG8gJ2J1aWxkSW4nLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIEh1bWFuLXJlYWRhYmxlIG5hbWUgZm9yIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGVzY3JpcHRpb24gLSBEZXNjcmlwdGlvbiBvZiB0aGUgcnVsZSdzIHB1cnBvc2UuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBTdHJpbmdpZmllZCBmdW5jdGlvbiBzb3VyY2UgZm9yIHNjcmlwdGluZy5cclxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gdHlwZSAtIFN1cHBvcnRlZCB0eXBlcyBmb3IgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7YW55W119IGNvbmZpZ0VsZW1lbnRzIC0gQ29uZmlndXJhdGlvbiBlbGVtZW50cyBmb3IgdGhlIHJ1bGUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZUJ1aWxkSW5GdWxsUGF0aEZvbGRlck5vdGVzIGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaWQgPSAnZnVsbFBhdGhGb2xkZXJOb3Rlcyc7XHJcbiAgICAgICAgdGhpcy5ydWxlVHlwZSA9ICdidWlsZEluJztcclxuICAgICAgICB0aGlzLm5hbWUgPSAnRnVsbCBQYXRoIChjb21wbHkgd2l0aCBcImZvbGRlciBub3Rlc1wiKSc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdQYXRoIGNvbXBhdGlibGUgY29tcGF0aWJsZSB3aXRoIGZvbGRlciBub3Rlcy4nO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIGxldCBwYXJ0cyA9IGZpbGUucGF0aC5zcGxpdCgnLycpO1xcbiAgcGFydHMucG9wKCk7XFxuICBpZiAocGFydHNbcGFydHMubGVuZ3RoLTFdID09PSBmaWxlLmJhc2VuYW1lKSBwYXJ0cy5wb3AoKTtcXG4gIHBhcnRzLnB1c2goZmlsZS5iYXNlbmFtZSk7XFxuICByZXR1cm4gcGFydHMuam9pbignLycpO1xcbn07XCI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAgICAgbGV0IHBhcnRzID0gZmlsZS5wYXRoLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgcGFydHMucG9wKCk7IC8vIHJlbW92ZSBmaWxlIG5hbWVcclxuICAgICAgICBpZiAocGFydHNbcGFydHMubGVuZ3RoLTFdID09PSBmaWxlLmJhc2VuYW1lKSBwYXJ0cy5wb3AoKTsgLy8gcmVtb3ZlIHBhcmVudCBmb2xkZXIgaWYgc2FtZSBuYW1lIGFzIHRoZSBmaWxlXHJcbiAgICAgICAgcGFydHMucHVzaChmaWxlLmJhc2VuYW1lKTsgLy8gYWRkIHRoZSBmaWxlIG5hbWUgYmFja1xyXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKCcvJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uZmlnVGFiIChvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6RnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDphbnksIHByZXZpZXdDb21wb25lbnQ6IGFueSkge1xyXG4gICAgICAgIC8vIENvbmZpZ3VyYXRpb24gdGFiIGxvZ2ljIGNhbiBiZSBhZGRlZCBoZXJlIGlmIG5lZWRlZFxyXG4gICAgfTtcclxuICAgIFxyXG59IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIFByb3BlcnR5VHlwZUluZm8gfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuaW1wb3J0IHsgQXBwLCBFeHRyYUJ1dHRvbkNvbXBvbmVudCwgU2V0dGluZywgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHsgZGVsaW1pdGVyIH0gZnJvbSBcInBhdGhcIjtcclxuaW1wb3J0IHsgTXVsdGlQcm9wZXJ0eVNldHRpbmcgfSBmcm9tIFwiLi4vdWlNdWx0aVByb3BlcnR5U2V0dGluZ1wiO1xyXG5pbXBvcnQgeyBFUlJPUiwgbG9nZ2VyIH0gZnJvbSBcIi4uL0xvZ1wiO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBBIGJ1aWx0LWluIHJ1bGUgZm9yIHJldHJpZXZpbmcgYW5kIGNvbmNhdGVuYXRpbmcgbXVsdGlwbGUgZnJvbnRtYXR0ZXIgcHJvcGVydGllcyBmcm9tIGEgZmlsZS5cclxuICogXHJcbiAqIFRoaXMgcnVsZSBzdXBwb3J0cyBwcm9wZXJ0aWVzIG9mIHR5cGUgJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgYW5kICdtdWx0aXRleHQnLiBJdCBhbGxvd3MgdXNlcnMgdG8gc2VsZWN0XHJcbiAqIG11bHRpcGxlIHByb3BlcnRpZXMsIG9wdGlvbmFsbHkgcmVxdWlyZSB0aGF0IGFsbCBzZWxlY3RlZCBwcm9wZXJ0aWVzIGV4aXN0LCBhbmQgc3BlY2lmeSBhIGRlbGltaXRlciBmb3IgY29uY2F0ZW5hdGlvbi5cclxuICogXHJcbiAqICMjIENvbmZpZ3VyYXRpb24gT3B0aW9uc1xyXG4gKiAtIGBpbnB1dFByb3BlcnRpZXNgOiBBcnJheSBvZiBwcm9wZXJ0eSBrZXlzIHRvIHJldHJpZXZlIGZyb20gdGhlIGZyb250bWF0dGVyLlxyXG4gKiAtIGBvbmx5V2hlbkFsbFByb3BlcnRpZXNFeGlzdGA6IElmIHRydWUsIHRoZSBydWxlIHJldHVybnMgYSB2YWx1ZSBvbmx5IGlmIGFsbCBzZWxlY3RlZCBwcm9wZXJ0aWVzIGV4aXN0IGFuZCBhcmUgbm90IGVtcHR5LlxyXG4gKiAtIGBwcm9wZXJ0eURlbGltaXRlcmA6IFN0cmluZyB1c2VkIHRvIHNlcGFyYXRlIGNvbmNhdGVuYXRlZCB2YWx1ZXMgd2hlbiBvdXRwdXR0aW5nIGFzIHRleHQuXHJcbiAqIFxyXG4gKiAjIyBCZWhhdmlvclxyXG4gKiAtIElmIGBvbmx5V2hlbkFsbFByb3BlcnRpZXNFeGlzdGAgaXMgZW5hYmxlZCBhbmQgYW55IHNlbGVjdGVkIHByb3BlcnR5IGlzIG1pc3Npbmcgb3IgZW1wdHksIHRoZSBydWxlIHJldHVybnMgYW4gZW1wdHkgcmVzdWx0LlxyXG4gKiAtIEZvciAndGV4dCcgdHlwZSwgdGhlIHNlbGVjdGVkIHByb3BlcnRpZXMgYXJlIGNvbmNhdGVuYXRlZCB1c2luZyB0aGUgc3BlY2lmaWVkIGRlbGltaXRlci5cclxuICogLSBGb3IgJ3RhZ3MnLCAnYWxpYXNlcycsIG9yICdtdWx0aXRleHQnIHR5cGVzLCB0aGUgcmVzdWx0IGlzIGFuIGFycmF5IG9mIHZhbHVlcy5cclxuICogXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICogQGNhdGVnb3J5IEJ1aWx0LWluIFJ1bGVzXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIFJldHJpZXZlICd0YWdzJyBhbmQgJ2FsaWFzZXMnIHByb3BlcnRpZXMsIGNvbmNhdGVuYXRlZCB3aXRoIGEgY29tbWFcclxuICoge1xyXG4gKiAgIGlucHV0UHJvcGVydGllczogWyd0YWdzJywgJ2FsaWFzZXMnXSxcclxuICogICBwcm9wZXJ0eURlbGltaXRlcjogJywnLFxyXG4gKiAgIG9ubHlXaGVuQWxsUHJvcGVydGllc0V4aXN0OiBmYWxzZVxyXG4gKiB9XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZUJ1aWxkSW5HZXRQcm9wZXJ0aWVzIGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5pZCA9ICdnZXRQcm9wZXJ0aWVzJztcclxuICAgIHRoaXMucnVsZVR5cGUgPSAnYnVpbGRJbic7XHJcbiAgICB0aGlzLm5hbWUgPSAnR2V0IFByb3BlcnRpZXMnO1xyXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdSZXRyaWV2ZXMgbXVsdGlwbGUgZnJvbnRtYXR0ZXIgcHJvcGVydGllcyAoTXVsdGl0ZXh0LCBUYWdzLCBBbGlhc2VzKS4nO1xyXG4gICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgY29uc3QgcHJvcGVydHlJZHMgPSB0b29scy5nZXRPcHRpb25Db25maWcodG9vbHMuZ2V0UnVsZSgpPy5pZCwnaW5wdXRQcm9wZXJ0aWVzJyk7XFxuICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcGVydHlJZHMpIHx8IHByb3BlcnR5SWRzLmxlbmd0aCA9PT0gMCkge1xcbiAgICByZXR1cm4gJ05vIHByb3BlcnRpZXMgc2VsZWN0ZWQnO1xcbiAgfVxcbiAgY29uc3QgZGVsaW1pdGVyID0gdG9vbHMuZ2V0T3B0aW9uQ29uZmlnKHRvb2xzLmdldFJ1bGUoKT8uaWQsJ2RlbGltaXRlcicpO1xcbiAgY29uc3Qgb25seVdoZW5BbGxQcm9wZXJ0aWVzRXhpc3QgPSB0b29scy5nZXRPcHRpb25Db25maWcodG9vbHMuZ2V0UnVsZSgpPy5pZCwgJ29ubHlXaGVuQWxsUHJvcGVydGllc0V4aXN0JykgfHwgZmFsc2U7XFxuICBpZiAob25seVdoZW5BbGxQcm9wZXJ0aWVzRXhpc3QpIHtcXG4gICAgLy8gQ2hlY2sgaWYgYWxsIHByb3BlcnRpZXMgZXhpc3RcXG4gICAgY29uc3QgYWxsRXhpc3QgPSBwcm9wZXJ0eUlkcy5ldmVyeShpZCA9PiB7IFxcbiAgICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkIHx8IGlkID09PSBudWxsIHx8IGlkID09PSAnJykge1xcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIFNraXAgZW1wdHkgb3IgdW5kZWZpbmVkIHByb3BlcnR5IElEc1xcbiAgICAgIH1cXG4gICAgICBjb25zdCBwcm9wZXJ0eVZhbHVlID0gdG9vbHMuZ2V0RnJvbnRtYXR0ZXJQcm9wZXJ0eShpZCk7XFxuICAgICAgY29uc3QgcmVzdWx0ID0gcHJvcGVydHlWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BlcnR5VmFsdWUgIT09IG51bGwgJiYgcHJvcGVydHlWYWx1ZSAhPT0gJyc7XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfSk7XFxuICAgIGlmICghYWxsRXhpc3QpIHtcXG4gICAgICByZXR1cm4gJyc7XFxuICAgIH1cXG4gIH1cXG4gIGNvbnN0IHJlc3VsdCA9IHByb3BlcnR5SWRzLm1hcChpZCA9PiB7XFxuICAgIGxldCB2YWx1ZSA9IHRvb2xzLmdldEZyb250bWF0dGVyUHJvcGVydHkoaWQpO1xcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gJycpIHtcXG4gICAgICByZXR1cm4gJyc7IC8vIFNraXAgZW1wdHkgb3IgdW5kZWZpbmVkIHByb3BlcnRpZXNcXG4gICAgfVxcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcXG4gIH0pLmZpbHRlcihyZXMgPT4gcmVzICE9PSB1bmRlZmluZWQpLmpvaW4oZGVsaW1pdGVyKTtcXG4gIHJldHVybiByZXN1bHQ7XFxufTtcIjtcclxuICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gIH1cclxuICBcclxuICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICBjb25zdCBydWxlID0gdG9vbHMuZ2V0UnVsZSgpO1xyXG4gICAgaWYgKCFydWxlKSB7XHJcbiAgICAgIGxvZ2dlci5sb2coRVJST1IsICdSdWxlQnVpbGRJbkdldFByb3BlcnRpZXM6IE5vIHJ1bGUgZm91bmQuJyk7XHJcbiAgICAgIHJldHVybiB0b29scy5nZXRDdXJyZW50Q29udGVudCgpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcHJvcGVydHlJZHMgPSB0b29scy5nZXRPcHRpb25Db25maWcocnVsZS5pZCwnaW5wdXRQcm9wZXJ0aWVzJyk7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcGVydHlJZHMpIHx8IHByb3BlcnR5SWRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gJ05vIHByb3BlcnRpZXMgc2VsZWN0ZWQnO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb25seVdoZW5BbGxQcm9wZXJ0aWVzRXhpc3QgPSB0b29scy5nZXRPcHRpb25Db25maWcocnVsZS5pZCwgJ29ubHlXaGVuQWxsUHJvcGVydGllc0V4aXN0JykgfHwgZmFsc2U7XHJcbiAgICBpZiAob25seVdoZW5BbGxQcm9wZXJ0aWVzRXhpc3QpIHtcclxuICAgICAgLy8gQ2hlY2sgaWYgYWxsIHByb3BlcnRpZXMgZXhpc3RcclxuICAgICAgY29uc3QgYWxsRXhpc3QgPSBwcm9wZXJ0eUlkcy5ldmVyeShpZCA9PiB7IFxyXG4gICAgICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkIHx8IGlkID09PSBudWxsIHx8IGlkID09PSAnJykge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7IC8vIFNraXAgZW1wdHkgb3IgdW5kZWZpbmVkIHByb3BlcnR5IElEc1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwcm9wZXJ0eVZhbHVlID0gdG9vbHMuZ2V0RnJvbnRtYXR0ZXJQcm9wZXJ0eShpZCk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcHJvcGVydHlWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BlcnR5VmFsdWUgIT09IG51bGwgJiYgcHJvcGVydHlWYWx1ZSAhPT0gJyc7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfSk7XHJcbiAgICAgIGlmICghYWxsRXhpc3QpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsZXQgcmVzdWx0QXJyYXk6IHN0cmluZ1tdID0gW107XHJcbiAgICBwcm9wZXJ0eUlkcy5mb3JFYWNoKGlkID0+IHtcclxuICAgICAgbGV0IHZhbHVlID0gdG9vbHMuZ2V0RnJvbnRtYXR0ZXJQcm9wZXJ0eShpZCk7XHJcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAnJykge1xyXG4gICAgICAgIHJldHVybjsgLy8gU2tpcCBlbXB0eSBvciB1bmRlZmluZWQgcHJvcGVydGllc1xyXG4gICAgICB9XHJcbiAgICAgIHJlc3VsdEFycmF5ID0gcmVzdWx0QXJyYXkuY29uY2F0KEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWUudG9TdHJpbmcoKV0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgc3dpdGNoIChydWxlLnR5cGUgfHwgcnVsZS50eXBlUHJvcGVydHk/LnR5cGUpIHtcclxuICAgICAgY2FzZSAoJ3RleHQnKTpcclxuICAgICAgICByZXR1cm4gcmVzdWx0QXJyYXkuam9pbih0b29scy5nZXRPcHRpb25Db25maWcocnVsZS5pZCwgJ2RlbGltaXRlcicpKTtcclxuICAgICAgY2FzZSAoJ3RhZ3MnKTpcclxuICAgICAgY2FzZSAoJ2FsaWFzZXMnKTpcclxuICAgICAgY2FzZSAoJ211bHRpdGV4dCcpOlxyXG4gICAgICAgIHJldHVybiByZXN1bHRBcnJheTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHRBcnJheTtcclxuICB9XHJcblxyXG4gIGNvbmZpZ1RhYihvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIHRoYXQ6IGFueSwgcHJldmlld0NvbXBvbmVudDogYW55KSB7XHJcbiAgICB0aGF0LnNldE9wdGlvbkNvbmZpZ0RlZmF1bHRzKHJ1bGUuaWQsIHtcclxuICAgICAgICBpbnB1dFByb3BlcnRpZXM6IFtdLFxyXG4gICAgICAgIG9ubHlXaGVuQWxsUHJvcGVydGllc0V4aXN0OiBmYWxzZSwgLy8gRGVmYXVsdCB0byBmYWxzZVxyXG4gICAgICAgIHByb3BlcnR5RGVsaW1pdGVyOiAnJyxcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IG11bHRpUHJvcCA9IG5ldyBNdWx0aVByb3BlcnR5U2V0dGluZyhvcHRpb25FTClcclxuICAgICAgLnNldE5hbWUoXCJJbnB1dCBQcm9wZXJ0aWVzXCIpXHJcbiAgICAgIC5zZXREZXNjKFwiU2VsZWN0IHByb3BlcnRpZXMgYXMgaW5wdXQuICh0ZXh0LCB0YWdzLCBhbGlhc2VzIG9yIG11bHRpdGV4dClcIilcclxuICAgICAgLnNldE9wdGlvbnMoT2JqZWN0LmtleXModGhhdC5rbm93blByb3BlcnRpZXMpLm1hcCgoa2V5KSA9PiB7XHJcbiAgICAgICAgY29uc3QgcHJvcCA9IHRoYXQua25vd25Qcm9wZXJ0aWVzW2tleV07XHJcbiAgICAgICAgaWYgKHByb3AudHlwZSA9PT0gJ3RleHQnIHx8IHByb3AudHlwZSA9PT0gJ3RhZ3MnIHx8IHByb3AudHlwZSA9PT0gJ2FsaWFzZXMnIHx8IHByb3AudHlwZSA9PT0gJ211bHRpdGV4dCcpIHtcclxuICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsOyAvLyBGaWx0ZXIgb3V0IHVuc3VwcG9ydGVkIHR5cGVzXHJcbiAgICAgIH0pLmZpbHRlcigoaXRlbSk6IGl0ZW0gaXMgc3RyaW5nID0+IGl0ZW0gIT09IG51bGwpKVxyXG4gICAgICAuc2V0VmFsdWUodGhhdC5nZXRPcHRpb25Db25maWcocnVsZS5pZCwgJ2lucHV0UHJvcGVydGllcycpIHx8IFtdKVxyXG4gICAgICAub25DaGFuZ2UoKGFycikgPT4ge1xyXG4gICAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWcocnVsZS5pZCwgJ2lucHV0UHJvcGVydGllcycsIGFycik7XHJcbiAgICAgICAgICB0aGF0LnVwZGF0ZVByZXZpZXcocnVsZSwgcHJldmlld0NvbXBvbmVudCk7XHJcbiAgICAgIH0pO1xyXG4gICAgXHJcbiAgICBuZXcgU2V0dGluZyhvcHRpb25FTClcclxuICAgICAgICAuc2V0TmFtZSgnT25seSB3aGVuIGFsbCBwcm9wZXJ0aWVzIGV4aXN0JylcclxuICAgICAgICAuc2V0RGVzYygnSWYgZW5hYmxlZCwgdGhlIHJ1bGUgd2lsbCBvbmx5IHJldHVybiBhIHZhbHVlIGlmIGFsbCBzZWxlY3RlZCBwcm9wZXJ0aWVzIGV4aXN0IGFuZCBub3QgZW1wdHkuJylcclxuICAgICAgICAuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcclxuICAgICAgICAgICAgLnNldFZhbHVlKHRoYXQuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQsICdvbmx5V2hlbkFsbFByb3BlcnRpZXNFeGlzdCcpKVxyXG4gICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZyhydWxlLmlkLCAnb25seVdoZW5BbGxQcm9wZXJ0aWVzRXhpc3QnLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZVByZXZpZXcocnVsZSwgcHJldmlld0NvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgKTtcclxuICAgICAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWdEZWZhdWx0cyhydWxlLmlkLCB7XHJcbiAgICAgICAgICAgIHByb3BlcnR5RGVsaW1pdGVyOiAnLicsXHJcbiAgICAgICAgfSlcclxuICAgIFxyXG4gICAgbmV3IFNldHRpbmcob3B0aW9uRUwpXHJcbiAgICAgIC5zZXROYW1lKCdEZWxpbWl0ZXInKVxyXG4gICAgICAuc2V0RGVzYygnQ2hhcmFjdGVyIHRvIHNlcGFyYXRlIGNvbmNhdGVuYXRlZCB2YWx1ZXMgaWYgcGxhY2VkIGludG8gYSB0ZXh0IHByb3BlcnR5LiBJZiBlbXB0eSwgbm8gZGVsaW1pdGVyIGlzIHVzZWQuJylcclxuICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAuc2V0VmFsdWUodGhhdC5nZXRPcHRpb25Db25maWcocnVsZS5pZCAsJ3Byb3BlcnR5RGVsaW1pdGVyJykgfHwgJy4nKVxyXG4gICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdlLmcuIFwiLlwiIG9yIFwiLFwiJylcclxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZyhydWxlLmlkLCdwcm9wZXJ0eURlbGltaXRlcicsIHZhbHVlKTtcclxuICAgICAgICAgIH0pKTtcclxuICB9O1xyXG59IiwgIiAgaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgUHJvcGVydHlUeXBlSW5mbyB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFNldHRpbmcsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGJ1aWx0LWluIHJ1bGUgZm9yIHJldHJpZXZpbmcgYSBwcm9wZXJ0eSB2YWx1ZSBmcm9tIHRoZSBmcm9udG1hdHRlciBvZiBhIGZpbGUuXHJcbiAqIFxyXG4gKiBUaGlzIHJ1bGUgYWxsb3dzIHVzZXJzIHRvIHNlbGVjdCBhIHByb3BlcnR5IChzdWNoIGFzIHRleHQsIHRhZ3MsIGFsaWFzZXMsIG9yIG11bHRpdGV4dCkgYW5kIHJldHJpZXZlIGl0cyB2YWx1ZVxyXG4gKiBmcm9tIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZmlsZSdzIGZyb250bWF0dGVyLiBUaGUgcnVsZSBwcm92aWRlcyBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHNlbGVjdGluZyB0aGUgcHJvcGVydHksXHJcbiAqIGFuZCBleHBvc2VzIGEgZnVuY3Rpb24gKGBmeGApIHRoYXQgcGVyZm9ybXMgdGhlIHJldHJpZXZhbC5cclxuICogXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICogXHJcbiAqIEByZW1hcmtzXHJcbiAqIC0gVGhlIHJ1bGUgaXMgaWRlbnRpZmllZCBieSB0aGUgSUQgJ2dldFByb3BlcnR5JyBhbmQgaXMgY2F0ZWdvcml6ZWQgYXMgYSBidWlsdC1pbiBydWxlLlxyXG4gKiAtIFRoZSBjb25maWd1cmF0aW9uIHRhYiBhbGxvd3MgdXNlcnMgdG8gc2VsZWN0IHdoaWNoIHByb3BlcnR5IHRvIHJldHJpZXZlLlxyXG4gKiAtIFRoZSBgZnhgIG1ldGhvZCBpcyB0aGUgbWFpbiBsb2dpYyBmb3IgZXh0cmFjdGluZyB0aGUgcHJvcGVydHkgdmFsdWUuXHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBVc2FnZSB3aXRoaW4gdGhlIHBsdWdpbidzIHJ1bGUgc3lzdGVtOlxyXG4gKiBjb25zdCBydWxlID0gbmV3IFJ1bGVCdWlsZEluR2V0UHJvcGVydHkoKTtcclxuICogY29uc3QgdmFsdWUgPSBydWxlLmZ4KGFwcCwgZmlsZSwgdG9vbHMpO1xyXG4gKiBcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcnVsZSAoJ2dldFByb3BlcnR5JykuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBydWxlVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBydWxlICgnYnVpbGRJbicpLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXNjcmlwdGlvbiAtIEEgYnJpZWYgZGVzY3JpcHRpb24gb2YgdGhlIHJ1bGUncyBwdXJwb3NlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSB0eXBlIC0gVGhlIHR5cGVzIG9mIHByb3BlcnRpZXMgdGhpcyBydWxlIGNhbiBoYW5kbGUuXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGZ4IC0gVGhlIGZ1bmN0aW9uIHRoYXQgcmV0cmlldmVzIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gY29uZmlnVGFiIC0gVGhlIGZ1bmN0aW9uIHRoYXQgcmVuZGVycyB0aGUgY29uZmlndXJhdGlvbiBVSSBmb3IgdGhlIHJ1bGUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZUJ1aWxkSW5HZXRQcm9wZXJ0eSBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuaWQgPSAnZ2V0UHJvcGVydHknO1xyXG4gICAgdGhpcy5ydWxlVHlwZSA9ICdidWlsZEluJztcclxuICAgIHRoaXMubmFtZSA9ICdHZXQgcHJvcGVydHknO1xyXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdHZXRzIGEgcHJvcGVydHkgZnJvbSBzZWxlY3RlZCBwcm9wZXJ0eS4nO1xyXG4gICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBURmlsZSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lISBcXG4gY29uc3QgcHJvcGVydHlJZCA9IHRvb2xzLmdldE9wdGlvbkNvbmZpZyh0b29scy5nZXRSdWxlKCk/LmlkLCdpbnB1dFByb3BlcnR5Jyk7IFxcbiBpZiAocHJvcGVydHlJZCA9PT0gdW5kZWZpbmVkIHx8IHByb3BlcnR5SWQgPT09ICcnKSB7IFxcbiByZXR1cm4gJ1Byb3BlcnR5IG5vdCBzZXQnOyBcXG4gfSBcXG4gY29uc3QgcmVzdWx0ID0gdG9vbHMuZ2V0RnJvbnRtYXR0ZXJQcm9wZXJ0eShwcm9wZXJ0eUlkKTsgXFxuIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkgeyBcXG4gcmV0dXJuICdQcm9wZXJ0eSBub3QgZm91bmQnOyBcXG4gfSBcXG4gcmV0dXJuIHJlc3VsdDsgXFxuIH1cIjtcclxuICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gIH1cclxuICBcclxuICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICBjb25zdCBwcm9wZXJ0eUlkID0gdG9vbHMuZ2V0T3B0aW9uQ29uZmlnKHRvb2xzLmdldFJ1bGUoKT8uaWQsJ2lucHV0UHJvcGVydHknKTtcclxuICAgIGlmIChwcm9wZXJ0eUlkID09PSB1bmRlZmluZWQgfHwgcHJvcGVydHlJZCA9PT0gJycpIHtcclxuICAgICAgcmV0dXJuICdQcm9wZXJ0eSBub3Qgc2V0JztcclxuICAgIH1cclxuICAgIGNvbnN0IHJlc3VsdCA9IHRvb2xzLmdldEZyb250bWF0dGVyUHJvcGVydHkocHJvcGVydHlJZCk7XHJcbiAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuICdQcm9wZXJ0eSBub3QgZm91bmQnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIGNvbmZpZ1RhYiAob3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOkZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIHRoYXQ6YW55LCBwcmV2aWV3Q29tcG9uZW50OiBhbnkpIHtcclxuICAgIC8vIENvbmZpZ3VyYXRpb24gdGFiIGxvZ2ljIGNhbiBiZSBhZGRlZCBoZXJlIGlmIG5lZWRlZFxyXG4gICAgLy8gQ3JlYXRlIGEgc2V0dGluZyBmb3IgdGhlIGNvbnN0YW50IHZhbHVlXHJcbiAgICB0aGF0LnNldE9wdGlvbkNvbmZpZ0RlZmF1bHRzKHJ1bGUuaWQsIHtcclxuICAgICAgICBpbnB1dFByb3BlcnR5OiAnJyxcclxuICAgIH0pXHJcbiAgICBsZXQgaW5wdXRQcm9wZXJ0aWVzRHJvcGRvd246YW55O1xyXG4gICAgbmV3IFNldHRpbmcob3B0aW9uRUwpXHJcbiAgICAgICAgLnNldE5hbWUoJ0lucHV0IFByb3BlcnR5JylcclxuICAgICAgICAuc2V0RGVzYygnU2VsZWN0IGEgcHJvcGVydHkgYXMgaW5wdXQnKVxyXG4gICAgICAgIC5hZGREcm9wZG93bihkcm9wZG93biA9PiB7XHJcbiAgICAgICAgICAgIGlucHV0UHJvcGVydGllc0Ryb3Bkb3duID0gZHJvcGRvd247XHJcbiAgICAgICAgICAgIGRyb3Bkb3duXHJcbiAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGF0LmdldE9wdGlvbkNvbmZpZyhydWxlLmlkICwnaW5wdXRQcm9wZXJ0eScpIHx8ICcnKVxyXG4gICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWcocnVsZS5pZCwnaW5wdXRQcm9wZXJ0eScsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHRoYXQudXBkYXRlUHJldmlldyhydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgT2JqZWN0LmtleXModGhhdC5rbm93blByb3BlcnRpZXMpLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgIC8vaW5wdXRQcm9wZXJ0aWVzRHJvcGRvd24uYWRkT3B0aW9uKGl0ZW1bMV0ubmFtZSxpdGVtWzFdLm5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGF0Lmtub3duUHJvcGVydGllc1trZXldIGFzIFByb3BlcnR5VHlwZUluZm87XHJcbiAgICAgICAgaW5wdXRQcm9wZXJ0aWVzRHJvcGRvd24uYWRkT3B0aW9uKGl0ZW0ubmFtZSwgaXRlbS5uYW1lKTtcclxuICAgIH0pO1xyXG4gIH07XHJcbn0iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFJ1bGVCdWlsZEluSXNSb290IGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaWQgPSAnaXNSb290JztcclxuICAgICAgICB0aGlzLnJ1bGVUeXBlID0gJ2J1aWxkSW4nO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdGaWxlIGluIFJvb3QgZm9sZGVyJztcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gJ0NoZWNrIGlmIHRoZSBmaWxlIGlzIGluIHRoZSByb290IGZvbGRlci4nO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIGxldCBwYXJ0cyA9IGZpbGUucGF0aC5zcGxpdCgnLycpO1xcbiAgcmV0dXJuIHBhcnRzLmxlbmd0aCA9PT0gMTtcXG59O1wiO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFsnY2hlY2tib3gnXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAgICAgbGV0IHBhcnRzID0gZmlsZS5wYXRoLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmxlbmd0aCA9PT0gMTtcclxuICAgIH1cclxuXHJcbiAgICBjb25maWdUYWIgKG9wdGlvbkVMOiBIVE1MRWxlbWVudCwgcnVsZTpGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCB0aGF0OmFueSwgcHJldmlld0NvbXBvbmVudDogYW55KSB7XHJcbiAgICAgICAgLy8gQ29uZmlndXJhdGlvbiB0YWIgbG9naWMgY2FuIGJlIGFkZGVkIGhlcmUgaWYgbmVlZGVkXHJcbiAgICB9O1xyXG4gICAgXHJcbn0iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFNldHRpbmcsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGJ1aWx0LWluIHJ1bGUgZm9yIGNyZWF0aW5nIGEgbGluayB0byBhIGZpbGUgaW4gdGhlIGN1cnJlbnQgdmF1bHQuXHJcbiAqIFRoaXMgcnVsZSBjYW4gYmUgY29uZmlndXJlZCB0byBpbmNsdWRlIG9yIGV4Y2x1ZGUgdGhlIGZpbGUgZXh0ZW5zaW9uIGluIHRoZSBnZW5lcmF0ZWQgbGluay5cclxuICpcclxuICogQGV4dGVuZHMgUnVsZVByb3RvdHlwZVxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiAtIFRoZSBydWxlIGdlbmVyYXRlcyBhIGxpbmsgaW4gdGhlIGZvcm1hdCBgW1twYXRoL3RvL2ZpbGV8ZmlsZU5hbWVdXWAuXHJcbiAqIC0gVGhlIGBhZGRFeHRlbnNpb25gIG9wdGlvbiBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGZpbGUgZXh0ZW5zaW9uIGlzIGluY2x1ZGVkIGluIHRoZSBsaW5rLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBFeGFtcGxlIG91dHB1dCB3aXRoIGBhZGRFeHRlbnNpb25gIHNldCB0byB0cnVlOlxyXG4gKiBbW3BhdGgvdG8vZmlsZS5tZHxmaWxlXV1cclxuICpcclxuICogLy8gRXhhbXBsZSBvdXRwdXQgd2l0aCBgYWRkRXh0ZW5zaW9uYCBzZXQgdG8gZmFsc2U6XHJcbiAqIFtbcGF0aC90by9maWxlfGZpbGVdXVxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBydWxlIChgbGlua1RvRmlsZWApLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcnVsZVR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgcnVsZSAoYGJ1aWxkSW5gKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSBydWxlIChgQ3JlYXRlIGxpbmsgdG8gZmlsZWApLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGVzY3JpcHRpb24gLSBBIGJyaWVmIGRlc2NyaXB0aW9uIG9mIHRoZSBydWxlJ3MgZnVuY3Rpb25hbGl0eS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZSAtIFRoZSBzb3VyY2UgY29kZSBvZiB0aGUgcnVsZSdzIG1haW4gZnVuY3Rpb24uXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHR5cGUgLSBUaGUgdHlwZXMgb2YgY29udGVudCB0aGlzIHJ1bGUgYXBwbGllcyB0byAoYHRleHRgLCBgdGFnc2AsIGBhbGlhc2VzYCwgYG11bHRpdGV4dGApLlxyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBmeCAtIFRoZSBtYWluIGZ1bmN0aW9uIHRoYXQgZ2VuZXJhdGVzIHRoZSBsaW5rIHRvIHRoZSBmaWxlLlxyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBjb25maWdUYWIgLSBUaGUgY29uZmlndXJhdGlvbiBVSSBmb3IgdGhlIHJ1bGUsIGFsbG93aW5nIHVzZXJzIHRvIHRvZ2dsZSB0aGUgYGFkZEV4dGVuc2lvbmAgb3B0aW9uLlxyXG4gKlxyXG4gKiBAbWV0aG9kIGRlZmF1bHRDb25maWdFbGVtZW50c1xyXG4gKiBSZXR1cm5zIHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gZWxlbWVudHMgZm9yIHRoZSBydWxlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FwcH0gYXBwIC0gVGhlIE9ic2lkaWFuIGFwcGxpY2F0aW9uIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0ge1RGaWxlfSBmaWxlIC0gVGhlIGZpbGUgZm9yIHdoaWNoIHRoZSBsaW5rIGlzIGJlaW5nIGdlbmVyYXRlZC5cclxuICogQHBhcmFtIHtTY3JpcHRpbmdUb29sc30gdG9vbHMgLSBVdGlsaXR5IHRvb2xzIGZvciBzY3JpcHRpbmcgYW5kIHJ1bGUgbWFuYWdlbWVudC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlQnVpbGRJbkxpbmtUb0ZpbGUgZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9ICdsaW5rVG9GaWxlJztcclxuICAgICAgICB0aGlzLnJ1bGVUeXBlID0gJ2J1aWxkSW4nO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdDcmVhdGUgbGluayB0byBmaWxlJztcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gJ0NyZWF0ZSBhIGxpbmsgdG8gdGhlIGZpbGUgaW4gdGhlIGN1cnJlbnQgdmF1bHQuIENhbiBiZSBjb25maWd1cmVkIHRvIGluY2x1ZGUgdGhlIGZpbGUgZXh0ZW5zaW9uLic7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgY29uc3QgcGFydHMgPSBmaWxlLnBhdGguc3BsaXQoJy8nKTtcXG4gIGNvbnN0IHJ1bGUgPSB0b29scy5nZXRSdWxlKCk7XFxuICBpZiAoIXJ1bGUpIHJldHVybiB0b29scy5nZXRDdXJyZW50Q29udGVudCgpO1xcbiAgY29uc3QgYWRkRXh0ZW5zaW9uID0gdG9vbHMuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQsJ2FkZEV4dGVuc2lvbicpIFxcbiAgcGFydHMucG9wKCk7XFxuICBpZiAocGFydHNbcGFydHMubGVuZ3RoLTFdID09PSBmaWxlLmJhc2VuYW1lKSBwYXJ0cy5wb3AoKTtcXG4gIGxldCBmaWxlTmFtZSA9IGFkZEV4dGVuc2lvbj8gZmlsZS5iYXNlbmFtZSArICcuJyArIGZpbGUuZXh0ZW5zaW9uIDogZmlsZS5iYXNlbmFtZTsgXFxuICByZXR1cm4gYFtbJHtwYXJ0cy5qb2luKCcvJyl9LyR7ZmlsZU5hbWV9fCR7ZmlsZS5iYXNlbmFtZX1dXWA7XFxufTtcIjtcclxuICAgICAgICB0aGlzLnR5cGUgPSBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddO1xyXG4gICAgICAgIHRoaXMuY29uZmlnRWxlbWVudHMgPSB0aGlzLmRlZmF1bHRDb25maWdFbGVtZW50cyh7fSk7XHJcbiAgICB9O1xyXG4gICAgZnggKGFwcDogQXBwLCBmaWxlOlRGaWxlLCB0b29sczpTY3JpcHRpbmdUb29scyl7XHJcbiAgICAgICAgY29uc3QgcGFydHMgPSBmaWxlLnBhdGguc3BsaXQoJy8nKTtcclxuICAgICAgICBjb25zdCBydWxlID0gdG9vbHMuZ2V0UnVsZSgpO1xyXG4gICAgICAgIGlmICghcnVsZSkgcmV0dXJuIHRvb2xzLmdldEN1cnJlbnRDb250ZW50KCk7XHJcbiAgICAgICAgY29uc3QgYWRkRXh0ZW5zaW9uID0gdG9vbHMuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQsJ2FkZEV4dGVuc2lvbicpIFxyXG4gICAgICAgIHBhcnRzLnBvcCgpO1xyXG4gICAgICAgIGlmIChwYXJ0c1twYXJ0cy5sZW5ndGgtMV0gPT09IGZpbGUuYmFzZW5hbWUpIHBhcnRzLnBvcCgpO1xyXG4gICAgICAgIGxldCBmaWxlTmFtZSA9IGFkZEV4dGVuc2lvbj8gZmlsZS5iYXNlbmFtZSArICcuJyArIGZpbGUuZXh0ZW5zaW9uIDogZmlsZS5iYXNlbmFtZTsgXHJcbiAgICAgICAgcmV0dXJuIGBbWyR7cGFydHMuam9pbignLycpfS8ke2ZpbGVOYW1lfXwke2ZpbGUuYmFzZW5hbWV9XV1gO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgY29uZmlnVGFiIChvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6RnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDphbnksIHByZXZpZXdDb21wb25lbnQ6IGFueSkge1xyXG4gICAgICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnRGVmYXVsdHMocnVsZS5pZCwge1xyXG4gICAgICAgICAgICBhZGRFeHRlbnNpb246IHRydWVcclxuICAgICAgICB9KVxyXG4gICAgXHJcbiAgICAgICAgbmV3IFNldHRpbmcob3B0aW9uRUwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdJbmNsdWRlIGZpbGUgZXh0ZW5zaW9uJylcclxuICAgICAgICAgICAgLnNldERlc2MoJ0FkZCBmaWxlIGV4dGVuc2lvbiB0byBwYXRobmFtZScpXHJcbiAgICAgICAgICAgIC5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoYXQuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQgLCdhZGRFeHRlbnNpb24nKSB8fCBmYWxzZSlcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZyhydWxlLmlkLCdhZGRFeHRlbnNpb24nLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC51cGRhdGVQcmV2aWV3KHJ1bGUsIHByZXZpZXdDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgIH07XHJcbn0iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5cclxuLyoqXHJcbiAqIEEgcnVsZSB0aGF0IGV4dHJhY3RzIHRoZSBmaWxlIG5hbWUgd2l0aG91dCBpdHMgZXh0ZW5zaW9uLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUaGlzIHJ1bGUgaXMgaW50ZW5kZWQgZm9yIHVzZSB3aXRoaW4gdGhlIEZvbGRlciB0byBUYWdzIE9ic2lkaWFuIHBsdWdpbi5cclxuICogSXQgcHJvdmlkZXMgYSB3YXkgdG8gcmV0cmlldmUgdGhlIGJhc2UgbmFtZSBvZiBhIGZpbGUsIGV4Y2x1ZGluZyBhbGwgZXh0ZW5zaW9ucy5cclxuICpcclxuICogQGV4dGVuZHMgUnVsZVByb3RvdHlwZVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBHaXZlbiBhIGZpbGUgbmFtZWQgXCJleGFtcGxlLm5vdGUubWRcIiwgdGhlIHJ1bGUgd2lsbCByZXR1cm4gXCJleGFtcGxlXCIuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHJ1bGUgKFwibmFtZVwiKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJ1bGVUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIHJ1bGUgKFwiYnVpbGRJblwiKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGVzY3JpcHRpb24gLSBBIGJyaWVmIGRlc2NyaXB0aW9uIG9mIHRoZSBydWxlJ3MgcHVycG9zZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZSAtIFRoZSBzb3VyY2Ugb2YgdGhlIHJ1bGUgKGVtcHR5IGZvciBidWlsdC1pbikuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHR5cGUgLSBUaGUgdHlwZXMgdGhpcyBydWxlIGFwcGxpZXMgdG8gKGUuZy4sIHRleHQsIHRhZ3MpLlxyXG4gKiBAcHJvcGVydHkge2FueVtdfSBjb25maWdFbGVtZW50cyAtIFRoZSBjb25maWd1cmF0aW9uIGVsZW1lbnRzIGZvciB0aGUgcnVsZS5cclxuICpcclxuICogQG1ldGhvZCBmeFxyXG4gKiBSZXR1cm5zIHRoZSBmaWxlIG5hbWUgd2l0aG91dCBpdHMgZXh0ZW5zaW9uIHVzaW5nIHRoZSBwcm92aWRlZCBzY3JpcHRpbmcgdG9vbHMuXHJcbiAqXHJcbiAqIEBtZXRob2QgY29uZmlnVGFiXHJcbiAqIChPcHRpb25hbCkgUHJvdmlkZXMgYSBjb25maWd1cmF0aW9uIHRhYiBmb3IgdGhlIHJ1bGUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZUJ1aWxkSW5OYW1lIGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5pZCA9ICduYW1lJztcclxuICAgIHRoaXMucnVsZVR5cGUgPSAnYnVpbGRJbic7XHJcbiAgICB0aGlzLm5hbWUgPSAnRmlsZSBuYW1lIHdpdGhvdXQgZXh0ZW5zaW9uJztcclxuICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnUmV0dXJucyB0aGUgZmlsZSBuYW1lIHdpdGhvdXQgYWxsIGV4dGVuc2lvbnMuIEkuZS4gZXhhbXBsZS5ub3RlLm1kID0+IGV4YW1wbGUnO1xyXG4gICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgLy8gYWNxdWlyZSBmaWxlIG5hbWVcXG4gIGNvbnN0IHJlc3VsdCA9IHRvb2xzLnJlbW92ZUFsbEV4dGVuc2lvbnMoZmlsZS5uYW1lKTtcXG4gIHJldHVybiByZXN1bHQ7XFxufVwiO1xyXG4gICAgdGhpcy50eXBlID0gWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXTtcclxuICAgIHRoaXMuY29uZmlnRWxlbWVudHMgPSB0aGlzLmRlZmF1bHRDb25maWdFbGVtZW50cyh7fSk7XHJcbiAgfVxyXG4gIFxyXG4gIGZ4IChhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogVEZpbGUsIHRvb2xzOiBTY3JpcHRpbmdUb29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgIC8vIGFjcXVpcmUgZmlsZSBuYW1lXHJcbiAgICBjb25zdCByZXN1bHQgPSB0b29scy5yZW1vdmVBbGxFeHRlbnNpb25zKGZpbGUubmFtZSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgY29uZmlnVGFiIChvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6RnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDphbnksIHByZXZpZXdDb21wb25lbnQ6IGFueSkge1xyXG4gICAgLy8gQ29uZmlndXJhdGlvbiB0YWIgbG9naWMgY2FuIGJlIGFkZGVkIGhlcmUgaWYgbmVlZGVkXHJcbiAgfTtcclxuICAgIFxyXG59IiwgIiAgaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG4vKipcclxuICogQSBidWlsdC1pbiBydWxlIHRoYXQgcmV0dXJucyB0aGUgZmlsZSBuYW1lIHdpdGggaXRzIGV4dGVuc2lvbi5cclxuICpcclxuICogQHJlbWFya3NcclxuICogVGhpcyBydWxlIGlzIHBhcnQgb2YgdGhlIGZvbGRlci10by10YWdzLXBsdWdpbiBhbmQgZXh0ZW5kcyB0aGUge0BsaW5rIFJ1bGVQcm90b3R5cGV9LlxyXG4gKiBJdCBpcyBpZGVudGlmaWVkIGJ5IHRoZSBJRCBgJ25hbWVFeHQnYCBhbmQgaXMgY2F0ZWdvcml6ZWQgYXMgYSBidWlsdC1pbiBydWxlLlxyXG4gKiBUaGUgcnVsZSBjYW4gYmUgdXNlZCBpbiBjb250ZXh0cyByZXF1aXJpbmcgdGhlIGZpbGUgbmFtZSBpbmNsdWRpbmcgaXRzIGV4dGVuc2lvbixcclxuICogc3VjaCBhcyB0ZXh0LCB0YWdzLCBhbGlhc2VzLCBvciBtdWx0aXRleHQgZmllbGRzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBSZXR1cm5zIFwiZXhhbXBsZS5tZFwiIGZvciBhIGZpbGUgbmFtZWQgXCJleGFtcGxlLm1kXCJcclxuICogY29uc3QgZmlsZU5hbWVXaXRoRXh0ID0gcnVsZS5meChhcHAsIGZpbGUsIHRvb2xzKTtcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVCdWlsZEluTmFtZUV4dCBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuaWQgPSAnbmFtZUV4dCc7XHJcbiAgICB0aGlzLnJ1bGVUeXBlID0gJ2J1aWxkSW4nO1xyXG4gICAgdGhpcy5uYW1lID0gJ0ZpbGUgbmFtZSB3aXRoIGV4dGVuc2lvbic7XHJcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gJ1JldHVybnMgdGhlIGZpbGUgbmFtZSB3aXRoIGV4dGVuc2lvbi4nO1xyXG4gICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgLy8gYWNxdWlyZSBmaWxlIG5hbWUgd2l0aCBleHRlbnNpb25cXG4gIGNvbnN0IHJlc3VsdCA9IGZpbGUubmFtZTtcXG4gIHJldHVybiByZXN1bHQ7XFxufVwiO1xyXG4gICAgdGhpcy50eXBlID0gWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXTtcclxuICAgIHRoaXMuY29uZmlnRWxlbWVudHMgPSB0aGlzLmRlZmF1bHRDb25maWdFbGVtZW50cyh7fSk7XHJcbiAgfVxyXG4gIFxyXG4gIHB1YmxpYyBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAvLyBhY3F1aXJlIGZpbGUgbmFtZVxyXG4gICAgY29uc3QgcmVzdWx0ID0gZmlsZS5uYW1lO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBjb25maWdUYWIgKG9wdGlvbkVMOiBIVE1MRWxlbWVudCwgcnVsZTpGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCB0aGF0OmFueSwgcHJldmlld0NvbXBvbmVudDogYW55KSB7XHJcbiAgICAvLyBDb25maWd1cmF0aW9uIHRhYiBsb2dpYyBjYW4gYmUgYWRkZWQgaGVyZSBpZiBuZWVkZWRcclxuICB9O1xyXG4gICAgXHJcbn0iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIHJ1bGUgdGhhdCBleHRyYWN0cyB0aGUgZm9sZGVyIHBhdGggb2YgYSBmaWxlIGluIE9ic2lkaWFuLlxyXG4gKiBUaGlzIHJ1bGUgaXMgYnVpbHQtaW4gYW5kIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgdG8gcmV0cmlldmUgdGhlIGZ1bGwgcGF0aFxyXG4gKiBvZiB0aGUgZm9sZGVyIHdoZXJlIGEgZmlsZSBpcyBzdG9yZWQuXHJcbiAqXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICpcclxuICogQHJlbWFya3NcclxuICogLSBUaGUgcnVsZSBpcyBpZGVudGlmaWVkIGJ5IHRoZSBgaWRgIFwicGF0aFwiLlxyXG4gKiAtIEl0IGlzIGNhdGVnb3JpemVkIGFzIGEgXCJidWlsZEluXCIgcnVsZSB0eXBlLlxyXG4gKiAtIFRoZSBydWxlIHN1cHBvcnRzIG11bHRpcGxlIHR5cGVzOiBgdGV4dGAsIGB0YWdzYCwgYGFsaWFzZXNgLCBhbmQgYG11bHRpdGV4dGAuXHJcbiAqIC0gVGhlIGBzb3VyY2VgIHByb3BlcnR5IGNvbnRhaW5zIHRoZSBmdW5jdGlvbiBkZWZpbml0aW9uIGFzIGEgc3RyaW5nLCB3aGljaCBzaG91bGQgbm90IGJlIG1vZGlmaWVkLlxyXG4gKiAtIFRoZSBgZnhgIHByb3BlcnR5IGltcGxlbWVudHMgdGhlIGxvZ2ljIHRvIGV4dHJhY3QgdGhlIGZvbGRlciBwYXRoIGZyb20gdGhlIGZpbGUncyBwYXRoLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBFeGFtcGxlIHVzYWdlIG9mIHRoZSBydWxlOlxyXG4gKiBjb25zdCBydWxlID0gbmV3IFJ1bGVCdWlsZEluUGF0aCgpO1xyXG4gKiBjb25zdCBmb2xkZXJQYXRoID0gcnVsZS5meChhcHAsIGZpbGUsIHRvb2xzKTtcclxuICogY29uc29sZS5sb2coZm9sZGVyUGF0aCk7IC8vIE91dHB1dHMgdGhlIGZvbGRlciBwYXRoIG9mIHRoZSBmaWxlXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHJ1bGUgKFwicGF0aFwiKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJ1bGVUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIHJ1bGUgKFwiYnVpbGRJblwiKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSBydWxlIChcIkZ1bGwgcGF0aFwiKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uIC0gQSBicmllZiBkZXNjcmlwdGlvbiBvZiB0aGUgcnVsZSdzIGZ1bmN0aW9uYWxpdHkuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBUaGUgc291cmNlIGNvZGUgb2YgdGhlIHJ1bGUncyBmdW5jdGlvbiBhcyBhIHN0cmluZy5cclxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gdHlwZSAtIFRoZSBzdXBwb3J0ZWQgdHlwZXMgZm9yIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBmeCAtIFRoZSBmdW5jdGlvbiB0aGF0IGltcGxlbWVudHMgdGhlIHJ1bGUncyBsb2dpYy5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gY29uZmlnVGFiIC0gQSBwbGFjZWhvbGRlciBmb3IgY29uZmlndXJpbmcgdGhlIHJ1bGUgaW4gdGhlIFVJLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVCdWlsZEluUGF0aCBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlkID0gJ3BhdGgnO1xyXG4gICAgICAgIHRoaXMucnVsZVR5cGUgPSAnYnVpbGRJbic7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ0Z1bGwgcGF0aCc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdSZXR1cm5zIHRoZSBmb2xkZXIgcGF0aCB0aGUgZmlsZSBpcyBzdG9yZWQgaW4uJztcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBsZXQgcGFydHMgPSBmaWxlLnBhdGguc3BsaXQoJy8nKTtcXG4gIHBhcnRzLnBvcCgpO1xcbiAgcmV0dXJuIHBhcnRzLmpvaW4oJy8nKTtcXG59O1wiO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICAgICAgdGhpcy5jb25maWdFbGVtZW50cyA9IHRoaXMuZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KTtcclxuICAgIH07XHJcblxyXG4gICAgZnggKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBURmlsZSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzKSB7XHJcbiAgICAgICAgbGV0IHBhcnRzID0gZmlsZS5wYXRoLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgcGFydHMucG9wKCk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJy8nKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uZmlnVGFiIChvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6RnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDphbnksIHByZXZpZXdDb21wb25lbnQ6IGFueSkge1xyXG4gICAgICAgIC8vIENvbmZpZ3VyYXRpb24gdGFiIGxvZ2ljIGNhbiBiZSBhZGRlZCBoZXJlIGlmIG5lZWRlZFxyXG4gICAgfTtcclxufSIsICJpbXBvcnQgeyBSdWxlUHJvdG90eXBlLCBydWxlc01hbmFnZXIgfSBmcm9tIFwiLi9ydWxlc1wiO1xyXG5pbXBvcnQgeyBTY3JpcHRpbmdUb29scyB9IGZyb20gXCIuLi90b29sc1wiO1xyXG5pbXBvcnQgeyBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzIH0gZnJvbSBcIi4uL3R5cGVzXCI7XHJcbmltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgYnVpbHQtaW4gcnVsZSBmb3IgaGFuZGxpbmcgZm9sZGVyIG5vdGVzIGluIGEgcGF0aC1jb21wYXRpYmxlIG1hbm5lci5cclxuICogVGhpcyBydWxlIHByb2Nlc3NlcyBmaWxlIHBhdGhzIHRvIGRldGVybWluZSB0aGUgYXBwcm9wcmlhdGUgZm9sZGVyIHN0cnVjdHVyZSxcclxuICogcmVtb3ZpbmcgcGFyZW50IGZvbGRlcnMgaWYgdGhleSBzaGFyZSB0aGUgc2FtZSBuYW1lIGFzIHRoZSBmaWxlLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIC0gVGhlIGBmeGAgbWV0aG9kIGltcGxlbWVudHMgdGhlIGNvcmUgbG9naWMgZm9yIHBhdGggbWFuaXB1bGF0aW9uLlxyXG4gKiAtIFRoZSBgc291cmNlYCBwcm9wZXJ0eSBjb250YWlucyB0aGUgc2VyaWFsaXplZCBmdW5jdGlvbiBsb2dpYyBmb3IgZXh0ZXJuYWwgdXNlLlxyXG4gKiAtIFRoaXMgcnVsZSBpcyBkZXNpZ25lZCB0byB3b3JrIHdpdGggdGV4dCwgdGFncywgYWxpYXNlcywgYW5kIG11bHRpdGV4dCB0eXBlcy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogLy8gRXhhbXBsZSB1c2FnZSBvZiB0aGUgYGZ4YCBtZXRob2Q6XHJcbiAqIGNvbnN0IHJlc3VsdCA9IHJ1bGUuZngoYXBwLCBmaWxlLCB0b29scyk7XHJcbiAqIGNvbnNvbGUubG9nKHJlc3VsdCk7IC8vIE91dHB1dHMgdGhlIHByb2Nlc3NlZCBwYXRoXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHJ1bGUgKGBwYXRoRm9sZGVyTm90ZXNgKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJ1bGVUeXBlIC0gVGhlIHR5cGUgb2YgcnVsZSAoYGJ1aWxkSW5gKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSBydWxlIChgUGF0aCAoZm9sZGVyIG5vdGVzKWApLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGVzY3JpcHRpb24gLSBBIGJyaWVmIGRlc2NyaXB0aW9uIG9mIHRoZSBydWxlJ3MgcHVycG9zZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZSAtIFRoZSBzZXJpYWxpemVkIGZ1bmN0aW9uIGxvZ2ljIGZvciBleHRlcm5hbCB1c2UuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHR5cGUgLSBUaGUgdHlwZXMgb2YgZGF0YSB0aGlzIHJ1bGUgYXBwbGllcyB0byAoYHRleHRgLCBgdGFnc2AsIGBhbGlhc2VzYCwgYG11bHRpdGV4dGApLlxyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBjb25maWdUYWIgLSBBIHBsYWNlaG9sZGVyIGZvciBjb25maWd1cmF0aW9uIHRhYiBsb2dpYy5cclxuICpcclxuICogQG1ldGhvZCBmeFxyXG4gKiBQcm9jZXNzZXMgdGhlIGZpbGUgcGF0aCB0byBkZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIGZvbGRlciBzdHJ1Y3R1cmUuXHJcbiAqIFJlbW92ZXMgdGhlIHBhcmVudCBmb2xkZXIgaWYgaXQgc2hhcmVzIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGZpbGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXBwIHwgdW5kZWZpbmVkfSBhcHAgLSBUaGUgYXBwbGljYXRpb24gaW5zdGFuY2UgKG9wdGlvbmFsKS5cclxuICogQHBhcmFtIHtURmlsZX0gZmlsZSAtIFRoZSBmaWxlIG9iamVjdCBjb250YWluaW5nIHBhdGggYW5kIGJhc2VuYW1lIGluZm9ybWF0aW9uLlxyXG4gKiBAcGFyYW0ge1NjcmlwdGluZ1Rvb2xzfSB0b29scyAtIFV0aWxpdHkgdG9vbHMgZm9yIHNjcmlwdGluZyBvcGVyYXRpb25zLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBwcm9jZXNzZWQgcGF0aCBhZnRlciBhcHBseWluZyB0aGUgcnVsZSBsb2dpYy5cclxuICpcclxuICogQG1ldGhvZCBjb25maWdUYWJcclxuICogUGxhY2Vob2xkZXIgbWV0aG9kIGZvciBhZGRpbmcgY29uZmlndXJhdGlvbiB0YWIgbG9naWMuXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBJbml0aWFsaXplcyB0aGUgcnVsZSB3aXRoIGRlZmF1bHQgcHJvcGVydGllcyBhbmQgY29uZmlndXJhdGlvbiBlbGVtZW50cy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlQnVpbGRJblBhdGhGb2xkZXJOb3RlcyBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlkID0gJ3BhdGhGb2xkZXJOb3Rlcyc7XHJcbiAgICAgICAgdGhpcy5ydWxlVHlwZSA9ICdidWlsZEluJztcclxuICAgICAgICB0aGlzLm5hbWUgPSAnUGF0aCAoZm9sZGVyIG5vdGVzKSc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdQYXRoIGNvbXBhdGlibGUgd2l0aCBmb2xkZXIgbm90ZXMuJztcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBsZXQgcGFydHMgPSBmaWxlLnBhdGguc3BsaXQoJy8nKTtcXG4gIHBhcnRzLnBvcCgpO1xcbiAgaWYgKHBhcnRzW3BhcnRzLmxlbmd0aC0xXSA9PT0gZmlsZS5iYXNlbmFtZSkgcGFydHMucG9wKCk7IC8vIHJlbW92ZSBwYXJlbnQgZm9sZGVyIGlmIHNhbWUgbmFtZSBhcyB0aGUgZmlsZVxcbiAgcmV0dXJuIHBhcnRzLmpvaW4oJy8nKTtcXG59O1wiO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICAgICAgdGhpcy5jb25maWdFbGVtZW50cyA9IHRoaXMuZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnggKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBURmlsZSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIGxldCBwYXJ0cyA9IGZpbGUucGF0aC5zcGxpdCgnLycpO1xyXG4gICAgICAgIHBhcnRzLnBvcCgpO1xyXG4gICAgICAgIGlmIChwYXJ0c1twYXJ0cy5sZW5ndGgtMV0gPT09IGZpbGUuYmFzZW5hbWUpIHBhcnRzLnBvcCgpOyAvLyByZW1vdmUgcGFyZW50IGZvbGRlciBpZiBzYW1lIG5hbWUgYXMgdGhlIGZpbGVcclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbignLycpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbmZpZ1RhYiAob3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOkZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIHRoYXQ6YW55LCBwcmV2aWV3Q29tcG9uZW50OiBhbnkpIHtcclxuICAgICAgICAvLyBDb25maWd1cmF0aW9uIHRhYiBsb2dpYyBjYW4gYmUgYWRkZWQgaGVyZSBpZiBuZWVkZWRcclxuICAgIH07XHJcbiAgICBcclxufSIsICJpbXBvcnQgeyBSdWxlUHJvdG90eXBlLCBydWxlc01hbmFnZXIgfSBmcm9tIFwiLi9ydWxlc1wiO1xyXG5pbXBvcnQgeyBTY3JpcHRpbmdUb29scyB9IGZyb20gXCIuLi90b29sc1wiO1xyXG5pbXBvcnQgeyBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzIH0gZnJvbSBcIi4uL3R5cGVzXCI7XHJcbmltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbi8qKlxyXG4gKiBSdWxlQnVpbGRJblJvb3RGb2xkZXIgaXMgYSBydWxlIGltcGxlbWVudGF0aW9uIHRoYXQgZXh0cmFjdHMgdGhlIHJvb3QgZm9sZGVyIG5hbWVcclxuICogZnJvbSB0aGUgcGF0aCBvZiBhIGdpdmVuIGZpbGUgaW4gYW4gT2JzaWRpYW4gdmF1bHQuXHJcbiAqXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICpcclxuICogQHJlbWFya3NcclxuICogLSBUaGUgcnVsZSBpZGVudGlmaWVzIHRoZSB0b3AtbGV2ZWwgZGlyZWN0b3J5IChyb290IGZvbGRlcikgd2hlcmUgdGhlIGZpbGUgaXMgc3RvcmVkLlxyXG4gKiAtIElmIHRoZSBmaWxlIGlzIGF0IHRoZSByb290IG9mIHRoZSB2YXVsdCAoaS5lLiwgbm90IGluc2lkZSBhbnkgZm9sZGVyKSwgYW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkLlxyXG4gKiAtIFRoZSBydWxlIGlzIGNhdGVnb3JpemVkIGFzIGEgJ2J1aWxkSW4nIHR5cGUgYW5kIHN1cHBvcnRzIG11bHRpcGxlIG91dHB1dCB0eXBlczogJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgYW5kICdtdWx0aXRleHQnLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBJZiBmaWxlLnBhdGggaXMgJ1Byb2plY3RzL05vdGVzL21lZXRpbmcubWQnLCB0aGUgcnVsZSByZXR1cm5zICdQcm9qZWN0cycuXHJcbiAqIC8vIElmIGZpbGUucGF0aCBpcyAncmVhZG1lLm1kJywgdGhlIHJ1bGUgcmV0dXJucyAnJyAoZW1wdHkgc3RyaW5nKS5cclxuICpcclxuICogQHBhcmFtIGFwcCAtIFRoZSBjdXJyZW50IE9ic2lkaWFuIEFwcCBpbnN0YW5jZSAobWF5IGJlIHVuZGVmaW5lZCkuXHJcbiAqIEBwYXJhbSBmaWxlIC0gVGhlIFRGaWxlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGZpbGUgd2hvc2Ugcm9vdCBmb2xkZXIgaXMgdG8gYmUgZGV0ZXJtaW5lZC5cclxuICogQHBhcmFtIHRvb2xzIC0gU2NyaXB0aW5nVG9vbHMgdXRpbGl0eSBvYmplY3QgZm9yIGFkZGl0aW9uYWwgb3BlcmF0aW9ucyAobm90IHVzZWQgaW4gdGhpcyBydWxlKS5cclxuICpcclxuICogQHJldHVybnMgVGhlIG5hbWUgb2YgdGhlIHJvb3QgZm9sZGVyIGFzIGEgc3RyaW5nLCBvciBhbiBlbXB0eSBzdHJpbmcgaWYgdGhlIGZpbGUgaXMgaW4gdGhlIHZhdWx0IHJvb3QuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZUJ1aWxkSW5Sb290Rm9sZGVyIGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5pZCA9ICdyb290Rm9sZGVyJztcclxuICAgIHRoaXMucnVsZVR5cGUgPSAnYnVpbGRJbic7XHJcbiAgICB0aGlzLm5hbWUgPSAnUm9vdCBmb2xkZXInO1xyXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdSZXR1cm5zIHRoZSByb290IGZvbGRlciB3aGVyZSB0aGUgZmlsZSBpcyBzdG9yZWQuJztcclxuICAgIHRoaXMuc291cmNlID0gXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIC8vIGFjcXVpcmUgZmlsZSBwYXRoXFxuICBjb25zdCBwYXRoID0gZmlsZS5wYXRoO1xcbiAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XFxuICByZXR1cm4gcGFydHMubGVuZ3RoID4gMSA/IHBhcnRzWzBdIDogJyc7IC8vIHJldHVybiByb290IGZvbGRlciBvciBlbXB0eSBzdHJpbmcgaWYgaW4gcm9vdFxcbn1cIjtcclxuICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gIH1cclxuICBcclxuICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAvLyBhY3F1aXJlIGZpbGUgcGF0aFxyXG4gICAgY29uc3QgcGF0aCA9IGZpbGUucGF0aDtcclxuICAgIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLycpO1xyXG4gICAgbGV0IHJlc3VsdCA9ICcnO1xyXG4gICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgcmVzdWx0ID0gcGFydHNbMF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgY29uZmlnVGFiIChvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6RnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDphbnksIHByZXZpZXdDb21wb25lbnQ6YW55KSB7XHJcbiAgICAgIC8vIENvbmZpZ3VyYXRpb24gdGFiIGxvZ2ljIGNhbiBiZSBhZGRlZCBoZXJlIGlmIG5lZWRlZFxyXG4gIH07XHJcbiAgICBcclxufSIsICJpbXBvcnQgeyBSdWxlUHJvdG90eXBlLCBydWxlc01hbmFnZXIgfSBmcm9tIFwiLi9ydWxlc1wiO1xyXG5pbXBvcnQgeyBTY3JpcHRpbmdUb29scyB9IGZyb20gXCIuLi90b29sc1wiO1xyXG5pbXBvcnQgeyBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzIH0gZnJvbSBcIi4uL3R5cGVzXCI7XHJcbmltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgYnVpbHQtaW4gcnVsZSB0aGF0IHBhc3NlcyB0aGUgY29udGVudCBvZiBhIGZyb250bWF0dGVyIHBhcmFtZXRlciB1bmFsdGVyZWQuXHJcbiAqIFRoaXMgcnVsZSBpcyB1c2VkIHRvIHJldHVybiB0aGUgaW5wdXQgY29udGVudCB3aXRob3V0IGFueSBtb2RpZmljYXRpb25zLlxyXG4gKiBcclxuICogQGV4dGVuZHMgUnVsZVByb3RvdHlwZVxyXG4gKiBcclxuICogQHJlbWFya3NcclxuICogLSBUaGUgYGZ4YCBmdW5jdGlvbiBhbmQgYHNvdXJjZWAgcHJvcGVydHkgYXJlIGRlc2lnbmVkIHRvIHByb2Nlc3MgdGhlIGlucHV0IGNvbnRlbnQgYW5kIHJldHVybiBpdCBhcy1pcy5cclxuICogLSBUaGlzIHJ1bGUgc3VwcG9ydHMgbXVsdGlwbGUgdHlwZXMgaW5jbHVkaW5nIGB0ZXh0YCwgYHRhZ3NgLCBgYWxpYXNlc2AsIGFuZCBgbXVsdGl0ZXh0YC5cclxuICogLSBUaGUgYGNvbmZpZ1RhYmAgbWV0aG9kIGlzIGN1cnJlbnRseSBhIHBsYWNlaG9sZGVyIGZvciBjb25maWd1cmF0aW9uIFVJIGVsZW1lbnRzLlxyXG4gKiBcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcnVsZSwgc2V0IHRvIGAnZGVmYXVsdCdgLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcnVsZVR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgcnVsZSwgc2V0IHRvIGAnYnVpbGRJbidgLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIHJ1bGUsIHNldCB0byBgJ1Bhc3MgcGFyYW1ldGVyIHVuYWx0ZXJlZCdgLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGVzY3JpcHRpb24gLSBBIGJyaWVmIGRlc2NyaXB0aW9uIG9mIHRoZSBydWxlJ3MgZnVuY3Rpb25hbGl0eS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZSAtIFRoZSBzb3VyY2UgY29kZSBvZiB0aGUgcnVsZSBhcyBhIHN0cmluZywgdXNlZCBmb3Igc2NyaXB0aW5nIHB1cnBvc2VzLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSB0eXBlIC0gVGhlIHN1cHBvcnRlZCB0eXBlcyBmb3IgdGhpcyBydWxlLCBpbmNsdWRpbmcgYHRleHRgLCBgdGFnc2AsIGBhbGlhc2VzYCwgYW5kIGBtdWx0aXRleHRgLlxyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBmeCAtIFRoZSBtYWluIGZ1bmN0aW9uIHRoYXQgcHJvY2Vzc2VzIHRoZSBpbnB1dCBjb250ZW50IGFuZCByZXR1cm5zIGl0IHVuYWx0ZXJlZC5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gY29uZmlnVGFiIC0gQSBtZXRob2QgZm9yIHJlbmRlcmluZyB0aGUgY29uZmlndXJhdGlvbiB0YWIgZm9yIHRoZSBydWxlLlxyXG4gKiBcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgUnVsZUJ1aWxkSW5EZWZhdWx0YCBjbGFzcy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlQnVpbGRJblNjcmlwdCBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlkID0gJ3NjcmlwdCc7XHJcbiAgICAgICAgdGhpcy5ydWxlVHlwZSA9ICdidWlsZEluJztcclxuICAgICAgICB0aGlzLm5hbWUgPSAnSmF2YVNjcmlwdCBmdW5jdGlvbiAoYWR2YW5jZWQpJztcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gJ0ltcGxlbWVudCBhIEphdmFTY3JpcHQgZnVuY3Rpb24gdG8gcHJvY2VzcyB0aGUgaW5wdXQgY29udGVudC4gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gdGhlIHByb2Nlc3NlZCBjb250ZW50Lic7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgY29uc3QgaW5wdXQgPSB0b29scy5nZXRDdXJyZW50Q29udGVudCgpOyAvLyBHZXQgdGhlIGN1cnJlbnQgY29udGVudCBvZiBwcm9wZXJ0eVxcbiAgcmV0dXJuIGlucHV0OyAvLyBSZXR1cm4gdGhlIGlucHV0IHVuYWx0ZXJlZFxcbn07XCI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAgICAgY29uc3QgaW5wdXQgPSB0b29scy5nZXRDdXJyZW50Q29udGVudCgpOyAvLyBHZXQgdGhlIGN1cnJlbnQgY29udGVudCBvZiBwcm9wZXJ0eVxyXG4gICAgICAgIHJldHVybiBpbnB1dDsgLy8gUmV0dXJuIHRoZSBpbnB1dCB1bmFsdGVyZWRcclxuICAgIH07XHJcblxyXG4gICAgY29uZmlnVGFiIChvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6RnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDphbnksIHByZXZpZXdDb21wb25lbnQ6YW55KSB7XHJcbiAgICAgICAgLy8gQ29uZmlndXJhdGlvbiB0YWIgbG9naWMgY2FuIGJlIGFkZGVkIGhlcmUgaWYgbmVlZGVkXHJcbiAgICB9O1xyXG4gICAgXHJcbn0iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgQXBwLCBTZXR0aW5nLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgeyBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzIH0gZnJvbSBcIi4uL3R5cGVzXCI7XHJcbmltcG9ydCB7IEVSUk9SLCBsb2dnZXIsIFdBUk5JTkcgfSBmcm9tIFwiLi4vTG9nXCI7XHJcblxyXG5cclxuLyoqXHJcbiAqIEEgcnVsZSBjbGFzcyBmb3IgcmVwbGFjaW5nIGNvbmZpZ3VyYWJsZSBjaGFyYWN0ZXJzIGluIGFuIGlucHV0IHZhbHVlIHdpdGggYSBzcGVjaWZpZWQgdGV4dCBzdHJpbmcuXHJcbiAqIFN1cHBvcnRzIGJvdGggcGxhaW4gdGV4dCBhbmQgcmVndWxhciBleHByZXNzaW9uIHJlcGxhY2VtZW50cy5cclxuICogXHJcbiAqIEByZW1hcmtzXHJcbiAqIC0gVGhpcyBydWxlIGlzIGludGVuZGVkIGZvciB1c2UgaW4gZm9ybWF0dGluZyBvcGVyYXRpb25zLCBzdWNoIGFzIHJlcGxhY2luZyBzcGFjZXMgb3Igb3RoZXIgY2hhcmFjdGVycyBpbiB0YWdzLCBhbGlhc2VzLCBvciB0ZXh0IGZpZWxkcy5cclxuICogLSBUaGUgcmVwbGFjZW1lbnQgYmVoYXZpb3IgaXMgY29uZmlndXJhYmxlIHZpYSB0aGUgYHJlcGxhY2VgIChzZWFyY2ggcGF0dGVybikgYW5kIGByZXBsYWNlQnlgIChyZXBsYWNlbWVudCBzdHJpbmcpIG9wdGlvbnMuXHJcbiAqIC0gVGhlIGNvbmZpZ3VyYXRpb24gVUkgYWxsb3dzIHVzZXJzIHRvIHNwZWNpZnkgdGhlIHNlYXJjaCBwYXR0ZXJuIChzdXBwb3J0cyByZWdleCkgYW5kIHRoZSByZXBsYWNlbWVudCBzdHJpbmcuXHJcbiAqIFxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBSZXBsYWNlIGFsbCBzcGFjZXMgd2l0aCB1bmRlcnNjb3JlcyBpbiBhIHN0cmluZ1xyXG4gKiBjb25zdCBydWxlID0gbmV3IFJ1bGVSZXBsYWNlU3BhY2VzKCk7XHJcbiAqIHJ1bGUuZngoYXBwLCBmaWxlLCB0b29scywgXCJteSB0YWcgbmFtZVwiKTsgLy8gcmV0dXJucyBcIm15X3RhZ19uYW1lXCIgaWYgY29uZmlndXJlZCBhcHByb3ByaWF0ZWx5XHJcbiAqIFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXNjcmlwdGlvbiAtIEEgZGVzY3JpcHRpb24gb2Ygd2hhdCB0aGUgcnVsZSBkb2VzLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcnVsZVR5cGUgLSBUaGUgdHlwZSBvZiBydWxlIChlLmcuLCAnZm9ybWF0dGVyJykuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBUaGUgc291cmNlIGNvZGUgZm9yIHRoZSBydWxlJ3MgZnVuY3Rpb24uXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHR5cGUgLSBUaGUgdHlwZXMgb2YgZmllbGRzIHRoaXMgcnVsZSBjYW4gYmUgYXBwbGllZCB0by5cclxuICogQHByb3BlcnR5IHthbnl9IGNvbmZpZ0VsZW1lbnRzIC0gVGhlIGNvbmZpZ3VyYXRpb24gZWxlbWVudHMgZm9yIHRoZSBydWxlLlxyXG4gKiBcclxuICogQG1ldGhvZCBmeFxyXG4gKiBBcHBsaWVzIHRoZSByZXBsYWNlbWVudCBydWxlIHRvIHRoZSBpbnB1dCB2YWx1ZSB1c2luZyB0aGUgY29uZmlndXJlZCBzZWFyY2ggcGF0dGVybiBhbmQgcmVwbGFjZW1lbnQgc3RyaW5nLlxyXG4gKiBcclxuICogQG1ldGhvZCBjb25maWdUYWJcclxuICogUmVuZGVycyB0aGUgY29uZmlndXJhdGlvbiB0YWIgVUkgZm9yIHNldHRpbmcgdGhlIHNlYXJjaCBhbmQgcmVwbGFjZW1lbnQgc3RyaW5ncy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlUmVwbGFjZUNoYXJzIGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaWQgPSAncmVwbGFjZUNoYXJzJztcclxuICAgICAgICB0aGlzLm5hbWUgPSAnUmVwbGFjZSBDaGFyYWN0ZXJzJztcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gJ1JlcGxhY2VzIGNvbmZpZ3VyYWJsZSBjaGFyYWN0ZXJzIGluIHRoZSBpbnB1dCB2YWx1ZSB3aXRoIGEgc3BlY2lmaWVkIHRleHQgc3RyaW5nLiBTdXBwb3J0cyB0ZXh0IGFuZCByZWdleCByZXBsYWNlbWVudHMuJztcclxuICAgICAgICB0aGlzLnJ1bGVUeXBlID0gJ2Zvcm1hdHRlcic7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgbGV0IHJlc3VsdCA9ICcnO1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59XCI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZnggKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBhbnksIHRvb2xzOiBTY3JpcHRpbmdUb29scywgaW5wdXQ/OmFueSkgeyAvLyBEZWZhdWx0IGZ1bmN0aW9uIHNpZ25hdHVyZVxyXG4gICAgICAgIGNvbnN0IHJlcGxhY2UgPSB0b29scy5nZXRPcHRpb25Db25maWcodG9vbHMuZ2V0UnVsZSgpPy5pZCwgJ3JlcGxhY2UnKTtcclxuICAgICAgICBpZiAoIXJlcGxhY2UgfHwgcmVwbGFjZSA9PT0gJycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXBsYWNlQnkgPSB0b29scy5nZXRPcHRpb25Db25maWcodG9vbHMuZ2V0UnVsZSgpPy5pZCwgJ3JlcGxhY2VCeScpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChyZXBsYWNlLCAnZycpO1xyXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZShyZWdleCwgcmVwbGFjZUJ5KTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5sb2coRVJST1IsYEVycm9yIGluIFJ1bGVSZXBsYWNlQ2hhcnM6IEludmFsaWQgcmVnZXggcGF0dGVybiBcIiR7cmVwbGFjZX1cImAsIGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBjb25maWdUYWIob3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOiBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCB0aGF0OiBhbnksIHByZXZpZXdDb21wb25lbnQ6IGFueSkge1xyXG4gICAgICAgIG9wdGlvbkVMLmVtcHR5KCk7XHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgc2V0dGluZyBmb3IgdGhlIHNtYWxsIHdvcmRzXHJcbiAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWdEZWZhdWx0cyhydWxlLmlkLCB7XHJcbiAgICAgICAgICAgIHJlcGxhY2U6ICcnLCAvLyBzZWFyY2ggZm9yIHRoaXMgc3RyaW5nXHJcbiAgICAgICAgICAgIHJlcGxhY2VCeTogJycsIC8vIHJlcGxhY2Ugd2l0aCB0aGlzIHN0cmluZ1xyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnc2VhcmNoIGZvcicpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdDaGFyYWN0ZXIgdG8gc2VhcmNoIGZvciBpbiB0aGUgaW5wdXQgdmFsdWUgKFJlZ2V4IHN1cHBvcnRlZCknKVxyXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignc2VhcmNoIGZvcicpXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhhdC5nZXRPcHRpb25Db25maWcocnVsZS5pZCAsJ3JlcGxhY2UnKSB8fCAnJylcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZyhydWxlLmlkLCdyZXBsYWNlJywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudXBkYXRlUHJldmlldyhydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgncmVwbGFjZSBieScpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdDaGFyYWN0ZXIgdG8gcmVwbGFjZSBtYXRjaGVzJylcclxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ3JlcGxhY2UgYnknKVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoYXQuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQgLCdyZXBsYWNlQnknKSB8fCAnJylcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZyhydWxlLmlkLCdyZXBsYWNlQnknLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC51cGRhdGVQcmV2aWV3KHJ1bGUsIHByZXZpZXdDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgIH07XHJcbn0iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgQXBwLCBTZXR0aW5nLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgeyBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzIH0gZnJvbSBcIi4uL3R5cGVzXCI7XHJcblxyXG4vKipcclxuICogQSBydWxlIGNsYXNzIHRoYXQgcmVwbGFjZXMgc3BhY2VzIGluIGEgZ2l2ZW4gaW5wdXQgdmFsdWUgd2l0aCBhIHNwZWNpZmllZCBjaGFyYWN0ZXIuXHJcbiAqIFxyXG4gKiBUaGlzIHJ1bGUgaXMgaW50ZW5kZWQgZm9yIHVzZSBpbiBmb3JtYXR0aW5nIHRleHQsIHRhZ3MsIGFsaWFzZXMsIG9yIG11bHRpdGV4dCBmaWVsZHMuXHJcbiAqIFRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgY2FuIGJlIGNvbmZpZ3VyZWQgYnkgdGhlIHVzZXIgdmlhIHRoZSBzZXR0aW5ncyBVSS5cclxuICogXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICogXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIElmIHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaXMgc2V0IHRvIFwiX1wiOlxyXG4gKiBydWxlLmZ4KGFwcCwgZmlsZSwgdG9vbHMsIFwiaGVsbG8gd29ybGRcIikgLy8gcmV0dXJucyBcImhlbGxvX3dvcmxkXCJcclxuICogXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHJ1bGUgKFwicmVwbGFjZVNwYWNlc1wiKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgZGlzcGxheSBuYW1lIGZvciB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uIC0gQSBkZXNjcmlwdGlvbiBvZiB3aGF0IHRoZSBydWxlIGRvZXMuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBydWxlVHlwZSAtIFRoZSB0eXBlIG9mIHJ1bGUgKFwiZm9ybWF0dGVyXCIpLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSB0eXBlIC0gVGhlIGFwcGxpY2FibGUgZmllbGQgdHlwZXMgZm9yIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge2FueX0gY29uZmlnRWxlbWVudHMgLSBUaGUgY29uZmlndXJhdGlvbiBlbGVtZW50cyBmb3IgdGhlIHJ1bGUuXHJcbiAqIFxyXG4gKiBAbWV0aG9kIGZ4XHJcbiAqIFJlcGxhY2VzIGFsbCBzcGFjZXMgaW4gdGhlIGlucHV0IHZhbHVlIHdpdGggdGhlIGNvbmZpZ3VyZWQgcmVwbGFjZW1lbnQgY2hhcmFjdGVyLlxyXG4gKiBcclxuICogQG1ldGhvZCBjb25maWdUYWJcclxuICogUmVuZGVycyB0aGUgY29uZmlndXJhdGlvbiBVSSBmb3Igc2V0dGluZyB0aGUgc3BhY2UgcmVwbGFjZW1lbnQgY2hhcmFjdGVyLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVSZXBsYWNlU3BhY2VzIGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaWQgPSAncmVwbGFjZVNwYWNlcyc7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ1JlcGxhY2UgU3BhY2VzJztcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gJ1JlcGxhY2VzIHNwYWNlcyBpbiB0aGUgaW5wdXQgdmFsdWUgd2l0aCBhIHNwZWNpZmllZCBjaGFyYWN0ZXIuJztcclxuICAgICAgICB0aGlzLnJ1bGVUeXBlID0gJ2Zvcm1hdHRlcic7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgbGV0IHJlc3VsdCA9ICcnO1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59XCI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZnggKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBhbnksIHRvb2xzOiBTY3JpcHRpbmdUb29scywgaW5wdXQ/OmFueSkgeyAvLyBEZWZhdWx0IGZ1bmN0aW9uIHNpZ25hdHVyZVxyXG4gICAgICAgIGNvbnN0IHNwYWNlUmVwbGFjZW1lbnQgPSB0b29scy5nZXRPcHRpb25Db25maWcodG9vbHMuZ2V0UnVsZSgpPy5pZCwgJ3NwYWNlUmVwbGFjZW1lbnQnKTtcclxuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxzKy9nLCBzcGFjZVJlcGxhY2VtZW50KTsgLy8gUmVwbGFjZSBhbGwgc3BhY2VzIHdpdGggdGhlIHNwZWNpZmllZCBjaGFyYWN0ZXJcclxuICAgIH07XHJcblxyXG4gICAgY29uZmlnVGFiKG9wdGlvbkVMOiBIVE1MRWxlbWVudCwgcnVsZTogRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncywgdGhhdDogYW55LCBwcmV2aWV3Q29tcG9uZW50OiBhbnkpIHtcclxuICAgICAgICBvcHRpb25FTC5lbXB0eSgpO1xyXG4gICAgICAgIC8vIENyZWF0ZSBhIHNldHRpbmcgZm9yIHRoZSBzbWFsbCB3b3Jkc1xyXG4gICAgICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnRGVmYXVsdHMocnVsZS5pZCwge1xyXG4gICAgICAgICAgICBzcGFjZVJlcGxhY2VtZW50IDogJycsIC8vIERlZmF1bHQgc3VmZml4XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgbmV3IFNldHRpbmcob3B0aW9uRUwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdTcGFjZSByZXBsYWNlbWVudCcpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdDaGFyYWN0ZXIgdG8gcmVwbGFjZSBzcGFjZXMgKHN1Z2dlc3RlZDogXCJfXCIpJylcclxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ3dpbGwgcmVtb3ZlIHNwYWNlcycpXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhhdC5nZXRPcHRpb25Db25maWcocnVsZS5pZCAsJ3NwYWNlUmVwbGFjZW1lbnQnKSB8fCAnJylcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZyhydWxlLmlkLCdzcGFjZVJlcGxhY2VtZW50JywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudXBkYXRlUHJldmlldyhydWxlLCBwcmV2aWV3Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICk7XHJcbiAgICB9O1xyXG59IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEFwcCwgU2V0dGluZywgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJBdXRvbWF0ZVJ1bGVTZXR0aW5ncyB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBBIHJ1bGUgY2xhc3MgZm9yIHJlcGxhY2luZyBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gc3RyaW5ncywgd2hpbGUgcHJlc2VydmluZyBsZXR0ZXJzIHdpdGggZGlhY3JpdGljcy5cclxuICogXHJcbiAqIFRoaXMgcnVsZSBpcyBpbnRlbmRlZCBmb3IgdXNlIGluIGZvcm1hdHRpbmcgdGV4dCwgdGFncywgYWxpYXNlcywgYW5kIG11bHRpdGV4dCBmaWVsZHMuIEl0IGFsbG93c1xyXG4gKiB0aGUgdXNlciB0byBzcGVjaWZ5IGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIChzdWdnZXN0ZWQ6IFwiLVwiKSBmb3IgYW55IGNoYXJhY3RlciB0aGF0IGRvZXMgbm90IG1hdGNoXHJcbiAqIHRoZSBhbGxvd2VkIHNldCAobGV0dGVycywgbnVtYmVycywgZGFzaGVzLCB1bmRlcnNjb3Jlcywgc2xhc2hlcywgYW5kIGNvbW1vbiBkaWFjcml0aWNzKS5cclxuICogXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICogXHJcbiAqIEByZW1hcmtzXHJcbiAqIC0gVGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlciBjYW4gYmUgY29uZmlndXJlZCB2aWEgdGhlIHNldHRpbmdzIFVJLlxyXG4gKiAtIFRoZSBydWxlIHByZXNlcnZlcyBsZXR0ZXJzIHdpdGggZGlhY3JpdGljcyAoZS5nLiwgXHUwMEU0LCBcdTAwRjYsIFx1MDBGQywgXHUwMEUxLCBcdTAwRTksIGV0Yy4pLlxyXG4gKiAtIFRoZSBgZnhgIG1ldGhvZCBwZXJmb3JtcyB0aGUgcmVwbGFjZW1lbnQgdXNpbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBSZXBsYWNlIGFsbCBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gYSBzdHJpbmcgd2l0aCAnLSdcclxuICogcnVsZS5meChhcHAsIGZpbGUsIHRvb2xzLCBcImhlbGxvQHdvcmxkIVwiKSAvLyByZXR1cm5zIFwiaGVsbG8td29ybGQtXCJcclxuICogXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBEaXNwbGF5IG5hbWUgZm9yIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGVzY3JpcHRpb24gLSBEZXNjcmlwdGlvbiBvZiB0aGUgcnVsZSdzIHB1cnBvc2UuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBydWxlVHlwZSAtIFR5cGUgb2YgdGhlIHJ1bGUgKGUuZy4sICdmb3JtYXR0ZXInKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZSAtIFNvdXJjZSBjb2RlIGZvciB0aGUgcnVsZSdzIGZ1bmN0aW9uLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSB0eXBlIC0gVHlwZXMgb2YgZmllbGRzIHRoZSBydWxlIGFwcGxpZXMgdG8uXHJcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBjb25maWdFbGVtZW50cyAtIENvbmZpZ3VyYXRpb24gZWxlbWVudHMgZm9yIHRoZSBydWxlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVSZXBsYWNlU3BlY2lhbENoYXJzIGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaWQgPSAncmVwbGFjZVNwZWNpYWxDaGFycyc7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ1JlcGxhY2UgU3BlY2lhbCBDaGFyYWN0ZXJzJztcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gJ0NoYXJhY3RlciB0byByZXBsYWNlIHNwZWNpYWwgY2hhcmFjdGVycyAoc3VnZ2VzdGVkOiBcIi1cIikgLSBwcmVzZXJ2ZXMgbGV0dGVycyB3aXRoIGRpYWNyaXRpY3MnO1xyXG4gICAgICAgIHRoaXMucnVsZVR5cGUgPSAnZm9ybWF0dGVyJztcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBsZXQgcmVzdWx0ID0gJyc7XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIjtcclxuICAgICAgICB0aGlzLnR5cGUgPSBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddO1xyXG4gICAgICAgIHRoaXMuY29uZmlnRWxlbWVudHMgPSB0aGlzLmRlZmF1bHRDb25maWdFbGVtZW50cyh7fSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IGFueSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzLCBpbnB1dD86YW55KSB7IC8vIERlZmF1bHQgZnVuY3Rpb24gc2lnbmF0dXJlXHJcbiAgICAgICAgY29uc3Qgc3BlY2lhbENoYXJSZXBsYWNlbWVudCA9IHRvb2xzLmdldE9wdGlvbkNvbmZpZyh0b29scy5nZXRSdWxlKCk/LmlkLCAnc3BlY2lhbENoYXJSZXBsYWNlbWVudCcpO1xyXG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9bXmEtekEtWjAtOVxcLV9cXC9cdTAwRTRcdTAwRjZcdTAwRkNcdTAwREZcdTAwQzRcdTAwRDZcdTAwRENcdTAwRTFcdTAwRTlcdTAwRURcdTAwRjNcdTAwRkFcdTAwRkRcdTAwQzFcdTAwQzlcdTAwQ0RcdTAwRDNcdTAwREFcdTAwRERcdTAwRTBcdTAwRThcdTAwRUNcdTAwRjJcdTAwRjlcdTAwQzBcdTAwQzhcdTAwQ0NcdTAwRDJcdTAwRDlcdTAwRTJcdTAwRUFcdTAwRUVcdTAwRjRcdTAwRkJcdTAwQzJcdTAwQ0FcdTAwQ0VcdTAwRDRcdTAwREJcdTAwRTNcdTAwRjFcdTAwRjVcdTAwQzNcdTAwRDFcdTAwRDVdL2csIHNwZWNpYWxDaGFyUmVwbGFjZW1lbnQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25maWdUYWIob3B0aW9uRUw6IEhUTUxFbGVtZW50LCBydWxlOiBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzLCB0aGF0OiBhbnksIHByZXZpZXdDb21wb25lbnQ6IGFueSkge1xyXG4gICAgICAgIG9wdGlvbkVMLmVtcHR5KCk7XHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgc2V0dGluZyBmb3IgdGhlIHNtYWxsIHdvcmRzXHJcbiAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWdEZWZhdWx0cyhydWxlLmlkLCB7XHJcbiAgICAgICAgICAgIHNwZWNpYWxDaGFyUmVwbGFjZW1lbnQgOiAnJywgLy8gRGVmYXVsdCBzdWZmaXhcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBuZXcgU2V0dGluZyhvcHRpb25FTClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ1JlcGxhY2UgU3BlY2lhbCBDaGFyYWN0ZXJzJylcclxuICAgICAgICAgICAgLnNldERlc2MoJ0NoYXJhY3RlciB0byByZXBsYWNlIHNwZWNpYWwgY2hhcmFjdGVycyAoc3VnZ2VzdGVkOiBcIi1cIikgLSBwcmVzZXJ2ZXMgbGV0dGVycyB3aXRoIGRpYWNyaXRpY3MnKVxyXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignd2lsbCByZW1vdmUgc3BlY2lhbCBjaGFyYWN0ZXJzJylcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGF0LmdldE9wdGlvbkNvbmZpZyhydWxlLmlkICwnc3BlY2lhbENoYXJSZXBsYWNlbWVudCcpIHx8ICcnKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQsJ3NwZWNpYWxDaGFyUmVwbGFjZW1lbnQnLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC51cGRhdGVQcmV2aWV3KHJ1bGUsIHByZXZpZXdDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgIH07XHJcbn0iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBydWxlIHRoYXQgY29udmVydHMgaW5wdXQgdmFsdWVzIHRvIENhbWVsIENhc2UuXHJcbiAqIFRoaXMgcnVsZSBjYW4gaGFuZGxlIHZhcmlvdXMgaW5wdXQgdHlwZXMgaW5jbHVkaW5nIHN0cmluZ3MsIGFycmF5cywgZGF0ZXMsIGFuZCBvYmplY3RzLlxyXG4gKiBcclxuICogQGV4dGVuZHMgUnVsZVByb3RvdHlwZVxyXG4gKiBcclxuICogQHJlbWFya3NcclxuICogLSBGb3Igc3RyaW5ncywgaXQgY29udmVydHMgdGhlIGVudGlyZSBzdHJpbmcgdG8gQ2FtZWwgQ2FzZS5cclxuICogLSBGb3IgYXJyYXlzLCBpdCBtYXBzIGVhY2ggZWxlbWVudCB0byBpdHMgQ2FtZWwgQ2FzZSBzdHJpbmcgcmVwcmVzZW50YXRpb24uXHJcbiAqIC0gRm9yIGRhdGVzLCBpdCBjb252ZXJ0cyB0aGUgZGF0ZSB0byBhbiBJU08gc3RyaW5nIGFuZCBhcHBsaWVzIENhbWVsIENhc2UuXHJcbiAqIC0gRm9yIG9iamVjdHMsIGl0IHNlcmlhbGl6ZXMgdGhlIG9iamVjdCB0byBhIEpTT04gc3RyaW5nIGFuZCBhcHBsaWVzIENhbWVsIENhc2UuXHJcbiAqIC0gSWYgdGhlIGlucHV0IHR5cGUgaXMgbm90IHJlY29nbml6ZWQsIGl0IHJldHVybnMgdGhlIGlucHV0IGFzIGlzLlxyXG4gKiBcclxuICogQGV4YW1wbGVcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjb25zdCBydWxlID0gbmV3IFJ1bGVUb0NhbWVsQ2FzZSgpO1xyXG4gKiBjb25zb2xlLmxvZyhydWxlLmZ4KFwiaGVsbG8gd29ybGRcIiwgdG9vbHMpKTsgLy8gT3V0cHV0czogXCJoZWxsb1dvcmxkXCJcclxuICogY29uc29sZS5sb2cocnVsZS5meChbXCJoZWxsbyB3b3JsZFwiLCBcInRlc3QgY2FzZVwiXSwgdG9vbHMpKTsgLy8gT3V0cHV0czogW1wiaGVsbG9Xb3JsZFwiLCBcInRlc3RDYXNlXCJdXHJcbiAqIGNvbnNvbGUubG9nKHJ1bGUuZngobmV3IERhdGUoXCIyMDIzLTAxLTAxXCIpLCB0b29scykpOyAvLyBPdXRwdXRzOiBcIjIwMjMtMDEtMDF0MDA6MDA6MDAuMDAwelwiXHJcbiAqIGNvbnNvbGUubG9nKHJ1bGUuZngoeyBrZXk6IFwidmFsdWVcIiB9LCB0b29scykpOyAvLyBPdXRwdXRzOiAne1wia2V5XCI6XCJ2YWx1ZVwifSdcclxuICogYGBgXHJcbiAqIFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXNjcmlwdGlvbiAtIEEgYnJpZWYgZGVzY3JpcHRpb24gb2YgdGhlIHJ1bGUncyBmdW5jdGlvbmFsaXR5LlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcnVsZVR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgcnVsZSwgd2hpY2ggaXMgXCJmb3JtYXR0ZXJcIi5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZSAtIFRoZSBzb3VyY2UgY29kZSB0ZW1wbGF0ZSBmb3IgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHR5cGUgLSBUaGUgdHlwZXMgb2YgaW5wdXQgdGhpcyBydWxlIGFwcGxpZXMgdG8sIGUuZy4sIFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J10uXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGZ4IC0gVGhlIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgdGhlIENhbWVsIENhc2UgdHJhbnNmb3JtYXRpb24uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZVRvQ2FtZWxDYXNlIGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaWQgPSAndG9DYW1lbENhc2UnO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdUbyBDYW1lbCBDYXNlJztcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gJ0NvbnZlcnQgdGhlIHZhbHVlIHRvIENhbWVsIENhc2UuJztcclxuICAgICAgICB0aGlzLnJ1bGVUeXBlID0gJ2Zvcm1hdHRlcic7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgbGV0IHJlc3VsdCA9ICcnO1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59XCI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gICAgfTtcclxuICAgIGZ4IChhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogVEZpbGUsIHRvb2xzOiBTY3JpcHRpbmdUb29scywgaW5wdXQ6IGFueSkgeyBcclxuICAgICAgICBjb25zdCB0b0NhbWVsQ2FzZSA9IChzdHI6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgdGV4dFBhcnRzID0gc3RyLnNwbGl0KCcgJyk7XHJcbiAgICAgICAgICAgIGxldCBjb252ZXJ0ZWRUZXh0UGFydHM6c3RyaW5nW10gPSBbXTtcclxuICAgICAgICAgICAgdGV4dFBhcnRzLmZvckVhY2goKHRleHQsaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgbGV0IG5ld1RleHRQYXJ0ID0gdGV4dC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXg+MCkgbmV3VGV4dFBhcnQgPSBuZXdUZXh0UGFydC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5ld1RleHRQYXJ0LnNsaWNlKDEpO1xyXG4gICAgICAgICAgICBjb252ZXJ0ZWRUZXh0UGFydHMucHVzaChuZXdUZXh0UGFydCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gY29udmVydGVkVGV4dFBhcnRzLmpvaW4oJycpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0b0NhbWVsQ2FzZShpbnB1dCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQubWFwKChpdGVtKSA9PiB0b0NhbWVsQ2FzZShTdHJpbmcoaXRlbSkpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdG9DYW1lbENhc2UoaW5wdXQudG9JU09TdHJpbmcoKSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0b0NhbWVsQ2FzZShKU09OLnN0cmluZ2lmeShpbnB1dCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW5wdXQ7XHJcbiAgICB9O1xyXG59XHJcblxyXG4vL3J1bGVzTWFuYWdlci5yZWdpc3RlclJ1bGUobmV3IFJ1bGVUb0NhbWVsQ2FzZSgpKTsiLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgcnVsZSBmb3IgZm9ybWF0dGluZyBpbnB1dCBhcyBhIG1hcmtkb3duIGxpbmsuXHJcbiAqIFRoaXMgY2xhc3MgZXh0ZW5kcyB0aGUgYFJ1bGVQcm90b3R5cGVgIGFuZCBwcm92aWRlcyBmdW5jdGlvbmFsaXR5XHJcbiAqIHRvIGNvbnZlcnQgaW5wdXQgaW50byBhIG1hcmtkb3duIGxpbmsgZm9ybWF0IHVzaW5nIHRoZSBwcm92aWRlZCB0b29scy5cclxuICpcclxuICogQGNsYXNzIFJ1bGVUb0xpbmtNYXJrZG93blxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBJbml0aWFsaXplcyB0aGUgcnVsZSB3aXRoIGRlZmF1bHQgcHJvcGVydGllcyBzdWNoIGFzIGBpZGAsIGBuYW1lYCxcclxuICogYGRlc2NyaXB0aW9uYCwgYHJ1bGVUeXBlYCwgYHNvdXJjZWAsIGB0eXBlYCwgYW5kIGBjb25maWdFbGVtZW50c2AuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uIC0gQSBicmllZiBkZXNjcmlwdGlvbiBvZiB0aGUgcnVsZSdzIHB1cnBvc2UuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBydWxlVHlwZSAtIFRoZSB0eXBlIG9mIHJ1bGUsIGluIHRoaXMgY2FzZSwgYSBsaW5rIGZvcm1hdHRlci5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZSAtIFRoZSBzb3VyY2UgY29kZSBvZiB0aGUgcnVsZSBhcyBhIHN0cmluZywgdXNlZCBmb3Igc2NyaXB0aW5nIHB1cnBvc2VzLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSB0eXBlIC0gVGhlIGFwcGxpY2FibGUgaW5wdXQgdHlwZXMgZm9yIHRoZSBydWxlLCBzdWNoIGFzICd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsIGFuZCAnbXVsdGl0ZXh0Jy5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZnggLSBUaGUgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyB0aGUgbWFya2Rvd24gbGluayBmb3JtYXR0aW5nLlxyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBjb25maWdFbGVtZW50cyAtIEEgbWV0aG9kIHRvIHJldHJpZXZlIHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gZWxlbWVudHMgZm9yIHRoZSBydWxlLlxyXG4gKlxyXG4gKiBAbWV0aG9kIGZ4XHJcbiAqIENvbnZlcnRzIHRoZSBpbnB1dCBpbnRvIGEgbWFya2Rvd24gbGluayBmb3JtYXQgdXNpbmcgdGhlIGB0b29scy50b01hcmtkb3duTGlua2AgbWV0aG9kLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBjb25zdCBydWxlID0gbmV3IFJ1bGVUb0xpbmtNYXJrZG93bigpO1xyXG4gKiBjb25zdCBmb3JtYXR0ZWQgPSBydWxlLmZ4KFwiZXhhbXBsZVwiLCB0b29scyk7XHJcbiAqIGNvbnNvbGUubG9nKGZvcm1hdHRlZCk7IC8vIE91dHB1dHMgdGhlIGlucHV0IGZvcm1hdHRlZCBhcyBhIG1hcmtkb3duIGxpbmsuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZVRvTGlua01hcmtkb3duIGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaWQgPSAndG9NYXJrZG93bkxpbmsnO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICd0byBtYXJrZG93biBsaW5rJztcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gJ0Zvcm1hdCBhcyBhIG1hcmtkb3duIGxpbmsuJztcclxuICAgICAgICB0aGlzLnJ1bGVUeXBlID0gJ2xpbmtGb3JtYXR0ZXInO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gXCJmdW5jdGlvbiAoaW5wdXQ6IGFueSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgaW5wdXQgPSB0b29scy50b01hcmtkb3duTGluayhpbnB1dCk7IC8vIENvbnZlcnQgdG8gbWFya2Rvd24gbGluayBmb3JtYXRcXG4gIHJldHVybiBpbnB1dDtcXG59XCI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gICAgfTtcclxuICAgIGZ4IChhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogVEZpbGUsIHRvb2xzOiBTY3JpcHRpbmdUb29scywgaW5wdXQ6IGFueSkgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgICAgICBpbnB1dCA9IHRvb2xzLnRvTWFya2Rvd25MaW5rKGlucHV0KTsgLy8gQ29udmVydCB0byBtYXJrZG93biBsaW5rIGZvcm1hdFxyXG4gICAgICAgIHJldHVybiBpbnB1dDtcclxuICAgIH07XHJcbn0iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBydWxlIHRoYXQgcGFzc2VzIGlucHV0IHZhbHVlcyB1bmFsdGVyZWQuXHJcbiAqIFRoaXMgcnVsZSBzaW1wbHkgcmV0dXJucyB0aGUgaW5wdXQgYXMgaXMsIHdpdGhvdXQgYW55IHRyYW5zZm9ybWF0aW9uLlxyXG4gKiBcclxuICogQGV4dGVuZHMgUnVsZVByb3RvdHlwZVxyXG4gKiBcclxuICogQGV4YW1wbGVcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjb25zdCBydWxlID0gbmV3IFJ1bGVUb09yaWdpbmFsKCk7XHJcbiAqIGNvbnNvbGUubG9nKHJ1bGUuZngoXCJoZWxsbyB3b3JsZFwiLCB0b29scykpOyAvLyBPdXRwdXRzOiBcImhlbGxvIHdvcmxkXCJcclxuICogY29uc29sZS5sb2cocnVsZS5meChbXCJoZWxsb1wiLCBcIndvcmxkXCJdLCB0b29scykpOyAvLyBPdXRwdXRzOiBbXCJoZWxsb1wiLCBcIndvcmxkXCJdXHJcbiAqIGNvbnNvbGUubG9nKHJ1bGUuZngobmV3IERhdGUoXCIyMDIzLTAxLTAxXCIpLCB0b29scykpOyAvLyBPdXRwdXRzOiBEYXRlIG9iamVjdFxyXG4gKiBjb25zb2xlLmxvZyhydWxlLmZ4KHsga2V5OiBcInZhbHVlXCIgfSwgdG9vbHMpKTsgLy8gT3V0cHV0czogeyBrZXk6IFwidmFsdWVcIiB9XHJcbiAqIGBgYFxyXG4gKiBcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGVzY3JpcHRpb24gLSBBIGJyaWVmIGRlc2NyaXB0aW9uIG9mIHRoZSBydWxlJ3MgZnVuY3Rpb25hbGl0eS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJ1bGVUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIHJ1bGUsIHdoaWNoIGlzIFwiZm9ybWF0dGVyXCIuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBUaGUgc291cmNlIGNvZGUgdGVtcGxhdGUgZm9yIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSB0eXBlIC0gVGhlIHR5cGVzIG9mIGlucHV0IHRoaXMgcnVsZSBhcHBsaWVzIHRvLCBlLmcuLCBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddLlxyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBmeCAtIFRoZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGlucHV0IHVuYWx0ZXJlZC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlVG9MaW5rT3JpZ2luYWwgZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9ICd0b09yaWdpbmFsTGluayc7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ25vIGNoYW5nZSc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdQYXNzIHRoZSBpbnB1dCB1bmFsdGVyZWQuJztcclxuICAgICAgICB0aGlzLnJ1bGVUeXBlID0gJ2xpbmtGb3JtYXR0ZXInO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIGxldCByZXN1bHQgPSAnJztcXG4gIHJldHVybiByZXN1bHQ7XFxufVwiO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICAgICAgdGhpcy5jb25maWdFbGVtZW50cyA9IHRoaXMuZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGZ4IChhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogVEZpbGUsIHRvb2xzOiBTY3JpcHRpbmdUb29scywgaW5wdXQ6IGFueSkgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgICAgICByZXR1cm4gaW5wdXQ7IC8vIFJldHVybiB0aGUgaW5wdXQgdW5hbHRlcmVkXHJcbiAgICB9O1xyXG59IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGV9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbi8qKlxyXG4gKiBBIHJ1bGUgdGhhdCBmb3JtYXRzIGEgZ2l2ZW4gaW5wdXQgYXMgYSBzaW1wbGUgT2JzaWRpYW4gbGluayBieSB3cmFwcGluZyBpdCBpbiBkb3VibGUgc3F1YXJlIGJyYWNrZXRzIChbWy4uLl1dKS5cclxuICogUmV0dXJucyBhbiBlbXB0eSBzdHJpbmcgaWYgdGhlIGlucHV0IGlzIGB1bmRlZmluZWRgLCBgbnVsbGAsIG9yIGFuIGVtcHR5IHN0cmluZy5cclxuICpcclxuICogQHJlbWFya3NcclxuICogLSBSZXR1cm5zIGFuIGVtcHR5IHN0cmluZyBpZiB0aGUgaW5wdXQgaXMgYHVuZGVmaW5lZGAsIGBudWxsYCwgb3IgYW4gZW1wdHkgc3RyaW5nLlxyXG4gKiAtIEludGVuZGVkIGZvciB1c2UgYXMgYSBsaW5rIGZvcm1hdHRlciB3aXRoaW4gdGhlIHBsdWdpbidzIHJ1bGUgc3lzdGVtLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNvbnN0IHJ1bGUgPSBuZXcgUnVsZVRvTGlua1NpbXBsZSgpO1xyXG4gKiBydWxlLmZ4KGFwcCwgZmlsZSwgdG9vbHMsIFwiTXlOb3RlXCIpOyAvLyByZXR1cm5zICdbW015Tm90ZV1dJ1xyXG4gKiBydWxlLmZ4KGFwcCwgZmlsZSwgdG9vbHMsIFwiXCIpOyAvLyByZXR1cm5zICcnXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZVRvTGlua1NpbXBsZSBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlkID0gJ3RvU2ltcGxlTGluayc7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ3RvIHNpbXBsZSBsaW5rJztcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gJ0Zvcm1hdCBhcyBhIHNpbXBsZSBsaW5rIGJ5IGFkZGluZyBbW11dLic7XHJcbiAgICAgICAgdGhpcy5ydWxlVHlwZSA9ICdsaW5rRm9ybWF0dGVyJztcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMsIGlucHV0KSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgaWYgKGlucHV0ID09PSB1bmRlZmluZWQgfHwgaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09ICcnKSB7XFxuICAgIHJldHVybiAnJzsgLy8gUmV0dXJuIGVtcHR5IHN0cmluZyBpZiBpbnB1dCBpcyB1bmRlZmluZWQsIG51bGwsIG9yIGVtcHR5XFxuICB9XFxuICAgICAgICAgaW5wdXQgPSBgW1ske2lucHV0fV1dYDsgLy8gQ29udmVydCB0byBzaW1wbGUgTGlua1xcbiAgcmV0dXJuIGlucHV0O1xcbn07XCI7IC8vIFNvdXJjZSBjb2RlIHRlbXBsYXRlXHJcbiAgICAgICAgdGhpcy50eXBlID0gWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZnggKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBURmlsZSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzLCBpbnB1dDogYW55KSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkIHx8IGlucHV0ID09PSBudWxsIHx8IGlucHV0ID09PSAnJykge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7IC8vIFJldHVybiBlbXB0eSBzdHJpbmcgaWYgaW5wdXQgaXMgdW5kZWZpbmVkLCBudWxsLCBvciBlbXB0eSBcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5wdXQgPSBgW1ske2lucHV0fV1dYDsgLy8gQ29udmVydCB0byBzaW1wbGUgTGlua1xyXG4gICAgICAgIHJldHVybiBpbnB1dDtcclxuICAgIH07XHJcbn0iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZX0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBydWxlIGZvciBmb3JtYXR0aW5nIGlucHV0IGFzIGEgd2lraSBsaW5rLlxyXG4gKiBcclxuICogVGhpcyBjbGFzcyBleHRlbmRzIHRoZSBgUnVsZVByb3RvdHlwZWAgYW5kIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgdG9cclxuICogY29udmVydCBpbnB1dCBpbnRvIGEgd2lraSBsaW5rIGZvcm1hdCB1c2luZyB0aGUgcHJvdmlkZWQgc2NyaXB0aW5nIHRvb2xzLlxyXG4gKiBcclxuICogQGNsYXNzIFJ1bGVUb0xpbmtXaWtpXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICogXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBJbml0aWFsaXplcyB0aGUgcnVsZSB3aXRoIHByZWRlZmluZWQgcHJvcGVydGllcyBzdWNoIGFzIElELCBuYW1lLCBkZXNjcmlwdGlvbixcclxuICogcnVsZSB0eXBlLCBzb3VyY2UgY29kZSB0ZW1wbGF0ZSwgYXBwbGljYWJsZSB0eXBlcywgYW5kIGNvbmZpZ3VyYXRpb24gZWxlbWVudHMuXHJcbiAqIFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBydWxlIChgdG9XaWtpTGlua2ApLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIHJ1bGUgKGB3aWtpIGxpbmtgKS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uIC0gQSBicmllZiBkZXNjcmlwdGlvbiBvZiB0aGUgcnVsZSdzIHB1cnBvc2UuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBydWxlVHlwZSAtIFRoZSB0eXBlIG9mIHJ1bGUgKGBsaW5rRm9ybWF0dGVyYCkuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBUaGUgc291cmNlIGNvZGUgdGVtcGxhdGUgZm9yIHRoZSBydWxlJ3MgZnVuY3Rpb25hbGl0eS5cclxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gdHlwZSAtIFRoZSBhcHBsaWNhYmxlIGlucHV0IHR5cGVzIGZvciB0aGUgcnVsZSBcclxuICogKGBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddYCkuXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGZ4IC0gVGhlIGZ1bmN0aW9uIHRoYXQgYXBwbGllcyB0aGUgcnVsZSBsb2dpYywgY29udmVydGluZ1xyXG4gKiBpbnB1dCB0byBhIHdpa2kgbGluayBmb3JtYXQgdXNpbmcgdGhlIHByb3ZpZGVkIGBTY3JpcHRpbmdUb29sc2AuXHJcbiAqIFxyXG4gKiBAbWV0aG9kIGRlZmF1bHRDb25maWdFbGVtZW50c1xyXG4gKiBHZW5lcmF0ZXMgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBlbGVtZW50cyBmb3IgdGhlIHJ1bGUuXHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBjb25zdCBydWxlID0gbmV3IFJ1bGVUb0xpbmtXaWtpKCk7XHJcbiAqIGNvbnN0IGZvcm1hdHRlZElucHV0ID0gcnVsZS5meChcImV4YW1wbGVcIiwgdG9vbHMpO1xyXG4gKiBjb25zb2xlLmxvZyhmb3JtYXR0ZWRJbnB1dCk7IC8vIE91dHB1dHMgdGhlIGlucHV0IGZvcm1hdHRlZCBhcyBhIHdpa2kgbGluay5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlVG9MaW5rV2lraSBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlkID0gJ3RvV2lraUxpbmsnO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICd0byB3aWtpIGxpbmsnO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnRm9ybWF0IGFzIGEgd2lraSBsaW5rLic7XHJcbiAgICAgICAgdGhpcy5ydWxlVHlwZSA9ICdsaW5rRm9ybWF0dGVyJztcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IFwiZnVuY3Rpb24gKGlucHV0OiBhbnksIHRvb2xzOiBTY3JpcHRpbmdUb29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIGlucHV0ID0gdG9vbHMudG9XaWtpTGluayhpbnB1dCk7IC8vIENvbnZlcnQgdG8gd2lraSBsaW5rIGZvcm1hdFxcbiAgcmV0dXJuIGlucHV0O1xcbn1cIjsgLy8gU291cmNlIGNvZGUgdGVtcGxhdGVcclxuICAgICAgICB0aGlzLnR5cGUgPSBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddO1xyXG4gICAgICAgIHRoaXMuY29uZmlnRWxlbWVudHMgPSB0aGlzLmRlZmF1bHRDb25maWdFbGVtZW50cyh7fSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMsIGlucHV0OiBhbnkpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAgICAgaW5wdXQgPSB0b29scy50b1dpa2lMaW5rKGlucHV0KTsgLy8gQ29udmVydCB0byB3aWtpIGxpbmsgZm9ybWF0XHJcbiAgICAgICAgcmV0dXJuIGlucHV0O1xyXG4gICAgfTtcclxufSIsICJpbXBvcnQgeyBSdWxlUHJvdG90eXBlLCBydWxlc01hbmFnZXIgfSBmcm9tIFwiLi9ydWxlc1wiO1xyXG5pbXBvcnQgeyBTY3JpcHRpbmdUb29scyB9IGZyb20gXCIuLi90b29sc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIHJ1bGUgdGhhdCBjb252ZXJ0cyBpbnB1dCB2YWx1ZXMgdG8gbG93ZXIgY2FzZS5cclxuICogVGhpcyBydWxlIGNhbiBoYW5kbGUgdmFyaW91cyBpbnB1dCB0eXBlcyBpbmNsdWRpbmcgc3RyaW5ncywgYXJyYXlzLCBkYXRlcywgYW5kIG9iamVjdHMuXHJcbiAqIFxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqIFxyXG4gKiBAcmVtYXJrc1xyXG4gKiAtIEZvciBzdHJpbmdzLCBpdCBjb252ZXJ0cyB0aGUgZW50aXJlIHN0cmluZyB0byBsb3dlciBjYXNlLlxyXG4gKiAtIEZvciBhcnJheXMsIGl0IG1hcHMgZWFjaCBlbGVtZW50IHRvIGl0cyBsb3dlciBjYXNlIHN0cmluZyByZXByZXNlbnRhdGlvbi5cclxuICogLSBGb3IgZGF0ZXMsIGl0IGNvbnZlcnRzIHRoZSBkYXRlIHRvIGFuIElTTyBzdHJpbmcgaW4gbG93ZXIgY2FzZS5cclxuICogLSBGb3Igb2JqZWN0cywgaXQgc2VyaWFsaXplcyB0aGUgb2JqZWN0IHRvIGEgSlNPTiBzdHJpbmcgYW5kIGNvbnZlcnRzIGl0IHRvIGxvd2VyIGNhc2UuXHJcbiAqIC0gSWYgdGhlIGlucHV0IHR5cGUgaXMgbm90IHJlY29nbml6ZWQsIGl0IHJldHVybnMgdGhlIGlucHV0IGFzIGlzLlxyXG4gKiBcclxuICogQGV4YW1wbGVcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjb25zdCBydWxlID0gbmV3IFJ1bGVUb0xvd2VyQ2FzZSgpO1xyXG4gKiBjb25zb2xlLmxvZyhydWxlLmZ4KFwiSEVMTE9cIiwgdG9vbHMpKTsgLy8gT3V0cHV0czogXCJoZWxsb1wiXHJcbiAqIGNvbnNvbGUubG9nKHJ1bGUuZngoW1wiSEVMTE9cIiwgXCJXT1JMRFwiXSwgdG9vbHMpKTsgLy8gT3V0cHV0czogW1wiaGVsbG9cIiwgXCJ3b3JsZFwiXVxyXG4gKiBjb25zb2xlLmxvZyhydWxlLmZ4KG5ldyBEYXRlKFwiMjAyMy0wMS0wMVwiKSwgdG9vbHMpKTsgLy8gT3V0cHV0czogXCIyMDIzLTAxLTAxdDAwOjAwOjAwLjAwMHpcIlxyXG4gKiBjb25zb2xlLmxvZyhydWxlLmZ4KHsgS0VZOiBcIlZBTFVFXCIgfSwgdG9vbHMpKTsgLy8gT3V0cHV0czogJ3tcImtleVwiOlwidmFsdWVcIn0nXHJcbiAqIGBgYFxyXG4gKiBcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGVzY3JpcHRpb24gLSBBIGJyaWVmIGRlc2NyaXB0aW9uIG9mIHRoZSBydWxlJ3MgZnVuY3Rpb25hbGl0eS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJ1bGVUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIHJ1bGUsIHdoaWNoIGlzIFwiZm9ybWF0dGVyXCIuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBUaGUgc291cmNlIGNvZGUgdGVtcGxhdGUgZm9yIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSB0eXBlIC0gVGhlIHR5cGVzIG9mIGlucHV0IHRoaXMgcnVsZSBhcHBsaWVzIHRvLCBlLmcuLCBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddLlxyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBmeCAtIFRoZSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIHRoZSBsb3dlciBjYXNlIHRyYW5zZm9ybWF0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVUb0xvd2VyQ2FzZSBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlkID0gJ3RvTG93ZXJDYXNlJztcclxuICAgICAgICB0aGlzLm5hbWUgPSAnVG8gTG93ZXIgQ2FzZSc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdDb252ZXJ0IHRoZSB2YWx1ZSB0byBsb3dlciBjYXNlLic7XHJcbiAgICAgICAgdGhpcy5ydWxlVHlwZSA9ICdmb3JtYXR0ZXInO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIGxldCByZXN1bHQgPSAnJztcXG4gIHJldHVybiByZXN1bHQ7XFxufVwiO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICAgICAgdGhpcy5jb25maWdFbGVtZW50cyA9IHRoaXMuZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KTtcclxuICAgIH07XHJcbiAgICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMsIGlucHV0OiBhbnkpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAgICAgaWYgKFN0cmluZy5pc1N0cmluZyhpbnB1dCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5tYXAoKGl0ZW0pID0+IFN0cmluZyhpdGVtKS50b0xvd2VyQ2FzZSgpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQudG9JU09TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaW5wdXQpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnB1dDtcclxuICAgIH1cclxufVxyXG5cclxuLy9ydWxlc01hbmFnZXIucmVnaXN0ZXJSdWxlKG5ldyBSdWxlVG9Mb3dlckNhc2UoKSk7IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgcnVsZSB0aGF0IHBhc3NlcyBpbnB1dCB2YWx1ZXMgdW5hbHRlcmVkLlxyXG4gKiBUaGlzIHJ1bGUgc2ltcGx5IHJldHVybnMgdGhlIGlucHV0IGFzIGlzLCB3aXRob3V0IGFueSB0cmFuc2Zvcm1hdGlvbi5cclxuICogXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICogXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY29uc3QgcnVsZSA9IG5ldyBSdWxlVG9PcmlnaW5hbCgpO1xyXG4gKiBjb25zb2xlLmxvZyhydWxlLmZ4KFwiaGVsbG8gd29ybGRcIiwgdG9vbHMpKTsgLy8gT3V0cHV0czogXCJoZWxsbyB3b3JsZFwiXHJcbiAqIGNvbnNvbGUubG9nKHJ1bGUuZngoW1wiaGVsbG9cIiwgXCJ3b3JsZFwiXSwgdG9vbHMpKTsgLy8gT3V0cHV0czogW1wiaGVsbG9cIiwgXCJ3b3JsZFwiXVxyXG4gKiBjb25zb2xlLmxvZyhydWxlLmZ4KG5ldyBEYXRlKFwiMjAyMy0wMS0wMVwiKSwgdG9vbHMpKTsgLy8gT3V0cHV0czogRGF0ZSBvYmplY3RcclxuICogY29uc29sZS5sb2cocnVsZS5meCh7IGtleTogXCJ2YWx1ZVwiIH0sIHRvb2xzKSk7IC8vIE91dHB1dHM6IHsga2V5OiBcInZhbHVlXCIgfVxyXG4gKiBgYGBcclxuICogXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uIC0gQSBicmllZiBkZXNjcmlwdGlvbiBvZiB0aGUgcnVsZSdzIGZ1bmN0aW9uYWxpdHkuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBydWxlVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBydWxlLCB3aGljaCBpcyBcImZvcm1hdHRlclwiLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc291cmNlIC0gVGhlIHNvdXJjZSBjb2RlIHRlbXBsYXRlIGZvciB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gdHlwZSAtIFRoZSB0eXBlcyBvZiBpbnB1dCB0aGlzIHJ1bGUgYXBwbGllcyB0bywgZS5nLiwgWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXS5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZnggLSBUaGUgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBpbnB1dCB1bmFsdGVyZWQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZVRvT3JpZ2luYWwgZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9ICd0b09yaWdpbmFsJztcclxuICAgICAgICB0aGlzLm5hbWUgPSAnbm8gY2hhbmdlJztcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gJ1Bhc3MgdGhlIGlucHV0IHVuYWx0ZXJlZC4nO1xyXG4gICAgICAgIHRoaXMucnVsZVR5cGUgPSAnZm9ybWF0dGVyJztcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IFwiZnVuY3Rpb24gKGFwcCwgZmlsZSwgdG9vbHMpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXFxuICBsZXQgcmVzdWx0ID0gJyc7XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cIjtcclxuICAgICAgICB0aGlzLnR5cGUgPSBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddO1xyXG4gICAgICAgIHRoaXMuY29uZmlnRWxlbWVudHMgPSB0aGlzLmRlZmF1bHRDb25maWdFbGVtZW50cyh7fSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IGFueSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzLCBpbnB1dD86YW55KSB7IC8vIERlZmF1bHQgZnVuY3Rpb24gc2lnbmF0dXJlXHJcbiAgICAgICAgcmV0dXJuIGlucHV0OyAvLyBSZXR1cm4gdGhlIGlucHV0IHVuYWx0ZXJlZFxyXG4gICAgfTtcclxufSIsICJpbXBvcnQgeyBSdWxlUHJvdG90eXBlLCBydWxlc01hbmFnZXIgfSBmcm9tIFwiLi9ydWxlc1wiO1xyXG5pbXBvcnQgeyBTY3JpcHRpbmdUb29scyB9IGZyb20gXCIuLi90b29sc1wiO1xyXG5pbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIHJ1bGUgdGhhdCBjb252ZXJ0cyBpbnB1dCB2YWx1ZXMgdG8gUGFzY2FsIENhc2UgKFVwcGVyIENhbWVsIENhc2UpLlxyXG4gKiBUaGlzIHJ1bGUgY2FuIGhhbmRsZSB2YXJpb3VzIGlucHV0IHR5cGVzIGluY2x1ZGluZyBzdHJpbmdzLCBhcnJheXMsIGRhdGVzLCBhbmQgb2JqZWN0cy5cclxuICogXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICogXHJcbiAqIEByZW1hcmtzXHJcbiAqIC0gRm9yIHN0cmluZ3MsIGl0IGNvbnZlcnRzIHRoZSBlbnRpcmUgc3RyaW5nIHRvIFBhc2NhbCBDYXNlLlxyXG4gKiAtIEZvciBhcnJheXMsIGl0IG1hcHMgZWFjaCBlbGVtZW50IHRvIGl0cyBQYXNjYWwgQ2FzZSBzdHJpbmcgcmVwcmVzZW50YXRpb24uXHJcbiAqIC0gRm9yIGRhdGVzLCBpdCBjb252ZXJ0cyB0aGUgZGF0ZSB0byBhbiBJU08gc3RyaW5nIGFuZCBhcHBsaWVzIFBhc2NhbCBDYXNlLlxyXG4gKiAtIEZvciBvYmplY3RzLCBpdCBzZXJpYWxpemVzIHRoZSBvYmplY3QgdG8gYSBKU09OIHN0cmluZyBhbmQgYXBwbGllcyBQYXNjYWwgQ2FzZS5cclxuICogLSBJZiB0aGUgaW5wdXQgdHlwZSBpcyBub3QgcmVjb2duaXplZCwgaXQgcmV0dXJucyB0aGUgaW5wdXQgYXMgaXMuXHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNvbnN0IHJ1bGUgPSBuZXcgUnVsZVRvUGFzY2FsQ2FzZSgpO1xyXG4gKiBjb25zb2xlLmxvZyhydWxlLmZ4KFwiaGVsbG8gd29ybGRcIiwgdG9vbHMpKTsgLy8gT3V0cHV0czogXCJIZWxsb1dvcmxkXCJcclxuICogY29uc29sZS5sb2cocnVsZS5meChbXCJoZWxsbyB3b3JsZFwiLCBcInRlc3QgY2FzZVwiXSwgdG9vbHMpKTsgLy8gT3V0cHV0czogW1wiSGVsbG9Xb3JsZFwiLCBcIlRlc3RDYXNlXCJdXHJcbiAqIGNvbnNvbGUubG9nKHJ1bGUuZngobmV3IERhdGUoXCIyMDIzLTAxLTAxXCIpLCB0b29scykpOyAvLyBPdXRwdXRzOiBcIjIwMjMtMDEtMDFUMDA6MDA6MDAuMDAwWlwiXHJcbiAqIGNvbnNvbGUubG9nKHJ1bGUuZngoeyBrZXk6IFwidmFsdWVcIiB9LCB0b29scykpOyAvLyBPdXRwdXRzOiAne1wiS2V5XCI6XCJWYWx1ZVwifSdcclxuICogYGBgXHJcbiAqIFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXNjcmlwdGlvbiAtIEEgYnJpZWYgZGVzY3JpcHRpb24gb2YgdGhlIHJ1bGUncyBmdW5jdGlvbmFsaXR5LlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcnVsZVR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgcnVsZSwgd2hpY2ggaXMgXCJmb3JtYXR0ZXJcIi5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZSAtIFRoZSBzb3VyY2UgY29kZSB0ZW1wbGF0ZSBmb3IgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHR5cGUgLSBUaGUgdHlwZXMgb2YgaW5wdXQgdGhpcyBydWxlIGFwcGxpZXMgdG8sIGUuZy4sIFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J10uXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGZ4IC0gVGhlIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgdGhlIFBhc2NhbCBDYXNlIHRyYW5zZm9ybWF0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVUb1Bhc2NhbENhc2UgZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9ICd0b1Bhc2NhbENhc2UnO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdUbyBQYXNjYWwgQ2FzZSc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdDb252ZXJ0IHRoZSB2YWx1ZSB0byBQYXNjYWwgQ2FzZSAoVXBwZXIgQ2FtZWwgQ2FzZSkuJztcclxuICAgICAgICB0aGlzLnJ1bGVUeXBlID0gJ2Zvcm1hdHRlcic7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgbGV0IHJlc3VsdCA9ICcnO1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59XCI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gICAgfTtcclxuICAgIGZ4IChhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogVEZpbGUsIHRvb2xzOiBTY3JpcHRpbmdUb29scywgaW5wdXQ6IGFueSkgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgICAgICBjb25zdCB0b1Bhc2NhbENhc2UgPSAoc3RyOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0clxyXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoLyg/Ol5cXHd8W0EtWl18XFxiXFx3fFxccyspL2csIChtYXRjaCkgPT5cclxuICAgICAgICAgICAgICAgICAgICBtYXRjaC50b1VwcGVyQ2FzZSgpXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxzKy9nLCAnJylcclxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXmEtekEtWjAtOV0vZywgJycpOyAvLyBSZW1vdmUgc3BlY2lhbCBjaGFyYWN0ZXJzXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRvUGFzY2FsQ2FzZShpbnB1dCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQubWFwKChpdGVtKSA9PiB0b1Bhc2NhbENhc2UoU3RyaW5nKGl0ZW0pKSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dCBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRvUGFzY2FsQ2FzZShpbnB1dC50b0lTT1N0cmluZygpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRvUGFzY2FsQ2FzZShKU09OLnN0cmluZ2lmeShpbnB1dCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW5wdXQ7XHJcbiAgICB9O1xyXG59XHJcblxyXG4vL3J1bGVzLnJlZ2lzdGVyUnVsZShuZXcgUnVsZVRvUGFzY2FsQ2FzZSgpKTsiLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBydWxlIHRoYXQgY29udmVydHMgaW5wdXQgdmFsdWVzIHRvIFRpdGxlIENhc2UuXHJcbiAqIFRoaXMgcnVsZSBjYW4gaGFuZGxlIHZhcmlvdXMgaW5wdXQgdHlwZXMgaW5jbHVkaW5nIHN0cmluZ3MsIGFycmF5cywgZGF0ZXMsIGFuZCBvYmplY3RzLlxyXG4gKiBcclxuICogQGV4dGVuZHMgUnVsZVByb3RvdHlwZVxyXG4gKiBcclxuICogQHJlbWFya3NcclxuICogLSBGb3Igc3RyaW5ncywgaXQgY29udmVydHMgdGhlIGVudGlyZSBzdHJpbmcgdG8gVGl0bGUgQ2FzZS5cclxuICogLSBGb3IgYXJyYXlzLCBpdCBtYXBzIGVhY2ggZWxlbWVudCB0byBpdHMgVGl0bGUgQ2FzZSBzdHJpbmcgcmVwcmVzZW50YXRpb24uXHJcbiAqIC0gRm9yIGRhdGVzLCBpdCBjb252ZXJ0cyB0aGUgZGF0ZSB0byBhbiBJU08gc3RyaW5nIGFuZCBhcHBsaWVzIFRpdGxlIENhc2UuXHJcbiAqIC0gRm9yIG9iamVjdHMsIGl0IHNlcmlhbGl6ZXMgdGhlIG9iamVjdCB0byBhIEpTT04gc3RyaW5nIGFuZCBhcHBsaWVzIFRpdGxlIENhc2UuXHJcbiAqIC0gSWYgdGhlIGlucHV0IHR5cGUgaXMgbm90IHJlY29nbml6ZWQsIGl0IHJldHVybnMgdGhlIGlucHV0IGFzIGlzLlxyXG4gKiBcclxuICogQGV4YW1wbGVcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjb25zdCBydWxlID0gbmV3IFJ1bGVUb1RpdGxlQ2FzZSgpO1xyXG4gKiBjb25zb2xlLmxvZyhydWxlLmZ4KFwiaGVsbG8gd29ybGRcIiwgdG9vbHMpKTsgLy8gT3V0cHV0czogXCJIZWxsbyBXb3JsZFwiXHJcbiAqIGNvbnNvbGUubG9nKHJ1bGUuZngoW1wiaGVsbG9cIiwgXCJ3b3JsZFwiXSwgdG9vbHMpKTsgLy8gT3V0cHV0czogW1wiSGVsbG9cIiwgXCJXb3JsZFwiXVxyXG4gKiBjb25zb2xlLmxvZyhydWxlLmZ4KG5ldyBEYXRlKFwiMjAyMy0wMS0wMVwiKSwgdG9vbHMpKTsgLy8gT3V0cHV0czogXCIyMDIzLTAxLTAxVDAwOjAwOjAwLjAwMFpcIlxyXG4gKiBjb25zb2xlLmxvZyhydWxlLmZ4KHsga2V5OiBcInZhbHVlXCIgfSwgdG9vbHMpKTsgLy8gT3V0cHV0czogJ3tcIktleVwiOlwiVmFsdWVcIn0nXHJcbiAqIGBgYFxyXG4gKiBcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGVzY3JpcHRpb24gLSBBIGJyaWVmIGRlc2NyaXB0aW9uIG9mIHRoZSBydWxlJ3MgZnVuY3Rpb25hbGl0eS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJ1bGVUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIHJ1bGUsIHdoaWNoIGlzIFwiZm9ybWF0dGVyXCIuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBUaGUgc291cmNlIGNvZGUgdGVtcGxhdGUgZm9yIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSB0eXBlIC0gVGhlIHR5cGVzIG9mIGlucHV0IHRoaXMgcnVsZSBhcHBsaWVzIHRvLCBlLmcuLCBbJ3RleHQnLCAndGFncycsICdhbGlhc2VzJywgJ211bHRpdGV4dCddLlxyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBmeCAtIFRoZSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIHRoZSBUaXRsZSBDYXNlIHRyYW5zZm9ybWF0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJ1bGVUb1RpdGxlQ2FzZSBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlkID0gJ3RvVGl0bGVDYXNlJztcclxuICAgICAgICB0aGlzLm5hbWUgPSAnVG8gVGl0bGUgQ2FzZSAoU2ltcGxlKSc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdDb252ZXJ0IHRoZSB2YWx1ZSB0byBUaXRsZSBDYXNlLic7XHJcbiAgICAgICAgdGhpcy5ydWxlVHlwZSA9ICdmb3JtYXR0ZXInO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIGxldCByZXN1bHQgPSAnJztcXG4gIHJldHVybiByZXN1bHQ7XFxufVwiO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICAgICAgdGhpcy5jb25maWdFbGVtZW50cyA9IHRoaXMuZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KTtcclxuICAgIH07XHJcbiAgICBmeCAoYXBwOiBBcHAgfCB1bmRlZmluZWQsIGZpbGU6IFRGaWxlLCB0b29sczogU2NyaXB0aW5nVG9vbHMsIGlucHV0OiBhbnkpIHsgLy8gZG8gbm90IGNoYW5nZSB0aGlzIGxpbmUhXHJcbiAgICAgICAgY29uc3QgdG9UaXRsZUNhc2UgPSAoc3RyOiBzdHJpbmcpID0+IHsgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgbGV0IHRleHRQYXJ0cyA9IHN0ci5zcGxpdCgnICcpO1xyXG4gICAgICAgICAgICBsZXQgY29udmVydGVkVGV4dFBhcnRzOnN0cmluZ1tdID0gW107XHJcbiAgICAgICAgICAgIHRleHRQYXJ0cy5mb3JFYWNoKCh0ZXh0LGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3VGV4dFBhcnQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICBuZXdUZXh0UGFydCA9IG5ld1RleHRQYXJ0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmV3VGV4dFBhcnQuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgICAgICBjb252ZXJ0ZWRUZXh0UGFydHMucHVzaChuZXdUZXh0UGFydClcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0ZWRUZXh0UGFydHMuam9pbignICcpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0b1RpdGxlQ2FzZShpbnB1dCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQubWFwKChpdGVtKSA9PiB0b1RpdGxlQ2FzZShTdHJpbmcoaXRlbSkpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdG9UaXRsZUNhc2UoaW5wdXQudG9JU09TdHJpbmcoKSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0b1RpdGxlQ2FzZShKU09OLnN0cmluZ2lmeShpbnB1dCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW5wdXQ7XHJcbiAgICB9O1xyXG59XHJcblxyXG4vLyBydWxlcy5yZWdpc3RlclJ1bGUobmV3IFJ1bGVUb1RpdGxlQ2FzZSgpKTsiLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgQXBwLCBTZXR0aW5nLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgeyBGcm9udG1hdHRlckF1dG9tYXRlUnVsZVNldHRpbmdzIH0gZnJvbSBcIi4uL3R5cGVzXCI7XHJcbmltcG9ydCB7IERFQlVHLCBsb2dnZXIsIFRSQUNFIH0gZnJvbSBcIi4uL0xvZ1wiO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBydWxlIHRoYXQgY29udmVydHMgaW5wdXQgdmFsdWVzIHRvIFRpdGxlIENhc2Ugd2l0aCBHZXJtYW4gXCJzbWFsbFwiIFdvcmRzLlxyXG4gKiBUaGlzIHJ1bGUgY2FuIGhhbmRsZSB2YXJpb3VzIGlucHV0IHR5cGVzIGluY2x1ZGluZyBzdHJpbmdzLCBhcnJheXMsIGRhdGVzLCBhbmQgb2JqZWN0cy5cclxuICogZ2VybWFuIGRlZmluaXRpb24gb2Ygc21hbGwgd29yZHM6IGh0dHBzOi8vY29weW1hdGUuYXBwL2RlL2Jsb2cvbXVsdGkvdGl0ZWwta2FwaXRhbGlzaWVyZXJcclxuICogbGlzdCBvZiBtb3N0IGdlcm1hbiBzbWFsbCB3b3JkczogR2VtaW5pIEFJXHJcbiAqIFxyXG4gKiBAZXh0ZW5kcyBSdWxlUHJvdG90eXBlXHJcbiAqIFxyXG4gKiBAcmVtYXJrc1xyXG4gKiAtIEZvciBzdHJpbmdzLCBpdCBjb252ZXJ0cyB0aGUgZW50aXJlIHN0cmluZyB0byBUaXRsZSBDYXNlLlxyXG4gKiAtIEZvciBhcnJheXMsIGl0IG1hcHMgZWFjaCBlbGVtZW50IHRvIGl0cyBUaXRsZSBDYXNlIHN0cmluZyByZXByZXNlbnRhdGlvbi5cclxuICogLSBGb3IgZGF0ZXMsIGl0IGNvbnZlcnRzIHRoZSBkYXRlIHRvIGFuIElTTyBzdHJpbmcgYW5kIGFwcGxpZXMgVGl0bGUgQ2FzZS5cclxuICogLSBGb3Igb2JqZWN0cywgaXQgc2VyaWFsaXplcyB0aGUgb2JqZWN0IHRvIGEgSlNPTiBzdHJpbmcgYW5kIGFwcGxpZXMgVGl0bGUgQ2FzZS5cclxuICogLSBJZiB0aGUgaW5wdXQgdHlwZSBpcyBub3QgcmVjb2duaXplZCwgaXQgcmV0dXJucyB0aGUgaW5wdXQgYXMgaXMuXHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNvbnN0IHJ1bGUgPSBuZXcgUnVsZVRvVGl0bGVDYXNlKCk7XHJcbiAqIGNvbnNvbGUubG9nKHJ1bGUuZngoXCJoZWxsbyB3b3JsZFwiLCB0b29scykpOyAvLyBPdXRwdXRzOiBcIkhlbGxvIFdvcmxkXCJcclxuICogY29uc29sZS5sb2cocnVsZS5meChbXCJoZWxsb1wiLCBcIndvcmxkXCJdLCB0b29scykpOyAvLyBPdXRwdXRzOiBbXCJIZWxsb1wiLCBcIldvcmxkXCJdXHJcbiAqIGNvbnNvbGUubG9nKHJ1bGUuZngobmV3IERhdGUoXCIyMDIzLTAxLTAxXCIpLCB0b29scykpOyAvLyBPdXRwdXRzOiBcIjIwMjMtMDEtMDFUMDA6MDA6MDAuMDAwWlwiXHJcbiAqIGNvbnNvbGUubG9nKHJ1bGUuZngoeyBrZXk6IFwidmFsdWVcIiB9LCB0b29scykpOyAvLyBPdXRwdXRzOiAne1wiS2V5XCI6XCJWYWx1ZVwifSdcclxuICogYGBgXHJcbiAqIFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBydWxlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXNjcmlwdGlvbiAtIEEgYnJpZWYgZGVzY3JpcHRpb24gb2YgdGhlIHJ1bGUncyBmdW5jdGlvbmFsaXR5LlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcnVsZVR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgcnVsZSwgd2hpY2ggaXMgXCJmb3JtYXR0ZXJcIi5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZSAtIFRoZSBzb3VyY2UgY29kZSB0ZW1wbGF0ZSBmb3IgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHR5cGUgLSBUaGUgdHlwZXMgb2YgaW5wdXQgdGhpcyBydWxlIGFwcGxpZXMgdG8sIGUuZy4sIFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J10uXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGZ4IC0gVGhlIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgdGhlIFRpdGxlIENhc2UgdHJhbnNmb3JtYXRpb24uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZVRvVGl0bGVDYXNlREUgZXh0ZW5kcyBSdWxlUHJvdG90eXBlIHtcclxuICAgIHByaXZhdGUgdmVyYm9zZUxvZ2dpbmcgPSBmYWxzZTsgLy8gU2V0IHRvIHRydWUgZm9yIHZlcmJvc2UgbG9nZ2luZ1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlkID0gJ3RvVGl0bGVDYXNlRGUnO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdUbyBUaXRsZSBDYXNlIChHZXJtYW4gc21hbGwgd29yZHMpJztcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gJ0NvbnZlcnQgR2VybWFuIHZhbHVlIHRvIFRpdGxlIENhc2UuJztcclxuICAgICAgICB0aGlzLnJ1bGVUeXBlID0gJ2Zvcm1hdHRlcic7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgbGV0IHJlc3VsdCA9ICcnO1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59XCI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZnggKGFwcDogQXBwIHwgdW5kZWZpbmVkLCBmaWxlOiBURmlsZSwgdG9vbHM6IFNjcmlwdGluZ1Rvb2xzLCBpbnB1dDogYW55KSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxyXG4gICAgICAgIGNvbnN0IHRvVGl0bGVDYXNlID0gKHN0cjogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bGVJZCA9IHRvb2xzLmdldFJ1bGUoKT8uaWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvTm90Q2FwaXRhbGl6ZVNtYWxsV29yZHMgPSB0b29scy5nZXRPcHRpb25Db25maWcocnVsZUlkLCAnZG9Ob3RDYXBpdGFsaXplU21hbGxXb3JkcycpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aXRsZUNhcHMoc3RyLCBkb05vdENhcGl0YWxpemVTbWFsbFdvcmRzID8gdG9vbHMuZ2V0T3B0aW9uQ29uZmlnKHJ1bGVJZCwnc21hbGxXb3JkcycpIDogdW5kZWZpbmVkKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCByZXN1bHQ6IGFueSA9IGlucHV0O1xyXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHRvVGl0bGVDYXNlKGlucHV0KTtcclxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGlucHV0Lm1hcCgoaXRlbSkgPT4gdG9UaXRsZUNhc2UoU3RyaW5nKGl0ZW0pKSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dCBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gdG9UaXRsZUNhc2UoaW5wdXQudG9JU09TdHJpbmcoKSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHRvVGl0bGVDYXNlKEpTT04uc3RyaW5naWZ5KGlucHV0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxvZ2dlci5sb2coREVCVUcsIGBSdWxlVG9UaXRsZUNhc2VERS5meCAtIGlucHV0Oicke2lucHV0fScgcmVzdWx0OickeyByZXN1bHR9J2ApO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbmZpZ1RhYihvcHRpb25FTDogSFRNTEVsZW1lbnQsIHJ1bGU6IEZyb250bWF0dGVyQXV0b21hdGVSdWxlU2V0dGluZ3MsIHRoYXQ6IGFueSwgcHJldmlld0NvbXBvbmVudDogYW55KSB7XHJcbiAgICAgICAgb3B0aW9uRUwuZW1wdHkoKTtcclxuICAgICAgICAvLyBDcmVhdGUgYSBzZXR0aW5nIGZvciB0aGUgc21hbGwgd29yZHNcclxuICAgICAgICB0aGF0LnNldE9wdGlvbkNvbmZpZ0RlZmF1bHRzKHJ1bGUuaWQsIHtcclxuICAgICAgICAgICAgc21hbGxXb3JkczogJ2RlcnxkaWV8ZGFzfGRlbnxkZW18ZGVzfGVpbmVyfGVpbmVzfGRlcmVufGVpbnxlaW5lfGVpbmVtfGVpbmVyfGVpbmVzfGVpbmVyfHVuZHxvZGVyfGFiZXJ8ZGVubnxzb25kZXJufHNvd2llfHdlZGVyfG5vY2h8ZW50d2VkZXJ8b2RlcnxkYXNzfHdlaWx8b2J3b2hsfHdlbm58YWxzfG5hY2hkZW18YmV2b3J8d1x1MDBFNGhyZW5kfGJpc3xkYW1pdHx1bXx6dXxzb2JhbGR8c29sYW5nZXxkYXxpbmRlbXxzb3xkYXNzfG9obmV8enV8ZHVyY2h8Zlx1MDBGQ3J8Z2VnZW58b2huZXx1bXxiaXN8YXVzfGF1XHUwMERGZXJ8YmVpfGdlZ2VuXHUwMEZDYmVyfG1pdHxuYWNofHNlaXR8dm9ufHp1fGFuc3RhdHR8YXVmZ3J1bmR8YXVcdTAwREZlcmhhbGJ8aW5uZXJoYWxifHRyb3R6fHdcdTAwRTRocmVuZHx3ZWdlbnxhbnxhdWZ8aGludGVyfGlufG5lYmVufFx1MDBGQ2Jlcnx1bnRlcnx2b3J8endpc2NoZW4nLFxyXG4gICAgICAgICAgICBkb05vdENhcGl0YWxpemVTbWFsbFdvcmRzOiB0cnVlLFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgbmV3IFNldHRpbmcob3B0aW9uRUwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdEbyBub3QgY2FwaXRhbGl6ZSBzbWFsbCB3b3JkcycpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdJZiBlbmFibGVkLCBzbWFsbCB3b3JkcyB3aWxsIG5vdCBiZSBjYXBpdGFsaXplZC4gSWYgZGlzYWJsZWQsIGFsbCB3b3JkcyB3aWxsIGJlIGNhcGl0YWxpemVkLicpXHJcbiAgICAgICAgICAgIC5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoYXQuZ2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQgLCdkb05vdENhcGl0YWxpemVTbWFsbFdvcmRzJykgfHwgZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zZXRPcHRpb25Db25maWcocnVsZS5pZCwnZG9Ob3RDYXBpdGFsaXplU21hbGxXb3JkcycsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZVByZXZpZXcocnVsZSwgcHJldmlld0NvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIC8vIENyZWF0ZSBhIHNldHRpbmcgZm9yIHRoZSBzbWFsbCB3b3Jkc1xyXG4gICAgICAgIG5ldyBTZXR0aW5nKG9wdGlvbkVMKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnTGlzdCBvZiBzbWFsbCB3b3JkcycpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdFbnRlciBhIGxpc3Qgb2Ygc21hbGwgd29yZHMgdG8gYmUgZXhjbHVkZWQgZnJvbSBjYXBpdGFsaXphdGlvbi4gVXNlIFwifFwiIGFzIHNlcGFyYXRvci4nKVxyXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGF0LmdldE9wdGlvbkNvbmZpZyhydWxlLmlkICwnc21hbGxXb3JkcycpIHx8ICcnKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2V0T3B0aW9uQ29uZmlnKHJ1bGUuaWQsJ3NtYWxsV29yZHMnLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC51cGRhdGVQcmV2aWV3KHJ1bGUsIHByZXZpZXdDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgIH07XHJcblx0XHJcblx0cHJpdmF0ZSBzbWFsbCA9IFwiKGRlcnxkaWV8ZGFzfGRlbnxkZW18ZGVzfGVpbmVyfGVpbmVzfGRlcmVufGVpbnxlaW5lfGVpbmVtfGVpbmVyfGVpbmVzfGVpbmVyfHVuZHxvZGVyfGFiZXJ8ZGVubnxzb25kZXJufHNvd2llfHdlZGVyfG5vY2h8ZW50d2VkZXJ8b2RlcnxkYXNzfHdlaWx8b2J3b2hsfHdlbm58YWxzfG5hY2hkZW18YmV2b3J8d1x1MDBFNGhyZW5kfGJpc3xkYW1pdHx1bXx6dXxzb2JhbGR8c29sYW5nZXxkYXxpbmRlbXxzb3xkYXNzfG9obmV8enV8ZHVyY2h8Zlx1MDBGQ3J8Z2VnZW58b2huZXx1bXxiaXN8YXVzfGF1XHUwMERGZXJ8YmVpfGdlZ2VuXHUwMEZDYmVyfG1pdHxuYWNofHNlaXR8dm9ufHp1fGFuc3RhdHR8YXVmZ3J1bmR8YXVcdTAwREZlcmhhbGJ8aW5uZXJoYWxifHRyb3R6fHdcdTAwRTRocmVuZHx3ZWdlbnxhbnxhdWZ8aGludGVyfGlufG5lYmVufFx1MDBGQ2Jlcnx1bnRlcnx2b3J8endpc2NoZW4pXCI7XHJcbiAgICBwcml2YXRlIHB1bmN0dWF0aW9uID0gXCJcXFxcKFshXFxcIiMkJSYnKCkqKywuLzo7PD0+P0BbXFxcXFxcXFxcXFxcXV5fYHt8fX5cXFxcLV0qXFxcXClcIjtcclxuXHJcbiAgICB0aXRsZUNhcHModGl0bGU6IHN0cmluZywgc21hbGxXb3Jkczogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgY29uc3QgcGFydHM6IHN0cmluZ1tdID0gW107XHJcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBuZXcgUmVnRXhwKGBbOi47PyFdIHwoPzogfF4pW1wiJHt0aGlzLnB1bmN0dWF0aW9ufV1gLCBcImdcIik7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuXHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgY29uc3QgbSA9IHNwbGl0LmV4ZWModGl0bGUpO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgc3Vic3RyaW5nID0gdGl0bGUuc3Vic3RyaW5nKGluZGV4LCBtID8gbS5pbmRleCA6IHRpdGxlLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGxvZ2dlci5sb2coVFJBQ0UsXCJQcm9jZXNzaW5nIHN1YnN0cmluZzpcIiwgc3Vic3RyaW5nKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBpc0ZpcnN0V29yZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXHJcbiAgICAgICAgICAgICAgICBzdWJzdHJpbmcucmVwbGFjZSgvKFtcXHB7TH1cXHB7TX1dKyg/OlxcLltcXHB7TH1cXHB7TX1dKykqKS9ndSwgKGFsbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coVFJBQ0UsXCJNYXRjaGVkIHdvcmQ6XCIsIGFsbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4Y2x1ZGUgd29yZHMgd2l0aCBtaXhlZCBjYXBpdGFsaXphdGlvbiAoZS5nLiwgXCJpUGhvbmVcIiwgXCJpTWFjXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKC9bYS16XVtBLVpdfFtBLVpdW2Etel0vLnRlc3QoYWxsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFRSQUNFLFwiRXhjbHVkaW5nIG1peGVkIGNhcGl0YWxpemF0aW9uIHdvcmQ6XCIsIGFsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRmlyc3RXb3JkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBFeGNsdWRlIGZ1bGx5IGNhcGl0YWxpemVkIHdvcmRzIChlLmcuLCBcIklCTVwiLCBcIkRFTExcIilcclxuICAgICAgICAgICAgICAgICAgICBpZiAoL15bQS1aXHUwMEM0XHUwMEQ2XHUwMERDXHUwMERGXSskLy50ZXN0KGFsbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhUUkFDRSxcIkV4Y2x1ZGluZyBmdWxseSBjYXBpdGFsaXplZCB3b3JkOlwiLCBhbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpcnN0V29yZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhjbHVkZSB3b3JkcyB3aXRoIHB1bmN0dWF0aW9uIHdpdGhvdXQgc3BhY2VzIChlLmcuLCBcImdvb2dsZS5jb21cIilcclxuICAgICAgICAgICAgICAgICAgICBpZiAoL1teXFxzXStcXC5bXlxcc10rLy50ZXN0KGFsbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhUUkFDRSxcIkV4Y2x1ZGluZyB3b3JkIHdpdGggcHVuY3R1YXRpb246XCIsIGFsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRmlyc3RXb3JkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzbWFsbFJlZ2V4ID0gbmV3IFJlZ0V4cChgXigke3NtYWxsV29yZHN9KSRgLCBcIml1XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0ZpcnN0V29yZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFRSQUNFLFwiQ2FwaXRhbGl6aW5nIGZpcnN0IHdvcmQgb2Ygc2VudGVuY2U6XCIsIGFsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRmlyc3RXb3JkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVwcGVyREUoYWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNtYWxsUmVnZXgudGVzdChhbGwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coVFJBQ0UsXCJTa2lwcGluZyBjYXBpdGFsaXphdGlvbiBmb3Igc21hbGwgd29yZDpcIiwgYWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG93ZXJERShhbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaXNGaXJzdFdvcmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51cHBlckRFKGFsbCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgaW5kZXggPSBzcGxpdC5sYXN0SW5kZXg7XHJcblxyXG4gICAgICAgICAgICBpZiAobSkgcGFydHMucHVzaChtWzBdKTtcclxuICAgICAgICAgICAgZWxzZSBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGxvd2VyREUod29yZDogc3RyaW5nKSB7XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhUUkFDRSxcIkxvd2VyaW5nOlwiLCB3b3JkKTtcclxuICAgICAgICByZXR1cm4gd29yZC50b0xvY2FsZUxvd2VyQ2FzZShcImRlXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwcGVyREUod29yZDogc3RyaW5nKSB7XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhUUkFDRSxcIlVwcGVyaW5nOlwiLCB3b3JkKTtcclxuICAgICAgICAvLyBDYXBpdGFsaXplIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIGxlYXZlIHRoZSByZXN0IG9mIHRoZSB3b3JkIHVuY2hhbmdlZFxyXG4gICAgICAgIHJldHVybiB3b3JkLmNoYXJBdCgwKS50b0xvY2FsZVVwcGVyQ2FzZShcImRlXCIpICsgd29yZC5zbGljZSgxKS50b0xvY2FsZUxvd2VyQ2FzZShcImRlXCIpO1xyXG4gICAgfVxyXG59IiwgImltcG9ydCB7IFJ1bGVQcm90b3R5cGUsIHJ1bGVzTWFuYWdlciB9IGZyb20gXCIuL3J1bGVzXCI7XHJcbmltcG9ydCB7IFNjcmlwdGluZ1Rvb2xzIH0gZnJvbSBcIi4uL3Rvb2xzXCI7XHJcbmltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgcnVsZSB0aGF0IGNvbnZlcnRzIGlucHV0IHZhbHVlcyB0byBUaXRsZSBDYXNlIHdpdGggRW5nbGlzaCBcInNtYWxsXCIgV29yZHMuXHJcbiAqIFRoaXMgcnVsZSBjYW4gaGFuZGxlIHZhcmlvdXMgaW5wdXQgdHlwZXMgaW5jbHVkaW5nIHN0cmluZ3MsIGFycmF5cywgZGF0ZXMsIGFuZCBvYmplY3RzLlxyXG4gKiBjcmVkaXQgaHR0cHM6Ly9qb2hucmVzaWcuY29tL2Jsb2cvdGl0bGUtY2FwaXRhbGl6YXRpb24taW4tamF2YXNjcmlwdC9cclxuICogXHJcbiAqIEBleHRlbmRzIFJ1bGVQcm90b3R5cGVcclxuICogXHJcbiAqIEByZW1hcmtzXHJcbiAqIC0gRm9yIHN0cmluZ3MsIGl0IGNvbnZlcnRzIHRoZSBlbnRpcmUgc3RyaW5nIHRvIFRpdGxlIENhc2UuXHJcbiAqIC0gRm9yIGFycmF5cywgaXQgbWFwcyBlYWNoIGVsZW1lbnQgdG8gaXRzIFRpdGxlIENhc2Ugc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxyXG4gKiAtIEZvciBkYXRlcywgaXQgY29udmVydHMgdGhlIGRhdGUgdG8gYW4gSVNPIHN0cmluZyBhbmQgYXBwbGllcyBUaXRsZSBDYXNlLlxyXG4gKiAtIEZvciBvYmplY3RzLCBpdCBzZXJpYWxpemVzIHRoZSBvYmplY3QgdG8gYSBKU09OIHN0cmluZyBhbmQgYXBwbGllcyBUaXRsZSBDYXNlLlxyXG4gKiAtIElmIHRoZSBpbnB1dCB0eXBlIGlzIG5vdCByZWNvZ25pemVkLCBpdCByZXR1cm5zIHRoZSBpbnB1dCBhcyBpcy5cclxuICogXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY29uc3QgcnVsZSA9IG5ldyBSdWxlVG9UaXRsZUNhc2UoKTtcclxuICogY29uc29sZS5sb2cocnVsZS5meChcImhlbGxvIHdvcmxkXCIsIHRvb2xzKSk7IC8vIE91dHB1dHM6IFwiSGVsbG8gV29ybGRcIlxyXG4gKiBjb25zb2xlLmxvZyhydWxlLmZ4KFtcImhlbGxvXCIsIFwid29ybGRcIl0sIHRvb2xzKSk7IC8vIE91dHB1dHM6IFtcIkhlbGxvXCIsIFwiV29ybGRcIl1cclxuICogY29uc29sZS5sb2cocnVsZS5meChuZXcgRGF0ZShcIjIwMjMtMDEtMDFcIiksIHRvb2xzKSk7IC8vIE91dHB1dHM6IFwiMjAyMy0wMS0wMVQwMDowMDowMC4wMDBaXCJcclxuICogY29uc29sZS5sb2cocnVsZS5meCh7IGtleTogXCJ2YWx1ZVwiIH0sIHRvb2xzKSk7IC8vIE91dHB1dHM6ICd7XCJLZXlcIjpcIlZhbHVlXCJ9J1xyXG4gKiBgYGBcclxuICogXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uIC0gQSBicmllZiBkZXNjcmlwdGlvbiBvZiB0aGUgcnVsZSdzIGZ1bmN0aW9uYWxpdHkuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBydWxlVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBydWxlLCB3aGljaCBpcyBcImZvcm1hdHRlclwiLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc291cmNlIC0gVGhlIHNvdXJjZSBjb2RlIHRlbXBsYXRlIGZvciB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gdHlwZSAtIFRoZSB0eXBlcyBvZiBpbnB1dCB0aGlzIHJ1bGUgYXBwbGllcyB0bywgZS5nLiwgWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXS5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZnggLSBUaGUgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyB0aGUgVGl0bGUgQ2FzZSB0cmFuc2Zvcm1hdGlvbi5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSdWxlVG9UaXRsZUNhc2VFTiBleHRlbmRzIFJ1bGVQcm90b3R5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlkID0gJ3RvVGl0bGVDYXNlRW4nO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdUbyBUaXRsZSBDYXNlIChFbmdsaXNoIHNtYWxsIHdvcmRzKSc7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdDb252ZXJ0IHRoZSB2YWx1ZSB0byBUaXRsZSBDYXNlLic7XHJcbiAgICAgICAgdGhpcy5ydWxlVHlwZSA9ICdmb3JtYXR0ZXInO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gXCJmdW5jdGlvbiAoYXBwLCBmaWxlLCB0b29scykgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcXG4gIGxldCByZXN1bHQgPSAnJztcXG4gIHJldHVybiByZXN1bHQ7XFxufVwiO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFsndGV4dCcsICd0YWdzJywgJ2FsaWFzZXMnLCAnbXVsdGl0ZXh0J107XHJcbiAgICAgICAgdGhpcy5jb25maWdFbGVtZW50cyA9IHRoaXMuZGVmYXVsdENvbmZpZ0VsZW1lbnRzKHt9KTtcclxuXHR9O1xyXG5cdFxyXG5cdGZ4IChhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogVEZpbGUsIHRvb2xzOiBTY3JpcHRpbmdUb29scywgaW5wdXQ6IGFueSkgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuXHRcdGNvbnN0IHRvVGl0bGVDYXNlID0gKHN0cjogc3RyaW5nKSA9PiB7XHJcblx0XHRcdHJldHVybiB0aGlzLnRpdGxlQ2FwcyhzdHIpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRyZXR1cm4gdG9UaXRsZUNhc2UoaW5wdXQpO1xyXG5cdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xyXG5cdFx0XHRyZXR1cm4gaW5wdXQubWFwKChpdGVtKSA9PiB0b1RpdGxlQ2FzZShTdHJpbmcoaXRlbSkpKTtcclxuXHRcdH0gZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBEYXRlKSB7XHJcblx0XHRcdHJldHVybiB0b1RpdGxlQ2FzZShpbnB1dC50b0lTT1N0cmluZygpKTtcclxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRyZXR1cm4gdG9UaXRsZUNhc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXQpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBpbnB1dDtcclxuXHR9O1xyXG5cclxuXHRwcml2YXRlIHNtYWxsID0gXCIoYXxhbnxhbmR8YXN8YXR8YnV0fGJ5fGVufGZvcnxpZnxpbnxvZnxvbnxvcnx0aGV8dG98dlsuXT98dmlhfHZzWy5dPylcIjtcclxuXHRwcml2YXRlIHB1bmN0dWF0aW9uID0gXCIoWyFcXFwiIyQlJicoKSorLC4vOjs8PT4/QFtcXFxcXFxcXFxcXFxdXl9ge3x9fi1dKilcIjtcclxuICBcclxuXHR0aXRsZUNhcHMgKHRpdGxlOnN0cmluZyl7XHJcblx0XHR2YXIgcGFydHM6IHN0cmluZ1tdID0gW10sIHNwbGl0ID0gL1s6Ljs/IV0gfCg/OiB8XilbXCJcdTAwRDJdL2csIGluZGV4ID0gMDtcclxuXHRcdFxyXG5cdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0dmFyIG0gPSBzcGxpdC5leGVjKHRpdGxlKTtcclxuXHJcblx0XHRcdHBhcnRzLnB1c2goIHRpdGxlLnN1YnN0cmluZyhpbmRleCwgbSA/IG0uaW5kZXggOiB0aXRsZS5sZW5ndGgpXHJcblx0XHRcdFx0LnJlcGxhY2UoL1xcYihbQS1aYS16XVthLXouJ1x1MDBENV0qKVxcYi9nLCAoYWxsOnN0cmluZykgPT57XHJcblx0XHRcdFx0XHRyZXR1cm4gL1tBLVphLXpdXFwuW0EtWmEtel0vLnRlc3QoYWxsKSA/IGFsbCA6IHRoaXMudXBwZXIoYWxsKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5yZXBsYWNlKFJlZ0V4cChcIlxcXFxiXCIgKyB0aGlzLnNtYWxsICsgXCJcXFxcYlwiLCBcImlnXCIpLCB0aGlzLmxvd2VyKVxyXG5cdFx0XHRcdC5yZXBsYWNlKFJlZ0V4cChcIl5cIiArIHRoaXMucHVuY3R1YXRpb24gKyB0aGlzLnNtYWxsICsgXCJcXFxcYlwiLCBcImlnXCIpLCAoYWxsOnN0cmluZywgcHVuY3Q6c3RyaW5nLCB3b3JkOnN0cmluZykgPT57XHJcblx0XHRcdFx0XHRyZXR1cm4gcHVuY3QgKyB0aGlzLnVwcGVyKHdvcmQpO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0LnJlcGxhY2UoUmVnRXhwKFwiXFxcXGJcIiArIHRoaXMuc21hbGwgKyB0aGlzLnB1bmN0dWF0aW9uICsgXCIkXCIsIFwiaWdcIiksIHRoaXMudXBwZXIpKTtcclxuXHRcdFx0XHJcblx0XHRcdGluZGV4ID0gc3BsaXQubGFzdEluZGV4O1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKCBtICkgcGFydHMucHVzaCggbVswXSApO1xyXG5cdFx0XHRlbHNlIGJyZWFrO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRyZXR1cm4gcGFydHMuam9pbihcIlwiKS5yZXBsYWNlKC8gVihzPylcXC4gL2lnLCBcIiB2JDEuIFwiKVxyXG5cdFx0XHQucmVwbGFjZSgvKFsnXHUwMEQ1XSlTXFxiL2lnLCBcIiQxc1wiKVxyXG5cdFx0XHQucmVwbGFjZSgvXFxiKEFUJlR8USZBKVxcYi9pZywgZnVuY3Rpb24oYWxsKXtcclxuXHRcdFx0XHRyZXR1cm4gYWxsLnRvVXBwZXJDYXNlKCk7XHJcblx0XHRcdH0pO1xyXG5cdH07XHJcbiAgICBcclxuXHRsb3dlcih3b3JkOnN0cmluZyl7XHJcblx0XHRyZXR1cm4gd29yZC50b0xvd2VyQ2FzZSgpO1xyXG5cdH1cclxuICAgIFxyXG5cdHVwcGVyKHdvcmQ6c3RyaW5nKXtcclxuXHQgIHJldHVybiB3b3JkLnN1YnN0cigwLDEpLnRvVXBwZXJDYXNlKCkgKyB3b3JkLnN1YnN0cigxKTtcclxuXHR9XHJcbn0iLCAiaW1wb3J0IHsgUnVsZVByb3RvdHlwZSwgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcclxuaW1wb3J0IHsgU2NyaXB0aW5nVG9vbHMgfSBmcm9tIFwiLi4vdG9vbHNcIjtcclxuaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBydWxlIHRoYXQgY29udmVydHMgaW5wdXQgdmFsdWVzIHRvIHVwcGVyIGNhc2UuXHJcbiAqIFRoaXMgcnVsZSBjYW4gaGFuZGxlIHZhcmlvdXMgaW5wdXQgdHlwZXMgaW5jbHVkaW5nIHN0cmluZ3MsIGFycmF5cywgZGF0ZXMsIGFuZCBvYmplY3RzLlxyXG4gKiBcclxuICogQGV4dGVuZHMgUnVsZVByb3RvdHlwZVxyXG4gKiBcclxuICogQHJlbWFya3NcclxuICogLSBGb3Igc3RyaW5ncywgaXQgY29udmVydHMgdGhlIGVudGlyZSBzdHJpbmcgdG8gdXBwZXIgY2FzZS5cclxuICogLSBGb3IgYXJyYXlzLCBpdCBtYXBzIGVhY2ggZWxlbWVudCB0byBpdHMgdXBwZXIgY2FzZSBzdHJpbmcgcmVwcmVzZW50YXRpb24uXHJcbiAqIC0gRm9yIGRhdGVzLCBpdCBjb252ZXJ0cyB0aGUgZGF0ZSB0byBhbiBJU08gc3RyaW5nIGluIHVwcGVyIGNhc2UuXHJcbiAqIC0gRm9yIG9iamVjdHMsIGl0IHNlcmlhbGl6ZXMgdGhlIG9iamVjdCB0byBhIEpTT04gc3RyaW5nIGFuZCBjb252ZXJ0cyBpdCB0byB1cHBlciBjYXNlLlxyXG4gKiAtIElmIHRoZSBpbnB1dCB0eXBlIGlzIG5vdCByZWNvZ25pemVkLCBpdCByZXR1cm5zIHRoZSBpbnB1dCBhcyBpcy5cclxuICogXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY29uc3QgcnVsZSA9IG5ldyBSdWxlVG9VcHBlckNhc2UoKTtcclxuICogY29uc29sZS5sb2cocnVsZS5meChcImhlbGxvXCIsIHRvb2xzKSk7IC8vIE91dHB1dHM6IFwiSEVMTE9cIlxyXG4gKiBjb25zb2xlLmxvZyhydWxlLmZ4KFtcImhlbGxvXCIsIFwid29ybGRcIl0sIHRvb2xzKSk7IC8vIE91dHB1dHM6IFtcIkhFTExPXCIsIFwiV09STERcIl1cclxuICogY29uc29sZS5sb2cocnVsZS5meChuZXcgRGF0ZShcIjIwMjMtMDEtMDFcIiksIHRvb2xzKSk7IC8vIE91dHB1dHM6IFwiMjAyMy0wMS0wMVQwMDowMDowMC4wMDBaXCJcclxuICogY29uc29sZS5sb2cocnVsZS5meCh7IGtleTogXCJ2YWx1ZVwiIH0sIHRvb2xzKSk7IC8vIE91dHB1dHM6ICd7XCJLRVlcIjpcIlZBTFVFXCJ9J1xyXG4gKiBgYGBcclxuICogXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHJ1bGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uIC0gQSBicmllZiBkZXNjcmlwdGlvbiBvZiB0aGUgcnVsZSdzIGZ1bmN0aW9uYWxpdHkuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBydWxlVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBydWxlLCB3aGljaCBpcyBcImZvcm1hdHRlclwiLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc291cmNlIC0gVGhlIHNvdXJjZSBjb2RlIHRlbXBsYXRlIGZvciB0aGUgcnVsZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gdHlwZSAtIFRoZSB0eXBlcyBvZiBpbnB1dCB0aGlzIHJ1bGUgYXBwbGllcyB0bywgZS5nLiwgWyd0ZXh0J10uXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGZ4IC0gVGhlIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgdGhlIHVwcGVyIGNhc2UgdHJhbnNmb3JtYXRpb24uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUnVsZVRvVXBwZXJDYXNlIGV4dGVuZHMgUnVsZVByb3RvdHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaWQgPSAndG9VcHBlckNhc2UnO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdUbyBVcHBlciBDYXNlJztcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gJ0NvbnZlcnQgdGhlIHZhbHVlIHRvIHVwcGVyIGNhc2UuJztcclxuICAgICAgICB0aGlzLnJ1bGVUeXBlID0gJ2Zvcm1hdHRlcic7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcImZ1bmN0aW9uIChhcHAsIGZpbGUsIHRvb2xzKSB7IC8vIGRvIG5vdCBjaGFuZ2UgdGhpcyBsaW5lIVxcbiAgbGV0IHJlc3VsdCA9ICcnO1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59XCI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gWyd0ZXh0JywgJ3RhZ3MnLCAnYWxpYXNlcycsICdtdWx0aXRleHQnXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ0VsZW1lbnRzID0gdGhpcy5kZWZhdWx0Q29uZmlnRWxlbWVudHMoe30pO1xyXG4gICAgfTtcclxuICAgIGZ4IChhcHA6IEFwcCB8IHVuZGVmaW5lZCwgZmlsZTogVEZpbGUsIHRvb2xzOiBTY3JpcHRpbmdUb29scywgaW5wdXQ6IGFueSkgeyAvLyBkbyBub3QgY2hhbmdlIHRoaXMgbGluZSFcclxuICAgICAgICBpZiAoU3RyaW5nLmlzU3RyaW5nKGlucHV0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQudG9VcHBlckNhc2UoKTtcclxuICAgICAgICB9IGVsc2UgaWYoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0Lm1hcCgoaXRlbSkgPT4gU3RyaW5nKGl0ZW0pLnRvVXBwZXJDYXNlKCkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC50b0lTT1N0cmluZygpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShpbnB1dCkudG9VcHBlckNhc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlucHV0O1xyXG4gICAgfVxyXG59XHJcblxyXG4vL3J1bGVzTWFuYWdlci5yZWdpc3RlclJ1bGUobmV3IFJ1bGVUb1VwcGVyQ2FzZSgpKTsiLCAiLy8gVGhpcyBmaWxlIGlzIGF1dG8tZ2VuZXJhdGVkLiBEbyBub3QgZWRpdCBtYW51YWxseS5cbi8vIEdlbmVyYXRlZCBieSBidWlsZC1ydWxlcy1pbmRleC5qc1xuaW1wb3J0IHsgcnVsZXNNYW5hZ2VyIH0gZnJvbSBcIi4vcnVsZXNcIjtcbmltcG9ydCB7IFJ1bGVBZGRQcmVmaXggfSBmcm9tIFwiLi9hZGRQcmVmaXhcIjtcbmltcG9ydCB7IFJ1bGVBZGRTdWZmaXggfSBmcm9tIFwiLi9hZGRTdWZmaXhcIjtcbmltcG9ydCB7IFJ1bGVBdXRvbWF0aW9uQXV0b0xpbmsgfSBmcm9tIFwiLi9hdXRvbWF0aW9uQXV0b0xpbmtcIjtcbmltcG9ydCB7IFJ1bGVCdWlsZEluQXV0b0NvbXBsZXRlTW9kYWwgfSBmcm9tIFwiLi9idWlsZEluQXV0b0NvbXBsZXRlTW9kYWxcIjtcbmltcG9ydCB7IFJ1bGVCdWlsZEluQ29uY2F0UHJvcGVydGllcyB9IGZyb20gXCIuL2J1aWxkSW5Db25jYXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBSdWxlQnVpbGRJbkNvbnN0YW50IH0gZnJvbSBcIi4vYnVpbGRJbkNvbnN0YW50XCI7XG5pbXBvcnQgeyBSdWxlQnVpbGRJbkRhdGVUaW1lQ3JlYXRlZCB9IGZyb20gXCIuL2J1aWxkSW5EYXRlVGltZUNyZWF0ZWRcIjtcbmltcG9ydCB7IFJ1bGVCdWlsZEluRGF0ZVRpbWVNb2RpZmllZCB9IGZyb20gXCIuL2J1aWxkSW5EYXRlVGltZU1vZGlmaWVkXCI7XG5pbXBvcnQgeyBSdWxlQnVpbGRJbkRlZmF1bHQgfSBmcm9tIFwiLi9idWlsZEluRGVmYXVsdFwiO1xuaW1wb3J0IHsgUnVsZUJ1aWxkSW5GaWxlU2l6ZUJ5dGVzIH0gZnJvbSBcIi4vYnVpbGRJbkZpbGVTaXplQnl0ZXNcIjtcbmltcG9ydCB7IFJ1bGVCdWlsZEluRmlsZVNpemVTdHJpbmcgfSBmcm9tIFwiLi9idWlsZEluRmlsZVNpemVTdHJpbmdcIjtcbmltcG9ydCB7IFJ1bGVCdWlsZEluRm9sZGVyIH0gZnJvbSBcIi4vYnVpbGRJbkZvbGRlclwiO1xuaW1wb3J0IHsgUnVsZUJ1aWxkSW5Gb2xkZXJGb2xkZXJOb3RlcyB9IGZyb20gXCIuL2J1aWxkSW5Gb2xkZXJGb2xkZXJOb3Rlc1wiO1xuaW1wb3J0IHsgUnVsZUJ1aWxkSW5Gb2xkZXJzIH0gZnJvbSBcIi4vYnVpbGRJbkZvbGRlcnNcIjtcbmltcG9ydCB7IFJ1bGVCdWlsZEluRnVsbFBhdGggfSBmcm9tIFwiLi9idWlsZEluRnVsbFBhdGhcIjtcbmltcG9ydCB7IFJ1bGVCdWlsZEluRnVsbFBhdGhFeHQgfSBmcm9tIFwiLi9idWlsZEluRnVsbFBhdGhFeHRcIjtcbmltcG9ydCB7IFJ1bGVCdWlsZEluRnVsbFBhdGhFeHRGb2xkZXJOb3RlcyB9IGZyb20gXCIuL2J1aWxkSW5GdWxsUGF0aEV4dEZvbGRlck5vdGVzXCI7XG5pbXBvcnQgeyBSdWxlQnVpbGRJbkZ1bGxQYXRoRm9sZGVyTm90ZXMgfSBmcm9tIFwiLi9idWlsZEluRnVsbFBhdGhGb2xkZXJOb3Rlc1wiO1xuaW1wb3J0IHsgUnVsZUJ1aWxkSW5HZXRQcm9wZXJ0aWVzIH0gZnJvbSBcIi4vYnVpbGRJbkdldFByb3BlcnRpZXNcIjtcbmltcG9ydCB7IFJ1bGVCdWlsZEluR2V0UHJvcGVydHkgfSBmcm9tIFwiLi9idWlsZEluR2V0UHJvcGVydHlcIjtcbmltcG9ydCB7IFJ1bGVCdWlsZEluSXNSb290IH0gZnJvbSBcIi4vYnVpbGRJbklzUm9vdFwiO1xuaW1wb3J0IHsgUnVsZUJ1aWxkSW5MaW5rVG9GaWxlIH0gZnJvbSBcIi4vYnVpbGRJbkxpbmtUb0ZpbGVcIjtcbmltcG9ydCB7IFJ1bGVCdWlsZEluTmFtZSB9IGZyb20gXCIuL2J1aWxkSW5OYW1lXCI7XG5pbXBvcnQgeyBSdWxlQnVpbGRJbk5hbWVFeHQgfSBmcm9tIFwiLi9idWlsZEluTmFtZUV4dFwiO1xuaW1wb3J0IHsgUnVsZUJ1aWxkSW5QYXRoIH0gZnJvbSBcIi4vYnVpbGRJblBhdGhcIjtcbmltcG9ydCB7IFJ1bGVCdWlsZEluUGF0aEZvbGRlck5vdGVzIH0gZnJvbSBcIi4vYnVpbGRJblBhdGhGb2xkZXJOb3Rlc1wiO1xuaW1wb3J0IHsgUnVsZUJ1aWxkSW5Sb290Rm9sZGVyIH0gZnJvbSBcIi4vYnVpbGRJblJvb3RGb2xkZXJcIjtcbmltcG9ydCB7IFJ1bGVCdWlsZEluU2NyaXB0IH0gZnJvbSBcIi4vYnVpbGRJblNjcmlwdFwiO1xuaW1wb3J0IHsgUnVsZVJlcGxhY2VDaGFycyB9IGZyb20gXCIuL3JlcGxhY2VDaGFyc1wiO1xuaW1wb3J0IHsgUnVsZVJlcGxhY2VTcGFjZXMgfSBmcm9tIFwiLi9yZXBsYWNlU3BhY2VzXCI7XG5pbXBvcnQgeyBSdWxlUmVwbGFjZVNwZWNpYWxDaGFycyB9IGZyb20gXCIuL3JlcGxhY2VTcGVjaWFsQ2hhcnNcIjtcbmltcG9ydCB7IFJ1bGVUb0NhbWVsQ2FzZSB9IGZyb20gXCIuL3RvQ2FtZWxDYXNlXCI7XG5pbXBvcnQgeyBSdWxlVG9MaW5rTWFya2Rvd24gfSBmcm9tIFwiLi90b0xpbmtNYXJrZG93blwiO1xuaW1wb3J0IHsgUnVsZVRvTGlua09yaWdpbmFsIH0gZnJvbSBcIi4vdG9MaW5rT3JpZ2luYWxcIjtcbmltcG9ydCB7IFJ1bGVUb0xpbmtTaW1wbGUgfSBmcm9tIFwiLi90b0xpbmtTaW1wbGVcIjtcbmltcG9ydCB7IFJ1bGVUb0xpbmtXaWtpIH0gZnJvbSBcIi4vdG9MaW5rV2lraVwiO1xuaW1wb3J0IHsgUnVsZVRvTG93ZXJDYXNlIH0gZnJvbSBcIi4vdG9Mb3dlckNhc2VcIjtcbmltcG9ydCB7IFJ1bGVUb09yaWdpbmFsIH0gZnJvbSBcIi4vdG9PcmlnaW5hbFwiO1xuaW1wb3J0IHsgUnVsZVRvUGFzY2FsQ2FzZSB9IGZyb20gXCIuL3RvUGFzY2FsQ2FzZVwiO1xuaW1wb3J0IHsgUnVsZVRvVGl0bGVDYXNlIH0gZnJvbSBcIi4vdG9UaXRsZUNhc2VcIjtcbmltcG9ydCB7IFJ1bGVUb1RpdGxlQ2FzZURFIH0gZnJvbSBcIi4vdG9UaXRsZUNhc2VERVwiO1xuaW1wb3J0IHsgUnVsZVRvVGl0bGVDYXNlRU4gfSBmcm9tIFwiLi90b1RpdGxlQ2FzZUVOXCI7XG5pbXBvcnQgeyBSdWxlVG9VcHBlckNhc2UgfSBmcm9tIFwiLi90b1VwcGVyQ2FzZVwiO1xuXG4vLyBMaXN0IG9mIGFsbCBydWxlIGNsYXNzZXNcbmNvbnN0IHJ1bGVDbGFzc2VzID0gW1J1bGVBZGRQcmVmaXgsIFJ1bGVBZGRTdWZmaXgsIFJ1bGVBdXRvbWF0aW9uQXV0b0xpbmssIFJ1bGVCdWlsZEluQXV0b0NvbXBsZXRlTW9kYWwsIFJ1bGVCdWlsZEluQ29uY2F0UHJvcGVydGllcywgUnVsZUJ1aWxkSW5Db25zdGFudCwgUnVsZUJ1aWxkSW5EYXRlVGltZUNyZWF0ZWQsIFJ1bGVCdWlsZEluRGF0ZVRpbWVNb2RpZmllZCwgUnVsZUJ1aWxkSW5EZWZhdWx0LCBSdWxlQnVpbGRJbkZpbGVTaXplQnl0ZXMsIFJ1bGVCdWlsZEluRmlsZVNpemVTdHJpbmcsIFJ1bGVCdWlsZEluRm9sZGVyLCBSdWxlQnVpbGRJbkZvbGRlckZvbGRlck5vdGVzLCBSdWxlQnVpbGRJbkZvbGRlcnMsIFJ1bGVCdWlsZEluRnVsbFBhdGgsIFJ1bGVCdWlsZEluRnVsbFBhdGhFeHQsIFJ1bGVCdWlsZEluRnVsbFBhdGhFeHRGb2xkZXJOb3RlcywgUnVsZUJ1aWxkSW5GdWxsUGF0aEZvbGRlck5vdGVzLCBSdWxlQnVpbGRJbkdldFByb3BlcnRpZXMsIFJ1bGVCdWlsZEluR2V0UHJvcGVydHksIFJ1bGVCdWlsZEluSXNSb290LCBSdWxlQnVpbGRJbkxpbmtUb0ZpbGUsIFJ1bGVCdWlsZEluTmFtZSwgUnVsZUJ1aWxkSW5OYW1lRXh0LCBSdWxlQnVpbGRJblBhdGgsIFJ1bGVCdWlsZEluUGF0aEZvbGRlck5vdGVzLCBSdWxlQnVpbGRJblJvb3RGb2xkZXIsIFJ1bGVCdWlsZEluU2NyaXB0LCBSdWxlUmVwbGFjZUNoYXJzLCBSdWxlUmVwbGFjZVNwYWNlcywgUnVsZVJlcGxhY2VTcGVjaWFsQ2hhcnMsIFJ1bGVUb0NhbWVsQ2FzZSwgUnVsZVRvTGlua01hcmtkb3duLCBSdWxlVG9MaW5rT3JpZ2luYWwsIFJ1bGVUb0xpbmtTaW1wbGUsIFJ1bGVUb0xpbmtXaWtpLCBSdWxlVG9Mb3dlckNhc2UsIFJ1bGVUb09yaWdpbmFsLCBSdWxlVG9QYXNjYWxDYXNlLCBSdWxlVG9UaXRsZUNhc2UsIFJ1bGVUb1RpdGxlQ2FzZURFLCBSdWxlVG9UaXRsZUNhc2VFTiwgUnVsZVRvVXBwZXJDYXNlXTtcblxuLy8gUmVnaXN0ZXIgZWFjaCBydWxlIGNsYXNzXG5ydWxlQ2xhc3Nlcy5mb3JFYWNoKChSdWxlQ2xhc3MpID0+IHtcbiAgICBjb25zdCBydWxlSW5zdGFuY2UgPSBuZXcgUnVsZUNsYXNzKCk7XG4gICAgcnVsZXNNYW5hZ2VyLnJlZ2lzdGVyUnVsZShydWxlSW5zdGFuY2UpO1xufSk7Il0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQSxvQkFBNkk7OztBQ0E3SSxJQUFBQyxvQkFBaUg7OztBQ0FqSCxJQUFBQyxtQkFBaUQ7OztBQ0FqRCxzQkFBdUI7OztBQ0VoQixJQUFNLGVBQU4sY0FBMkIsTUFBTTtBQUFBLEVBQ3BDLFlBQVksS0FBb0IsYUFBc0I7QUFDbEQsVUFBTSxHQUFHO0FBRG1CO0FBRTVCLFNBQUssT0FBTyxLQUFLLFlBQVk7QUFDN0IsUUFBSSxNQUFNLG1CQUFtQjtBQUN6QixZQUFNLGtCQUFrQixNQUFNLEtBQUssV0FBVztBQUFBLElBQ2xEO0FBQUEsRUFDSjtBQUNKO0FBbUJPLFNBQVMsaUJBQW9CQyxLQUFhLEtBQWdCO0FBQzdELE1B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cG9ydF9vYnNpZGlhbiIsICJmbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgInJ1bGUiLCAidmFsdWUiLCAianNDb2RlIiwgInJvdyIsICJ0ZXh0IiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJqc0NvZGUiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAicnVsZSIsICJfYSIsICJfYiIsICJfYyIsICJfZCIsICJfZSIsICJfZiIsICJyb3ciLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJuYW1lIiwgInN0eWxlIiwgIndpbmRvdyIsICJtaW4iLCAibWF4IiwgInRvUGFkZGluZ09iamVjdCIsICJwb3BwZXJPZmZzZXRzIiwgIm1pbiIsICJtYXgiLCAib2Zmc2V0IiwgImVmZmVjdCIsICJwb3BwZXIiLCAiZWZmZWN0IiwgIndpbmRvdyIsICJoYXNoIiwgImNsaXBwaW5nUGFyZW50cyIsICJyZWZlcmVuY2UiLCAicG9wcGVyT2Zmc2V0cyIsICJvZmZzZXQiLCAicGxhY2VtZW50cyIsICJwbGFjZW1lbnQiLCAicGxhY2VtZW50cyIsICJwbGFjZW1lbnQiLCAiX2xvb3AiLCAiX2kiLCAiY2hlY2tzIiwgIm9mZnNldCIsICJwb3BwZXJPZmZzZXRzIiwgIm9mZnNldCIsICJtaW4iLCAibWF4IiwgImZuIiwgIm1lcmdlZCIsICJkZWZhdWx0TW9kaWZpZXJzIiwgImNyZWF0ZVBvcHBlciIsICJyZWZlcmVuY2UiLCAicG9wcGVyIiwgIm9wdGlvbnMiLCAiZm4iLCAic3RhdGUiLCAiZWZmZWN0IiwgIm5vb3BGbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJmcm9udG1hdHRlciIsICJpbXBvcnRfb2JzaWRpYW4iLCAicmVzdWx0IiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiZm9sZGVyIiwgIl9hIl0KfQo=
